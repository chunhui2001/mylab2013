<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
        Objective-C 提供了 4 中基本数据类型: int， float， double， char <br />
        Objective-C 的限定词: long, long long ,short, unsigned , signed <br />
        
        long int: 长整型 <br />
        long long int: 长长整型 <br />
        unsigned int: 只能用于存储正整数 <br />
        
        <br />
        <b>复合类型</b> <br />
        BOOL YES or NO
    ]]>
  </c:abstract>

  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
    <c:title>第一个 Object-C 程序</c:title>
    <c:desc>
      <c:desc1>
        <![CDATA[。。]]>
      </c:desc1>
    </c:desc>

    <c:sourceContent type="" title="FristObjectiveCProgram.m" id="sourceContent1">
        <![CDATA[//
//  main.m
//  Product1
//
//  Created by Keesh on 14-8-8.
//  Copyright (c) 2014年 Chunhui.Zhang. All rights reserved.

#import <Foundation/Foundation.h>

int main (int argc, const char * argv[]) {

    // 自动释放池，即自动释放内存
    @autoreleasepool {
        // 如果字符串前面不加 @, 表示创建 C 类型的字符串
        // 加 @ 表示创建 NSString 类型的字符串
        NSLog(@"Hello Chunhui!");
        
        int i = 6;
        int b = 5;
        int c = 8;
        
        NSLog(@"6 + 5 = %i, 5 + 8 = %i", i + b, b + c);
	
    }

    return 0;
}
      ]]>
    </c:sourceContent>
    <c:comment style="margin-top:2em;">
      <c:comment1 style="color:black;">
        <![CDATA[
                ]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>类、对象和方法</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
            <span style="display:block;margin-bottom:.3em;">Objective-C 采用特定的语法对类和实例应用方法。</span>
            <span style="display:block;margin-bottom:.3em;">
            <b>[ ClassOrInstance method : paramters]</b>
            </span>
            <span style="display:block;margin-bottom:.3em;">
                左方括号后要紧跟类或实例的名称，后面可以是一个或多个空格，空格后面是将要执行的方法。
                <br />
                方法后面可以跟一个冒号， 冒号后面是参数列表。
            </span>
            <span style="display:block;margin-bottom:.3em;">
                请求一个类或者实例执行某个操作时，就是在向<b>接收者</b>发送一条<b>消息</b>，<b>消息</b>就是空格后面的方法，<b>接受者</b>就是空格前面的类或实例的名字。
            </span>
            <span style="display:block;margin-bottom:.3em;">
                <b>Car yourCar = [Car new]; <br />
                [yourCar run]; <br />
                [yourCar close]; <br />
                [yourCar shutdown]; <br />
                [yourCar shutdown : 5]; <br />
                </b>
            </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="一个打印分数的例子" id="sourceContent1">
          <![CDATA[#import <Foundation/Foundation.h>
              
@interface Fraction : NSObject

// 开头的 + 或 － 号说明此处定义的是方法
// 开头的 － 号说明该方法是一个实例方法，如果开头是 ＋ 号说明该方法是一个类方法
-(void) print;
-(void) setNumerator : (int) num;
-(void) setDenominator : (int) d;

@end




@implementation Fraction  {

  // 开头不带 - 或 + 号说明此处定义的是变量而不是方法
  int numerator;
  int denominator;
}

-(void) print {
  NSLog(@"The Fraction is %i/%i", numerator, denominator);
}

-(void) setNumerator : (int) num {
  numerator = num;
}

-(void) setDenomanitor : (int) d {
  denominator = d;
}

@end



int main (int argc, char *argv[]) {

  // 在过去，iOS 程序员需要给对象发送 release 消息，通知系统释放内存
  // 这在内存管理系统中称为手工引用计数
  // 在 XCode 4.2+ 版本中默认开启 ARC (自动引用计数)
  @autoreleasepool {
      Fraction *fraction;               // 根据 Fraction 的定义申请一块内存,
                                        // 并将该段内存的首地址存储在 fraction 中
                                        // 此时 fraction 仅仅是一个存储了一个内存地址的指针,
                                        // 内存中的数据有待填充
      
      fraction = [Fraction alloc];      // 向 Fraction 类发送初始化消息，以获得该实例的新实例，
                                        // alloc 继承自父类是 allocate 的缩写
      fraction = [fraction init];       // 向类的新实例发送初始化消息，创建对象之后必须进行初始化 init
      
      
      // 以上三行可以简写成 Fraction *fraction = [[Fraction alloc] init]
      
      
      [fraction setNumerator : 1];
      [fraction setDenomanitor : 3];
      
      [fraction print];
  }

  return 0;
}
          ]]>
          
          
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="基础数据类型" id="sourceContent1">
          <![CDATA[
              <img style="max-width:100%;" src="//c2.staticflickr.com/4/3860/14863454924_4830648da7_z.jpg" />
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="id 类型" id="sourceContent1">
          <![CDATA[
              <b>id 数据类型可以存储任何类型的对象，是 Objective-C 中十分重要的特性，它是 <b style="font-style:italic; color:green;">多态</b>、<b style="font-style:italic; color:green;">动态类型</b> 和 <b style="font-style:italic; color:green;">动态绑定</b> 的基础.</b> <br />
              例如如下语句将 graphicObject 声明为 id 类型的变量: <br/ >
              
              <b>id graphicObject; </b><br />
              
              <br />
              如下语句声明一个方法并具有 id 类型的返回值: <br />
              <b>-(id) newObject : (int) c ;
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="逻辑控制" id="sourceContent1">
          <![CDATA[
              <b>for</b> <br />
              <b>while</b><br />
              <b>do</b> <br />
              
              <br />
              
              <b>if</b> <br />
              <b>switch</b> <br />
              <b>conditional</b> <br />
              
              <br />
              
              <b>scanf("%i", &number);</b> &nbsp;&nbsp; scanf 从屏幕读取输入并存入变量 number 中，& 是寻址运算符
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>类</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[将类的声明和定义放在单独的文件中 <br />
              把类的声明放在 *.h 文件中 <br />
              把类的定义放在 *.m 文件中]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="在 XCode 中添加一个新类" id="sourceContent1">
          <![CDATA[
              <img style="max-width:90%;" src="//c2.staticflickr.com/4/3857/14870459004_09a8ec13b4_z.jpg" />
              <br />
              <span>
                单击 Next 并选中 Subclass of NSObject，再次单击 Next。(以 Fraction 类为例)<br />
                在 Save as 输入框中输入 Fraction.m 做为文件名，其它默认，点击 Save 将生成 Fraction.h 和 Fraction.m 两个文件。
              </span>
          ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="Fraction.h" id="sourceContent1">
          <![CDATA[#import <Foundation/Foundation.h>
              
@interface Fraction : NSObject

-(void) print;
-(void) setNumerator:(int) n;
-(void) setDenominator: (int) d;
-(void) numerator;
-(void) denominator;
-(double) convertToNum;

@end
          ]]>
      </c:sourceContent>
  <c:sourceContent type="" title="Fraction.m" id="sourceContent1">
      <![CDATA[#import "Fraction.h"
          
@implementation Fraction {
    int numerator;
    int denominator;
}

-(void) print {
    NSLog (@"%i / %i", numerator,denominator)
}

-(void) setNumerator:(int) n {
    numerator = n;
}

-(void) setDenominator: (int) d {
    denominator = d;
}

-(void) numerator {
    return numerator;
}

-(void) denominator {
    return denominator;
}

-(double) convertToNum {
    if(denominator != 0) {
        return (double) numerator / denominator;
    } else {
        return NAN;
    }
}

@end
      ]]>
  </c:sourceContent>
  
  <c:sourceContent type="html" title="合成存取方法" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">从 Objective-C 2.0 开始可以自动生成 <b>set</b> 和 <b>get</b> 方法。</span>
          <ul style="padding-left:1.5em;list-style:decimal;">
              <li>
                    <span style="display:block;margin-bottom:.3em;">在接口部分使用 @property 指令标识属性，这些属性的命名与实例变量相同:</span>
                    <span style="display:block;margin-bottom:.3em;"><b>@property int numerator, denominator;</b> </span>
                    <span style="display:block;margin-bottom:.3em;">使用 @property 指令就不需要在实现部分声明相应的实例变量</span>
              </li>
              <li>
                    <span style="display:block;margin-bottom:.3em;">在实现部分使用 @synthesize 指令标识实例变量:</span>
                    <span style="display:block;margin-bottom:.3em;"><b>@synthesize int numerator, denominator;</b> <br /></span>
                    <span style="display:block;margin-bottom:.3em;">@synthesize 将为实例变量生成赋值和取值方法</span>
              </li>
              <li>
                    <span style="display:block;margin-bottom:.3em;">编译器将自动生成如下方法:</span>
                    <br />
                    
                    -(void) setNumerator:(int) n {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    numerator = n;<br />
                    }<br /><br />

                    -(void) setDenominator: (int) d {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    denominator = d;<br />
                    }<br /><br />

                    -(void) numerator {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    return numerator;<br />
                    }<br /><br />

                    -(void) denominator {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    return denominator;<br />
                    }
              </li>
          </ul>
      ]]>
  </c:sourceContent>
  
  <c:sourceContent type="html" title="使用 . 操作符访问属性" id="sourceContent1">
      <![CDATA[
        <span style="display:block;margin-bottom:.3em;">
            要取得 myFraction 中 numerator 的值，可以使用如下方法：
        </span>
        <span style="display:block;margin-bottom:.3em;">
            <b>[myFraction numerator]; </b>
        </span>
        <br />
        <span style="display:block;margin-bottom:.3em;">
            用点操作符重写等价的表达式：
        </span>
        
        <span style="display:block;margin-bottom:.3em;">
            <b>myFraction.numerator;</b>
            <br />
            <br />
            赋值：<br />
            <b>myFraction.numerator = 6;</b>
            <br />
            <br />
            等价于： <br />
            <b>[myFraction setNumerator:6];</b>
            
        </span>
        <br />
        
        <span style="display:block;margin-bottom:.3em;">
        注意:
        </span>
        
        <span style="display:block;margin-bottom:.3em;color:red;">
        点操作符通常用来操作属性，即用来设置或取得实例变量的值。<br />
        虽然 . 操作符也可以用来执行方法 (方法在 Objective-C 中也可以叫做任务)，但任务通常不是由 . 操作符来执行。<br />
        在 Objective－C 中，任务的执行是通过使用传统的方括号形式的<b>消息表达式</b>作为首选的语法。
        
        </span>
        
        <span style="display:block;margin-bottom:.3em;color:red;">
        使用合成 (synthesize) 的存取方法，属性名称前不要以 new、alloc、copy、init 这些词开头。
        
        </span>
        
      ]]>
  </c:sourceContent>
  
  <c:sourceContent type="html" title="具有多个参数的任务" id="sourceContent1">
        <![CDATA[
            <span style="display:block;margin-bottom:.3em;">
            通过列出多个连续的参数并用冒号将其连接起来，就可以定义一个接收多个参数的方法。
            </span>
            
            <span style="display:block;margin-bottom:.3em;">
            命名参数：<br />
            -(void) setTo: (int) n over: (int) d { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    numerator = n;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;    denominator = d;<br />
            }
            </span>
            
            
            <span style="display:block;margin-bottom:.3em;">
            调用：
            <br />
            <b>[myFraction setTo:1 over:3]</b>
            </span>
            
            <br />
            <br />
            
            <span style="display:block;margin-bottom:.3em;">
            非命名参数：<br />
            -(void) set: (int) n : (int) d { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    numerator = n;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;    denominator = d;<br />
            }
            </span>
            
            
            <span style="display:block;margin-bottom:.3em;">
            调用：
            <br />
            <b>[myFraction setTo:1 :3]</b>
            </span>
            <br />
            <span style="display:block;margin-bottom:.3em;color:red;">
            <b>注:在编写新方法时省略参数命不是一种良好的编程风格，因为它使程序很难读懂并且很不直观。</b>
            </span>
        ]]>
  </c:sourceContent>
  
  
  <c:sourceContent type="html" title="局部变量" id="sourceContent1">
      <![CDATA[
            <span style="display:block;margin-bottom:.3em;">考虑以下方法：</span>
            <span style="display:block;margin-bottom:.3em;">
            -(void) reduce { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    int u = numerator; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    int v = denominator; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    int temp; <br />
                 <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    while (v != 0) { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        temp = u % v; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        u = v; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        v= temp; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    } <br />
                 <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    numerator /= u; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    denominator /= u; <br />
            }
            </span>
            
            <br />
            <br />
            
            <span style="display:block;margin-bottom:.3em;">
                在这个方法中声明了 3 个局部变量, 这些变量对于 reduce 方法来说是局部变量，并且只能在 reduce 方法中访问。<br />并且当方法返回时这些变量的值都消失了。
            </span>
            
            
            <span style="display:block;margin-bottom:.3em;">
                局部变量是基本的 C 数据类型，没有默认的初始值，所以在使用前要先赋值。
            </span>
      ]]>
  </c:sourceContent>
  
  
  <c:sourceContent type="html" title="方法的参数" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">
            方法的参数命也是局部变量。执行方法时，通过方法传递的任何参数都被复制到局部变量中。<br />
            因为方法使用的是参数的副本，所以不能改变通过方法传递的参数原始值。
            <br />
            <br />
            如果方法的参数是对象，即当传递一个对象作为方法的参数时，实际上是传递了该对象的指针。<br />
            正因为如此，你才能修改参数对象的数据。
          </span>
      ]]>
  </c:sourceContent>
  
  
  
  <c:sourceContent type="html" title="static 关键字" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">
          <b>static int i = 0;</b>
          
          </span>
          
          <span style="display:block;margin-bottom:.3em;">
          和其它基本数据类型的初始值不同，静态变量的初始值是 0，并且在程序开始执行时初始化一次，在多次调用方法时保存这些数值。
          <br />
          通常将静态变量的声明放到 implementation 文件的开始处，这样所有的方法都能访问它们。
          
          </span>
      ]]>
  </c:sourceContent>
  
  
  
  <c:sourceContent type="html" title="self 关键字" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">
            <b>相当于 this</b>
          </span>
      ]]>
  </c:sourceContent>
  
  
  
  <c:sourceContent type="" title="在方法中分配和返回对象" id="sourceContent1">
      <![CDATA[
-(Fraction *) add: (Fraction *) f {
    Fraction *result = [[Fraction alloc] init];
    
    // do something...
    [result reduce];
    
    return result ;
}
      ]]>
  </c:sourceContent>
  
  



      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>继承</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">
                    父类的非私有实例变量和方法都会成为新类定义的一部分，子类可以直接使用这些实例变量和方法。
                  </span>
                  
                  <span style="display:block;margin-bottom:.3em;">
                  在类的实现部分声明和合成的实例变量是私有的，子类不能够直接访问。<br />
                  需要在类的接口文件中明确定义或合成取值方法，才能访问实例变量的值。
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface ClassA : NSObject {
    int x;      // 非私有实例变量，子类可以使用
}

-(void) initVar;
@end

@implementation ClassA {
    -(void) initVar {
        x = 100;
    }
}
@end


@interface ClassB :ClassA {
    -(void) printVar;
}
@end


@implementation ClassB {
    -(void) printVar {
        NSLog(@"x is %i", x);
    }
}
@end
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="定义一个矩形" id="sourceContent1" style="background-color:white;margin-top:2em;"
          titleStyle="background-color:white;color:black;padding-left:0;"
          bodyStyle="display:none;">
          <![CDATA[
                        ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="Rectangle.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface Rectangle : NSObject {
    @property int width, height;

    -(int) area;
    -(int) perimeter;
    
    -(void) setWidth: (int) width : andHeight: (int) height;
}
@end
          ]]>
      </c:sourceContent>


<c:sourceContent type="" title="Rectangle.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "Rectangle.h"

@implementation Rectangle

@synthesize width, height;

-(void) setWidth:(int) width: andHeight: (int) height {
    self.width = width;
    self.height = height;
}

-(int) area {
    return width * height;
}

-(int) perimeter {
    return (width + height) * 2;
}

@end
    ]]>
</c:sourceContent>


<c:sourceContent type="" title="driver" id="sourceContent1">
    <![CDATA[
#import "Rectangle.h"

int main (int argc, char *argv[]) {
    @autoreleasepool {
        Rectangle *rec = [[Rectangle alloc] init];

        [rec setWidth : 5 andHeight: 6];

        NSLog(@"Rectangle: w = %i, h = %i", rec.width, rec.height);
        NSLog(@"Area = %i, Perimeter = %i", [rec area], [rec perimeter]);
    }
    
    return 0;
}

    ]]>
</c:sourceContent>



<c:sourceContent type="html" title="定义一个正方形继承自矩形" id="sourceContent1" style="background-color:white;margin-top:2em;"
    titleStyle="background-color:white;color:black;padding-left:0;"
    bodyStyle="background-color:white;padding-left:0;">
    <![CDATA[
        
        <span style="display:block;margin-bottom:.3em;">
            将 Square 定义为 Rectangle 的子类，虽然正方形的四条边都相等，但在内部也可以用两个值表示，对于 Square 的使用者是隐藏的，如果需要可以随时重新定义 Square 类。
        </span>
    ]]>
</c:sourceContent>

<c:sourceContent type="" title="Square.h" id="sourceContent1">
    <![CDATA[
#import "Rectangle.h"


@interface Square : Rectangle

-(void) setSide : (int) s;
-(int) side;

@end
        
    ]]>
</c:sourceContent>



<c:sourceContent type="" title="Square.m" id="sourceContent1">
    <![CDATA[
#import "Square.h"


@interface Square

-(void) setSide : (int) s {
    [self setWidth: s andHeight: s];
}
-(int) side {
    // 此处用到的是一个取值方法，而不是实例变量
    // 此处的 .width 方法是从基类继承而来的
    // 子类不能调用基类的私有实例变量
    
    // 此处是执行取值方法，而不是获取实例变量
    return self.width;
}

@end

    ]]>
</c:sourceContent>


<c:sourceContent type="html" title="原点类" id="sourceContent1" style="background-color:white;margin-top:2em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;"
    bodyStyle="background-color:white;padding-left:0;">
    <![CDATA[
        
        <span style="display:block;margin-bottom:.3em;">
        在开发绘图应用程序的过程中需要处理很多坐标，所以定义一个 XYPoint 类。
        </span>
    ]]>
</c:sourceContent>

<c:sourceContent type="" title="XYPoint.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

@interface XYPoint : NSObject

@property int x, y;

-(void) setX:(int) xVal andY :(int) yVal;

@end

    ]]>
</c:sourceContent>


<c:sourceContent type="" title="XYPoint.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "XYPoint.h"

@implementation XYPoint

@synthesize x, y;

-(void) setX:(int) xVal andY :(int) yVal {
    x = xVal;
    y = yVal;
}

@end

    ]]>
</c:sourceContent>

<c:sourceContent type="" title="Rectangle.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "XYPoint.h"

@interface Rectangle : NSObject

@property int width, height;

-(XYPoint *) origin;
-(void) setOrigin : (XYPoint *) point;
-(void) setWidth : (int) w andHeight : (int) h;
-(int) area;
-(int) perimeter;

@end

    ]]>
</c:sourceContent>


<c:sourceContent type="" title="Rectangle.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "Rectangle.h"

@implementation Rectangle {
    XYPoint *origin;
}

@synthesize width, height;

-(XYPoint *) origin {
    // 此处应该创建一个 origin 的副本，从而避免该实例变量在类的外部被不经意的修改
    // ....
    return origin;
}

-(void) setOrigin : (XYPoint *) point {
    /*
        之所以没有使用合成方法来生成 origin 的取值与赋值方法.
        是因为默认情况下，合成的设置方法只是简单的复制对象指针，而不是对象本身.
    */

    // 如果 origin 为 0 时，创建和初始化一个新的 XYPoint 对象并存储在 origin 中
    if (!origin) {
        origin = [[XYPoint alloc] init];
    }

    origin.x = point.x;
    origin.y = point.y;
}

-(void) setWidth : (int) w andHeight : (int) h {
    width = w;
    height = h;
}

-(int) area {
    return w * h;
}

-(int) perimeter {
    return (width + height) * 2;
}

@end

    ]]>
</c:sourceContent>



<c:sourceContent type="html" title="覆写父类的方法" id="sourceContent1" style="margin-top:3em;"
                             titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
                             bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
        <span>
            不能通过继承删除或减少方法，但可以利用覆写来改变继承方法的定义
        </span>
        
    ]]>
</c:sourceContent>



<c:sourceContent type="" title="ClassA.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

@interface ClassA : NSObject {
    int x;      // 非私有实例变量
}

-(void) initVar ;

@end

    ]]>
</c:sourceContent>

<c:sourceContent type="" title="ClassA.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "ClassA.h"

@implementation ClassA

-(void) initVar {
    x = 100;
}

@end

    ]]>
</c:sourceContent>

<c:sourceContent type="" title="ClassB.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "ClassA.h"

@interface ClassB : ClassA

-(void) initVar;
-(void) printVal;       // 子类覆盖父类同名、同参且同返回值的方法

@end
    ]]>
</c:sourceContent>


<c:sourceContent type="" title="ClassB.M" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "ClassB.h"

@implementation ClassB

-(void) initVar {
    x = 300;
}

-(void) printVal {
    NSLog(@"x is %i", x);
}

@end
    ]]>
</c:sourceContent>




<c:sourceContent type="html" title="抽象类" id="sourceContent1" style="margin-top:3em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
    bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
        <span style="display:block;margin-bottom:.3em;">
        创建抽象类是为了更容易的创建子类，在抽象类中定义方法和实例变量，但不希望任何人从该类创建实例。
        </span>
        
        <span style="display:block;margin-bottom:.3em;">
        例如: 在 Foundation 中，NSNumber 是为了将数字作为对象处理而创建的抽象类。<br />
        
        </span>
        
    ]]>
</c:sourceContent>


      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>多态、动态类型、动态绑定</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;"><b>多态</b> 能使来自不同类的对象定义相同名称的方法。</span>
                  
                  <span style="display:block;margin-bottom:.3em;"><b>动态类型</b> 能使程序直到执行时才确定对象所属的类。</span>
                  
                  <span style="display:block;margin-bottom:.3em;"><b>动态绑定</b> 能使程序直到执行时才确定实际要调用的方法。</span>
              ]]>
          </c:desc1>
      </c:desc>
      
      
      <c:sourceContent type="" title="Complex.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface Complex : NSObject

@property double real, imaginary;

-(void) print;
-(void) setReal : (double) a andImaginary: (double) b ;
-(Complex *) add: (Complex *) f;

@end

          ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="Complex.m" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

#import "Complex.h"

@implementation Complex

@synthesize real, imaginary;

-(void) print {
    NSLog(@"%g + %g", real, imaginary);
}

-(void) setReal : (double) a andImaginary: (double) b {
    real = a;
    imaginary = b;
}

-(Complex *) add: (Complex *) f {
    Complex *result = [[Complex alloc] init];

    result.real = real + f.real;
    result.imaginary = imaginary + f.imaginary;

    return result;
}

@end

          ]]>
      </c:sourceContent>



<c:sourceContent type="html" title="动态绑定和 id 类型" id="sourceContent1" style="margin-top:3em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
    bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
        <span style="display:block;margin-bottom:.3em;">
        id 类型可以用来存储任何类的对象，声明为 id 类型的变量前面不可以加 * 号。
        </span>
        
        
        <span style="display:block;margin-bottom:.3em;">
        编译器将解释 id 类型的动作推迟到程序运行时，也就是说系统在运行时获取 id 对象的具体类型。
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        声明一个 id 类型的对象： <br />
        <b style="color:red;">
        id obj = [[Fraction alloc] init];
        <br />
        [obj print];
        </b>
        </span>
        <br />
        <span style="display:block;margin-bottom:.3em;">
        
        <b>静态类型</b> 将一个变量定义为特定类的对象时，使用的是 "静态类型". 静态类型指的是在定义变量时显示指定类名。使用静态类型可以提高程序可读性。
        </span>
        
    ]]>
</c:sourceContent>

<c:sourceContent type="html" title="NSObject 提供的处理动态类型的方法" id="sourceContent1">
    <![CDATA[
        <img style="max-width:100%;" src="//c2.staticflickr.com/4/3890/14719824349_a1a67f014e_c.jpg" />
        
        <br />
        <br />
        <span style="display:block;margin-bottom:.3em;">
            <b>根据类名创建该类的实例</b>
            <br />
            <b>Fraction *fraction = [Fraction class];</b>
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>根据根据变量命取得该变量所属的类</b>
        <br />
        <b>[fraction class];</b>
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>比较两个变量是不是同一个类</b>
        <br />
        <b>if ([obj1 class] == [obj2 class]) ...</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>查看 myFraction 是不是 Fraction 类的实例</b>
        <br />
        <b>[myFraction isMemberOfClass : [Fraction class]]</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>为名为 alloc 的方法生成一个 SEL 类型的值</b>
        <br />
        <b>@selector (alloc)</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>为名为 setTo:over: 的方法生成一个 selector</b>
        <br />
        <b>@selector (setTo:over:)</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>查看 Fraction 类是否能接收 setTo:over: 消息 (消息指的就是方法)</b>
        <br />
        <b>[Fraction instancesRespondToSelector : @selector (setTo:over:)]</b>
        </span>
        
        
        <br />
        <br />
        <span style="display:block;margin-bottom:.3em;">
        一个例子：<br />
        (SEL 变量 action 所指定的方法被发送到存储在 graphicObject 中的任何图形对象。)
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        SEL action; <br />
        id graphicObject; <br />
        
        <br />
        action = @select (drwa); <br />
        <br />
        
        在程序执行过程中 action 所指向的方法可能会被改变，所以在执行该方法之前需确定对象是否支持该方法<br />
        performSelector 用于向对象发送消息
        
        <br />
        <br />
        if ([graphicObject respondsToSelector : action] == YES) <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    [graphicObject performSelector : action]; <br/>
        else <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    // 错误处理代码 <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    。。。。 <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    // 也可以使用 forwardInvocation: 方法将消息转发给其它对象 <br/>
        </span>
    ]]>
</c:sourceContent>


<c:sourceContent type="" title="@try 异常处理" id="sourceContent1" style="margin-top:3em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
    bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
@try {





} @catch (NDException *exception) {

    NSLog(@"Caught %@%@", [exception name], [exception reason]);


}
    ]]>
</c:sourceContent>

      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>变量和数据类型</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
// 创建对象并初始化
Fraction *fraction = [[Fraction alloc] init];

// 赋值
[fraction setTo: 1 over: 3];


-(id) init {
    // 确保继承的实例变量被初始化
    self = [super init];
    
    // 初始化过程将改变对象在内存中的位置，所以必须将父类 init 方法的执行结果赋值给 self
    // 如果父类的初始化过程成功，返回值将是非空的
    if(self) {
        //..
    }

    return self;
}



@interface Printer {
    @private
        int pageCount;
        int tonerLevel;
    
    @protected
        // ..
        
    // 将实例变量声明为 public 不是一个良好的编程习惯，因为这违背了数据封装的思想
    // (即一个类需要隐藏它的实例变量)
    @public
        // ..
}


// 合成属性 window 的取值方法和设置方法，并将属性与实例变量 _window 关联起来
@synthesize window = _window;


// 在实现部分显示声明的实例变量 (或者使用 @synthesize 指令隐式声明的实例变量) 是私有的
// 这意味着不能在子类中通过名字直接获取到实例变量，但是可以使用继承的存取方法获取实例变量的值


// 小写 g 作为全局变量的首字母
// 用于初始化的方法以 init 开头



// 静态变量
// 静态变量声明在所有方法之外
static int gCounter;

@implementation Fraction

+(Fraction *) allocF {
    // 可以省略 extern 声明
    extern int gCounter;
    ++gCounter;

    return [Fraction alloc];
}

+(int) count {
    // 可以省略 extern 声明
    extern int gCounter;

    return gCounter;
}

@end




// 枚举类型
enum flag { false = 0, true = 1 };

enum flag endOfData, matchFound;
          ]]>
      </c:sourceContent>
      
      
     
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>typedef</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">将类名定义一个别名</span> <br />
                  <b>typedef int Counter;</b>
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="typedef" id="sourceContent1">
          <![CDATA[
              
          ]]>
      </c:sourceContent>
  
  <c:comment style="margin-top:2em;">
      <c:comment1 style="color:black;">
          <![CDATA[
          ]]>
      </c:comment1>
  </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:4em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>分类 (category) 和协议</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  1. 使用 category 以模块的方式向类添加方法 <br />
                  2. 协议 (类似与接口) 用于创建标准化的方法列表供其它人实现
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="Fraction.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface Fraction : NSObject

@property int numerator, denominator;

-(void) setTo : (int) n over : (int) b;
-(void) reduce;
-(double) convertToNum;
-(void) print;

@end
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="Fraction.m" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

#import "Fraction.h"

@implementation Fraction : NSObject

@synthesize numerator, denominator;

-(void) setTo : (int) n over : (int) b {
    numerator = n;
    denominator = b;
}

-(void) reduce {
    // ..
}

-(double) convertToNum {
    // ..
}
-(void) print {
    NSLog(@"numerator is %i, denominator is %i ", numerator, denominator);
}

@end
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="FractionMathOps.h" id="sourceContent1">
          <![CDATA[
#import "Fraction.h"

@interface Fraction (MathOps)

-(Fraction *) add : (Fraction *) f;
-(Fraction *) mul : (Fraction *) f;
-(Fraction *) sub : (Fraction *) f;
-(Fraction *) div : (Fraction *) f;

@end
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="FractionMathOps.m" id="sourceContent1">
          <![CDATA[
#import "FractionMathOps.h"

@implementation Fraction (MathOps)

-(Fraction *) add : (Fraction *) f {

}

-(Fraction *) mul : (Fraction *) f {

}

-(Fraction *) sub : (Fraction *) f {

}

-(Fraction *) div : (Fraction *) f {

}

@end
          ]]>
      </c:sourceContent>
      
      
      
      
      <c:sourceContent type="html" title="协议" id="sourceContent1" style="background-color:white;"
                       titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;margin-top:2em;"
                       bodyStyle="padding-left:0;padding-right:0;">
          <![CDATA[
              <span style="display:block;margin-bottom:.3em;">协议中列出的方法没有具体实现，它用指定的名称定义了一组多少有点相关的方法。</span>
              <span style="display:block;margin-bottom:.3em;">协议列出了一组方法，有些是可选实现，有些是必须实现。</span>
              <br />
              <span style="display:block;margin-bottom:.3em;"><b>下面是 Foundation 头文件 NSObject.h 中定义 NSCopying 协议的方式: </b></span>
              <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">@protocol NSCopying <br />
                
                -(id) copyWithZone : (NSZone *) zone; <br />
                
                @end
                </b>
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;"><b>下面是 AddressBook 类实现了 NSObject 中的 NSCopying 协议, 可以在尖括号中加 ， (逗号)</b></span>
              <span style="display:block;margin-bottom:.3em;">
              <b style="color:green;">@interface AddressBook :NSObject &lt;NSCopying&gt;<br /><br />
              
              // 不必在接口部分声明协议中的方法 <br />
              // 但是需要在实现部分中定义协议中的方法 <br /><br />
              
              
              
              @end
              </b>
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>如果希望子类实现一些父类的方法，则可以为父类定义一个协议，不必在父类中实现这些方法，但是可以指定一些方法，让子类去实现。<br />
              例如下面的 Drawing 协议：</b>
              <br />
              <b>(协议不引用任何类，它是无类的)</b>
                </span>
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">
                @protocol Drawing<br /><br />
                
                -(void) paint;<br />
                -(void) erase;<br /><br />
                
                @optional<br />
                -(void) outline;<br /><br />
                
                @end</b>
                </span>
                
                <span style="display:block;margin-bottom:.3em;">任何类都可以遵守 Drawing 协议，可以使用 conformsToProtocol : 方法检查一个对象是否遵守某项协议：
                <br />用 @protocol 指令获取一个 Protocol 对象</span>
                <br />
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">
                id currentObject;
                <br />
                <br />
                if ([currentObject conformsToProtocol: @protocol (Drawing)] == YES) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;    // 给 currentObject 发送 paint、 erase 或  outline 消息<br />
                
                <br />
                
                &nbsp;&nbsp;&nbsp;&nbsp;// 测试可选的 outline 方法 <br />
                &nbsp;&nbsp;&nbsp;&nbsp;if ([currentObject respondsToSelector : @selector (outline)] == YES) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[currentObject outline];<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                }
                </b>
                </span>
                <br />
                <br />
                <span style="display:block;margin-bottom:.3em;">
                    定义一个遵守 Drawing 协议的 id 类型：
                </span>
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">id &lt;Drawing&gt; currentObject;</b>
                </span>
                <br />
                <br />
                <span style="display:block;margin-bottom:.3em;">
                定义一个协议的同时，扩展现有的协议
                </span>
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">@protocol Drawing3D <Drawing></b>
                </span>

          ]]>
      </c:sourceContent>
      
      
      
      
      <c:sourceContent type="html" title="代理" id="sourceContent1" style="background-color:white;"
          titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;margin-top:2em;"
          bodyStyle="padding-left:0;padding-right:0;">
          <![CDATA[
              <span style="display:block;margin-bottom:.3em;">
                定义了协议的类可以看做是将协议定义的方法<b>代理</b>给了实现它们的类。这样类的定义更为通用，因为具体的动作由代理类来承担。<br />
                父类可以对子类这样说: 你做我的<b>代理</b>人吧，我有一些任务你帮我去做。
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              Cocoa 和 iOS 非常依赖代理这个概念，例如当你在 iPhone 上建立一个表格时，会用到 UITableView 类: <br/>
              <br />
              1. 这个类不知道表格的标题是什么。 <br/>
              2. 不知道需要包含多少个区块或多少行。 <br/>
              3. 不知道单元格的内容是什么。
              </span>
              <br />
              
              <span style="display:block;margin-bottom:.3em;">
              UITable 类定义了一个 UITableViewDataSource 协议，用于帮助 UITableView 类填充以上信息。
              </span>
              
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="html" title="合成 (composite) 对象" id="sourceContent1" style="background-color:white;"
          titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;margin-top:2em;"
          bodyStyle="padding-left:0;padding-right:0;">
          <![CDATA[
              <b style="color:green;">
              @interface Square : NSObject
              { <br />
              &nbsp;&nbsp;&nbsp;&nbsp;// 需要在实现部分覆写 init 方法或添加 initWithSide: 方法为包含的对象分配内存空间 <br />
              &nbsp;&nbsp;&nbsp;&nbsp;// 一旦包含的对象创建成功，就可以在实现部分使用 [rect some_methods] <br />
                &nbsp;&nbsp;&nbsp;&nbsp;Rectangle * rect; <br />
              } <br /> <br />
              
              -(int) setSide : (int) s; <br />
              -(int) side ; <br />
              -(int) area ; <br />
              -(int) perimeter; <br /> <br />
              
              @end
              </b>
              
          ]]>
      </c:sourceContent>



      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;"
      >
      <c:title>预处理程序</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  预处理程序使用井号作为一行的第一个字符，是 Object-C 编译过程的一部分
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:white;"
          bodyStyle="padding-left:0;padding-right:0;background-color:white;">
          <![CDATA[
              <b>#define FALSE 0</b> <b style="color:red;">\</b> (如果有多行需要用 <b style="color:red;">\</b> 换行)<br />
              在程序编译阶段，#define 预定义名称右边的所有字符都会被预处理程序自动替换到程序中。
              <br />
              <br />
              <b>
              #define IPAD 1
              <br />
              <br />
              #ifdef IPAD<br />
              # define kImageFile @"barnHD.png"<br />
              #else<br />
              # define kImageFile @"barn.png"<br />
              #endif<br />
              </b>
              <br />
              <b>#import &lt;Foundation/Foundation.h&gt;</b>
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>基本的 C 语言特性</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1"
          bodyStyle="background-color:white;padding-left:0;padding-right:0;">
          <![CDATA[
              
              <span style="display:block;margin-bottom:.3em;">
              对于大型数组数据可以使用 C 语言内置的数据结构而不是 NSArray
              </span>
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="" id="sourceContent1"
          bodyStyle="background-color:white;padding-left:0;padding-right:0;">
          <![CDATA[
              
              <span style="display:block;margin-bottom:.3em;font-size:2em;">
              指针
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>int i = 9; <br />
              int *iPtr = &i;</b>
              </span>
              
              
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>
              #import <Foundation/Foundation.h>
              <br />
              <br />
              
              int main(int argc, char *argv[]) { <br />
              &nbsp;&nbsp;&nbsp;&nbsp;    @autoreleasepool { <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int count = 10, x; <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int *intPtr = &count; <br />
                      
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        intPtr = &count;<br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        x = *intPtr;<br />
                      
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        NSLog(@"count = %i, x = %i", count, x);<br />
              &nbsp;&nbsp;&nbsp;&nbsp;   } <br />
              }<br />
              </b>
              </span>
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="" id="sourceContent1"
          bodyStyle="background-color:white;padding-left:0;padding-right:0;">
          <![CDATA[
              
              <span style="display:block;margin-bottom:.3em;font-size:2em;">
              函数指针
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>int (*fnPtr) (void); </b>
              </span>
              
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:3em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>Foundation 框架</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">
                    Objective-C 有 90 多个框架：<br />
                  </span>
                  <span style="display:block;margin-bottom:.3em;">
                    <b style="color:red;">Foundation</b> 框架为开发 Objective-C 程序奠定基础。 <br />
                    它包含一些基本对象，如：数字、字符串、数组、字典、集合、日期、时间、ARC 、文件系统、存储 (或归档) 对象、处理几何数据结构 (如点和长方形)。
                    </span>
                    <span style="display:block;margin-bottom:.3em;">
                    <b style="color:red;">Application Kit</b> 框架包含广泛的类和方法，用于开发交互式图形应用程序。 <br />
                    使得开发文本、菜单、工具栏、表、文档、剪贴板、窗口的过程变得简单。
                    </span>
                    
                    <br />
                    <span style="display:block;margin-bottom:.3em;font-weight:bold;color:green;">
                    在 Mac OS X 系统中，术语 <b style="color:blue;">Cocoa</b> 总的来说指的是 Foundation 框架、Application Kit 框架和名为 Core Data 的第三方框架。
                    </span>
                    <span style="display:block;margin-bottom:.3em;font-weight:bold;color:green;">
                    术语 <b style="color:blue;">Cocoa Touch</b> 指的是 Foundation、Core Data、UIKit 框架。
                    </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="使用帮助文档" id="sourceContent1">
          <![CDATA[
              <span style="display:block;margin-bottom:.3em;">XCode <b>&rarr;</b> Help <b>&rarr;</b> Document </span>
              <img style="max-width:100%" src="//c2.staticflickr.com/4/3843/14754616720_19ecd26783_z.jpg" />
              <br />
              
              
              <span style="display:block;margin-bottom:.3em;">将鼠标放在类、变量或方法上，按住 Option 键，同时单击鼠标: </span>
              <img style="max-width:100%" src="//c2.staticflickr.com/4/3843/14938242501_9fff9e8059_z.jpg" />
              <br />

          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>数字、字符串、集合</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">所有的基础数据对象都可以通过 <b>&lt;Foundation/Foundation.h&gt;</b> 一次性导入</span>
                  <span style="display:block;margin-bottom:.3em;">int、float、long、double 都是基本数据类型，它们都不是对象，不能向它们发送消息。</span>
                  <span style="display:block;margin-bottom:.3em;">NSArray 对象可以创建一个数组，并要求存储的值必须是对象。所以不能将任何基础数据类型存入 NSArray 中。</span>
                  <span style="display:block;margin-bottom:.3em;">NSNumber 可以存储基础数据类型，它会根据这些数据的类型创建<b style="color:blue;">对象</b>。</span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="Number" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        NSNumber *myNumber, *floatNumber, *intNumber;
        NSInteger myInt;

        // integer 类型
        intNumber = [NSNumber numberWithInteger : 100];
        myInt = [intNumber integerValue];
        NSLog(@"%li", myInt);
        
        
        // long 类型
        myNumber = [NSNumber numberWithLong : 0xabcdef];
        NSLog(@"%lx", [myNumber longValue]);
        
        // char 类型
        myNumber = [NSNumber numberWithChar : 'Y'];
        NSLog(@"%c", [myNumber charValue]);
        
        // float 类型
        floatNumber = [NSNumber numberWithFloat : 0.25];
        NSLog(@"%g", [floatNumber floatValue]);
        
        // double 类型
        myNumber = [NSNumber numberWithDouble : 12345+15];
        NSLog(@"%lg", [myNumber doubleValue]);
        
        
        // 发生错误 (将输出 0, 并且不会有错误消息)
        NSLog (@"%li", (long) [myNumber integerValue]);
        
        
        // 验证两个 number 是否相等
        if ([intNumber isEqualToNumber : floatNumber] == YES) {
            // equal
        } else {
            // not equal
        }
        
        // 比较大小
        if ([intNumber compare : myNumber ] == NSOrderedAscending) {
            // first less than second
            
        } elsif ([intNumber compare : myNumber ] == NSOrderSame) {
            // equals
            
        } else ([intNumber compare : myNumber ] == NSOrderedDescending){
            //
            
        }
        
        
        
        NSNumber *testNumber = [[NSNumber alloc] initWithInt : 50];
        
        // 不能修改前面创建的 NSNumber 对象的值，如一下语句将导致程序崩溃
        [testNumber initWith : 100];
        
        
        // numberWithInt 和 numberWithInteger 在使用上存在差别：
        // 1. numberWithInt 创建的整数需要使用 intValue 取值，使用 %i 作为格式化字符串显示它的值
        // 2. numberWithInteger 创建的整数需要使用 integerValue 取值，使用 %li 作为格式化字符串
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="NSNumber 的创建方法和检索方法" id="sourceContent1">
          <![CDATA[
              
              <img style="max-width:100%" src="//c2.staticflickr.com/4/3867/14755084647_ef65bdf30f_b.jpg" />
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="html" title="NSString 对象" id="sourceContent1">
          <![CDATA[
               <span style="display:block;margin-bottom:.3em;">
                NSString 对象由 unichar 字符组成，unichar 字符是符合 unicode 标准的多字节字符，可以处理包含数百万字符的字符集。
               </span>
          ]]>
      </c:sourceContent>
      
      
      
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        NSString *str = @"This is a String";
        NSLog(@"%@", str);
        
        
        NSNumber *intNumber = [NSNumber numberWithInteger : 100];
        NSLog(@"%@", intNumber);
    }

    return 0;
}
          ]]>
      </c:sourceContent>



<c:sourceContent type="" title="description" id="sourceContent1">
    <![CDATA[
// 子类可以覆写父类的 description 方法

-(NSString *) description {
    return [NSString stringWithFormat : @"%i / %i", numerator, denominator];
}
    ]]>
</c:sourceContent>

      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>可变对象与不可变对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span><b>@"Programming is fun"</b> 创建了一个内容不可更改的对象，可以使用 NSString 处理不可变对象。</span>
                  
                  <img style="max-width:100%" src="//c2.staticflickr.com/4/3862/14943557491_856bcf071b_b.jpg" />
                  <br />
                  <img style="max-width:100%" src="//c2.staticflickr.com/4/3915/14946380252_f27fbc1481_z.jpg" />
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="在程序中处理不可变字符串的基本方式" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        // str1 和 str2 所引用的字符串对象的字符不可以改变
        // 但是 str1 和 str2 是可以改变的，也就是说可以重新为它们指定其它不可变的字符串
        NSString *str1 = @"This is String A";
        NSString *str2 = @"This is String B";

        NSString *res;

        NSComparisonResult compareResult;

        // 取得字符串的长度
        NSLog (@"%lu", [str1 length]);

        // 将一个字符串复制到另一个字符串
        res = [NSString stringWithString : str1];
        NSLog (@"%@", res);

        // 将一个字符串复制到另一个字符串的末尾
        str2 = [str1 stringByAppendingString : str2];
        NSLog (@"Concatentation %@", str2);

        // 验证两个字符串是否相等
        if ([str1 isEqualToString : res] == YES) {
            NSLog (@"str1 == str2");
        } else {
            NSLog (@"str1 != str2");
        }

        // 验证一个字符串是否小于、等于、大于另一个字符串
        // caseInsensitiveCompare 比较时忽略大小写
        compareResult = [str1 compare : str2];
        
        if (compareResult == NSOrderedAscending) {
            NSLog (@"str1 < str2");
        } else if (compareResult == NSOrderedSame) {
            NSLog (@"str1 == str2");
        } else {
            // NSOrderedDescending
            NSLog (@"str1 > str2");
        }
        
        // 将字符串转成小写
        res = [str1 lowercaseString];
        
        // 转小写
        res ＝ [str1 uppercaseString];
        
        
        
        
        NSRange subRange;
        
        res = [str1 substringToIndex : 3];
        res = [str1 substringFromIndex : 5];
        
        res = [[str1 substringFromIndex : 5] substringToIndex : 3];
        res = [str1 substringWithRange : NSMakeRange (8, 6)];
        
        
        subRange = [str1 rangeOfString : @"String A"];
        
        if(subRange.location != NSNotFound)
            NSLog (@"String is at index %lu, length is %lu"
                    , subRange.location, subRange.length);
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="可变字符串" id="sourceContent1">
          <![CDATA[
/*
  NSMuTableString 类可以用来创建可以更改字符的字符串对象。
*/

#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        NSString *str1 = @"This is String A";
        NSString *str2 = @"This is String B";

        NSString *search, *replace;

        NSMutableString *mstr;

        NSRange substr;

        // 从不可变字符串创建可变字符串
        mstr = [NSMutableString stringWithString : str1];
        
        // 插入字符
        [mstr insertString : @" mutable" atIndex : 7];
        
        // 插入末尾
        [mstr insertString : @" mutable" atIndex : [mstr length]];
        
        // appendString
        [mstr appendString : @" mutable"];
        
        // 根据范围删除子字符串
        [mstr deleteCharactersInRange : NSMakeRange (16 , 3)];
        
        // 查找人后删除
        substr = [mstr rangeOfString : @" String A"];
        
        if (substr.location != NSNotFound) {
            [mstr deleteCharactersInRange :substr];
        }
        
        
        // 直接设置为可变字符串
        [mstr setString : str1];
        
        // 替换字符
        [mstr replaceCharactersInRange : NSMakeRange ( 8,8) withString : @"a mutable string"];
        
        
        // 查找和替换
        search = @"This is";
        replace = @"An example of";
        
        substr = [mstr rangeOfString : search];
        
        if (substr.location != NSNotFound) {
            [mstr replaceCharactersInRange : substr withString : replace];
        }
        
        
        // 查找和替换所有匹配项
        search = @"a";
        replace = @"X";
        
        substr = [mstr rangeOfString : search];
        while (substring.location != NSNotFound) {
            [mstr replaceCharactersInRange : substr withString : replac];
            substr = [mstr rangeOfString : search];
        }
        
        
        // 查找和替换所有匹配项
        [mstr replaceOccurrencesOfString : search
              withString: replace
              options: nil
              range : NSMakeRange (0, [mstr length])];
    }
    
    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="数组对象" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>使用文件</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>内存管理和自动引用计数</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>复制对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>归档</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>复制对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>Cocoa 和 Cocoa Touch</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>编写 iOS 应用程序</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>


</c:component>
