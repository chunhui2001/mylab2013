<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
        Objective-C 提供了 4 中基本数据类型: int， float， double， char <br />
        Objective-C 的限定词: long, long long ,short, unsigned , signed <br />
        
        long int: 长整型 <br />
        long long int: 长长整型 <br />
        unsigned int: 只能用于存储正整数 <br />
        
        <br />
        <b>复合类型</b> <br />
        BOOL YES or NO
    ]]>
  </c:abstract>

  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
    <c:title>第一个 Object-C 程序</c:title>
    <c:desc>
      <c:desc1>
        <![CDATA[。。]]>
      </c:desc1>
    </c:desc>

    <c:sourceContent type="" title="FristObjectiveCProgram.m" id="sourceContent1">
        <![CDATA[//
//  main.m
//  Product1
//
//  Created by Keesh on 14-8-8.
//  Copyright (c) 2014年 Chunhui.Zhang. All rights reserved.

#import <Foundation/Foundation.h>

int main (int argc, const char * argv[]) {

    // 自动释放池，即自动释放内存
    @autoreleasepool {
        // 如果字符串前面不加 @, 表示创建 C 类型的字符串
        // 加 @ 表示创建 NSString 类型的字符串
        NSLog(@"Hello Chunhui!");
        
        int i = 6;
        int b = 5;
        int c = 8;
        
        NSLog(@"6 + 5 = %i, 5 + 8 = %i", i + b, b + c);
	
    }

    return 0;
}
      ]]>
    </c:sourceContent>
    <c:comment style="margin-top:2em;">
      <c:comment1 style="color:black;">
        <![CDATA[
                ]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>类、对象和方法</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
            <span style="display:block;margin-bottom:.3em;">Objective-C 采用特定的语法对类和实例应用方法。</span>
            <span style="display:block;margin-bottom:.3em;">
            <b>[ ClassOrInstance method : paramters]</b>
            </span>
            <span style="display:block;margin-bottom:.3em;">
                左方括号后要紧跟类或实例的名称，后面可以是一个或多个空格，空格后面是将要执行的方法。
                <br />
                方法后面可以跟一个冒号， 冒号后面是参数列表。
            </span>
            <span style="display:block;margin-bottom:.3em;">
                请求一个类或者实例执行某个操作时，就是在向<b>接收者</b>发送一条<b>消息</b>，<b>消息</b>就是空格后面的方法，<b>接受者</b>就是空格前面的类或实例的名字。
            </span>
            <span style="display:block;margin-bottom:.3em;">
                <b>Car yourCar = [Car new]; <br />
                [yourCar run]; <br />
                [yourCar close]; <br />
                [yourCar shutdown]; <br />
                [yourCar shutdown : 5]; <br />
                </b>
            </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="一个打印分数的例子" id="sourceContent1">
          <![CDATA[#import <Foundation/Foundation.h>
              
@interface Fraction : NSObject

// 开头的 + 或 － 号说明此处定义的是方法
// 开头的 － 号说明该方法是一个实例方法，如果开头是 ＋ 号说明该方法是一个类方法
-(void) print;
-(void) setNumerator : (int) num;
-(void) setDenominator : (int) d;

@end




@implementation Fraction  {

  // 开头不带 - 或 + 号说明此处定义的是变量而不是方法
  int numerator;
  int denominator;
}

-(void) print {
  NSLog(@"The Fraction is %i/%i", numerator, denominator);
}

-(void) setNumerator : (int) num {
  numerator = num;
}

-(void) setDenomanitor : (int) d {
  denominator = d;
}

@end



int main (int argc, char *argv[]) {

  // 在过去，iOS 程序员需要给对象发送 release 消息，通知系统释放内存
  // 这在内存管理系统中称为手工引用计数
  // 在 XCode 4.2+ 版本中默认开启 ARC (自动引用计数)
  @autoreleasepool {
      Fraction *fraction;               // 根据 Fraction 的定义申请一块内存,
                                        // 并将该段内存的首地址存储在 fraction 中
                                        // 此时 fraction 仅仅是一个存储了一个内存地址的指针,
                                        // 内存中的数据有待填充
      
      fraction = [Fraction alloc];      // 向 Fraction 类发送初始化消息，以获得该实例的新实例，
                                        // alloc 继承自父类是 allocate 的缩写
      fraction = [fraction init];       // 向类的新实例发送初始化消息，创建对象之后必须进行初始化 init
      
      
      // 以上三行可以简写成 Fraction *fraction = [[Fraction alloc] init]
      
      
      [fraction setNumerator : 1];
      [fraction setDenomanitor : 3];
      
      [fraction print];
  }

  return 0;
}
          ]]>
          
          
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="基础数据类型" id="sourceContent1">
          <![CDATA[
              <img style="max-width:100%;" src="//c2.staticflickr.com/4/3860/14863454924_4830648da7_z.jpg" />
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="id 类型" id="sourceContent1">
          <![CDATA[
              <b>id 数据类型可以存储任何类型的对象，是 Objective-C 中十分重要的特性，它是 <b style="font-style:italic; color:green;">多态</b>、<b style="font-style:italic; color:green;">动态类型</b> 和 <b style="font-style:italic; color:green;">动态绑定</b> 的基础.</b> <br />
              例如如下语句将 graphicObject 声明为 id 类型的变量: <br/ >
              
              <b>id graphicObject; </b><br />
              
              <br />
              如下语句声明一个方法并具有 id 类型的返回值: <br />
              <b>-(id) newObject : (int) c ;
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="逻辑控制" id="sourceContent1">
          <![CDATA[
              <b>for</b> <br />
              <b>while</b><br />
              <b>do</b> <br />
              
              <br />
              
              <b>if</b> <br />
              <b>switch</b> <br />
              <b>conditional</b> <br />
              
              <br />
              
              <b>scanf("%i", &number);</b> &nbsp;&nbsp; scanf 从屏幕读取输入并存入变量 number 中，& 是寻址运算符
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>类</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[将类的声明和定义放在单独的文件中 <br />
              把类的声明放在 *.h 文件中 <br />
              把类的定义放在 *.m 文件中]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="在 XCode 中添加一个新类" id="sourceContent1">
          <![CDATA[
              <img style="max-width:90%;" src="//c2.staticflickr.com/4/3857/14870459004_09a8ec13b4_z.jpg" />
              <br />
              <span>
                单击 Next 并选中 Subclass of NSObject，再次单击 Next。(以 Fraction 类为例)<br />
                在 Save as 输入框中输入 Fraction.m 做为文件名，其它默认，点击 Save 将生成 Fraction.h 和 Fraction.m 两个文件。
              </span>
          ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="Fraction.h" id="sourceContent1">
          <![CDATA[#import <Foundation/Foundation.h>
              
@interface Fraction : NSObject

-(void) print;
-(void) setNumerator:(int) n;
-(void) setDenominator: (int) d;
-(void) numerator;
-(void) denominator;
-(double) convertToNum;

@end
          ]]>
      </c:sourceContent>
  <c:sourceContent type="" title="Fraction.m" id="sourceContent1">
      <![CDATA[#import "Fraction.h"
          
@implementation Fraction {
    int numerator;
    int denominator;
}

-(void) print {
    NSLog (@"%i / %i", numerator,denominator)
}

-(void) setNumerator:(int) n {
    numerator = n;
}

-(void) setDenominator: (int) d {
    denominator = d;
}

-(void) numerator {
    return numerator;
}

-(void) denominator {
    return denominator;
}

-(double) convertToNum {
    if(denominator != 0) {
        return (double) numerator / denominator;
    } else {
        return NAN;
    }
}

@end
      ]]>
  </c:sourceContent>
  
  <c:sourceContent type="html" title="合成存取方法" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">从 Objective-C 2.0 开始可以自动生成 <b>set</b> 和 <b>get</b> 方法。</span>
          <ul style="padding-left:1.5em;list-style:decimal;">
              <li>
                    <span style="display:block;margin-bottom:.3em;">在接口部分使用 @property 指令标识属性，这些属性的命名与实例变量相同:</span>
                    <span style="display:block;margin-bottom:.3em;"><b>@property int numerator, denominator;</b> </span>
                    <span style="display:block;margin-bottom:.3em;">使用 @property 指令就不需要在实现部分声明相应的实例变量</span>
              </li>
              <li>
                    <span style="display:block;margin-bottom:.3em;">在实现部分使用 @synthesize 指令标识实例变量:</span>
                    <span style="display:block;margin-bottom:.3em;"><b>@synthesize int numerator, denominator;</b> <br /></span>
                    <span style="display:block;margin-bottom:.3em;">@synthesize 将为实例变量生成赋值和取值方法</span>
              </li>
              <li>
                    <span style="display:block;margin-bottom:.3em;">编译器将自动生成如下方法:</span>
                    <br />
                    
                    -(void) setNumerator:(int) n {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    numerator = n;<br />
                    }<br /><br />

                    -(void) setDenominator: (int) d {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    denominator = d;<br />
                    }<br /><br />

                    -(void) numerator {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    return numerator;<br />
                    }<br /><br />

                    -(void) denominator {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;    return denominator;<br />
                    }
              </li>
          </ul>
      ]]>
  </c:sourceContent>
  
  <c:sourceContent type="html" title="使用 . 操作符访问属性" id="sourceContent1">
      <![CDATA[
        <span style="display:block;margin-bottom:.3em;">
            要取得 myFraction 中 numerator 的值，可以使用如下方法：
        </span>
        <span style="display:block;margin-bottom:.3em;">
            <b>[myFraction numerator]; </b>
        </span>
        <br />
        <span style="display:block;margin-bottom:.3em;">
            用点操作符重写等价的表达式：
        </span>
        
        <span style="display:block;margin-bottom:.3em;">
            <b>myFraction.numerator;</b>
            <br />
            <br />
            赋值：<br />
            <b>myFraction.numerator = 6;</b>
            <br />
            <br />
            等价于： <br />
            <b>[myFraction setNumerator:6];</b>
            
        </span>
        <br />
        
        <span style="display:block;margin-bottom:.3em;">
        注意:
        </span>
        
        <span style="display:block;margin-bottom:.3em;color:red;">
        点操作符通常用来操作属性，即用来设置或取得实例变量的值。<br />
        虽然 . 操作符也可以用来执行方法 (方法在 Objective-C 中也可以叫做任务)，但任务通常不是由 . 操作符来执行。<br />
        在 Objective－C 中，任务的执行是通过使用传统的方括号形式的<b>消息表达式</b>作为首选的语法。
        
        </span>
        
        <span style="display:block;margin-bottom:.3em;color:red;">
        使用合成 (synthesize) 的存取方法，属性名称前不要以 new、alloc、copy、init 这些词开头。
        
        </span>
        
      ]]>
  </c:sourceContent>
  
  <c:sourceContent type="html" title="具有多个参数的任务" id="sourceContent1">
        <![CDATA[
            <span style="display:block;margin-bottom:.3em;">
            通过列出多个连续的参数并用冒号将其连接起来，就可以定义一个接收多个参数的方法。
            </span>
            
            <span style="display:block;margin-bottom:.3em;">
            命名参数：<br />
            -(void) setTo: (int) n over: (int) d { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    numerator = n;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;    denominator = d;<br />
            }
            </span>
            
            
            <span style="display:block;margin-bottom:.3em;">
            调用：
            <br />
            <b>[myFraction setTo:1 over:3]</b>
            </span>
            
            <br />
            <br />
            
            <span style="display:block;margin-bottom:.3em;">
            非命名参数：<br />
            -(void) set: (int) n : (int) d { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    numerator = n;<br />
            &nbsp;&nbsp;&nbsp;&nbsp;    denominator = d;<br />
            }
            </span>
            
            
            <span style="display:block;margin-bottom:.3em;">
            调用：
            <br />
            <b>[myFraction setTo:1 :3]</b>
            </span>
            <br />
            <span style="display:block;margin-bottom:.3em;color:red;">
            <b>注:在编写新方法时省略参数命不是一种良好的编程风格，因为它使程序很难读懂并且很不直观。</b>
            </span>
        ]]>
  </c:sourceContent>
  
  
  <c:sourceContent type="html" title="局部变量" id="sourceContent1">
      <![CDATA[
            <span style="display:block;margin-bottom:.3em;">考虑以下方法：</span>
            <span style="display:block;margin-bottom:.3em;">
            -(void) reduce { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    int u = numerator; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    int v = denominator; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    int temp; <br />
                 <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    while (v != 0) { <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        temp = u % v; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        u = v; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        v= temp; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    } <br />
                 <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    numerator /= u; <br />
            &nbsp;&nbsp;&nbsp;&nbsp;    denominator /= u; <br />
            }
            </span>
            
            <br />
            <br />
            
            <span style="display:block;margin-bottom:.3em;">
                在这个方法中声明了 3 个局部变量, 这些变量对于 reduce 方法来说是局部变量，并且只能在 reduce 方法中访问。<br />并且当方法返回时这些变量的值都消失了。
            </span>
            
            
            <span style="display:block;margin-bottom:.3em;">
                局部变量是基本的 C 数据类型，没有默认的初始值，所以在使用前要先赋值。
            </span>
      ]]>
  </c:sourceContent>
  
  
  <c:sourceContent type="html" title="方法的参数" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">
            方法的参数命也是局部变量。执行方法时，通过方法传递的任何参数都被复制到局部变量中。<br />
            因为方法使用的是参数的副本，所以不能改变通过方法传递的参数原始值。
            <br />
            <br />
            如果方法的参数是对象，即当传递一个对象作为方法的参数时，实际上是传递了该对象的指针。<br />
            正因为如此，你才能修改参数对象的数据。
          </span>
      ]]>
  </c:sourceContent>
  
  
  
  <c:sourceContent type="html" title="static 关键字" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">
          <b>static int i = 0;</b>
          
          </span>
          
          <span style="display:block;margin-bottom:.3em;">
          和其它基本数据类型的初始值不同，静态变量的初始值是 0，并且在程序开始执行时初始化一次，在多次调用方法时保存这些数值。
          <br />
          通常将静态变量的声明放到 implementation 文件的开始处，这样所有的方法都能访问它们。
          
          </span>
      ]]>
  </c:sourceContent>
  
  
  
  <c:sourceContent type="html" title="self 关键字" id="sourceContent1">
      <![CDATA[
          <span style="display:block;margin-bottom:.3em;">
            <b>相当于 this</b>
          </span>
      ]]>
  </c:sourceContent>
  
  
  
  <c:sourceContent type="" title="在方法中分配和返回对象" id="sourceContent1">
      <![CDATA[
-(Fraction *) add: (Fraction *) f {
    Fraction *result = [[Fraction alloc] init];
    
    // do something...
    [result reduce];
    
    return result ;
}
      ]]>
  </c:sourceContent>
  
  



      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>继承</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">
                    父类的非私有实例变量和方法都会成为新类定义的一部分，子类可以直接使用这些实例变量和方法。
                  </span>
                  
                  <span style="display:block;margin-bottom:.3em;">
                  在类的实现部分声明和合成的实例变量是私有的，子类不能够直接访问。<br />
                  需要在类的接口文件中明确定义或合成取值方法，才能访问实例变量的值。
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface ClassA : NSObject {
    int x;      // 非私有实例变量，子类可以使用
}

-(void) initVar;
@end

@implementation ClassA {
    -(void) initVar {
        x = 100;
    }
}
@end


@interface ClassB :ClassA {
    -(void) printVar;
}
@end


@implementation ClassB {
    -(void) printVar {
        NSLog(@"x is %i", x);
    }
}
@end
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="定义一个矩形" id="sourceContent1" style="background-color:white;margin-top:2em;"
          titleStyle="background-color:white;color:black;padding-left:0;"
          bodyStyle="display:none;">
          <![CDATA[
                        ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="Rectangle.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface Rectangle : NSObject {
    @property int width, height;

    -(int) area;
    -(int) perimeter;
    
    -(void) setWidth: (int) width : andHeight: (int) height;
}
@end
          ]]>
      </c:sourceContent>


<c:sourceContent type="" title="Rectangle.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "Rectangle.h"

@implementation Rectangle

@synthesize width, height;

-(void) setWidth:(int) width: andHeight: (int) height {
    self.width = width;
    self.height = height;
}

-(int) area {
    return width * height;
}

-(int) perimeter {
    return (width + height) * 2;
}

@end
    ]]>
</c:sourceContent>


<c:sourceContent type="" title="driver" id="sourceContent1">
    <![CDATA[
#import "Rectangle.h"

int main (int argc, char *argv[]) {
    @autoreleasepool {
        Rectangle *rec = [[Rectangle alloc] init];

        [rec setWidth : 5 andHeight: 6];

        NSLog(@"Rectangle: w = %i, h = %i", rec.width, rec.height);
        NSLog(@"Area = %i, Perimeter = %i", [rec area], [rec perimeter]);
    }
    
    return 0;
}

    ]]>
</c:sourceContent>



<c:sourceContent type="html" title="定义一个正方形继承自矩形" id="sourceContent1" style="background-color:white;margin-top:2em;"
    titleStyle="background-color:white;color:black;padding-left:0;"
    bodyStyle="background-color:white;padding-left:0;">
    <![CDATA[
        
        <span style="display:block;margin-bottom:.3em;">
            将 Square 定义为 Rectangle 的子类，虽然正方形的四条边都相等，但在内部也可以用两个值表示，对于 Square 的使用者是隐藏的，如果需要可以随时重新定义 Square 类。
        </span>
    ]]>
</c:sourceContent>

<c:sourceContent type="" title="Square.h" id="sourceContent1">
    <![CDATA[
#import "Rectangle.h"


@interface Square : Rectangle

-(void) setSide : (int) s;
-(int) side;

@end
        
    ]]>
</c:sourceContent>



<c:sourceContent type="" title="Square.m" id="sourceContent1">
    <![CDATA[
#import "Square.h"


@interface Square

-(void) setSide : (int) s {
    [self setWidth: s andHeight: s];
}
-(int) side {
    // 此处用到的是一个取值方法，而不是实例变量
    // 此处的 .width 方法是从基类继承而来的
    // 子类不能调用基类的私有实例变量
    
    // 此处是执行取值方法，而不是获取实例变量
    return self.width;
}

@end

    ]]>
</c:sourceContent>


<c:sourceContent type="html" title="原点类" id="sourceContent1" style="background-color:white;margin-top:2em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;"
    bodyStyle="background-color:white;padding-left:0;">
    <![CDATA[
        
        <span style="display:block;margin-bottom:.3em;">
        在开发绘图应用程序的过程中需要处理很多坐标，所以定义一个 XYPoint 类。
        </span>
    ]]>
</c:sourceContent>

<c:sourceContent type="" title="XYPoint.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

@interface XYPoint : NSObject

@property int x, y;

-(void) setX:(int) xVal andY :(int) yVal;

@end

    ]]>
</c:sourceContent>


<c:sourceContent type="" title="XYPoint.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "XYPoint.h"

@implementation XYPoint

@synthesize x, y;

-(void) setX:(int) xVal andY :(int) yVal {
    x = xVal;
    y = yVal;
}

@end

    ]]>
</c:sourceContent>

<c:sourceContent type="" title="Rectangle.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "XYPoint.h"

@interface Rectangle : NSObject

@property int width, height;

-(XYPoint *) origin;
-(void) setOrigin : (XYPoint *) point;
-(void) setWidth : (int) w andHeight : (int) h;
-(int) area;
-(int) perimeter;

@end

    ]]>
</c:sourceContent>


<c:sourceContent type="" title="Rectangle.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "Rectangle.h"

@implementation Rectangle {
    XYPoint *origin;
}

@synthesize width, height;

-(XYPoint *) origin {
    // 此处应该创建一个 origin 的副本，从而避免该实例变量在类的外部被不经意的修改
    // ....
    return origin;
}

-(void) setOrigin : (XYPoint *) point {
    /*
        之所以没有使用合成方法来生成 origin 的取值与赋值方法.
        是因为默认情况下，合成的设置方法只是简单的复制对象指针，而不是对象本身.
    */

    // 如果 origin 为 0 时，创建和初始化一个新的 XYPoint 对象并存储在 origin 中
    if (!origin) {
        origin = [[XYPoint alloc] init];
    }

    origin.x = point.x;
    origin.y = point.y;
}

-(void) setWidth : (int) w andHeight : (int) h {
    width = w;
    height = h;
}

-(int) area {
    return w * h;
}

-(int) perimeter {
    return (width + height) * 2;
}

@end

    ]]>
</c:sourceContent>



<c:sourceContent type="html" title="覆写父类的方法" id="sourceContent1" style="margin-top:3em;"
                             titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
                             bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
        <span>
            不能通过继承删除或减少方法，但可以利用覆写来改变继承方法的定义
        </span>
        
    ]]>
</c:sourceContent>



<c:sourceContent type="" title="ClassA.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

@interface ClassA : NSObject {
    int x;      // 非私有实例变量
}

-(void) initVar ;

@end

    ]]>
</c:sourceContent>

<c:sourceContent type="" title="ClassA.m" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "ClassA.h"

@implementation ClassA

-(void) initVar {
    x = 100;
}

@end

    ]]>
</c:sourceContent>

<c:sourceContent type="" title="ClassB.h" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "ClassA.h"

@interface ClassB : ClassA

-(void) initVar;
-(void) printVal;       // 子类覆盖父类同名、同参且同返回值的方法

@end
    ]]>
</c:sourceContent>


<c:sourceContent type="" title="ClassB.M" id="sourceContent1">
    <![CDATA[
#import <Foundation/Foundation.h>

#import "ClassB.h"

@implementation ClassB

-(void) initVar {
    x = 300;
}

-(void) printVal {
    NSLog(@"x is %i", x);
}

@end
    ]]>
</c:sourceContent>




<c:sourceContent type="html" title="抽象类" id="sourceContent1" style="margin-top:3em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
    bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
        <span style="display:block;margin-bottom:.3em;">
        创建抽象类是为了更容易的创建子类，在抽象类中定义方法和实例变量，但不希望任何人从该类创建实例。
        </span>
        
        <span style="display:block;margin-bottom:.3em;">
        例如: 在 Foundation 中，NSNumber 是为了将数字作为对象处理而创建的抽象类。<br />
        
        </span>
        
    ]]>
</c:sourceContent>


      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>多态、动态类型、动态绑定</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;"><b>多态</b> 能使来自不同类的对象定义相同名称的方法。</span>
                  
                  <span style="display:block;margin-bottom:.3em;"><b>动态类型</b> 能使程序直到执行时才确定对象所属的类。</span>
                  
                  <span style="display:block;margin-bottom:.3em;"><b>动态绑定</b> 能使程序直到执行时才确定实际要调用的方法。</span>
              ]]>
          </c:desc1>
      </c:desc>
      
      
      <c:sourceContent type="" title="Complex.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface Complex : NSObject

@property double real, imaginary;

-(void) print;
-(void) setReal : (double) a andImaginary: (double) b ;
-(Complex *) add: (Complex *) f;

@end

          ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="Complex.m" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

#import "Complex.h"

@implementation Complex

@synthesize real, imaginary;

-(void) print {
    NSLog(@"%g + %g", real, imaginary);
}

-(void) setReal : (double) a andImaginary: (double) b {
    real = a;
    imaginary = b;
}

-(Complex *) add: (Complex *) f {
    Complex *result = [[Complex alloc] init];

    result.real = real + f.real;
    result.imaginary = imaginary + f.imaginary;

    return result;
}

@end

          ]]>
      </c:sourceContent>



<c:sourceContent type="html" title="动态绑定和 id 类型" id="sourceContent1" style="margin-top:3em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
    bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
        <span style="display:block;margin-bottom:.3em;">
        id 类型可以用来存储任何类的对象，声明为 id 类型的变量前面不可以加 * 号。
        </span>
        
        
        <span style="display:block;margin-bottom:.3em;">
        编译器将解释 id 类型的动作推迟到程序运行时，也就是说系统在运行时获取 id 对象的具体类型。
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        声明一个 id 类型的对象： <br />
        <b style="color:red;">
        id obj = [[Fraction alloc] init];
        <br />
        [obj print];
        </b>
        </span>
        <br />
        <span style="display:block;margin-bottom:.3em;">
        
        <b>静态类型</b> 将一个变量定义为特定类的对象时，使用的是 "静态类型". 静态类型指的是在定义变量时显示指定类名。使用静态类型可以提高程序可读性。
        </span>
        
    ]]>
</c:sourceContent>

<c:sourceContent type="html" title="NSObject 提供的处理动态类型的方法" id="sourceContent1">
    <![CDATA[
        <img style="max-width:100%;" src="//c2.staticflickr.com/4/3890/14719824349_a1a67f014e_c.jpg" />
        
        <br />
        <br />
        <span style="display:block;margin-bottom:.3em;">
            <b>根据类名创建该类的实例</b>
            <br />
            <b>Fraction *fraction = [Fraction class];</b>
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>根据根据变量命取得该变量所属的类</b>
        <br />
        <b>[fraction class];</b>
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>比较两个变量是不是同一个类</b>
        <br />
        <b>if ([obj1 class] == [obj2 class]) ...</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>查看 myFraction 是不是 Fraction 类的实例</b>
        <br />
        <b>[myFraction isMemberOfClass : [Fraction class]]</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>为名为 alloc 的方法生成一个 SEL 类型的值</b>
        <br />
        <b>@selector (alloc)</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>为名为 setTo:over: 的方法生成一个 selector</b>
        <br />
        <b>@selector (setTo:over:)</b>
        </span>
        
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        <b>查看 Fraction 类是否能接收 setTo:over: 消息 (消息指的就是方法)</b>
        <br />
        <b>[Fraction instancesRespondToSelector : @selector (setTo:over:)]</b>
        </span>
        
        
        <br />
        <br />
        <span style="display:block;margin-bottom:.3em;">
        一个例子：<br />
        (SEL 变量 action 所指定的方法被发送到存储在 graphicObject 中的任何图形对象。)
        </span>
        
        <br />
        <span style="display:block;margin-bottom:.3em;">
        SEL action; <br />
        id graphicObject; <br />
        
        <br />
        action = @select (drwa); <br />
        <br />
        
        在程序执行过程中 action 所指向的方法可能会被改变，所以在执行该方法之前需确定对象是否支持该方法<br />
        performSelector 用于向对象发送消息
        
        <br />
        <br />
        if ([graphicObject respondsToSelector : action] == YES) <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    [graphicObject performSelector : action]; <br/>
        else <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    // 错误处理代码 <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    。。。。 <br/>
        &nbsp;&nbsp;&nbsp;&nbsp;    // 也可以使用 forwardInvocation: 方法将消息转发给其它对象 <br/>
        </span>
    ]]>
</c:sourceContent>


<c:sourceContent type="" title="@try 异常处理" id="sourceContent1" style="margin-top:3em;"
    titleStyle="background-color:white;color:black;padding-left:0;font-size:1.3em;"
    bodyStyle="background-color:white;padding-left:0;padding-right:0;">
    <![CDATA[
@try {





} @catch (NDException *exception) {

    NSLog(@"Caught %@%@", [exception name], [exception reason]);


}
    ]]>
</c:sourceContent>

      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>变量和数据类型</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
// 创建对象并初始化
Fraction *fraction = [[Fraction alloc] init];

// 赋值
[fraction setTo: 1 over: 3];


-(id) init {
    // 确保继承的实例变量被初始化
    self = [super init];
    
    // 初始化过程将改变对象在内存中的位置，所以必须将父类 init 方法的执行结果赋值给 self
    // 如果父类的初始化过程成功，返回值将是非空的
    if(self) {
        //..
    }

    return self;
}



@interface Printer {
    @private
        int pageCount;
        int tonerLevel;
    
    @protected
        // ..
        
    // 将实例变量声明为 public 不是一个良好的编程习惯，因为这违背了数据封装的思想
    // (即一个类需要隐藏它的实例变量)
    @public
        // ..
}


// 合成属性 window 的取值方法和设置方法，并将属性与实例变量 _window 关联起来
@synthesize window = _window;


// 在实现部分显示声明的实例变量 (或者使用 @synthesize 指令隐式声明的实例变量) 是私有的
// 这意味着不能在子类中通过名字直接获取到实例变量，但是可以使用继承的存取方法获取实例变量的值


// 小写 g 作为全局变量的首字母
// 用于初始化的方法以 init 开头



// 静态变量
// 静态变量声明在所有方法之外
static int gCounter;

@implementation Fraction

+(Fraction *) allocF {
    // 可以省略 extern 声明
    extern int gCounter;
    ++gCounter;

    return [Fraction alloc];
}

+(int) count {
    // 可以省略 extern 声明
    extern int gCounter;

    return gCounter;
}

@end




// 枚举类型
enum flag { false = 0, true = 1 };

enum flag endOfData, matchFound;
          ]]>
      </c:sourceContent>
      
      
     
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>typedef</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">将类名定义一个别名</span> <br />
                  <b>typedef int Counter;</b>
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="typedef" id="sourceContent1">
          <![CDATA[
              
          ]]>
      </c:sourceContent>
  
  <c:comment style="margin-top:2em;">
      <c:comment1 style="color:black;">
          <![CDATA[
          ]]>
      </c:comment1>
  </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:4em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>分类 (category) 和协议</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  1. 使用 category 以模块的方式向类添加方法 <br />
                  2. 协议 (类似与接口) 用于创建标准化的方法列表供其它人实现
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="Fraction.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface Fraction : NSObject

@property int numerator, denominator;

-(void) setTo : (int) n over : (int) b;
-(void) reduce;
-(double) convertToNum;
-(void) print;

@end
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="Fraction.m" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

#import "Fraction.h"

@implementation Fraction : NSObject

@synthesize numerator, denominator;

-(void) setTo : (int) n over : (int) b {
    numerator = n;
    denominator = b;
}

-(void) reduce {
    // ..
}

-(double) convertToNum {
    // ..
}
-(void) print {
    NSLog(@"numerator is %i, denominator is %i ", numerator, denominator);
}

@end
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="FractionMathOps.h" id="sourceContent1">
          <![CDATA[
#import "Fraction.h"

@interface Fraction (MathOps)

-(Fraction *) add : (Fraction *) f;
-(Fraction *) mul : (Fraction *) f;
-(Fraction *) sub : (Fraction *) f;
-(Fraction *) div : (Fraction *) f;

@end
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="FractionMathOps.m" id="sourceContent1">
          <![CDATA[
#import "FractionMathOps.h"

@implementation Fraction (MathOps)

-(Fraction *) add : (Fraction *) f {

}

-(Fraction *) mul : (Fraction *) f {

}

-(Fraction *) sub : (Fraction *) f {

}

-(Fraction *) div : (Fraction *) f {

}

@end
          ]]>
      </c:sourceContent>
      
      
      
      
      <c:sourceContent type="html" title="协议" id="sourceContent1" style="background-color:white;"
                       titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;margin-top:2em;"
                       bodyStyle="padding-left:0;padding-right:0;">
          <![CDATA[
              <span style="display:block;margin-bottom:.3em;">协议中列出的方法没有具体实现，它用指定的名称定义了一组多少有点相关的方法。</span>
              <span style="display:block;margin-bottom:.3em;">协议列出了一组方法，有些是可选实现，有些是必须实现。</span>
              <br />
              <span style="display:block;margin-bottom:.3em;"><b>下面是 Foundation 头文件 NSObject.h 中定义 NSCopying 协议的方式: </b></span>
              <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">@protocol NSCopying <br />
                
                -(id) copyWithZone : (NSZone *) zone; <br />
                
                @end
                </b>
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;"><b>下面是 AddressBook 类实现了 NSObject 中的 NSCopying 协议, 可以在尖括号中加 ， (逗号)</b></span>
              <span style="display:block;margin-bottom:.3em;">
              <b style="color:green;">@interface AddressBook :NSObject &lt;NSCopying&gt;<br /><br />
              
              // 不必在接口部分声明协议中的方法 <br />
              // 但是需要在实现部分中定义协议中的方法 <br /><br />
              
              
              
              @end
              </b>
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>如果希望子类实现一些父类的方法，则可以为父类定义一个协议，不必在父类中实现这些方法，但是可以指定一些方法，让子类去实现。<br />
              例如下面的 Drawing 协议：</b>
              <br />
              <b>(协议不引用任何类，它是无类的)</b>
                </span>
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">
                @protocol Drawing<br /><br />
                
                -(void) paint;<br />
                -(void) erase;<br /><br />
                
                @optional<br />
                -(void) outline;<br /><br />
                
                @end</b>
                </span>
                
                <span style="display:block;margin-bottom:.3em;">任何类都可以遵守 Drawing 协议，可以使用 conformsToProtocol : 方法检查一个对象是否遵守某项协议：
                <br />用 @protocol 指令获取一个 Protocol 对象</span>
                <br />
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">
                id currentObject;
                <br />
                <br />
                if ([currentObject conformsToProtocol: @protocol (Drawing)] == YES) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;    // 给 currentObject 发送 paint、 erase 或  outline 消息<br />
                
                <br />
                
                &nbsp;&nbsp;&nbsp;&nbsp;// 测试可选的 outline 方法 <br />
                &nbsp;&nbsp;&nbsp;&nbsp;if ([currentObject respondsToSelector : @selector (outline)] == YES) {<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[currentObject outline];<br />
                &nbsp;&nbsp;&nbsp;&nbsp;}<br />
                }
                </b>
                </span>
                <br />
                <br />
                <span style="display:block;margin-bottom:.3em;">
                    定义一个遵守 Drawing 协议的 id 类型：
                </span>
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">id &lt;Drawing&gt; currentObject;</b>
                </span>
                <br />
                <br />
                <span style="display:block;margin-bottom:.3em;">
                定义一个协议的同时，扩展现有的协议
                </span>
                <span style="display:block;margin-bottom:.3em;">
                <b style="color:green;">@protocol Drawing3D <Drawing></b>
                </span>

          ]]>
      </c:sourceContent>
      
      
      
      
      <c:sourceContent type="html" title="代理" id="sourceContent1" style="background-color:white;"
          titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;margin-top:2em;"
          bodyStyle="padding-left:0;padding-right:0;">
          <![CDATA[
              <span style="display:block;margin-bottom:.3em;">
                定义了协议的类可以看做是将协议定义的方法<b>代理</b>给了实现它们的类。这样类的定义更为通用，因为具体的动作由代理类来承担。<br />
                父类可以对子类这样说: 你做我的<b>代理</b>人吧，我有一些任务你帮我去做。
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              Cocoa 和 iOS 非常依赖代理这个概念，例如当你在 iPhone 上建立一个表格时，会用到 UITableView 类: <br/>
              <br />
              1. 这个类不知道表格的标题是什么。 <br/>
              2. 不知道需要包含多少个区块或多少行。 <br/>
              3. 不知道单元格的内容是什么。
              </span>
              <br />
              
              <span style="display:block;margin-bottom:.3em;">
              UITable 类定义了一个 UITableViewDataSource 协议，用于帮助 UITableView 类填充以上信息。
              </span>
              
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="html" title="合成 (composite) 对象" id="sourceContent1" style="background-color:white;"
          titleStyle="background-color:white;color:black;padding-left:0;font-size:2em;margin-top:2em;"
          bodyStyle="padding-left:0;padding-right:0;">
          <![CDATA[
              <b style="color:green;">
              @interface Square : NSObject
              { <br />
              &nbsp;&nbsp;&nbsp;&nbsp;// 需要在实现部分覆写 init 方法或添加 initWithSide: 方法为包含的对象分配内存空间 <br />
              &nbsp;&nbsp;&nbsp;&nbsp;// 一旦包含的对象创建成功，就可以在实现部分使用 [rect some_methods] <br />
                &nbsp;&nbsp;&nbsp;&nbsp;Rectangle * rect; <br />
              } <br /> <br />
              
              -(int) setSide : (int) s; <br />
              -(int) side ; <br />
              -(int) area ; <br />
              -(int) perimeter; <br /> <br />
              
              @end
              </b>
              
          ]]>
      </c:sourceContent>



      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;"
      >
      <c:title>预处理程序</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  预处理程序使用井号作为一行的第一个字符，是 Object-C 编译过程的一部分
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:white;"
          bodyStyle="padding-left:0;padding-right:0;background-color:white;">
          <![CDATA[
              <b>#define FALSE 0</b> <b style="color:red;">\</b> (如果有多行需要用 <b style="color:red;">\</b> 换行)<br />
              在程序编译阶段，#define 预定义名称右边的所有字符都会被预处理程序自动替换到程序中。
              <br />
              <br />
              <b>
              #define IPAD 1
              <br />
              <br />
              #ifdef IPAD<br />
              # define kImageFile @"barnHD.png"<br />
              #else<br />
              # define kImageFile @"barn.png"<br />
              #endif<br />
              </b>
              <br />
              <b>#import &lt;Foundation/Foundation.h&gt;</b>
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>基本的 C 语言特性</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1"
          bodyStyle="background-color:white;padding-left:0;padding-right:0;">
          <![CDATA[
              
              <span style="display:block;margin-bottom:.3em;">
              对于大型数组数据可以使用 C 语言内置的数据结构而不是 NSArray
              </span>
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="" id="sourceContent1"
          bodyStyle="background-color:white;padding-left:0;padding-right:0;">
          <![CDATA[
              
              <span style="display:block;margin-bottom:.3em;font-size:2em;">
              指针
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>int i = 9; <br />
              int *iPtr = &i;</b>
              </span>
              
              
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>
              #import <Foundation/Foundation.h>
              <br />
              <br />
              
              int main(int argc, char *argv[]) { <br />
              &nbsp;&nbsp;&nbsp;&nbsp;    @autoreleasepool { <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int count = 10, x; <br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        int *intPtr = &count; <br />
                      
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        intPtr = &count;<br />
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        x = *intPtr;<br />
                      
              &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;        NSLog(@"count = %i, x = %i", count, x);<br />
              &nbsp;&nbsp;&nbsp;&nbsp;   } <br />
              }<br />
              </b>
              </span>
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="" id="sourceContent1"
          bodyStyle="background-color:white;padding-left:0;padding-right:0;">
          <![CDATA[
              
              <span style="display:block;margin-bottom:.3em;font-size:2em;">
              函数指针
              </span>
              <br />
              <span style="display:block;margin-bottom:.3em;">
              <b>int (*fnPtr) (void); </b>
              </span>
              
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  
  <c:entry style="margin-top:3em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>Foundation 框架</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">
                    Objective-C 有 90 多个框架：<br />
                  </span>
                  <span style="display:block;margin-bottom:.3em;">
                    <b style="color:red;">Foundation</b> 框架为开发 Objective-C 程序奠定基础。 <br />
                    它包含一些基本对象，如：数字、字符串、数组、字典、集合、日期、时间、ARC 、文件系统、存储 (或归档) 对象、处理几何数据结构 (如点和长方形)。
                    </span>
                    <span style="display:block;margin-bottom:.3em;">
                    <b style="color:red;">Application Kit</b> 框架包含广泛的类和方法，用于开发交互式图形应用程序。 <br />
                    使得开发文本、菜单、工具栏、表、文档、剪贴板、窗口的过程变得简单。
                    </span>
                    
                    <br />
                    <span style="display:block;margin-bottom:.3em;font-weight:bold;color:green;">
                    在 Mac OS X 系统中，术语 <b style="color:blue;">Cocoa</b> 总的来说指的是 Foundation 框架、Application Kit 框架和名为 Core Data 的第三方框架。
                    </span>
                    <span style="display:block;margin-bottom:.3em;font-weight:bold;color:green;">
                    术语 <b style="color:blue;">Cocoa Touch</b> 指的是 Foundation、Core Data、UIKit 框架。
                    </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="使用帮助文档" id="sourceContent1">
          <![CDATA[
              <span style="display:block;margin-bottom:.3em;">XCode <b>&rarr;</b> Help <b>&rarr;</b> Document </span>
              <img style="max-width:100%" src="//c2.staticflickr.com/4/3843/14754616720_19ecd26783_z.jpg" />
              <br />
              
              
              <span style="display:block;margin-bottom:.3em;">将鼠标放在类、变量或方法上，按住 Option 键，同时单击鼠标: </span>
              <img style="max-width:100%" src="//c2.staticflickr.com/4/3843/14938242501_9fff9e8059_z.jpg" />
              <br />

          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>数字、字符串、集合</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;">所有的基础数据对象都可以通过 <b>&lt;Foundation/Foundation.h&gt;</b> 一次性导入</span>
                  <span style="display:block;margin-bottom:.3em;">int、float、long、double 都是基本数据类型，它们都不是对象，不能向它们发送消息。</span>
                  <span style="display:block;margin-bottom:.3em;">NSArray 对象可以创建一个数组，并要求存储的值必须是对象。所以不能将任何基础数据类型存入 NSArray 中。</span>
                  <span style="display:block;margin-bottom:.3em;">NSNumber 可以存储基础数据类型，它会根据这些数据的类型创建<b style="color:blue;">对象</b>。</span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="Number" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        NSNumber *myNumber, *floatNumber, *intNumber;
        NSInteger myInt;

        // integer 类型
        intNumber = [NSNumber numberWithInteger : 100];
        myInt = [intNumber integerValue];
        NSLog(@"%li", myInt);
        
        
        // long 类型
        myNumber = [NSNumber numberWithLong : 0xabcdef];
        NSLog(@"%lx", [myNumber longValue]);
        
        // char 类型
        myNumber = [NSNumber numberWithChar : 'Y'];
        NSLog(@"%c", [myNumber charValue]);
        
        // float 类型
        floatNumber = [NSNumber numberWithFloat : 0.25];
        NSLog(@"%g", [floatNumber floatValue]);
        
        // double 类型
        myNumber = [NSNumber numberWithDouble : 12345+15];
        NSLog(@"%lg", [myNumber doubleValue]);
        
        
        // 发生错误 (将输出 0, 并且不会有错误消息)
        NSLog (@"%li", (long) [myNumber integerValue]);
        
        
        // 验证两个 number 是否相等
        if ([intNumber isEqualToNumber : floatNumber] == YES) {
            // equal
        } else {
            // not equal
        }
        
        // 比较大小
        if ([intNumber compare : myNumber ] == NSOrderedAscending) {
            // first less than second
            
        } elsif ([intNumber compare : myNumber ] == NSOrderSame) {
            // equals
            
        } else ([intNumber compare : myNumber ] == NSOrderedDescending){
            //
            
        }
        
        
        
        NSNumber *testNumber = [[NSNumber alloc] initWithInt : 50];
        
        // 不能修改前面创建的 NSNumber 对象的值，如一下语句将导致程序崩溃
        [testNumber initWith : 100];
        
        
        // numberWithInt 和 numberWithInteger 在使用上存在差别：
        // 1. numberWithInt 创建的整数需要使用 intValue 取值，使用 %i 作为格式化字符串显示它的值
        // 2. numberWithInteger 创建的整数需要使用 integerValue 取值，使用 %li 作为格式化字符串
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="html" title="NSNumber 的创建方法和检索方法" id="sourceContent1">
          <![CDATA[
              
              <img style="max-width:100%" src="//c2.staticflickr.com/4/3867/14755084647_ef65bdf30f_b.jpg" />
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="html" title="NSString 对象" id="sourceContent1">
          <![CDATA[
               <span style="display:block;margin-bottom:.3em;">
                NSString 对象由 unichar 字符组成，unichar 字符是符合 unicode 标准的多字节字符，可以处理包含数百万字符的字符集。
               </span>
          ]]>
      </c:sourceContent>
      
      
      
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        NSString *str = @"This is a String";
        NSLog(@"%@", str);
        
        
        NSNumber *intNumber = [NSNumber numberWithInteger : 100];
        NSLog(@"%@", intNumber);
    }

    return 0;
}
          ]]>
      </c:sourceContent>



<c:sourceContent type="" title="description" id="sourceContent1">
    <![CDATA[
// 子类可以覆写父类的 description 方法

-(NSString *) description {
    return [NSString stringWithFormat : @"%i / %i", numerator, denominator];
}
    ]]>
</c:sourceContent>

      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>可变对象与不可变对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span><b>@"Programming is fun"</b> 创建了一个内容不可更改的对象，可以使用 NSString 处理不可变对象。</span>
                  
                  <img style="max-width:100%" src="//c2.staticflickr.com/4/3862/14943557491_856bcf071b_b.jpg" />
                  <br />
                  <img style="max-width:100%" src="//c2.staticflickr.com/4/3915/14946380252_f27fbc1481_z.jpg" />
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="在程序中处理不可变字符串的基本方式" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        // str1 和 str2 所引用的字符串对象的字符不可以改变
        // 但是 str1 和 str2 是可以改变的，也就是说可以重新为它们指定其它不可变的字符串
        NSString *str1 = @"This is String A";
        NSString *str2 = @"This is String B";

        NSString *res;

        NSComparisonResult compareResult;

        // 取得字符串的长度
        NSLog (@"%lu", [str1 length]);

        // 将一个字符串复制到另一个字符串
        res = [NSString stringWithString : str1];
        NSLog (@"%@", res);

        // 将一个字符串复制到另一个字符串的末尾
        str2 = [str1 stringByAppendingString : str2];
        NSLog (@"Concatentation %@", str2);

        // 验证两个字符串是否相等
        if ([str1 isEqualToString : res] == YES) {
            NSLog (@"str1 == str2");
        } else {
            NSLog (@"str1 != str2");
        }

        // 验证一个字符串是否小于、等于、大于另一个字符串
        // caseInsensitiveCompare 比较时忽略大小写
        compareResult = [str1 compare : str2];
        
        if (compareResult == NSOrderedAscending) {
            NSLog (@"str1 < str2");
        } else if (compareResult == NSOrderedSame) {
            NSLog (@"str1 == str2");
        } else {
            // NSOrderedDescending
            NSLog (@"str1 > str2");
        }
        
        // 将字符串转成小写
        res = [str1 lowercaseString];
        
        // 转小写
        res ＝ [str1 uppercaseString];
        
        
        
        
        NSRange subRange;
        
        res = [str1 substringToIndex : 3];
        res = [str1 substringFromIndex : 5];
        
        res = [[str1 substringFromIndex : 5] substringToIndex : 3];
        res = [str1 substringWithRange : NSMakeRange (8, 6)];
        
        
        subRange = [str1 rangeOfString : @"String A"];
        
        if(subRange.location != NSNotFound)
            NSLog (@"String is at index %lu, length is %lu"
                    , subRange.location, subRange.length);
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="可变字符串" id="sourceContent1">
          <![CDATA[
/*
  NSMuTableString 类可以用来创建可以更改字符的字符串对象。
*/

#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {
    @autoreleasepool {
        NSString *str1 = @"This is String A";
        NSString *str2 = @"This is String B";

        NSString *search, *replace;

        NSMutableString *mstr;

        NSRange substr;

        // 从不可变字符串创建可变字符串
        mstr = [NSMutableString stringWithString : str1];
        
        // 插入字符
        [mstr insertString : @" mutable" atIndex : 7];
        
        // 插入末尾
        [mstr insertString : @" mutable" atIndex : [mstr length]];
        
        // appendString
        [mstr appendString : @" mutable"];
        
        // 根据范围删除子字符串
        [mstr deleteCharactersInRange : NSMakeRange (16 , 3)];
        
        // 查找人后删除
        substr = [mstr rangeOfString : @" String A"];
        
        if (substr.location != NSNotFound) {
            [mstr deleteCharactersInRange :substr];
        }
        
        
        // 直接设置为可变字符串
        [mstr setString : str1];
        
        // 替换字符
        [mstr replaceCharactersInRange : NSMakeRange ( 8,8) withString : @"a mutable string"];
        
        
        // 查找和替换
        search = @"This is";
        replace = @"An example of";
        
        substr = [mstr rangeOfString : search];
        
        if (substr.location != NSNotFound) {
            [mstr replaceCharactersInRange : substr withString : replace];
        }
        
        
        // 查找和替换所有匹配项
        search = @"a";
        replace = @"X";
        
        substr = [mstr rangeOfString : search];
        while (substring.location != NSNotFound) {
            [mstr replaceCharactersInRange : substr withString : replac];
            substr = [mstr rangeOfString : search];
        }
        
        
        // 查找和替换所有匹配项
        [mstr replaceOccurrencesOfString : search
              withString: replace
              options: nil
              range : NSMakeRange (0, [mstr length])];
    }
    
    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="数组对象" id="sourceContent1">
          <![CDATA[
/*
在 Foundation 框架中，NSArray 处理不可变数组，NSMutableArray 处理可变数组。
*/

#import <Foundation/Foundation.h>

int main (int argc, char *argv[] ) {
    int i ;
    @autoreleasepool {
    
        // 最后一个 nil 用于标记数组已经结束， 实际上并不会存储在数组中
        NSArray *monthNames = [NSArray arrayWithObjects :
                                 @"January", @"February", @"March"
                               , @"April", @"May", @"June", @"July"
                               , @"August", @"September", @"October"
                               , @"November", @"December", nil];

        for (i=0; i < 12; ++i) {
            NSLog (@"%2i %@", [monthNames objectAtIndex : i]);
        }
    }

    return 0;
}





// 可变数组
#import <Foundation/Foundation.h>


int main (int argc, char *argv[] ) {

    @autoreleasepool {
        NSMutableArray *array = [NSMutableArray array];
        NSNumber *number;

        int i = 0;

        for (i=0; i<10; ++i) {
            number = [NSNumber numberWithInteger : i];
            [array addObject : number];
        }

        for ( i=0; i< 10; ++i) {
            NSLog (@"%i", [array objectAtIndex: i]);
        }

    }

    return 0;

}
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:2em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>地址卡片</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="AddressCard.h" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

@interface AddressCard : NSObject

-(void ) setName : (NSString *) name;
-(void ) setEmail : (NSString *) email;
-(NSString *) name;
-(NSString *) email;
-(NSComparisonResult) compareName : (id) element;
-(void) print;

@end
          ]]>
      </c:sourceContent>
      
      <c:sourceContent type="" title="AddressCard.m" id="sourceContent1">
          <![CDATA[
#import AddressCard.h

@implementation AddressCard {
    NSString *name;
    NSString *email;
}

-(void ) setName : (NSString *) name {
    if (name != name)
        name = [NSString stringWithString : name];
}

-(void ) setEmail : (NSString *) email {
    if (email != email)
        email = [NSString stringWithString : email];
}

-(NSString *) name {
    retur name;
}

-(NSString *) email {
    return email;
}

-(NSComparisonResult) compareName : (id) element {
    return [name compare : element.name];
}

-(void ) print {
    // 打印 31 个字符，做对齐
    NSLog (@"%-31s", [name UTF8String]);
    NSLog (@"%-31s", [email UTF8String]);
}

-(BOOL) isEqual : (AddressCard *) theCard {
    if ([name isEqualToString : theCard.name] == YES
        && [email isEqualToString : theCard.email] == YES) {
        return YES;
    }

    return NO;
}

@end
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="使用合成实例变量" id="sourceContent1">
          <![CDATA[
@property (copy, nonatomic) NSString *name, *email;
/*
copy 特性会在 setter 方法内生成实例变量的副本，默认的方法不会生成副本，仅仅是进行赋值 (默认为 assign 特性)
nonatomic 特性表明不必担心在竞争条件下，多个线程试图同时读取同一个变量
*/


// 增加一个设置方法用于初始化实例变量的值
-(void) setName : (NSString *) theName andEmail : (NSString *) theEmail {
    // self.name 使用了 setter 方法为实例变量赋值， 等价于 [self setName : theName];
    // 而 name = theName 的写法绕过了 setter 方法，即：直接为实例变量赋值
    self.name = theName;
    self.email = theEmail;
}

          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="AddressBook.h" id="sourceContent1">
          <![CDATA[
// AddressBook 用于存储多个 AddressCard
// 1. 创建新的地址薄
// 2. 添加地址卡片
// 3. 计算地址薄的记录数
// 4. 列出地址薄内容
// 5. 搜索地址薄
// 6. 删除记录
// 7. 编辑现有记录
// 8. 排序记录
// 9. 复制记录

#import <Foundation/Foundation.h>

#import "AddressCard.h"

@interface AddressBook : NSObject

@property (nonatomic, copy) NSString *bookName;
@property (nonatomic, strong) NSMutalbeArray *book;


-(id) initWithName : (NSString *) theBookName;  // 初始化地址数组并设置地址薄名字
-(void) addCard : (AddressCard *) theCard;
-(int) entries;                                 // 取得卡片数量
-(void) list;
-(AddressCard *) lookup : (NSString *) theName; // 查询
-(void) removeCard : (AddressCard *) theCard;   // 删除
-(void) sort;                                   // 排序
-(void) sortByBlock;                            // 区块排序

@end


          ]]>
      </c:sourceContent>
      
      
      
      <c:sourceContent type="" title="AddressBook.m" id="sourceContent1">
          <![CDATA[
#import "AddressBook.h"

@implentation AddressBook

@synthesize bookName, book;



-(id) initWithName : (NSString *) theBookName {
    self = [self init];

    if(self) {
        bookName = [NSString stringWithString : theBookName];
        book = [NSMutableArray array];
    }

    return self;
}

-(id) init {
    return [self initWithName : @"NoName"];
}

-(void) addCard : (AddressCard *) theCard {
    [book addObject : theCard];
}

-(int) entries {
    return [book count];
}

-(void) list {
    for (AddressCard *theCard in book ) {
        NSLog (@"%-20s %-30s", [theCard.name UTF8String], [theCard.email UTF8String]);
    }
}

-(AddressCard *) lookup : (NSString *) theName {
    for (AddressCard *theCard in book) {
        if ([theCard.name caseInsensitiveCompare : theName] == NSOrderedSame) {
            return theCard;
        }
    }

    return nil;
}

-(void) removeCard : (AddressCard *) theCard {
    // 移除同一对象，removeObjectIdenticalTo 会调用 isEqual 方法判断两个对象是否相等，
    // 并且默认的 isEqual 通过内存地址判断两个对象是否相等
    // 一个更好的办法是覆写 NSObject 的 isEqual 方法判断两个对象是否相等
    [book removeObjectIdenticalTo : theCard];
}

-(void) sort {
    // 利用 NSMutableArray 类的 sortUsingSelector: 可以很容易实现排序
    // sortUsingSelector: 会使用 selector 比较两个元素
    // 由于数组可以包含任何类型的对象，所以需要由实现者来决定数组中的元素是否有序
    // 添加一个方法比较数组中的两个元素，该方法的返回类性是 NSComparisonResult

    [book sortUsingSelector : @selector (compareName:)];
}

-(void) sortByBlock {
    /*
        NSArray
        -(NSArray *) sortedArrayUsingComparator: (NSComparator) block;
        
        
        NSMutableArray
        -(void) sortUsingComparator: (NSComparator) block;
        
        NSComparator 是一个区块，使用两个对象作为参数， 并返回 NSComparisonResult 类型的结果
        该方法对大数组排序具有高性能
        
    */
    
    ［book sortUsingComparator: ^(id obj1, id obj2) {
                                    return [obj1.name compare: obj2.name];
                                }];
}

@end

              
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5573/14793557788_cf2c1c24fb_b.jpg" />
                  <br />
                  
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5589/14793491789_6d2ee11176_b.jpg" />
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>NSValue</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
                  <span style="display:block;margin-bottom:.3em;">
                  在开发 iOS 程序时，需要在集合中存储非对象类型 (源于 C 语言数据类型) 的数据。
                  </span>
                  
                  <span style="display:block;margin-bottom:.3em;">
                  因为存储在集合中的数据必须是对象类型，所以 NSValue 可以将非对象类型的数据转换成为对象。
                  </span>
                  
                  <span style="display:block;margin-bottom:.3em;">
                  将结构转化为对象的方式，简称为包装 (wrapping)，逆向的处理叫展开 (unwrapping).
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
/* 将 CGPoint 结构加入到可变数组中 */
CGPoint *myPoint;
NSValue *pointObject;

NSMutableArray *touchPoints = [NSMutableArray array];

myPoint.x = 100;
myPoint.y = 150;

pointObject = [NSValue valueWithPoint : myPoint];     // wrapping
[touchPoints addObject : pointObject];



// 取出最后一个并 unwrapping
myPoint = [[touchPoint lastObject] pointValue];
              
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
                  <img src="//c2.staticflickr.com/6/5569/14986785121_3d770d3e6f_b.jpg" style="max-width:100%;" />
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>词典对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
                  <span style="display:block;margin-bottom:.3em;">
                  词典中的键必须是单值的，通常是字符串，但也可以是其它对象类型。和键关联的值可以是任何对象类型，但不能是 nil.
                  </span>
                  <span style="display:block;margin-bottom:.3em;">
                  词典中的数据是无序的，第一个放入的不一定第一个取出。如果想按照顺序取出数据，可以先取出所有键，然后对键排序，然后在按照键的顺序取出数据
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleastpool {
        //可变词典
        NSMutableDictionary *dict = [NSMutableDictionary dictionary];

        [dict setObject: @"A class defined so other classes can inherit from it"
                         , forKey : @"abstract class"];
        [dict setObject: @"To implement all the methods defined in protocol"
                         , forKey : @"adopt"];
        [dict setObject: @"Storing an object for later user"
                         , forKey: @"archiving"];


        NSLog (@"%@", [dict objectForKey: @"abstract class"]);
        
        
        
        
        // 不可变词典
        // 用字符串数组初始化 NSDictionary，键值对用逗号隔开，数组必须以 nil 结尾，
        NSDictionary *dict2 = [NSDictionary dictionaryWithObjectsAndKeys :
                                      @"A class defined so other classes can inherit from it"
                                    , @"abstract class"
                                    , @"To implement all the methods defined in protocol"
                                    , @"adopt"
                                    , @"Storing an object for later user"
                                    , @"archiving"
                                    , nil];
                                    
        for (NSString *key in dict2)
            NSLog(@"%@", [dict2 objectForKey : key]);
            
            
        // 取出所有键
        NSArray *keys = [dict2 : allKeys];
        
        // 对键排序
        keys = [keys sortedArrayUsingComparator :
                        ^(id obj1, id obj2) {
                            return [obj1 compare : obj2];
                            }];
                            
        // 按顺序显示
        for (NSString *key in keys)
            NSLog(@"%@", [dict2 objectForKey : key]);
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5561/14817930110_def3f7e5e1_b.jpg" />
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>集合对象：NSSet、NSMutableSet、NSIndexSet、NSCountedSet</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
                  
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="集合的一些基本操作" id="sourceContent1">
<![CDATA[
#import <Foundation/Foundation.h>

// 定义一个宏，用于方便的创建一个整数对象
@define INTOBJ (v) [NSNumber numberWithInteger : v];

// 使用 Printing 类，将打印方法添加到 NSSet
@interface NSSet (Printing)

-(void) print ;

@end





@implementation NSSet (Printing)


// 该方法只适合打印整数类型的集合，所以它并不通用
-(void) print {
    printf ("{");

    for (NSNumber *element in self) {
        printf ("%li", (long) [element intergateValue]);
    }

    printf ("}");
}

@end





int main (int argc, char *argv[]) {

    @autoreleasepool {
        NSMutableSet *set1 = [NSMutableSet setWithObjects :
                                                INTOBJ(1), INTOBJ(3), INTOBJ(6), nil];
        NSSet *set2 = [NSSet setWithObjects :
                                    INTOBJ(-5), INTOBJ(3), INTOBJ(6), INTOBJ(7), nil];
        NSSet *set3 = [NSSet setWithObjects :
                                    INTOBJ(100), INTOBJ(4), INTOBJ(6), INTOBJ(7), nil];


        NSLog(@"set1:");
        [set1 print];

        NSLog(@"set2:");
        [set2 print];


        // 判断相等
        if ( [set1 isEqualToSet : set2] == YES) {
            NSLog(@"set1 is equals set2");
        }


        // 成员测试
        if ([set1 containsObject : INTOBJ(3)] == YES) {
            NSLog(@"set1 contains 3");
        }


        // 添加
        [set1 addObject : INTOBJ(4)];
        [set1 removeObject : INTOBJ(6)];

        [set1 print];


        // 取得交集 (将运算的结果赋值给消息的接收者)
        [set1 intersectSet : set2];
        [set1 print];

        //  取得并集
        [set1 unionSet : set3];
        [set1 print];
        
        
        /*
        
        NSCountedSet 中的同一个元素可以出现多次，然而并非在集合中存放多次同一对象，而是维护一个次数计数器。
        当第一次添加对象到集合中时，对象的 count 值被置为 1，删除时减 1，当 count 值为 0 时，该对象将被删除。
        使用 countForObject 可以在集合中检索某个对象的 count 值
        
        */
    }

    return 0;
}

          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/4/3899/15004476342_b3bf0af105_b.jpg" />
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>NSIndexSet</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  该类用于存储<b>一组有序的索引</b>，比如数组的索引
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
// 找到一个匹配的元素
-(AddressCard) lookup : (NSString *) theName {

    NSUInteger theIndex =
                [book indexOfObjectPassingTest :
                    ^(id obj, NSUInteger idx, BOOL *stop) {
                        if ([[obj.name] caseInsensitiveCompare : theName] == NSOrderedSame) {
                            *stop = YES;
                            return YES;
                        } else return NO;
                    }
                ];
                
    if (theIndex != NSNotFound) {
        return [book objectAtIndex : theIndex];
    } else return nil;
}


// 查找所有匹配项
-(NSMutableArray *) lookupAll : (NSString *) theName{
    NSMutableArray *theResults = [NSMutableArray array];

    NSUInteger theIndex =
                [book indexOfObjectPassingTest :
                    ^(id obj, NSUInteger idx, BOOL *stop) {
                        if ([[obj.name] caseInsensitiveCompare : theName] == YES) {
                            [theResults addObject : obj];
                            return YES;
                        } else return NO;
                    }
                ];
                
    if ([theResult count]) {
        return theResults;
    } else return nil;
}


// 使用 indexesOfObjectsPassingTest 查找多个匹配项， 该方法返回 NSIndexSet
-(NSIndexSet *) lookupAll : (NSString *) theName {
    NSIndexSet *result = [book indexesOfObjectsPassingTest :
                                ^(id obj, NSUInteger idx, BOOL *stop) {
                                    if ([[obj.name] caseInsensitiveCompare : theName]
                                                    == NSOrderedSame) {
                                        return YES;
                                    } else return NO;
                                }];

    // 将匹配的元素的所以放入返回结果中
    return result;
}
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/4/3850/14818467360_e561b07d19_b.jpg" />
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>使用文件</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  
                  <span style="display:block;margin-bottom:.3em;">
                  在 Foundation 框架中处理文件或目录的类是 NSFileManager: 创建、读取、写入、重命名、删除、exists、复制、测试相等、读取大小和属性
                  </span>
                  
                  <span style="display:block;margin-bottom:.3em;">
                  NSFileHandle 提供的操作: 读文件、写文件、更新、查找指定位置、读取或写入指定数目的字节。该类也可以处理各种设备或套接字。
                  </span>
                  
                  
                  <span style="display:block;margin-bottom:.3em;">
                  NSURL 可以从互联网读取数据
                  </span>
                  
                  <span style="display:block;margin-bottom:.3em;">
                  NSBundle 类提供了在应用中使用包 (Bundle) 的方法
                  </span>
                  
                  
                  <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5564/14819164108_0d88fa5454_b.jpg" />
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="NSFileManager 管理文件和目录" id="sourceContent1">
          <![CDATA[
/*
copy1.m 表示当前路径，也可以写成 ./copy1.m
/copy1.m 绝对路径: /代表系统跟目录
～/copy1.m 用户主目录

尽量使用方法和函数来获取当前目录、用户主目录、创建林书文件的目录
*/

// 创建 NSFileManager 对象实例
NSFileManager *fm = [NSFileManager defaultManager];

// 删除文件并测试返回结果
if ([fm removeItemAtPath : @"filename" error: NULL] == NO) {
    NSLog(@"Couldn't remove file!");
    return 1;
}

/*
    属性字典允许你指定要创建的文件的权限，以便获取或者更改现有文件的信息。
    对于文件的创建，如果将该参数指定为 nil，该文件会被设置为默认权限
    
    attributesOfItemAtPath:traverseLink: 方法返回一个包含指定文件属性的字典，
    traverseLink: 参数的值为 YES 或 NO, 如果该文件是一个链接, 则指定 YES.
*/



// 基本的文件操作
// 假设在当前目录有一个 testfile 的文件
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleasepool {
        NSString        *fName      = "testfile";
        NSFileManager   *fm         = [NSFileManager defaultManager];
        NSDictionary    *attr;


        // 确定文件是否存在
        if ([fm fileExistsAtPath : fName] == NO) {
            NSLog(@"File not exists!");
            return 1;
        }

        // 创建文件副本
        if ([fm copyItemAtPath : fName toPath : @"newfile" error : NULL] == NO) {
            NSLog(@"Copy file faild!");
            return 2;
        }

        // 测试两个文件是否一致
        if ([fm contentsEqualAtPath : fName andPath : @"newfile" error: NULL] == NO) {
            NSLog (@"Files are not equal!");
            return 3;
        }

        // 重命名
        if ([fs moveItemAtPath : @"newfile" toPath : @"newfile2" error: NULL] == NO) {
            NSLog(@"File rename failed!");
            return 4;
        }

        // 取得文件大小
        if ((attr = [fs attributesOfItemAtPath : @"newfile" error: NULL]) == nil) {
            NSLog(@"Couldn't get file attributes!");
            return 5;
        }

        NSLog(@"File size is %llu bytes.",
                    [[attr objectForKey : NSFileSize] unsignedLongLongValue]);
                    
                    
        // 删除文件
        if ( [fs removeItemAtPath : fName error: NULL] == NO) {
            NSLog(@"remove item failed!");
            return 6;
        }
        
        // 显示文件内容
        NSLog(@"%@", [NSString stringWithContentsOfFile :
                        @"newfile" encoding : NSUTF8StringEncoding error : NULL]);

    }

    return 0;
}


          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="NSData" id="sourceContent1">
          <![CDATA[
/*
使用文件时，需要频繁地将数据读入到一个临时存储区，这个临时存储区通常称为缓冲区

既可以定义不可变缓冲区 NSData, 也可以定义可变缓冲区 NSMutableData
*/


#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleasepool {

        NSFileManager *fm = [NSFileManager defaultManager];
        NSData *data ;


        data = [fm contentsAtPath : @"filename"];

        if (data == nil) {
            NSLog (@"File read failed!");
            return 1;
        }

        if ([fs createFileAtPath : @"newfile" contents : data attributes: nil] == NO) {
            NSLog(@"Couldn't create the copy!");
            return 2;
        }

        NSLog (@"File copy was successful!");
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>使用目录</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/4/3855/14820609228_73e05e8252_b.jpg" />
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleastpool {
        NSString *dirName = @"testDir";
        NSString *path ;

        NSFileManager *fm = [NSFileManager defaultManager];

        // 取得当前目录
        path = [fs currentDirectoryPath];
        NSLog (@"Current directory is %@.", path);

        // 创建一个新目录
        if([fs createDirectoryAtPath : dirName
                        withIntermediateDirectories : YES
                        attributes : nil error : NULL] == NO) {
            NSLog (@"Couldn't create folder!");
            return 1;
        }


        // 重命名
        if ([fs moveItemAtPath : dirName toPath : @"newDir" error: nil] == NO) {
            NSLog (@"Couldn't not move directory!");
            return 2;
        }

        // 转到新的目录
        if ([fs changeCurrentDirectoryPath : @"newDir"] == NO) {
            NSLog (@"Couldn't change dictory!");
            return 3;
        }

        // 取得当前目录
        NSLog (@"Current directory is %@", [fs currentDirectoryPath]);
        
        
        
        // 遍历文件夹及子文件夹 enumeratorAtPath
        NSDirectoryEnumerator *dirEnum;
        dirEnum = [fs enumeratorAtPath : @"newDir"];
        while ((path = [dirEnum nextObject]) != nil) {
        
            // 忽略自文件夹
            if([fs fileExistsAtPath : path isDirectory : &flag]) {
                if (flag == YES) [dirEnum skipDescendents];
            }
            
            NSLog(@"%@", path);
        }
        
        
        // 遍历文件夹但是忽略子文件夹
        NSArray *dirArray;
        dirArray = [fs contentsOfDirectoryAtPath : [fs currentDirectoryPath] error : NULL];
        
        for (path in dirArray)
        NSLog (@"%@", path);
    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>使用路径 NSPathUtilities.h</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  NSPathUtilities.h 包含了 NSString 的函数和分类扩展，可以操作路径名。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="路径的基本操作" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main(int argc, char *argv[]) {

    @autoreleastpool {
        NSString *fName = "path.m";
        NSFileManager *fs ;

        NSString *path, *tempdir, *extension, *homeDir, *fullPath;

        NSArray *components;


        // 取得系统临时工作目录 (如果在这个目录中创建临时文件，一定要在任务完成之后将之删除，并确保文件名是唯一的)
        tempDir = NSTemporaryDirectory();

        // 取得当枪路径
        path = [fs currentDirectoryPath];
        
        // 取得路径的最后一部分 (通常是文件名)
        NSLog (@"%@", [path lastPathComponent]);
        

        // 创建文件名和当前路径完整路径
        fullPath = [path stringByAppendingPathComponent : fName];

        // 取得文件扩展名 (如果没有扩展名则返回一个空字符串)
        extension = [path pathExtension];

        // 取得用户主目录
        homeDir = NSHomeDirectory();

        // 拆分路径为各组成部分
        components = [homeDir pathComponents];

        // 打印各组成部分
        for (path in components)
            NSLog (@"%@", path);
            
            
            
        // 查找系统的特殊目录，如: Application、Documents
        // NSSearchPathForDirectoriesInDomains 用于查找系统的特殊目录
        NSArray *dirList = NSSearchPathForDirectoriesInDomains (NSDocumentDirectory, NSUserDomainMask, YES);
        NSString *docDir = [dirList objectAtIndex : 0];
        
        // 取得文件在 Documents 目录中的全名称
        NSString *fileFullNameAtDocuments = [docDir stringByAppendingPathComponent : @"fileName"];
        
        /*
            为了保存数据，直到下次运行程序仍能使用，可以使用 Documents 目录。
            每个 iOS 应用都有自己的 Documents 目录供数据写入。
            应用中的 Caches 目录也可以存储一些输入。但是在 iOS5+ 来说，Apple 鼓励开发者将数据存储到云端。
            
            
            NSSearchPathForDirectoriesInDomains ：
            第一个参数是指定要查找目录的路径，
            第二个参数可以是多个值，用于指定要列出的目录，如: 用户的、系统的、或所有目录，
            第三个参数用于指定是否展开路径中的 ~ 字符，
            返回类型是一组路径的数组，如果第二个参数指定多个值，则返回的数组中将包含多个值
            
        */
    }

return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5562/14821095567_6871877eb9_b.jpg" />
                  <br />
                  
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5555/14821027499_498971c87e_z.jpg" />
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>NSProcessInfo </c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  NSProcessInfo 类中包含一些方法，可以设置或检索正在运行的应用程序 (进程)。
                  
                  <br />
                  
                  <img style="max-width:100%;" src="//c2.staticflickr.com/6/5561/14993432516_bbbb1b2722_b.jpg" />
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="基本的复制工具" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleasepool {
        NSFileManager *fm ;
        NSString *source, *dest;
        BOOL isDir;
        NSProcessInfo *proc = [NSProcessInfo processInfo];
        NSArray *args = [proc arguments];

        fs = [NSFileManager defaultManager];

        // 检查命令行的两个参数
        if ([args count] != 3) {
            NSLog(@"Usage: %@ src dest", [proc processName]);
            return 1;
        }

        source = [args objectAtIndex : 1];
        dest = [args objectAtIndex : 2];

        // 确定能够读取源文件
        if ([fm isReadableFileAtPath : source] == NO) {
            NSLog ("Can't read %@", source);
            return 2;
        }

        // 目标文件是否是一个目录
        // 若是添加到目标的结尾
        [fm fileExistsAtPath : dest isDirectory : &isDir];

        if (isDir == YES) {
            dest = [dest stringByAppendingPathComponent : [source lastPathComponent]];
        }


        // 若目标已存在则将其删除
        [fm removeItemAtPath : dest error : NULL];


        // 执行复制
        if ([fm copyItemPath : source toPath : dest error: NULL] == NO) {
            NSLog (@"Copy failed!");
            return 3;
        }

        NSLog (@"Copy of %@ to %@ successed!", source, dest);

    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>基本的文件操作：NSFileHandle</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  利用 NSFileHandle 类更有效地处理文件。
                  
                  <br />
                  
                  <img style="max-width:100%;" src="//c2.staticflickr.com/4/3874/14830105187_eddbcd5256_b.jpg" />
                  
                  <br />
                  
                  <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                  这里没有列出异步读取或写入的方法。
                  </span>
                  <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                  NSFileHandle 没有提供创建文件的方法，必须使用 NSFileManager 类创建文件。
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="" title="文件的一些基本操作" id="sourceContent1">
          <![CDATA[
/*
    假设在当前目录存在一个 "testfile" 文件
*/

#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleasepool {

        NSFileHandle *inFile, *outFile;
        NSData *buffer;

        // 打开文件并读取
        inFile = [NSFileHandle fileHandleForReadingAtPath : @"testFile"];

        if  (inFile == nil) {
            NSLog (@"Open of testfile for reading failed!");
            return 1;
        }

        // 创建输出文件
        [[NSFileManager defaultManager] createFileAtPath : @"testout"
                                        contents : nil
                                        attributes : nil];

        // 打开文件待写入
        outFile = [NSFileHandle fileHandleForWritingAtPath : @"testout"];

        if ( outFile == nil) {
            NSLog (@"Open of testout for writing failed!");
            return 2;
        }

        // 因为输出文件可能包含数据，截断输出文件
        [outFile truncateFileAtOffset : 0];

        // 从 inFile 中读取数据，并写入到 outFile
        /*
         readDataToEndOfFile 每次从文件中读取最多 UINT_MAX 字节的数据，
         这个量定义在 <limits.h> 中，该值已经足够大。
         
         利用 readDataOfLength 可以设置循环读取，可以判断 NSData 的 length 确定文件是否已经读完。
        */
        buffer = [inFile readDataToEndOfFile];

        [outFile writeData : buffer];

        [inFile closeFile];
        [outFile closeFile];

        // 输出文件内容
        NSLog (@"%@", [NSString stringWithContentsOfFile : @"testout"
                                encoding : NSUTF8StringEncoding
                                error : NULL]);

    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      
      <c:sourceContent type="" title="将文件 fileA 追加到 fileB" id="sourceContent1">
          <![CDATA[
#import <Foundation/Foundation.h>

int main (int argc, char *argv[]) {

    @autoreleasepool {

        NSFileHandle *inFile, *outFile;
        NSData *buffer;

        // 打开文件 fileA 待读
        inFile = [NSFileHandle fileHandleForReadingAtPath : @"fileA"];

        if (inFile == nil) {
            // failed
            return 1;
        }

        // 打开文件 fileB 待写
        outFile = [NSFileHandle fileHandleForWritingAtPath : @"fileB"];

        if (outFile == nil) {
            // failed
            return 2;
        }

        // 定位到文件的末尾 (seekToEndOfFile 可以返回当前文件的偏移量，可以使用该值获取文件的大小)
        [outFile seekToEndOfFile];

        buffer = [inFile readDataToEndOfFile];

        [outFile writeData : buffer];

        // 关闭文件
        [inFile closeFile];
        [outFile closeFile];

        // 输出内容
        NSLog (@"%@", [NSString stringWithContentsOfFile : @"fileB"
                                encoding : NSUTF8StringEncoding
                                error : null]);

    }

    return 0;
}
          ]]>
      </c:sourceContent>
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>


<c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
    <c:title>NSURL</c:title>
    <c:desc>
        <c:desc1>
            <![CDATA[
                
            ]]>
        </c:desc1>
    </c:desc>
    
    <c:sourceContent type="" title="利用 NSURL 抓去网页内容" id="sourceContent1">
        <![CDATA[
#import <Foundation/Foundation.h>

int mian (int argc, char *argv[]) {

    @autoreleasepool {
        NSURL *myURL = [NSURL URLWithString : @"http://www.snnmo.com"];
        NSString *pageContent = [NSString stringWithContentsOfURL : myURL
                                          encoding : NSASCIIStringEncoding
                                          error : NULL];

        NSLog (@"%@", pageContent);
    }

    return 0;
}
        ]]>
    </c:sourceContent>
    
    
    <c:comment style="margin-top:2em;">
        <c:comment1 style="color:black;">
            <![CDATA[
            ]]>
        </c:comment1>
    </c:comment>
</c:entry>


<c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
    <c:title>NSBundle</c:title>
    <c:desc>
        <c:desc1>
            <![CDATA[
                
                <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                NSBundle 可以访问与应用相关的一些资源，例如：图片、本地化字符串、图标等等。
                </span>
                <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                将需要添加的资源拖拽到 Xcode 的左边窗格中，当出现对话框时选择复制资源文件到项目目录中。
                </span>
            ]]>
        </c:desc1>
    </c:desc>
    
    <c:sourceContent type="" title="" id="sourceContent1">
        <![CDATA[
// 返回存储在应用包中 instructions.txt 文件的内容
NSString *filePath = [[NSBundle mainBundle] pathForResource : @"instructions"
                                            ofType : @"txt"];

NSString *fileContent = [NSString stringWithContentsOfFile : filePath
                                  encoding : NSUTF8StringEncoding
                                  error : NULL];

// 列出应用中所有以 .jpg 为文件结尾的 JPEG 图片
NSArray *jpgList = [NSBundle mainBundle] pathsForResourcesOfType : @"jpg" inDirectory : @""];
        ]]>
    </c:sourceContent>
    
    
    <c:comment style="margin-top:2em;">
        <c:comment1 style="color:black;">
            <![CDATA[
            ]]>
        </c:comment1>
    </c:comment>
</c:entry>



  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>内存管理和自动引用计数</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>复制对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>归档</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>复制对象</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  。。
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>Cocoa 和 Cocoa Touch</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                  Cocoa 框架为 Mac OS X 应用程序提供了丰富的用户体验，它由三个框架组成:
                  
                  </span>
                  <span style="display:block;margin-bottom:.3em;margin-top:.3em;">
                  <ul style="list-style:decimal;margin-left:1.5em;">
                  <li>Foundation 框架</li>
                  <li>Cocoa Data 框架: 便于使用数据库和管理数据</li>
                  <li>Application Kit 框架: AppKit 框架提供了与窗口、按钮、列表</li>
                  </ul>
                  
                  </span>
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="应用程序层次结构" id="sourceContent1">
          <![CDATA[
              <img style="max-width:480px;" src="//c2.staticflickr.com/6/5557/14856009230_e9a4dc403e_b.jpg" />
              <br />
              <span style="display:block;margin-bottom:.3em;margin-top:.3em;font-size:1.3em;">
              <b style="color:blue;">Cocoa 层</b>包含 Foundation (处理集合、字符串、内存管理、文件系统、存档等)、Cocoa Data、AppKit (管理视图、窗口、文档、多用户界面).
              </span>
              <span style="display:block;margin-bottom:.3em;margin-top:.3em;font-size:1.3em;">
              <b style="color:blue;">应用服务层</b>包含打印和图形渲染的支持，例如：Quarta、OpenGL、Quicktime.
              </span>
              <span style="display:block;margin-bottom:.3em;margin-top:.3em;font-size:1.3em;">
              <b style="color:blue;">核心服务层</b>提供对集合、网络、调试、文件管理、文件夹、内存管理、线程、时间和电源管理等。
              </span>
              <span style="display:block;margin-bottom:.3em;margin-top:.3em;font-size:1.3em;">
              <b style="color:blue;">内核</b>以设备驱动程序的形式提供与硬件的底层通信，他负责管理系统资源，如：调度需要执行的程序、管理内存和电源、执行基本的 I／O 操作等.
              </span>
              <br />
              
              <span style="display:block;margin-bottom:.3em;margin-top:.3em;font-size:1.3em;">
              Cocoa Touch 框架应用于 iOS 设备上应用程序的开发。<br />
              在 Cocoa Touch 下 UIKit 代替了 AppKit.
              </span>
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(156, 25, 197);font-weight:bold;">
      <c:title>编写 iOS 应用程序</c:title>
      <c:desc>
          <c:desc1>
              <![CDATA[
                  <img style="max-width:100%;" src="//c2.staticflickr.com/4/3910/14832896137_5361774340_b.jpg" />
              ]]>
          </c:desc1>
      </c:desc>
      
      <c:sourceContent type="html" title="" id="sourceContent1">
          <![CDATA[
              .
          ]]>
      </c:sourceContent>
      
      
      <c:comment style="margin-top:2em;">
          <c:comment1 style="color:black;">
              <![CDATA[
              ]]>
          </c:comment1>
      </c:comment>
  </c:entry>


</c:component>
