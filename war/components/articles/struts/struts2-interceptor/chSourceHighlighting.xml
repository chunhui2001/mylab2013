<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">

  <c:abstract>
    <![CDATA[当设法描述拦截器所完成的各种任务时，我们通常称其为横切 (cross-cutting)、预处理 (preprocessing)、后加工 (postprocessing)。<br />
    从概念上说拦截器的机制是很清晰的，即不让一个简单的控制器直接调用动作，而是有一个处在控制器和动作组件之间的组件。]]>
  </c:abstract>
  
  <c:entry>
    <c:title>横切 (cross-cutting)</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent id="sourceContent1">
    <![CDATA[
    
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[日志处理是一个典型的横切任务。我们把它成为横切是因为它不是某一个动作所特有的，它横向关联所有动作。利用拦截器可以把这个任务提到更高的层面，让它处在任何需要记录日志的请求上 (或之前)。]]>
        
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>预处理 (preprocessing)</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent id="sourceContent1">
      <![CDATA[  ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[预处理任务的一个绝好的示例是我们已经熟悉的数据转移，它通过 params 拦截器实现。几乎所有的动作组件都需要将一些数据从请求参数转移到特定领域的动作属性上。它必须在动作出发之前完成。]]>

      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>后加工 (postprocessing)</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent id="sourceContent1">
      <![CDATA[
    .....
  ]]>
    </c:sourceContent>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>ActionInvocation</c:title>
    <c:desc>
      <c:desc1> <![CDATA[在 Struts2 中没有一个动作被单独调用。动作调用总是包含一系列的拦截器在动作执行前或之后执行。]]></c:desc1>
      <c:desc1> <![CDATA[Struts 框架不直接调用动作的 execute() 方法，而是创建一个叫做 <span style="font-weight:bold;font-style:oblique;">ActionInvocation</span> 的对象，它封装了动作和一系列被配置在动作执行之前或之后触发的拦截器。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="ActionInvocation" id="sourceContent1">
      <![CDATA[
    <img alt="ActionInvocation" src="http://farm8.staticflickr.com/7291/12652039153_eb84141781_b.jpg" />
  ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[图示的是一个 defaultStack 的简化版本。并且展示了一个常见的工作流&mdash;没有一个拦截器中断调用。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[动作最终会执行并返回一个控制字符串用来选择合适的结果。在执行结果之后，按照相反的顺序每一个拦截器都有机会在做一些后加工的工作。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[拦截器能够访问动作和其它上下文信息。这允许拦截器了解在处理工程中发生了什么。例如: 拦截器可以检查动作返回的控制字符串以了解选择了哪个结果。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[拦截器可以决定动作该不该执行，且可以自己返回一个控制字符串从而终止工作流。例如 workflow 拦截器: 如果动作实现了 Validateable 接口，那么调用该动作的 validate() 方法。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[&nbsp;]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[知道 ActionInvocation 做什么？ 就等于知道 Struts2 如何处理请求。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[当框架接收到一个请求时，它首先必须决定这个 url 映射到哪个动作。这个动作的一个实例会被加入到一个新创建的 ActionInvocation 实例中。接着会框架咨询声明性架构，以发现哪些拦截器应该被触发及按照什么样的顺序触发。]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>开发拦截器</c:title>
    <c:desc>
      <c:desc1> <![CDATA[Web 领域的大部分常见任务已经编写和捆绑进了 struts-default 包中。]]></c:desc1>
      <c:desc1> <![CDATA[在开发动作时，时刻注意可以被转移到拦截器中的任何任务。当你这样开始做时，说明你已经迷恋上了拦截器。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1">
      <![CDATA[
    
  ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>TimerInterceptor</c:title>
    <c:desc>
      <c:desc1> <![CDATA[TimerInterceptor 是 struts-default 包含的一个拦截器。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"><![CDATA[public String interceptor(ActionInvocation invocation) throws Exception {
    long startTime = System.currentTimeMillis();
    String result = invocation.invoke();
    long executionTime = System.currentTimeMillis() - startTime;
      ... log time...
    return result;
}]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[Interceptor 接口定义的 interceptor 方法的拦截器执行的入口点。 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[拦截器必须决定是否将控制权转交给剩余的拦截器和动作 (即: 调用 invoke() 方法)。 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[在调用 invoke() 方法之后，拦截器等待这个方法的返回值。invoke() 方法返回一个结果字符串，用来指示那个结果被呈现。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[虽然结果字符串告诉拦截器哪个结果会被呈现，但是它没有指出动作是否被触发。完全有可能更深层次的拦截器没有调用 invoke() 方法而是自己返回了一个控制字符串从而改变了工作流。]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>内建的 Struts2 拦截器</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1">
      <![CDATA[
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[timer 拦截器 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[logger 拦截器 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[params 拦截器 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[static-params 拦截器 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[autowiring 拦截器 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[servler-config 拦截器 ]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[fileUpload 拦截器 ]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>工作流拦截器</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1">
      <![CDATA[...
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>其它拦截器</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1">
      <![CDATA[...
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

</c:component>