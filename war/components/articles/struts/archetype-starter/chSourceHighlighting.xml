<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">

  <c:abstract>
    <![CDATA[]]>
  </c:abstract>

  <c:entry>
    <c:title>生成 struts2-archetype-starter 启动器项目</c:title>
    <c:desc>
      <c:desc1> <![CDATA[通过该启动器创建的项目包含所有基本元素以及大多数 Web 应用将要使用到的公共 Struts2 插件]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title=""
                     id="sourceContent1"><![CDATA[mvn archetype:generate -B  
    -DgroupId=com.test.mysite 
    -DartifactId=mysite 
    -DarchetypeGroupId=org.apache.struts 
    -DarchetypeArtifactId=struts2-archetype-starter


// 运行 Servlet 容器 (需进入 pom.xml 文件所在目录)
mvn -Djetty.port=9999 jetty:run

// 安装
mvn clean install

// 打包
mvn package]]></c:sourceContent>

    <c:sourceContent type="html" title="目录结构"
                     id="sourceContent1">
      <![CDATA[
      <div>
<img src="http://farm4.staticflickr.com/3679/13261559325_59723e80dc_b.jpg" 
      style="border:solid 1px gray;float:left;margin-right:1em;
            border-top-right-radius:8px;
            border-top-left-radius:8px;
            border-bottom-right-radius:8px;
            border-bottom-left-radius:8px;" alt="" />
<div>
  <span><span style="font-weight:bold;color:red;">src 目录</span> 是所有代码的根目录，在该目录下包含 main 目录和 test 目录，只有在 src 目录下的内容才会被打包到最终软件制品中去。</span><br />
  <span><span style="font-weight:bold;color:red;">resource 目录</span> 包含属性、XML、配置文件</span><br />
  <span><span style="font-weight:bold;color:red;">aspects 目录</span> 当 AspectJ 插件被包含进来时，会出现该目录</span><br />
  <span><span style="font-weight:bold;color:red;">groovy 目录</span> 包含 Groovy 脚本以备执行 (<a target="_blank" href="http://groovy.codehaus.org/Chinese+Home">Groovy</a> 是一种动态脚本语言，语法和 Java 很相似，可以直接执行也可以向下编译成字节码。) </span><br />  
  <span><span style="font-weight:bold;color:red;">webapp 目录</span> 对于打包成 war 文件的软件制品，该目录包含 WAR 文件所需的其它信息，而 EAR 或 JAR 不需要这些信息</span><br />
</div>
<div class="clear"></div>
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Maven2 配置文件"
                     id="sourceContent1"><![CDATA[<project>      
    <!-- modelVersion 该值表示 Maven2 的模型版本 -->
    <modelVersion>4.0.0</modelVersion> 
    
    <groupId>com.mytest.webapp</groupId>
    <artifactId>webapp</artifactId>
    
    <!-- 如果是 web 项目，那么该值总是 war (也可以是 jar) -->
    <!-- 如果项目中是一个包含了 Web 组件、EJB 组件或其它资源的 J2EE 应用，那么 packaging 的值就是 ear -->
    <packaging>war</packaging>       
    
    <!-- version 的值可以保持不变。当组件作为产品发布时，version 的值需改成 1.0，随之进一步的开发可以做相应递增。 -->
    <version>1.0-SNAPSHOT</version>
    
    <!-- 在启动器应用的代码生成之后可以修改 name、url、description 的默认值，这三个元素用来描述开发者和使用者的信息 -->
    <name>Struts 2 Starter</name>
    <url>http://www.myComp.com</url>
    <description>Struts 2 Starter</description>
    .........
</project>]]></c:sourceContent>

    <c:sourceContent type="" title="依赖项的配置"
                     id="sourceContent1"><![CDATA[<project>      
    .........
    <dependencies>
        <!-- jUnit -->
        <dependency>
            <groupId>junit</groupId>
            <artifactId>junit</artifactId>
            <version>3.8.1</version>
            <scope>test</scope>
        </dependency>
        
        <!-- Struts2 -->
        <dependency>
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-core</artifactId>
            <version>2.0.9</version>
        </dependency>
        
        <!-- Servlet & Jsp -->
        <dependency>
            <groupId>javax.servlet</groupId>
            <artifactId>servlet-api</artifactId>
            <version>2.4</version>
            <scope>provided</scope>
        </dependency>
        ........
    </dependencies>
    .........
</project>]]></c:sourceContent>

    <c:sourceContent type="" title="控制构建过程&#8212;build"
                     id="sourceContent1"><![CDATA[<project>      
    .........
    <build>
        <!-- finalName 用于覆盖最终产品名字: myapp.war (设置), myapp-1.0-SNAPSHOT.war(不设置) -->
        <finalName>myapp</finalName> 
        <plugins>
            <plugin>
                 <artifactId>maven-compiler-plugin</artifactId>   <!-- Java5 编译器 -->
                 <configuration>
                    <source>1.5</source>
                    <target>1.5</target>
                 </configuration>
            </plugin>
            <plugin>
                <groupId>org.mortbay.jetty</groupId>              <!-- Servlet 容器 -->
                <artifactId>maven-jetty-plugin</artifactId>
                <version>6.0.1</version>
                <configuration>
                    <!-- 默认 8080 端口 -->
                     
                    <!-- 告诉 Jetty 10 秒钟检查一次 war 文件，一旦发生变化就重新加载应用 -->
                    <scanIntervalSeconds>10</scanIntervalSeconds>
                </configuration>
            </plugin>
        </plugins>
    </build>
    .........
</project>]]></c:sourceContent>

    <c:sourceContent type="" title="struts2-archetype-starter 启动器包含的插件"
                     id="sourceContent1">
              <![CDATA[<project>      
    .........
    <dependencies>
        <!-- sitemesh -->
        <dependency>
            <!-- sitemesh 提供一套初始用户界面 -->
            <!-- sitemesh 利用过滤器拦截 Struts2 结果然后往结果里增加其他 HTML 代码 -->
            <!-- 启动器生成的 WEB-INF/decorators.xml 文件中给出了 URL 模式与装饰器之间的映射信息 -->
            <!-- webapp/WEB-INF/decorators/main.jsp 中定义了 3 个非常有用的标签: <decorator:title />，<decorator:head />，<decorator:body /> -->
            <!-- <decorator:title /> 将原始页面的 title 插入装饰器模板 -->
            <!-- <decorator:head /> 将原始页面的 head 标签里的内容插入装饰器模板 -->
            <!-- <decorator:body /> 将原始页面的 body 标签里的内容插入装饰器模板 -->
            <!-- 原始页面并不需要引用装时器模板文件，这是一种松耦合的可选机制 -->
            <!-- 放在 webapp/nodecorate/* 目录下的文件可以避免被 SiteMesh 装饰 -->
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-sitemesh-plugin</artifactId>
            <version>2.0.9</version>
        </dependency>
        
        <!-- spring -->
        <dependency>
            <groupId>org.apache.struts</groupId>
            <artifactId>struts2-spring-plugin</artifactId>
            <version>2.0.9</version>
        </dependency>
    </dependencies>
    .........
</project>

<!-- 修改 web.xml 配置文件，使插件工作 --> 
<context-param>
    <!-- 指定 applicationContext.xml 配置文件的存放位置 -->
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath*:applicationContext*.xml</param-value>
</context-param>

<listener>
    <!-- 该监听器用于访问 spring 上下文 -->
    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
</listener>


<!-- 为 sitemesh 定义过滤器 -->
<filter>
    <filter-name>action2-cleanup</filter-name>
    <filter-class>org.apache.struts2.dispather.ActionContextCleanUp</filter-class>
</filter>
<filter>
    <filter-name>sitemesh</filter-name>
    <filter-class>com.opensymphony.module.sitemesh.filter.PageFilter</filter-class>
</filter>
<filter>
    <filter-name>action2</filter-name>
    <filter-class>org.apache.struts2.dispather.FilterDispather</filter-class>
</filter>

<filter-mapping>
    <filter-name>action2-cleanup</filter-name>
    <filter-class>/*</filter-class>
</filter-mapping>
<filter-mapping>
    <filter-name>sitemesh</filter-name>
    <filter-class>/*</filter-class>
</filter-mapping>
<filter-mapping>
    <filter-name>action2</filter-name>
    <filter-class>/*</filter-class>
</filter-mapping>]]></c:sourceContent>
    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:2em;">
    <c:title>显示第一个页面 index.action</c:title>
    <c:desc>
      <c:desc1> <![CDATA[运行 servlet 容器, jetty:run --> http://localhost:8080/app --> http://localhost:8080/app/index.action ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="IndexAction.java" style="border-bottom:none;"
                      id="sourceContent1"><![CDATA[@Conversion()
public class IndexAction extends ActionSupport {
    // Struts2 为每个请求创建一个新的 action 实例，所以实例中类的成员变量是每个请求独有的，因此可以使用该成员变量传递数据 (当然也可以使用方法中的局部变量)
    // Struts1.x 在多个请求中共享 action 实例，无法保证线程安全，因此只能使用方法中的局部变量
    private Date now = new Date(System.currentTimeMillis());
    
    @TypeConversion(converter = "com.fdar.apress.s2.DateConverter")
    public Date getDateNow() { 
        return this.now;        // 任何类属性都可以在获取方法和设置方法中使用
    }
          
    public String execute() {
        // 使用方法中的局部变量
        now = new Date(System.currentTimeMillis());
        return SUCCESS;
    }
}]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" style="border-top:none;"
                      id="sourceContent1"><![CDATA[<!-- src/main/resources/struts.xml -->
<struts>
    <package name="myPackage" extends="struts-default">
        <action name="index" class="com.mypackagename.IndexAction">
            <!-- 注意该 action 没有提供 namespace 属性 -->
            <!-- result 的 name 属性默认是 success，type 属性默认是 jsp -->
            <result>/jsp/index.jsp</result>
        </action>
    </package>
</struts>]]></c:sourceContent>
    
    <c:sourceContent type="" title="/jsp/index.jsp"
                      id="sourceContent1"><![CDATA[<%@ page contentType="text/html;charset=utf-8" %>
<%@taglib prefix="s" uri="/struts-tags" %>
      
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>Index</title>
        <s:head />
    </head>
    <body>
        <s:form action="helloWorld">
            <s:textfield name="name" label="What is your name?" />
            <s:textfield name="dateNow" label="What is the date?" />
                
            <s:submit />
        </s:form>
    </body>
</html>]]></c:sourceContent>
    <c:sourceContent type="" title="helloWorldAction.java" style="border-bottom:none;"
                      id="sourceContent1"><![CDATA[@Validation()      // 类级别注释告诉 Struts2 该类具有验证功能
@Conversion()
public class HelloWorldAction extends ActionSupport {
    private Date now;
    private String name;
    
    @TypeConversion (converter = "com.mypackage.DateConverter")
    @RequiredFieldValidator (message = "Please enter the date")
    public void setDateNow(Date now) {
        this.now = now;
    }
    
    public Date getDateNow() {
        return this.now;
    }
    
    @RequiredStringValidator (message = "Please enter a name", tirm = true)
    public void setName(String name) {
        this.name = name;
    }
    
    public String getName() {
        return this.name;
    }
    
    public String execute() thorws Exception {
        return SUCCESS;
    }
}]]></c:sourceContent>
    <c:sourceContent type="" title="" style="border-top:none;border-bottom:none;"
                      id="sourceContent1"><![CDATA[<!-- src/main/resources/struts.xml -->
<struts>
    <package name="myPackage" extends="struts-default">
        <!-- 让 Spring 管理 action 的创建，需将 class 属性设置成 spring bean 的 id -->
        <action name="helloWorld" class="helloWorldAction">
            <result name="input">/jsp/index.jsp</result>
            <result>/jsp/helloWrold.jsp</result>
        </action>
    </package>
</struts>]]></c:sourceContent>
    <c:sourceContent type="" title="" style="border-top:none;"
                      id="sourceContent1"><![CDATA[<!-- src/main/resources/applicationContext.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC 
       "-//SPRING//DTD BEAN//EN" 
       "http://www.springframework.org/dtd/spring-beans.dtd">
<beans>
  <bean id="helloWorldAction"
        class="com.mystruts.web.HelloWorldAction" singleton="false" />
</beans>]]></c:sourceContent>

    <c:sourceContent type="" title="/jsp/helloWrold.jsp"
                  id="sourceContent1"><![CDATA[<%@taglib prefix="s" uri="/struts-tags" %>
      
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <title>Hello world!</title>
        <s:head />
    </head>
    <body>
        Hello <s:property name="name" />，today is <s:property name="dateNow" />
    </body>
</html>]]></c:sourceContent>

    <c:sourceContent type="" title="自定义数据类型转换"
                  id="sourceContent1"><![CDATA[/* Struts2 可以处理许多基本数据类型的转换，如: Boolean、char、Character、int、Integer、float、Float、etc. */
/* 可以编写自定义类型转换器，实现特殊转换 */
      
public class DateConverter extends StrutsTypeConverter {          
    public Object convertFromString (Map context, String[] values, Class toClass) {
        // values 定义为数组类型，是为了处理单个表单名传递多个值得情况
        if (values != null && values.length > 0 
                && values[0] != null && values[0].length() > 0) {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
                  
            try {
                return sdf.parse(values[0]);
            } catch (ParseException e) {
                throw new TypeConversionException (e);
            }
                  
            return null;
        }
    }
    
    public String convertToString (Map context, Object o) {
        if (o instanceof Date) {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
            return sdf.format((Date) o);
        }
        
        return "";
    }
}]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>测试 action</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title=""
              id="sourceContent1"><![CDATA[public class IndexActionTest extends TestCase {
    public void testIndexAction () throws Exception {
        IndexAction   indexAction = new IndexAction();
        String result = indexAction.execute();
              
        // 也可以为 action 的获取方法和设置方法设置断言
        assertEquals(Action.SUCCESS, result);
    }
}

mvn test]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:2em;">
    <c:title>com.google.code.kaptcha 验证码</c:title>
    <c:desc>
      <c:desc1> <![CDATA[s2app 是一个社区娱乐应用，可以为喜爱的选手投票，并可以看到投票结果。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="dependency"
              id="sourceContent1"><![CDATA[<repository>
  <id>sonatype-forge</id>
  <name>Sonatype Forge</name>
  <url>http://repository.sonatype.org/content/groups/forge/</url>
</repository>
    
<!-- captcha -->
<dependency>
  <groupId>com.google.code.kaptcha</groupId>
  <artifactId>kaptcha</artifactId>
  <version>2.3</version>
  <classifier>jdk15</classifier>
</dependency>]]></c:sourceContent>


    <c:sourceContent type="" title="CaptchaServiceImpl"
                  id="sourceContent1"><![CDATA[package com.myproject.web.impl;

import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import javax.imageio.ImageIO;

import org.springframework.beans.factory.InitializingBean;
import com.myproject.web.services.CaptchaService;

import com.google.code.kaptcha.impl.DefaultKaptcha;
import com.google.code.kaptcha.util.Config;

import java.util.List;
import java.util.Random;

public class CaptchaServiceImpl implements CaptchaService {
	private static String feed = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

	private DefaultKaptcha producer;
	private Map<String, String> captchaMap = new HashMap<String, String> ();
	private int textCount = 0;

	public CaptchaServiceImpl() {
		producer = new DefaultKaptcha();
		producer.setConfig(new Config(new Properties()));
	}

	public String generateCaptchaKey() {
		String key = getRandomString();
		String val = getCaptchaText();
		
		captchaMap.put(key, val);

		return  key;
	}
	public byte[] generateCaptchaImg(String captchaKey) {
		String text = captchaMap.get(captchaKey);
		BufferedImage image = producer.createImage (text);
		
		ByteArrayOutputStream out = new ByteArrayOutputStream();
		try {
			
			ImageIO.write(image, "jpg", out);
		} catch (IOException e) {
			
		}

		return out.toByteArray();
	}
	public boolean validateCaptcha(String captchaKey, String captchaVal) {
		String text = captchaMap.get(captchaKey);

		if (text.equals(captchaVal)) {
			captchaMap.remove(captchaKey);
			return true;
		}
		
		return false;
	}

	private String getCaptchaText() {
		return producer.createText();
	}

	public static synchronized String getRandomString() {
		Random random = new Random();
		StringBuffer buffer = new StringBuffer();

		for (int i =0; i<8; i++) {
			buffer.append( feed.charAt( random.nextInt(feed.length())));
		}

		return buffer.toString();
	}
}]]></c:sourceContent>



    <c:sourceContent type="" title="test"
              id="sourceContent1"><![CDATA[package com.myproject.web.services;

import junit.framework.TestCase;

import com.myproject.web.impl.CaptchaServiceImpl;


import java.io.File;
import java.io.OutputStream;
import java.io.FileOutputStream;


public class CaptchaServiceTest extends TestCase {

	private CaptchaServiceImpl captcha;
    
    public CaptchaServiceTest () {
        super();

		captcha = new CaptchaServiceImpl();
    }
          
    protected void setUp () throws Exception {
        super.setUp();
              
		
    }
          
    protected void tearDown () throws Exception {
        super.tearDown();

    }

	public void testGenerateKey() throws Exception{
		String key = captcha.generateCaptchaKey();
		System.out.println(key);
		assertNotNull(key);

		byte[] image = captcha.generateCaptchaImg(key);
		assertTrue(image.length > 0);

		File f = new File ( "D:\\" + key + ".jpg");

		OutputStream output = null;

		try {
			output = new FileOutputStream(f);
			output.write(image);
		} catch (Exception e) {
			
		} finally {
			if (output != null) {
				output.close();
			}
		}

		if (output != null) {
			output.close();
		}

		assertTrue(f.exists() && f.length() > 0);
	}
}]]></c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  
  
  

  <c:entry style="margin-top:2em;">
      <c:title>我的第一个应用 s2app</c:title>
      <c:desc>
        <c:desc1> <![CDATA[s2app 是一个社区娱乐应用，可以为喜爱的选手投票，并可以看到投票结果。]]></c:desc1>
      </c:desc>
      <c:sourceContent type="html" title="业务用例1：注册新活动"
                id="sourceContent1"><![CDATA[
                1、查询现存活动判定新活动是否存在 (此项可选，用户可以跳过这项继续下面的步骤) <br />
                2、用户需要登陆 (如果用户没有注册，用户还需要注册)<br />
                3、创建活动，指定活动名称、开始时间、结束时间、投票期限以及时差等等<br />
                4、将选手增加到活动中去]]></c:sourceContent>
      <c:sourceContent type="html" title="业务用例2：投票"
                  id="sourceContent1"><![CDATA[
                  1、登陆 (如果没有注册还需要事先注册) <br />
                  2、登记到用户想要投票的活动<br />
                  3、投票给参加活动的选手]]></c:sourceContent>
      <c:sourceContent type="html" title="业务用例3：查看投票结果"
                  id="sourceContent1"><![CDATA[
                  1、活动结束后马上出现结果，而且能让所有用户看到 (不管用户是否登陆)]]></c:sourceContent>
  
      <c:sourceContent type="html" title="系统用例" style="margin-top:1em;"
                id="sourceContent1"><![CDATA[
                1、注册、更新用户配置、上传头像<br />
                2、创建活动、用户登录、用户注销<br />
                3、搜索活动<br />
                4、发布活动信息<br />
                5、登记到某个活动<br />
                6、投票<br />
                7、查看活动结果]]></c:sourceContent>
  
      
      <c:sourceContent type="html" title="集成技术" style="margin-top:1em;"
                  id="sourceContent1"><![CDATA[
                  1、Hibernate： 使用 JPA (Java Persistence API) 为应用的持久化提供对象关系映射<br />
                  2、Spring：提供业务服务，这是一个将 Struts2 的 action 与持久化层隔开的架构层<br />
                  3、Acegi： 可选组件，用户提供授权和身份验证服务<br />
                  4、Rome： 用来为共享数据产生 RSS Feed<br />
                  5、GWT 和 Dojo： 提供 Ajax 界面]]></c:sourceContent>
  
    
      <c:comment>
        <c:comment1>
          <![CDATA[]]>
        </c:comment1>
      </c:comment>
    </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>s2app 的领域模型</c:title>
    <c:desc>
      <c:desc1> <![CDATA[每个应用都需要用类来表示应用的核心概念，类还包含核心概念之间的不同关系。类和关系一起形成了应用的领域模型。]]></c:desc1>
      <c:desc1> <![CDATA[在敏捷开发过程中，领域模型是逐步完善的。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title=""
              id="sourceContent1"><![CDATA[
      <img src="/images/UML/class01.png" alt="" />   <br />
      <br />
      <p style="margin:.2em 0">
          <span style="color:red;font-weight:bold;">Event</span> 是模型中的核心领域对象，它为活动的所有基本信息提供属性。该信息被分割成 Progress枚举、Location、Address 和 Broadcase类。
      </p>
      <p style="margin:.2em 0">
          <span style="color:red;font-weight:bold;">Progress</span> 枚举类型提供活动存在的生命周期状态。每个状态允许用户执行特定的任务，例如没有人能够在 CLOSED 或 NO_STARTE 状态时投票。
      </p>
      <p style="margin:.2em 0">
          <span style="color:red;font-weight:bold;">Location</span> 提供关于活动举办场所的信息，它有两个子类： Address 类提供物理地址，Broadcast 类提供有关活动转播电视台的信息。
      </p>
      <p style="margin:.2em 0">
          <span style="color:red;font-weight:bold;">User</span> 描述当前 Web 应用的当前用户。在本应用中用户不能同时是选手。
      </p>
      <p style="margin:.2em 0">
          <span style="color:red;font-weight:bold;">Contestant</span> 包含 Event 中的选手信息，选手就是参与竞赛活动的人，那些登记到活动的用户可以为选手投票。
      </p>
      <p style="margin:.2em 0">
          <span style="color:red;font-weight:bold;">Voter</span> 描述活动与用户之间的关系，在用户登记投票时就会创建一个 Voter 类实例。当用户投票时，被选定的活动选手就会被记录下来。
      </p>
    ]]></c:sourceContent>
    
    
    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
      <c:title>敏捷开发</c:title>
      <c:desc>
        <c:desc1> <![CDATA[敏捷开发将注意力集中在使提供的功能让用户直接受益的活动上，同时严格控制功能的膨胀。]]></c:desc1>
        <c:desc1> <![CDATA[产品开发被分割成多个更小的迭代过程 (每个迭代过程平均 2-6 个星期)]]></c:desc1>
        <c:desc1> <![CDATA[在每次迭代中，待完成特性要经历挑选、计划、实现、测试以及由客户或产品经理签出等阶段。]]></c:desc1>
        <c:desc1> <![CDATA[在每次迭代完成后还要检查整个迭代过程，看看还有哪些方面需要完善 (例如: 特性实现方面、管理方面、过程方面)]]></c:desc1>
      </c:desc>
      <c:sourceContent type="html" title=""
                id="sourceContent1"><![CDATA[
        
      ]]></c:sourceContent>
    
    
    
      <c:comment>
        <c:comment1>
          <![CDATA[]]>
        </c:comment1>
      </c:comment>
    </c:entry>

  <c:entry style="margin-top:2em;">
        <c:title>为 s2app 集成持久化层</c:title>
        <c:desc>
          <c:desc1> <![CDATA[本应用将使用 Hibernate 提供的 JPA 扩展，而不是使用自定义 Hibernate 映射机制。]]></c:desc1>
          <c:desc1> <![CDATA[JPA 是 J2EE 映射和持久化数据到数据库的标准方案。]]></c:desc1>
        </c:desc>
        <c:sourceContent type="" title="添加 Hibernate 依赖"
                  id="sourceContent1">
  <![CDATA[<project>
  <repositories>
      <!-- 添加 Hibernate 本地存储库 -->
      <repository>
      <id>maven2-repository.dev.java.net</id>
      <name>Java.net Repository for Maven</name>
      <url>http://download.java.net/maven/2/</url>
      <layout>default</layout>
    </repository>
  </repositories>
          
  <dependencies>
      <!-- Hibernate -->
      <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
        <version>5.1.6</version>
      </dependency>
      
      <dependency>
        <groupId>org.hsqldb</groupId>
        <artifactId>hsqldb</artifactId>
        <version>1.8.0.10</version>
        <!--scope>test</scope-->
      </dependency>
      
      <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate</artifactId>
        <version>3.2.1.ga</version>
      </dependency>
      <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-annotations</artifactId>
        <version>3.2.1.ga</version>
      </dependency>
      <dependency>
        <groupId>org.hibernate</groupId>
        <artifactId>hibernate-entitymanager</artifactId>
        <version>3.2.1.ga</version>
      </dependency>

      <!-- JPA 2.0 -->
      <!--dependency>
        <groupId>org.hibernate.javax.persistence</groupId>
        <artifactId>hibernate-jpa-2.0-api</artifactId>
        <version>1.0.1.Final</version>
      </dependency-->
      
      <dependency>
        <groupId>javax.persistence</groupId>
        <artifactId>persistence-api</artifactId>
        <version>1.0</version>
      </dependency>
      <dependency>
        <groupId>javax.transaction</groupId>
        <artifactId>jta</artifactId>
        <version>1.0.1B</version>
      </dependency>    
  </dependencies>
</project>]]></c:sourceContent>

    
        <c:comment>
          <c:comment1>
            <![CDATA[]]>
          </c:comment1>
        </c:comment>
      </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>创建 MySQL 数据库</c:title>
    <c:desc>
      <c:desc1> <![CDATA[MySQL 下载地址: <a href="http://dev.mysql.com/download/mysql/4.1.html">http://dev.mysql.com/download/mysql/4.1.html</a> ]]></c:desc1>
    </c:desc>
    

    <c:sourceContent type="html" title=""
                  id="sourceContent1">
<![CDATA[1. 创建数据库： create database s2app;<br />
2. 创建的数据库结构图如下： <br />
<img width="900px" src="/images/UML/er001.png" alt="" />]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title>配置 JPA</c:title>
    <c:desc>
      <c:desc1> <![CDATA[ ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="/src/main/resources/META-INF/persistence.xml"
                  id="sourceContent1">
      <![CDATA[<!-- MySQL -->
<persistence xmlns="http://java.sun.com/xml/ns/persistence"
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd"
             version="1.0">
    <persistence-unit name="s2app">
        <!-- 使用 Hibernate 提供的 JPA 实现 (也可以使用 Top Link 或者 IBM 提供的 JPA 实现) -->
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        <properties>
            <property name="hibernate.dialect" 
                      value="org.hibernate.dialect.MySQLDialect"/>
            <property name="hibernate.connection.driver_class" 
                      value="com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource" />
            <property name="hibernate.connection.url" 
                      value="jdbc:mysql://localhost/s2app" />
            <property name="hibernate.connection.username" value="root" />
            <property name="hibernate.connection.password" value="password" />
            <property name="hibernate.hbm2ddl.auto" value="update"/>
            <property name="hibernate.archive.autodetection" value="class"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
        </properties>
    </persistence-unit>
</persistence>

<!-- HyperSQL (HSQLDB) -->
<!-- http://www.programmingforfuture.com/2010/06/using-hypersql-hsqldb.html -->
<!--
    <dependency>
        <groupId>org.hsqldb</groupId>
        <artifactId>hsqldb</artifactId>
        <version>1.8.0.10</version>
        <scope>test</scope>
    </dependency>
    
    // server.properties 
    // Content：
       server.database.0=file:hsqldb/hemrajdb
       server.dbname.0=s2app
    
    // Command -> java -classpath lib/hsqldb.jar org.hsqldb.server.Server --database.0 file:hsqldb/s2appdb --dbname.0 s2app
    // Connection String -> jdbc:hsqldb:hsql://localhost/s2app
-->
<persistence xmlns="http://java.sun.com/xml/ns/persistence" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
             xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_1_0.xsd" 
             version="1.0">
    <persistence-unit name="manager" transaction-type="RESOURCE_LOCAL">
        <provider>org.hibernate.ejb.HibernatePersistence</provider>
        <properties>
            <property name="hibernate.dialect" 
                      value="org.hibernate.dialect.HSQLDialect" />
            <property name="hibernate.connection.driver_class" 
                      value="org.hsqldb.jdbcDriver" />
            <property name="hibernate.connection.url" 
                      value="jdbc:hsqldb:file:src/main/resources/db/mydbname;shutdown=true" />
            <!--
                <property name="hibernate.connection.url" 
                          value="jdbc:hsqldb:hsql://localhost/mydbname;shutdown=true" /> -->
            <property name="hibernate.connection.user" value="sa" />
            <property name="hibernate.hbm2ddl.auto" value="update" />
            <property name="hibernate.archive.autodetection" value="class" />
            <!-- <property name="hibernate.show_sql" value="true"/> -->
            <property name="hibernate.flushMode" value="FLUSH_AUTO" />
        </properties>
    </persistence-unit>
</persistence>]]></c:sourceContent>
    <c:sourceContent type="html" title="persistence.xml 文件中与数据库相关的属性"
                  id="sourceContent1">
      <![CDATA[
        <table>
            <thead>
                <tr>
                    <th style="padding:.2em .5em;font-weight:bold;">属性名</th>
                    <th style="padding:.2em .5em;font-weight:bold;">描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.dialect</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        方言，告诉 Hibernate 怎样为特定种类的数据库构建 SQL 和 DDL
                    </td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.connection.driver_class</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        用于连接数据库的 JDBC 驱动类
                    </td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.connection.url</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        数据库或 schema 的位置
                    </td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.connection.username</td>
                    <td style="padding:.2em .5em;font-style:italic;">用户名</td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.connection.passowrd</td>
                    <td style="padding:.2em .5em;font-style:italic;">密码</td>
                </tr>
            </tbody>
        </table>
      ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="persistence.xml 文件中与 Hibernate 相关的属性"
                  id="sourceContent1">
      <![CDATA[<table>
            <thead>
                <tr>
                    <th style="padding:.2em .5em;font-weight:bold;">属性名</th>
                    <th style="padding:.2em .5em;font-weight:bold;">描述</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.archive.autodetection</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        告诉 Hibernate 如何发现持久化类，class 值告诉 Hibernate 使用注释功能来发现持久化类，
                        其他可能的值还有 hbm，这个值告诉 Hibernate 使用老式 XML 配置文件的方式来发现持久化类。
                    </td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.hbm2ddl.auto</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        确定 Hibernate 是否使用 DDL 命令来管理数据库中的数据结构。该属性的值可以为 validate (表示仅验证数据结构)，
                        create (创建数据结构)，update (更新数据库以便和模型匹配)，create-drop (创建会话工厂 session factory 的同时创建数据结构),
                        当会话工厂销毁时，也同时销毁数据结构<br />
                        
                        <br />
                        <span style="color:rgb(213, 28, 181);font-weight:bold;font-style:normal;">
                        1. 当属性设置为 update 时，可以满足数据库的任何变动要求，包括创建初始数据库结构。<br />
                        2. 当需要测试数据完整性或者需要从某个数据结构版本移植到另一个版本时，这个特性也会带来问题。
                        在这种情况下，最好是自动产生数据结构的 DDL 脚本。
                        </span>
                    </td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.show_sql</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        显示在数据库上运行的 SQL 语句
                    </td>
                </tr>
                <tr>
                    <td style="padding:.2em .5em;font-weight:bold;">hibernate.format_sql</td>
                    <td style="padding:.2em .5em;font-style:italic;">
                        调整显示的 SQL 语句的格式
                    </td>
                </tr>
            </tbody>
        </table>]]>
    </c:sourceContent>
    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[ 创建数据访问对象 <span style="color:gray;">(<span style="font-style:italic;">使用 Hibernate/JPA 持久化注释</span> )</span>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[JPA 常用注释： (更多映射注释信息请访问: <a target="_blank" href="http://annotations.hibernate.org">http://annotations.hibernate.org</a>)]]></c:desc1>
      <c:desc1> <![CDATA[<span style="color:#066;font-weight:bold;">@Entity：</span> 将类定义成映射到数据的实体]]></c:desc1>
      <c:desc1> <![CDATA[<span style="color:#066;font-weight:bold;">@Table：</span> 
                  提供映射到数据库表中的其他信息，在本例中是将类映射到名为 S2APP 这个 schema 中的 APP_USER 表<br />
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
               <span style="color:rgb(255, 116, 0);font-weight:bold;font-style:italic;"> oracle, mysql 之类的数据库系统中，一个schema 其实就是一套表，VIEW，等。 类似于SQL SERVER中的一个数据库。</span>]]></c:desc1>
      <c:desc1> <![CDATA[<span style="color:#066;font-weight:bold;">@Id：</span> 标明表的主键字段]]></c:desc1>
      <c:desc1> <![CDATA[<span style="color:#066;font-weight:bold;">@Column：</span> 列名]]></c:desc1>
    </c:desc>

    <c:sourceContent expand="true" type="" title="User"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;
                    
import javax.persistence.*;
import java.io.Serializable;

@Entity @Table( name="APP_USER", schema="S2APP" )
public class User implements Serializable {

    private String firstName;
    private String lastName;
    private String email;
    private String password;
    private byte[] portrait;

   @Id @Column(name="EMAIL")
    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Column(name="FIRST_NAME")
    public String getFirstName() {
        return firstName;
    }

    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    @Column(name="LAST_NAME")
    public String getLastName() {
        return lastName;
    }

    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    @Column(name="USER_PASSWORD")
    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Lob @Column(name="PORTRAIT")
    public byte[] getPortrait() {
        return portrait;
    }

    public void setPortrait(byte[] portrait) {
        this.portrait = portrait;
    }
}
]]></c:sourceContent>
    <c:sourceContent expand="" type="" title="Event"
                  id="sourceContent1">
  <![CDATA[import org.hibernate.annotations.Generated;

import javax.persistence.*;
import java.util.*;
import java.io.Serializable;

@Entity @Table( name="EVENT", schema="S2APP" )
public class Event  implements Serializable {

    private long id;
    private String name;
    private Date startTime;
    private int duration;
    private int timeZoneOffset;
    private Date votingStartTime;
    private Date lastUpdateTime;
    private Set<Voter> voters = new HashSet<Voter>();
    private Location location;
    private List<Contestant> options = new ArrayList<Contestant>();
    private Progress status;

    @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="NAME")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="START_TIME") @Temporal(TemporalType.TIMESTAMP)
    public Date getStartTime() {
        return startTime;
    }

    public void setStartTime(Date startTime) {
        this.startTime = startTime;
    }

    @Column(name="DURATION")
    public int getDuration() {
        return duration;
    }

    public void setDuration(int duration) {
        this.duration = duration;
    }

    @Column(name="TZ_OFFSET")
    public int getTimeZoneOffset() {
        return timeZoneOffset;
    }

    public void setTimeZoneOffset(int timeZoneOffset) {
        this.timeZoneOffset = timeZoneOffset;
    }

    @Column(name="VOTING_STARTS") @Temporal(TemporalType.TIMESTAMP)
    public Date getVotingStartTime() {
        return votingStartTime;
    }

    public void setVotingStartTime(Date votingStartTime) {
        this.votingStartTime = votingStartTime;
    }

    @Column(name="LAST_UPDATE") @Temporal(TemporalType.TIMESTAMP)
    public Date getLastUpdateTime() {
        return lastUpdateTime;
    }

    public void setLastUpdateTime(Date lastUpdateTime) {
        this.lastUpdateTime = lastUpdateTime;
    }

    @OneToMany(mappedBy="event",cascade=CascadeType.REFRESH)
    public Set<Voter> getVoters() {
        return voters;
    }

    public void setVoters(Set<Voter> voters) {
        this.voters = voters;
    }

    public void addVoter( Voter v ) {
        v.setEvent(this);
        voters.add(v);
    }

    @ManyToOne(cascade=CascadeType.REFRESH) @JoinColumn(name="LOCATION_FK")
    public Location getLocation() {
        return location;
    }

    public void setLocation(Location location) {
        this.location = location;
    }

    @OneToMany(mappedBy="event",cascade=CascadeType.REFRESH)
    public List<Contestant> getOptions() {
        return options;
    }

    public void setOptions(List<Contestant> options) {
        this.options = options;
    }

    public void addOption( Contestant c ) {
        c.setEvent(this);
        options.add(c);
    }

    @Column(name="STATE") @Enumerated(EnumType.STRING)
    public Progress getStatus() {
        return status;
    }

    public void setStatus(Progress status) {
        this.status = status;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="" type="" title="Address"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;

import javax.persistence.*;

@Entity @Table( name="ADDRESS", schema="S2APP" )
@PrimaryKeyJoinColumn(name="LOCATION_PK")
public class Address extends Location {

    private String address;
    private String zipcode;

    @Column(name="ADDRESS")
    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Column(name="ZIPCODE")
    public String getZipcode() {
        return zipcode;
    }

    public void setZipcode(String zipcode) {
        this.zipcode = zipcode;
    }
}
]]></c:sourceContent>
    <c:sourceContent expand="" type="" title="Broadcast"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;

import javax.persistence.*;

@Entity @Table( name="BROADCAST", schema="S2APP" )
@PrimaryKeyJoinColumn(name="LOCATION_PK")
public class Broadcast extends Location {

    private String stationIdentifier;
    private String network;

    @Column(name="CALLSIGN")
    public String getStationIdentifier() {
        return stationIdentifier;
    }

    public void setStationIdentifier(String stationIdentifier) {
        this.stationIdentifier = stationIdentifier;
    }

    @Column(name="NETWORK")
    public String getNetwork() {
        return network;
    }

    public void setNetwork(String network) {
        this.network = network;
    }
}
]]></c:sourceContent>
    <c:sourceContent expand="" type="" title="Contestant"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;

import javax.persistence.*;

@Entity @Table( name="CONTESTANT", schema="S2APP" )
public class Contestant {

    private long id;
    private String name;
    private String description;
    private Event event;

    @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="NAME")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="DESCRIPTION")
    public String getDescription() {
        return description;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    @ManyToOne @JoinColumn(name="EVENT_FK")
    public Event getEvent() {
        return event;
    }

    public void setEvent(Event event) {
        this.event = event;
    }
}
]]></c:sourceContent>
    <c:sourceContent expand="" type="" title="Location"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;

import javax.persistence.*;
import java.io.Serializable;

@Entity @Table( name="LOCATION", schema="S2APP" )
@Inheritance(strategy= InheritanceType.JOINED)
public abstract class Location implements Serializable {

    private long id;
    private String name;
    private String city;
    private String state;

    @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="NAME")
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Column(name="CITY")
    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    @Column(name="STATE")
    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}
]]>
    </c:sourceContent>
    <c:sourceContent expand="" type="" title="Progress"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;

public enum Progress {
    NOT_STARTED,
    IN_PROGRESS,
    COMPLETED,
    VOTING_CLOSED,
    CLOSED
}]]></c:sourceContent>
    <c:sourceContent expand="" type="" title="Voter"
                  id="sourceContent1"><![CDATA[package com.fdar.apress.s2.domain;

import javax.persistence.*;
import java.io.Serializable;
import java.util.Date;

@Entity @Table( name="VOTER", schema="S2APP" )
public class Voter implements Serializable {

    private long id;
    private Date enrollmentTime;
    private Date voteRecordedTime;
    private Contestant votedForOption;
    private User user;
    private Event event;

    @Id  @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="ENROLLMENT_TIME") @Temporal(TemporalType.TIMESTAMP)
    public Date getEnrollmentTime() {
        return enrollmentTime;
    }

    public void setEnrollmentTime(Date enrollmentTime) {
        this.enrollmentTime = enrollmentTime;
    }

    @Column(name="VOTED_ON",nullable=true) @Temporal(TemporalType.TIMESTAMP)
    public Date getVoteRecordedTime() {
        return voteRecordedTime;
    }

    public void setVoteRecordedTime(Date voteRecordedTime) {
        this.voteRecordedTime = voteRecordedTime;
    }

    @ManyToOne @JoinColumn(name="CONTESTANT_FK",nullable=true)
    public Contestant getVotedForOption() {
        return votedForOption;
    }

    public void setVotedForOption(Contestant votedForOption) {
        this.votedForOption = votedForOption;
    }

    @ManyToOne @JoinColumn(name="USER_FK")
    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    @ManyToOne @JoinColumn(name="EVENT_FK")
    public Event getEvent() {
        return event;
    }

    public void setEvent(Event event) {
        this.event = event;
    }
}
]]></c:sourceContent>
    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[为实体类做单元测试]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[每个实体类的单元测试都包含一些公共功能：]]></c:desc1>
      <c:desc1> <![CDATA[1、获取实体管理器工厂。]]></c:desc1>
      <c:desc1> <![CDATA[2、创建实体管理器以及管理事务。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="测试公用类 PersistenceBaseClass"
                      id="sourceContent1"><![CDATA[import junit.framework.TestCase;

import javax.persistence.EntityTransaction;
import javax.persistence.EntityManager;
import javax.persistence.EntityManagerFactory;
import javax.persistence.Persistence;

public class PersistenceBaseClass extends TestCase {
    private EntityManagerFactory emf;
    protected EntityManager em;
    protected EntityTransaction tx;
          
    public PersistenceBaseClass () {
        super();
        emf = Persistence.createEntityManagerFactory("s2app");    // 根据 persistence.xml 取得实体管理器工厂
    }
          
    protected void setUp () throws Exception {
        super.setUp();
              
        em = emf.createEntityManager();                           // 使用工厂创建实体管理器
        tx = em.getTransaction();
        tx.begin();
    }
          
    protected void tearDown () throws Exception {
        super.tearDown();
        tx.rollback();
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="UserTestCase"
                      id="sourceContent1">
      <![CDATA[public class UserTestCase extends PersistenceBaseClass {
    public void testCreateFind () throws Exception {
        User u = new User();
              
        u.setEmail("Keesh@struts.com");
        u.setFirstName("张");
        u.setLastName("Chunhui");
        u.setPassword("123");
        em.persist(u);
        em.flush();
              
        User firstUser = em.find(User.class,u.getEmail());
              
        assertNotNull(firstUser);
        assertEquals(firstUser.getEmail(), u.getEmail());
        assertEquals(firstUser.getFirstName(), u.getFirstName());
    }
    
    public List<User> listUsers(){
		  return (List<User>) em.createQuery("select e from User e").getResultList();
	  }
}]]>
</c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[通过 maven 执行单元测试需要执行： <br /> mvn test <br /><br /><br />]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[<p style="color:red;font-weight:bold;"> 当解决完中文乱码问题后，又发现报 "非法字符： \65279" 问题。<br /><br />
        解决方案及原因：<br />
        UltraEdit、EditPlus等编辑器会在utf8编码格式的文件开头添加utf8标识，使文件的编码格式由utf8变为utf8+BOM，导致mvn编译时将utf8标识误认为非法字符。<br /><br />
        解决办法：<br />
        通过UltraEdit、EditPlus等编辑器将utf8+BOM编码格式的文件改为utf8格式，去掉文件开头的utf8标识即可。</p>]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[User 之 CURD]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    
    <c:sourceContent expand="true" type="" title="UserService"
                      id="sourceContent1"><![CDATA[package com.s2app.services;

public interface UserService {
    public User findByEmail(String email);          
    public void persist (User user, String email);
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="UserServiceImpl"
                      id="sourceContent1"><![CDATA[package com.s2app.services.impl;
      
import com.s2app.domain.User;

import javax.persistence.*;

public class UserServiceImpl implements UserService {

    private EntityManagerFactory emf;

    public UserServiceImpl() {
        emf = Persistence.createEntityManagerFactory("s2app");
    }

    public User findByEmail(String email) {
        EntityManager entityMgr = emf.createEntityManager();
        return entityMgr.find(User.class,email);
    }

    public void persist(User user,String emailId) {

        EntityManager entityMgr = emf.createEntityManager();
        EntityTransaction tx = null;
        try {
            tx = entityMgr.getTransaction();
            tx.begin();

            if( "".equals(emailId) ) {
                entityMgr.persist(user);
            } else {
                entityMgr.merge(user);
            }

            tx.commit();
        }
        catch (Exception e) {
            if ( tx != null && tx.isActive() )
                tx.rollback();
            throw (RuntimeException)e.getCause();
        }
    }

}]]></c:sourceContent>
    
    <c:sourceContent expand="true" type="" title="Spring Bean"
                      id="sourceContent1"><![CDATA[<bean id="userService" class="com.s2app.services.impl.UserServiceImpl" />
                      
// 需使用属性注入或自动装配

// 如果使用自动装配，需在 struts.xml 文件中添加如下内容：
<constant name="struts.objectFactory.spring.autoWire" value="type" />]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="struts.xml"
                          id="sourceContent1"><![CDATA[<package name="user" extends="struts-default" namespace="/user">
    <default-interceptor-ref name="paramsPrepareParamsStack" />
    ...
</package>]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="params-prepare-params 模式"
                          id="sourceContent1">
      <![CDATA[<span style="font-weight:bold;">paramsPrepareParamsStack 拦截器栈按照如下顺序执行拦截器：</span><br />
1. 执行 params 拦截器设置 emailId 属性<br />
2. 执行 prepare 拦截器调用 prepare() 方法<br />
3. 执行 modelDriven 拦截器将领域模型放在值栈中<br />
4. 模型已经可用 (可能取自数据库)，执行 params 拦截器为其赋值<br /><br />

<span style="font-weight:bold;">如果拦截器没有按照既定的顺序执行，可能会发生一些奇怪的 bug：</span><br />
1. 如果 params 拦截器没有在 prepare 拦截器之前执行，emailId 的值将一直是空<br />
2. 如果 modelDriven 拦截器没有被应用到 action 上，那么领域模型将不会被设置到 ValueStack 上，进而修改后的值和新值都不能被赋值给领域模型对象<br />
3. 如果 params 拦截器没有被先后两次执行，那么数据值将不会赋值给领域对象模型<br />
4. 如果 prepare 拦截器没有被调用，系统会抛出 NullPointerException 异常， 或者不会更新领域对象的数据
      ]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="UserAction"
                      id="sourceContent1"><![CDATA[public class UserAction implements ModelDriven<User>
                                   , Preparable {
    private User user;
    
    // 由于 prepare 拦截器在 modelDriven 拦截器之前执行，因此使用 prepare() 方法初始化领域对象，否则 ModelDriven 无效
    // 如果属性对应的设置方法在领域模型中不存在，那么系统将在值栈中继续向下查找以确定该值是否可以被赋给另一个对象
    // 排在领域模型之后的是 action，即: 如果在领域模型中没有对象的属性，但是在 action 中有对应的属性，那么也能够被正确赋值
    // 所以在 action 中创建一个新的领域模型没有的属性用于接收 email
    private String emailId;         
    private UserService userService;
    
    public User getModel() {
        return user;
    }
    
    public void setEmailId(String emailId) {
        this.emailId = emailId;
    }
    
    public String getEmailId() {
        return this.emailId;
    }
    
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    public void prepare() throws Exception {
        if (emailId == null || "".equals(emailId)) {
            user = new User();
        } else {
            user = userService.findByEmail(emailId);
        }
    }
}]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="BaseUserAction"
                          id="sourceContent1"><![CDATA[// 可能会有很多 action 需要构建类似的代码，为了避免出现冗余，可以将公用的代码抽取到基类中
public abstract class BaseUserAction extends ActionSupport 
                                     implements ModelDriven<User>
                                                , Preparable {
    private User user;
    private String emailId;         
    private UserService userService;
    
    public User getModel() {
        return user;
    }
    
    public void setEmailId(String emailId) {
        this.emailId = emailId;
    }
    
    public String getEmailId() {
        return this.emailId;
    }
    
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    public void prepare() throws Exception {
        if (emailId == null || "".equals(emailId)) {
            user = new User();
        } else {
            user = userService.findByEmail(emailId);
        }
    }         
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="FindUserAction (使用注释)" style="border-bottom:none;"
                              id="sourceContent1"><![CDATA[@ParentPackage ("base-package")
@Results({
        @Result(name="success", type="ServletDispatcherResult.class", value="/WEB-INF/jsp/user/user.jsp")
    }
)
public abstract class FindUserAction extends BaseUserAction {
    public String execute() throws Exception {
        return SUCCESS;
    }    
}

// @ParentPackage 注释用于指定当前 action 的所属包，该注释的值必须是在 struts.xml 中真实存在的包名。

// 由于基于注释配置的局限性，现在还不能完全通过注释来获得 web 应用的全部信息
// 可以同时使用基于 XML 的配置和基于注释的配置，以获得 web 应用的全部信息]]></c:sourceContent>

    <c:sourceContent expand="true" type="html" title="" style="border-top:none;"
                              id="sourceContent1">
      <![CDATA[<div style="color:red;font-weight:bold;">
 &diams;&nbsp;&nbsp;需要向 web.xml 中添加一个名为 actionPackages 的参数，以确定需要扫描包含注释的 action (多个包名之间用逗号分隔) <br />
 <img src="//yahoov4s2-a.akamaihd.net/so/7143/13461457975_4e5fde7731_b.jpg" alt="" /><br />

 &diams;&nbsp;&nbsp;选择将哪些包放在配置中定义也很重要，因为它将决定包含其中的 action 的命名空间，例如：
  <p style="margin-left:1.5em;color:blue;font-weight:bold;">
    1. 如果一个 action 被放在 com.apress.s2.actions.user 包中，而 actionPackages 的值在配置文件中的值是 com.apress.s2.action，那么该 action 的相对包路径就是 user，所以它的命名空间就是 /user<br />
    2. 如果一个 action 被放在 com.apress.s2.actions.search.user 包中，那么它的命名空间就是 /search/user
  </p>
   &diams;&nbsp;&nbsp;也可以给 action 添加 @Namespace 注释以指定命名空间
 </div>]]>
    </c:sourceContent>

    <c:sourceContent expand="true" type="" title="codebehind" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[<!-- 使用 codebehind 插件，需在 struts.xml 中配置两个新的常量，并添加相应依赖 -->
<!-- 该插件将按照以下规则构建结果名： -->
<!--
    1. 一个路径前缀 (如果被配置了的话)
    2. URL 的 action 名
    3. 连接符 '-'
    4. execute() 方法返回的值 (小写)
    5. 根据结果类型追加扩展名：JSP -> .jsp，Freemarker -> .ftl，Velocity -> .vm
    6. example: /user/findUser-success.jsp，/user/findUser-input.ftl，/user/findUser-update.vm
    7. 可以在开发应用原型时使用 codebehind 插件
-->

<!-- 指定使用 codebehind 功能的包名 -->
<constant name="struts.codebehind.defaultPackage" value="base-package" />   

<!-- 指定模板路径前缀 -->
<constant name="struts.codebehind.pathPrefix" value="/WEB-INF/jsp/" />

<!-- 在 pom.xml 中添加 codebehind 依赖 -->
<dependency>
    <groupId>org.apache.struts</groupId>
    <artifactId>struts2-codebehind-plugin</artifactId>
    <version>2.0.9</version>
</dependency>]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="UpdateUserAction (Add or Update)" style="margin-top:1em;border-bottom:none;"
                              id="sourceContent1"><![CDATA[@ParentPackage("base-package")
@Result(name="success", value="index", type="ServletActionRedirectResult.class")
public class UpdateUserAction extends BaseUserAction {
    public String execute() {
        userService.persist(user, emailId);
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="" style="border-top:none;color:blue;"
                              id="sourceContent1">
      <![CDATA[<div style="color:rgb(216, 12, 189);font-weight:bold;">
          在 UpdateUserAction 成功运行之后，使用重定向 <span style="color:#080;font-weight:bold;">(ServletActionRedirectResult)</span> 可以避免当用户刷新页面时请求被执行两次。<br />
          在 UpdateUserAction 中并没有使用 codebehind 插件。因为在用户创建或更新后再无其他任务，系统将重定向到首页。<br />
          如果使用了 codebehind 插件，许多 jsp 页面就会彼此重复，或很多 HTTP 请求被转发到某个公用 action。直接配置结果可以避免重复。<br /><br />
          <img src="//c2.staticflickr.com/4/3726/13441837093_3ab897a78c_b.jpg" alt="" />
          <br /><br />
          
          index action 没有实际的功能所以没有必要创建 IndexAction，可以使用 ActionSupport 类在 struts.xml 中配置 index action。          
          </div>
      ]]>
    </c:sourceContent>

    <c:sourceContent expand="true" type="" title="更新后的 struts.xml" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[<constant name="struts.codebehind.defaultPackage" value="base-package" />  
<constant name="struts.codebehind.pathPrefix" value="/WEB-INF/jsp/" />

<package name="base-package" extends="struts-default">
    <default-interceptor-ref name="paramsPrepareParamsStack" />
          
    <action name="index" class="com.opensymphony.xwork2.ActionSupport">
        <result name="success">/WEB-INF/jsp/index.jsp</result>
    </action>
</package>]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="UserAction 之多工作单元" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[/*
 * 在多工作单元中，一个 action 类不再只包含一个 execute() 方法，而是可以拥有很多方法，这些方法可以通过不同的 URL 调用
 * 以这种方式构建 action 时，再也不能使用零配置，而是使用基于 XML 的配置 (@Result 注释是类级别，而不是方法级)
*/
public class UserAction extends ActionSupport 
                        implements ModelDriven<User>
                                   , Preparable {
    private User user;
    private String emailId;         
    private UserService userService;
    
    public User getModel() {
        return user;
    }
    
    public void setEmailId(String emailId) {
        this.emailId = emailId;
    }
    
    public String getEmailId() {
        return this.emailId;
    }
    
    public void setUserService(UserService userService) {
        this.userService = userService;
    }
    
    public void prepare() throws Exception {
        if (emailId == null || "".equals(emailId)) {
            user = new User();
        } else {
            user = userService.findByEmail(emailId);
        }
    }
    
    // 替代 FindUserAction 类
    public String find() {
        // 执行完 find() 方法后显示编辑用户信息界面
        return INPUT;
    }
    
    // 替代 UpdateUserAction 类
    public String update() {
        userService.persist(user, emailId);
        
        // 更新用户信息之后回到首页
        return SUCCESS;
    }
}]]>
    </c:sourceContent>

    <c:sourceContent expand="true" type="" title="添加了方法属性的 struts.xml" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[<!-- constant name="struts.codebehind.defaultPackage" value="base-package" />  
<constant name="struts.codebehind.pathPrefix" value="/WEB-INF/jsp/" / -->

<package name="user" extends="struts-default" namespace="/user">
    <default-interceptor-ref name="paramsPrepareParamsStack" />
          
    <action name="index" class="com.opensymphony.xwork2.ActionSupport">
        <result name="success">/WEB-INF/jsp/index.jsp</result>
    </action>
          
    <action name="findUser" method="find" class="com.s2app.action.UserAction">
        <result name="input">/WEB-INF/jsp/user/findUser-success.jsp</result>
    </action>
          
    <action name="updateUser" method="update" class="com.s2app.action.UserAction">
        <result name="success" type="redirectAction">index</result>
    </action>
</package>]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="通配符映射" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[<!-- 单个领域对象 -->
<action name="*User" method="{1}" class="com.s2app.action.UserAction">
    <result name="input">/WEB-INF/jsp/user/{1}User-success.jsp</result>
    <result name="success" type="redirectAction">index</result>
</action>

<![CDATA[<!-- 多个领域对象 -->
<action name="*_*" method="{1}" class="com.s2app.action.{2}Action">
    <result name="input">/WEB-INF/jsp/user/{1}{2}-success.jsp</result>
    <result name="success" type="redirectAction">index</result>
</action>

<!-- 使用通配符需要注意的几点 -->
<!--
    1. 只能使用九个组，从 {1} - {9}
    2. {0} 具有特殊意义，包含完整的 URL 请求
    3. * 可以匹配零个或多个字符，但不包括 /
    4. ** 可以匹配零个或多个字符， 并包括 /
    5. 字符 \ 作为转义字符用来处理标点符号，例如： \\, \', \*
-->]]></c:sourceContent>

    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[单元测试]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[为测试 action 对象的功能，我们将使用 <a target="_blank" href="www.jmock.org">jModk</a> 库。]]></c:desc1>
      <c:desc1> <![CDATA[mock 对象提供与真实对象一样的方法，但允许通过设置，让那些你所期望的方法被调用。]]></c:desc1>
      <c:desc1> <![CDATA[在测试时 mock 对象可以确认方法调用的正确性，是否所有期望的方法都被调用了且没有额外的方法被调用等等。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="jMock"
                              id="sourceContent1"><![CDATA[<!-- 在 pom.xml 中添加 jmock 依赖 -->
      
<dependency>
    <groupId>jmock</groupId>
    <artifactId>jmock</artifactId>
    <version>1.0.1</version>
    <scope>test</scope>
</dependency>]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="BaseUserAction、FindUserAction、UpdateUserAction 和 UserAction" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[<!-- 
    1. BaseUserAction 是基类不需要测试
    2. FindUserAction 大部分的内容都是基于注释的配置，也不需要测试
    3. UpdateUserAction 需要测试
    4. UserAction 需要测试
-->

<!-- 按照下面的步骤来测试 action 类 -->      
<!-- 
    1. 创建 mock 对象并设置期望值
    2. 创建 action 实例
    3. 为 action 实例设置测试数据，包括依赖对象 (和 mock 对象)
    4. 执行被测试的方法
    5. 对结果是否正确进行断言，包括 mock 对象的方法是否像预期的那样被调用
-->]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="UpdateUserAction 测试用例之创建新用户" style="margin-top:1em;"
                              id="sourceContent1"><![CDATA[public void testPersistNewUser() throws Exception {
    // 通过接口创建一个 mock 对象
    Mock service = new Mock(UserService.class);
          
    // 期望 persist() 方法被调用一次
    service.excepts(once()).method("persiste").with(isA(User.class), eq(null));
          
    UpdateUserAction action = new UpdateUserAction();
    action.setUserService((UserService)service.proxy());
          
    // 因为有些测试依赖的功能需要 Struts2 在 action 外部执行，所以在调用 execute() 方法之前执行 prepare() 方法
    action.prepare();
    assertEquals(Action.SUCCESS, action.execute());
    service.verify();
}]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="UpdateUserAction 测试用例之更新已有用户"
                              id="sourceContent1"><![CDATA[public void testPersistExistingUser() throws Exception {
    User user = new User();
    
    Mock service = new Mock(UserService.class);
          
    service.excepts(once()).method("findByEmail")
                           .with(eq("keesh@struts.com"))
                           .with(returnValue(user));
                           
    service.excepts(once()).method("persist")
                           .with(same(user), eq("keesh@struts.com"));
          
    UpdateUserAction action = new UpdateUserAction();
    action.setUserService((UserService)service.proxy());
    action.setEmailId("keesh@struts.com");
          
    action.prepare();
    assertEquals(Action.SUCCESS, action.execute());
    service.verify();
}]]></c:sourceContent>

    <c:sourceContent expand="true" type="html" title="jUnit"
                              id="sourceContent1">
      <![CDATA[<div style="font-weight:bold;color:green;font-size:15px;">在 s2app 应用中使用 3.8 版本的 jUnit，它使用约定的命名规范来确定待测试类中哪些方法是测试用例 (以 test 开头的方法)，
      哪些方法需要在测试用例执行前调用 (setUp() 方法)，哪些方法需要在测试用例结束后调用 (tearDown()) <br />
      <br />
      所有测试用例都遵循一套共同的模式:<br />
      创建测试对象、调用测试对象的方法测试业务逻辑、断言结果是否与我们的预期结果一样<br />
      <br />
      在 4.0 的 jUnit 中，不再使用约定的命名规则，而是通过注释的方法标识测试方法。同时，注释提供一些高级功能，如忽略测试用例、在所有测试用例运行前将某个方法执行一次等等。。
      </div>]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的用户界面设计]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="/user/findUser-success.jsp"
                              id="sourceContent1"><![CDATA[<%@ taglib uri="/struts-tags" prefix="s" %>
      
<html>
    <head>
        <title>User Information</title>
    </head>
    <body>
        <s:form name="/user" action="updateUser" method="post">
            <s:textfield name="firstName" label="First Name" />
            <s:textfield name="lastName"  label="Last Name" />
            <s:textfield name="email"     label="Email" />
            <s:password  name="password"  label="Password" />
                  
            <s:hidden name="emailId" />
                  
            <s:if test="email == null">
                <s:submit value="Register" />
            </s:if>
            <s:else>
                <s:submit value="Update" />
            </s:else>
        </s:form>
    </body>
</html>]]>    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="/index.jsp"
                              id="sourceContent1"><![CDATA[<%@ taglib uri="/struts-tag" prefix="s" %>
                              
<html>
    <head>
        <title>Home</title>
    </head>
    <body>
        <s:if test="#session['user'] == null">
            <s:url id="register" action="findUser" namespace="/user" />
            <s:a href="%{register}">Register</a>
        </s:if>
        <s:else>
            <s:url id="update" action="findUser" namespace="/user" />
                <s:param name="emailId" value="#session['user'].email" />
            </s:url>
            <s:a href="%{update}">Update Profile</s:a>
        </s:else>
    </body>
</html>]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的国际化]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1">
      <![CDATA[。。。]]>
    </c:sourceContent>
    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的输入验证]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[为 action 类添加一个类级别的 @Validation 注释。]]></c:desc1>
      <c:desc1> <![CDATA[为待验证属性对应的设置方法添加具体的验证注释。]]></c:desc1>
      <c:desc1> <![CDATA[为 INPUT 返回值配置结果，验证框架在验证失败后返回该结果。]]></c:desc1>
      <c:desc1> <![CDATA[在 action 上使用 validation (执行验证工作) 拦截器和 workflow 拦截器 (返回 INPUT 结果)]]></c:desc1>
      <c:desc1> <![CDATA[validationWorkflowStack、paramsPrepareParamsStack 和 defaultStack 拦截器均包含 validation 拦截器和 workflow 拦截器]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="UserAction.java"
                              id="sourceContent1"><![CDATA[import com.opensymphony.xwork2.validator.annotations.Validations;
import com.opensymphony.xwork2.validator.annotations.VisitorFieldValidator;
import com.opensymphony.xwork2.validator.annotations.Validation;



                              
@Validations( visitorFields = {
            @VisitorFieldValidator(message = "Default message", key = "i18n.key", fieldName= "model", appendPrefix = false) }) 
public String execute() {
  ...
}   

@Validations( visitorFields = {
            @VisitorFieldValidator(message = "Default message", key = "i18n.key", fieldName= "model", appendPrefix = false) }) 
public String update() {
  ...
} 

public String find() {
  ...
}

// @Valications 可以对验证类型的多个实例分组
// @VisitorFieldValidator 是一个非常强大的验证器。它实现了访问者模式，允许每一个参数对象潜在提供它自己的验证信息。
// (该模式可以促使我们把注释放到领域对象上，然后再多个 action 中重用)

// 当验证框架发现 @VisitorFieldValidator 注释时，就会在对象类中搜索其它的验证信息。

// 默认情况下，执行 action 逻辑的所有方法都会执行 @Validations 注释 
// (findUser.action 和 updateUser.action 时都执行，应当仅在 updateUser.action 时才执行 @Validations 注释)
// 通过将拦截器中的 validateAnnotatedMethodOnly 属性设置为 true 可以达到此目的 
// (没有办法为包提供这种全局的配置，所以需要将这些附加的配置添加到每一个带有验证注释的 action 的配置中)
<action name="findUser" method="find" class="com.s2app.action.UserAction">
    <result name="input">/WEB-INF/jsp/user/findUser-success.jsp</result>
    <interceptor-ref name="paramsPrepareParamsStack">
        <param name="validation.validateAnnotatedMethodOnly">true</param>
    </interceptor-ref>
</action>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="添加了验证注释的 User.java"
                                  id="sourceContent1"><![CDATA[import com.opensymphony.xwork2.validator.annotations.EmailValidator;
import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;
import com.opensymphony.xwork2.validator.annotations.StringLengthFieldValidator;

                                  
@Entity @Table( name="APP_USER", schema="S2APP" )
public class User implements Serializable {

    private String firstName;
    private String lastName;
    private String email;
    private String password;
    private byte[] portrait;

   @Id @Column(name="EMAIL")
    public String getEmail() {
        return email;
    }
    
    @EmailValidator(message="Validation Error", key="validate.email")
    public void setEmail(String email) {
        this.email = email;
    }

    @Column(name="FIRST_NAME")
    public String getFirstName() {
        return firstName;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty", trim=true)
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }

    @Column(name="LAST_NAME")
    public String getLastName() {
        return lastName;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty", trim=true)
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }

    @Column(name="USER_PASSWORD")
    public String getPassword() {
        return password;
    }

    // shortCircuit 属性用来确定在某个验证失败后，后面的验证器是否继续执行。(所有验证器都具有 shortCircuit 属性)
    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty", trim=true, shortCircuit=true)
    @StringLengthFieldValidator(message="Length too short", key="validate.minLength.6", trim=true,minLength="6")
    public void setPassword(String password) {
        this.password = password;
    }

    @Lob @Column(name="PORTRAIT", nullable=true)
    public byte[] getPortrait() {
        return portrait;
    }

    public void setPortrait(byte[] portrait) {
        this.portrait = portrait;
    }
}]]>    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="User.properties"
                              id="sourceContent1"><![CDATA[# Validation Messages
validate.email=Please enter a valid email address
validate.notEmpty=Please enter a value
validate.minLength.6=Please enter more then 6 characters]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的异常处理]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[在 Struts2 中使用 exception 拦截器处理异常，该拦截器被置于所有内置的拦截器栈中。]]></c:desc1>
      <c:desc1> <![CDATA[可以在 struts.xml 配置文件中通过 global-results 和 global-exception-mappings 标签进行全局定义]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1"><![CDATA[<package name="base-package" extends="struts-default">
    <global-results>
        <result name="unknowError">/jsp/error.jsp</result>
        <result name="dbError">/jsp/error2.jsp</result>
        
        <result name="logon">/jsp/logon.jsp</result>
        <result name="noAccess">/jsp/noAccess.jsp</result>
    </global-results>
    <global-exception-mappings>
        <exception-mapping exception="java.lang.Exception" result="unknowError" />
        <exception-mapping exception="java.lang.SQLException" result="dbError" />
        
        <exception-mapping exception="UserNotAuthenticatedException" result="logon" />
        <exception-mapping exception="ActionNotAllowedException" result="noAccess" /> <!-- 该 exception-mapping 标签也可以在 action 中重用 -->
    </global-exception-mappings>
</package>]]></c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[通过与用户交互恢复异常]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[在已经编写的代码中并没有处理重复输入主键值得问题。]]></c:desc1>
      <c:desc1> <![CDATA[当用户输入了重复的 email 地址时，系统就会抛出异常。这个异常可以通过与用户交互的方式来解决 (如询问用户是否修改 E-mail 地址)。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1"><![CDATA[// 主键重复异常的嵌套层次如下：
javax.persistence.RollbackException
    caused by a org.hibernate.exception.ConstraintViolationException
        caused by a org.hibarnate.exception.java.sql.BatchUpdateException
        
// 为了避免处理一般的 RollbackException 异常，UserServiceImpl 的 persiste() 方法需要加入异常处理
try {
    // start transaction, persist object, commit transaction
} catch (RollbackException e) {
    // rollback transaction
    throw (RuntimeException) e.getCause();
    
    // 这样就可以抛出 ConstraintViolationException，并可以在 struts2 中进行配置，从而将异常分割为更精确的部分，并对其进行控制。
}]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[显示错误消息]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[当 exception 拦截器拦截了异常以后，将在 ValueStack 中增加两个新的属性用于显示错误信息，该信息可以反馈给用户。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="html" title=""
                              id="sourceContent1">
      <![CDATA[1、exception：<s:property value="exception" /> <br />
      2、exceptionStack：异常栈的跟踪信息。<s:property value="exceptionStack" />]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[异常日志]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[exception 拦截器可以避免向用户展示丑陋的错误页面，但也导致这些异常不能被记录到日志中。]]></c:desc1>
      <c:desc1> <![CDATA[可以为 exception 拦截器配置一些额外的参数，开启记录日志。]]></c:desc1>
      <c:desc1> <![CDATA[通常我们会创建一个新的拦截器栈，并将 exception 拦截器作为第一个拦截器。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1"><![CDATA[<interceptor-stack name="loggingParamsPrepareParamsStack">
    <interceptor-ref name="exception-logging">
        <param name="logEnabled">true</param>
        <param name="logLevel">ERROR</param>
        <param name="logCategory">com.s2app.web</param>
    </interceptor-ref>
    <interceptor-ref name="paramsPrepareParamsStack" />
</interceptor-stack>]]></c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的向导和工作流]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[使用一连串小的表单来收集所有数据，严格控制用户的操作过程以及表单顺序，以保证所有数据都被收集。]]></c:desc1>
      <c:desc1> <![CDATA[向导和工作流通过一连串页面来获取用户输入，应用程序能智能地决定下一步的询问内容。这种方式可以避免将不必要的信息显示给用户。]]></c:desc1>
      <c:desc1> <![CDATA[Struts2 提供了一个新的拦截器，该拦截器提供了诸如工作流、复杂验证、自定义验证、用来呈现模板的自定义标签以及 flash 作用域。]]></c:desc1>
      <c:desc1> <![CDATA[在 struts2 中创建工作流最简单的方式是使用 scope 拦截器，它在工作流生命周期中将数据半持久化，在工作流结束时在将这些数据删除。]]></c:desc1>
      <c:desc1> <![CDATA[scope 拦截器： scope 拦截器从会话 (session) 或应用 (application) 作用域对象中存取 action 属性。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="html" title="创建活动的过程中，需要完成如下一系列的任务： (可以把这一系列的任务视为一个工作流)"
                              id="sourceContent1">
      <![CDATA[1、输入活动的基本信息<br />
      2、从下拉框所列的场所中选择活动举办地<br />
      3、如果在下拉框中没有该场所，用户能够创建一个新的场所<br />
      4、为活动添加选手<br />
      5、每个活动将不止一个选手，用户能够根据需要添加选手<br />
      6、如果输入错误，能够删除选手并重新输入]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="html" title="将需求转换为流程图："
                                  id="sourceContent1">
      <![CDATA[<img src="//c2.staticflickr.com/4/3761/13773605963_15f977484d_b.jpg" alt="" /><br />
      <span style="color:green;font-weight:bold;">每个框表示一个屏幕或页面，并且应用中存在两种场所类型，即 Broadcast 和 Address，用户需要选择一种场所类型，
      只有这样下一个页面才能正确地显示需要添加的表单字段。</span><br />
      
      <b>创建活动用例的领域对象及其依赖项如下：</b><br />
      1、基本的活动信息被输入到 Event 领域对象中，在这个阶段还没有足够的信息来持久化该对象并在数据库中保存一个有效的活动。<br />
      2、选择 Location 对象或创建一个新的 Location 对象。场所对活动没有依赖，但活动却需要被赋予一个场所，所以在活动存储到数据库以前其对应的场所信息必须被持久保存到数据库。<br />
      3、为每个选手创建一个 Contestant 对象，选手依赖于活动，活动也依赖于选手，所以这些对象需要一起被持久保存。<br />
      4、解决方案是，将 Event 对象及其关联的 Location 对象和所有依赖的 Contestant 对象保存到会话中知道用户最后确认。<br />
      5、如果会话中保存的信息过多将影响系统性能与扩展性，尤其在引入高可用性集群后更是如此。<br />
      6、理解开发中应用的非功能性需求，尤其是用户负载方面的需求，将有助于你做出决定是采用此方案还是其他方案。<br />
      7、其它方案包含个性化实现。]]>
    </c:sourceContent>
    
    
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[enterEvent 包]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[由于 paramsPrepareParams 不包含 scope 拦截器，所以创建一个新的拦截器栈： eventStack]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="eventStack"
                              id="sourceContent1"><![CDATA[<package name="enterEvent" extends="struts-default" namespace="/event">
    <result-types>
      <result-type name="flashResult" 
                   class="com.opensymphony.webwork.dispatcher.FlashResult" />
    </result-types>
    <interceptors>    
        <interceptor name="flash" 
                     class="com.opensymphony.webwork.interceptor.FlashInterceptor" />
        
        <interceptor-stack name="eventStack">
            <interceptor-ref name="scope">
              <!-- scope 拦截器的两个参数： session (或 application) 和 key -->
              <!-- 配置的顺序很重要，因为在业务逻辑执行之前，保存在会话作用域或应用作用域中的对象需要被检索并设置到 action 上 -->
              <param name="session">model</param>     <!-- 一串用逗号分隔的属性值组成，这些值将被保存至 session 作用域，
                                                           也可以使用 application 参数! -->
              <param name="key">partialEvent</param>  <!-- key 参数指定了属性值的名称，如果整个工作流中只有一个 action， 那么 key 参数可以省去。
                                                           因为他的作用就是在 action 之间传递哪些保存在会话中的数据。 -->
            </interceptor-ref>
            <interceptor-ref name="paramsPrepareParamsStack" />
        </interceptor-stack>
    </interceptors>
          
    <default-interceptor-ref name="eventStack" />
</package>]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="工作流中的两个 action" style="border-bottom:none;"
                                  id="sourceContent1">
      <![CDATA[1、在定义好拦截器栈之后，还需要对两个 action 进行特殊配置：一个 action 用于初始化工作流，另一个用于完成工作流。<br />
      2、在这两个 action 中对拦截器的 type 属性进行重载，type 属性可以为 start 或 end。<br />
      3、当 type 的属性值为 start 的时候，scope 拦截器将重置会话里的属性。当为 end 时，将从会话作用域中清除属性值以节省服务器内存。<br />
      4、这个两个 action 均是过道式的 action，只是提供了工作流的入口和出口。<br />
      5、如果 scope 拦截器被应用于某个包的所有 action 上，那么包中的 action 的所有属性都必须具有获取和设置方法。否则须将该 action 移到工作流包外面。]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="" style="border-top:none;"
                                  id="sourceContent1">
      <![CDATA[<package name="enterEvent" extends="struts-default" namespace="/event">
    。。。
    <action name="addEventFlow" class="com.myproject.web.actions.event.BaseEventAction">
      <interceptor-ref name="eventStack">
        <param name="scope.type">start</param>
      </interceptor-ref>
      <result>/jsp/event/enterEventDetails-input.jsp</result>
    </action>

    <action name="enterEventDetails"
            class="com.myproject.web.actions.event.EnterEventDetailsAction">
      <result name="success" type="redirectAction">
        <param name="actionName">selectLocation</param>
        <param name="method">input</param>
      </result>
      <result name="input">/jsp/event/enterEventDetails-input.jsp</result>
    </action>

    <action name="selectLocation"
            class="com.myproject.web.actions.event.SelectLocationAction">
      <result name="success" type="redirectAction">selectContestants</result>
      <result name="input">/jsp/event/selectLocation-input.jsp</result>
    </action>

    <action name="selectLocationType"
            class="com.myproject.web.actions.event.SelectLocationTypeAction">
      <result name="success" type="redirectAction">enterLocationDetails</result>
      <result name="input">/jsp/event/selectLocationType-input.jsp</result>
    </action>

    <action name="enterLocationDetails"
            class="com.myproject.web.actions.event.EnterLocationDetailsAction">
      <result name="success" type="redirectAction">
        <param name="actionName">selectLocation</param>
        <param name="method">input</param>
      </result>
      <result name="selectType" type="flashResult">/event/flashedSelectEventType.action</result>
      <result name="broadcast">/jsp/event/enterLocationDetails-broadcast.jsp</result>
      <result name="address">/jsp/event/enterLocationDetails-address.jsp</result>
    </action>

    <action name="selectContestants"
            class="com.myproject.web.actions.event.SelectContestantsAction">
      <result name="input">/jsp/event/selectContestants-input.jsp</result>
    </action>

    <action name="removeContestants"
            class="com.myproject.web.actions.event.RemoveContestantsAction">
      <result name="success" type="redirectAction">selectContestants</result>
      <result name="input">/jsp/event/selectContestants-input.jsp</result>
    </action>

    <action name="enterContestantDetails"
            class="com.myproject.web.actions.event.EnterContestantDetailsAction">
      <result name="success" type="redirectAction">selectContestants</result>
      <result name="input">/jsp/event/enterContestantDetails-input.jsp</result>
    </action>

    <action name="saveEvent"
            class="com.myproject.web.actions.event.SaveEventAction">
      <result name="success" type="redirectAction">completeEvent</result>
      <result name="input">/jsp/event/selectContestants-input.jsp</result>
      <result name="error">/jsp/event/eventTest.jsp</result>
    </action>

    <action name="completeEvent"
            class="com.myproject.web.actions.event.BaseEventAction">
      <interceptor-ref name="eventStack">
        <param name="scope.type">end</param>
      </interceptor-ref>
      <result>/jsp/event/eventReview.jsp</result>
    </action>

    <action name="flashedSelectEventType"
            class="com.myproject.web.actions.event.SelectLocationTypeAction">
      <interceptor-ref name="flash">
        <param name="operation">Retrieve</param>
      </interceptor-ref>
      <interceptor-ref name="eventStack" />
      <result>/jsp/event/selectLocationType-input.jsp</result>
    </action>
</package>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="BaseEventAction"
                                  id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import com.s2app.domain.Event;
import com.opensymphony.xwork2.ActionSupport;
import com.opensymphony.xwork2.ModelDriven;

public class BaseEventAction extends ActionSupport implements ModelDriven<Event> {

    protected Event event = null;

    public Event getModel() {
        return event;
    }

    public void setModel(Event model) {
        this.event = model;
    }

}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/enterEventDetails-input.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.enterEvent.title" /></title>
</head>
<body>

<s:form action="enterEventDetails" namespace="/event" method="post" >

    <s:textfield key="event.name" name="name" />
    <s:textfield key="event.startDate" name="partialStartDate" />
    <s:textfield key="event.startTime" name="patialStartTime" />
    <s:textfield key="event.timeZoneOffset" name="timeZoneOffset" />
    <s:textfield key="event.votingStartTime" name="partialVotingStartTime" />
    <s:textfield key="event.duration" name="duration" />

    <s:submit key="button.create" />

</s:form>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/selectLocation-input.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.selectLocation.title" /></title>
</head>
<body>

<s:form action="selectLocation" namespace="/event" method="post" >

    <s:select size="10" name="selectedLocation"
            list="locations" listKey="id" listValue="name" />
    <s:submit key="button.select" />

</s:form>

<s:url id="addLocation" action="selectLocationType" namespace="/event" method="input" />
<s:a href="%{addLocation}"><s:text name="link.addLocation" /></s:a>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/enterLocationDetails-broadcast.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.enterLocationDetails.broadcast.title" /></title>
</head>
<body>

<s:form action="enterLocationDetails" namespace="/event" method="post" >

    <s:textfield key="broadcast.name" name="broadcast.name" />
    <s:textfield key="broadcast.city" name="broadcast.city" />
    <s:textfield key="broadcast.state" name="broadcast.state" />
    <s:textfield key="broadcast.network" name="broadcast.network" />
    <s:textfield key="broadcast.stationIdentifier" name="broadcast.stationIdentifier" />

    <s:hidden name="typeClass"/>
    <s:hidden name="setup" value="false" />
    
    <s:submit key="button.create" />

</s:form>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/enterLocationDetails-address.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.enterLocationDetails.address.title" /></title>
</head>
<body>

<s:form action="enterLocationDetails" namespace="/event" method="post" >

    <s:textfield key="address.name" name="address.name" value="%{address.name}"/>
    <s:textfield key="address.address" name="address.address" />
    <s:textfield key="address.city" name="address.city" />
    <s:textfield key="address.state" name="address.state" />
    <s:textfield key="address.zipcode" name="address.zipcode" />

    <s:hidden name="typeClass"/>
    <s:hidden name="setup" value="false" />

    <s:submit key="button.create" />

</s:form>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/selectLocationType-input.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.selectLocationType.title" /></title>
</head>
<body>

<s:form action="enterLocationDetails" namespace="/event" method="post" >
                
    <s:radio theme="apress" list="types" name="typeClass"
            listKey="class.name" listValue="getText(class.name)" />
    <s:hidden name="setup" value="true" />

    <s:submit key="button.select" />

</s:form>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/selectContestants-input.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.selectContestants.title" /></title>
</head>
<body>

<s:actionerror />

<s:form action="removeContestants" namespace="/event" method="post" >

    <s:checkboxlist name="selectedContestants" theme="apress"
            list="options" listKey="name" listValue="name+' - '+description" />
    <s:submit key="button.remove" />

</s:form>

<s:url id="saveEvent" action="saveEvent" namespace="/event" />
<s:a href="%{saveEvent}"><s:text name="link.completeEvent" /></s:a>
|
<s:url id="enterContentant" action="enterContestantDetails" method="input" namespace="/event" />
<s:a href="%{enterContentant}"><s:text name="link.addContestant" /></s:a>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="/jsp/event/enterContestantDetails-input.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.enterContestantDetails.title" /></title>
</head>
<body>

<s:form action="enterContestantDetails" namespace="/event" method="post" >

    <s:textfield key="contestant.name" name="contestant.name" />
    <s:textfield key="contestant.description" name="contestant.description" />

    <s:submit key="button.create" />

</s:form>

</body>
</html>]]></c:sourceContent>
    
    <c:sourceContent expand="false" type="" title="/jsp/event/eventReview.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="createEvent.eventReview.title" /></title>
</head>
<body>

YOU ARE DONE!

</body>
</html>]]></c:sourceContent>
    
    <c:sourceContent expand="true" type="html" title="工作流元素" 
                                  id="sourceContent1">
      <![CDATA[<div style="float:left;width:65%;"><img src="//c2.staticflickr.com/4/3756/13839075014_6d7c6731f0_b.jpg" alt="" style="width:100%;" /></div>
      <div style="float:left;width:33%;margin-left:1%;font-weight:bold;">
        1、灰色的方块表示的 action 在 struts.xml 文件中的配置，其它 action 通过注释配置。<br />
        2、jsp 页面和结果类型 (标注于箭头线中)。<br />
        3、因为 scope 拦截器保存了 "model" 属性，所以还需要一个 "model" 对象的设置方法，该方法被放在了 BaseEventAction 类中。<br />
        4、工作流的每一步都由一个单独的 action 实现，也可以仅使用一个大的 action 来实现整个工作流。从配置的角度看，唯一的变化是省去了 scope 拦截器中的 key 参数。<br />
        5、如果工作流中的每一步都使用同一个 action，那么将使用前文已经讨论过的默认名称机制 (由保存的属性名称和 action 名称合并而成)。<br />
        <span style="font-weight:bold;color:red;">6、开发一个新的 action 的原则是，该 action 是否可以被重用，如果不能够重用就将所有功能整合到同一个 action 中。<br /></span>
        <span style="font-weight:bold;color:red;">7、在开发 action 的时候尽量遵循单任务原则，这样使得 action 小巧而目标明确。</span>
      </div><div class="clear"></div>]]>
    </c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.EnterEventDetailsAction.java"
                                  id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.annotations.RequiredFieldValidator;
import com.opensymphony.xwork2.validator.annotations.CustomValidator;
import com.opensymphony.xwork2.validator.annotations.Validation;
import com.opensymphony.xwork2.validator.annotations.VisitorFieldValidator;
import com.fdar.apress.s2.domain.Event;
import com.fdar.apress.s2.domain.Progress;
import com.fdar.apress.s2.util.TimeUtil;

import java.util.Calendar;
import java.util.Date;
import java.text.DateFormat;

import org.apache.struts2.config.ParentPackage;
import org.apache.struts2.config.Result;
import org.apache.struts2.dispatcher.ServletActionRedirectResult;


@ParentPackage("enterEvent")
@Result(type= ServletActionRedirectResult.class,value="selectLocation",params={"method","input"})
@Validation
public class EnterEventDetailsAction extends BaseEventAction implements Preparable {

    private Date partialStartDate;
    private String patialStartTime;
    private String partialVotingStartTime;

    public void prepare() throws Exception {
        event = new Event();
        event.setStatus(Progress.NOT_STARTED);
        event.setLastUpdateTime( Calendar.getInstance().getTime() );
    }

    public Date getPartialStartDate() {
        return partialStartDate;
    }

    @RequiredFieldValidator(message="Validation Error", key="validate.notEmpty")
    public void setPartialStartDate(Date partialStartDate) {
        this.partialStartDate = partialStartDate;
    }

    public String getPatialStartTime() {
        return patialStartTime;
    }

    @CustomValidator(type ="timeValidator", key="validate.timeOfDay")
    public void setPatialStartTime(String patialStartTime) {
        this.patialStartTime = patialStartTime;
    }

    public String getPartialVotingStartTime() {
        return partialVotingStartTime;
    }

    @CustomValidator(type ="timeValidator", key="validate.timeOfDay")
    public void setPartialVotingStartTime(String partialVotingStartTime) {
        this.partialVotingStartTime = partialVotingStartTime;
    }

    @VisitorFieldValidator(message="Default message", fieldName="model", shortCircuit=false, appendPrefix=false)
    public String execute() throws Exception {

        Calendar cal = Calendar.getInstance();

        cal.setTime(partialStartDate);
        TimeUtil timeUtil = new TimeUtil(patialStartTime);
        event.setStartTime( timeUtil.resolveDate( partialStartDate, event.getTimeZoneOffset() ) );

        cal = Calendar.getInstance();
        cal.setTime(partialStartDate);
        timeUtil = new TimeUtil(partialVotingStartTime);
        event.setVotingStartTime( timeUtil.resolveDate( partialStartDate, event.getTimeZoneOffset() ) );

        return SUCCESS;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.SelectLocationAction.java"
                                  id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import org.apache.struts2.dispatcher.ServletActionRedirectResult;
import org.apache.struts2.config.ParentPackage;
import org.apache.struts2.config.Result;
import com.fdar.apress.s2.services.LocationService;
import com.fdar.apress.s2.domain.Location;
import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.annotations.RequiredFieldValidator;
import com.opensymphony.xwork2.validator.annotations.Validation;

import java.util.List;


@ParentPackage("enterEvent")
@Result(type= ServletActionRedirectResult.class,value="selectContestants")
@Validation
public class SelectLocationAction extends BaseEventAction implements Preparable {

    private List<Location> locations;
    private Long selectedLocation = null;

    private LocationService service;


    public void setLocationService(LocationService service) {
        this.service = service;
    }

    public void prepare() throws Exception {
        locations = service.findAll();
    }


    public List<Location> getLocations() {
        return locations;
    }

    public Long getSelectedLocation() {
        return selectedLocation;
    }

    @RequiredFieldValidator(message = "Default message", key = "validation.selectLocation")
    public void setSelectedLocation(Long selectedLocation) {
        this.selectedLocation = selectedLocation;
    }

    public String input() {
        return INPUT;
    }

    public String execute() throws Exception {
        event.setLocation(service.findById(selectedLocation));
        return SUCCESS;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.SelectLocationTypeAction.java"
                                  id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import com.opensymphony.xwork2.Preparable;
import com.fdar.apress.s2.domain.Broadcast;
import com.fdar.apress.s2.domain.Location;
import com.fdar.apress.s2.domain.Address;
import org.apache.struts2.config.Result;
import org.apache.struts2.config.ParentPackage;
import org.apache.struts2.dispatcher.ServletActionRedirectResult;

import java.util.List;
import java.util.ArrayList;


@ParentPackage("enterEvent")
@Result(type= ServletActionRedirectResult.class,value="enterLocationDetails")
public class SelectLocationTypeAction extends BaseEventAction implements Preparable {

    private Integer typeId;
    private List<Location> types;

    public Integer getTypeId() {
        return typeId;
    }

    public void setTypeId(Integer typeId) {
        this.typeId = typeId;
    }

    public List<Location> getTypes() {
        return types;
    }

    public void prepare() throws Exception {
        types = new ArrayList<Location>();
        types.add(new Address());
        types.add(new Broadcast());
    }

    public String input() throws Exception {
        return INPUT;
    }

}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.EnterLocationDetailsAction.java"
                id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import org.apache.struts2.config.Results;
import org.apache.struts2.config.ParentPackage;
import org.apache.struts2.config.Result;
import org.apache.struts2.dispatcher.ServletActionRedirectResult;

import java.util.List;
import java.util.ArrayList;

import com.opensymphony.webwork.dispatcher.FlashResult;
import com.opensymphony.xwork2.Preparable;
import com.opensymphony.xwork2.validator.validators.VisitorFieldValidator;
import com.opensymphony.xwork2.validator.DelegatingValidatorContext;
import com.fdar.apress.s2.services.LocationService;
import com.fdar.apress.s2.domain.Broadcast;
import com.fdar.apress.s2.domain.Address;
import com.fdar.apress.s2.domain.Location;

@ParentPackage("enterEvent")
@Results( value={
    @Result(type= ServletActionRedirectResult.class,value="selectLocation",params={"method","input"}),
    @Result(type= FlashResult.class,name="selectType",value="/event/flashedSelectEventType.action")
})
public class EnterLocationDetailsAction extends BaseEventAction implements Preparable {

    private Boolean setup;
    private String typeClass;
    private Object location;

    private LocationService service;

    public void prepare() throws Exception {
        if( typeClass!=null ) {
            Class clazz = Class.forName(typeClass);
            location = clazz.newInstance();
        }
    }

    public void setLocationService(LocationService service) {
        this.service = service;
    }

    public void setSetup(Boolean setup) {
        this.setup = setup;
    }

    public String getTypeClass() {
        return typeClass;
    }

    public void setTypeClass(String typeClass) {
        this.typeClass = typeClass;
    }

    public Broadcast getBroadcast() {
        return (Broadcast)location;
    }

    public void setBroadcast( Broadcast location ) {
        this.location = location;
    }

    public Address getAddress() {
        return (Address)location;
    }

    public void setAddress( Address location ) {
        this.location = location;
    }

    public String execute() throws Exception {

        if( typeClass==null ) {
            addFieldError("typeClass",getText("validate.selectType",new String[]{}));
            return "selectType";

        } else {

            String objType = typeClass.substring(typeClass.lastIndexOf(".")+1).toLowerCase();

            if( setup ) {
                return objType;
                
            } else {

                VisitorFieldValidator validator = new VisitorFieldValidator();
                validator.setAppendPrefix(true);
                validator.setValidatorContext(new DelegatingValidatorContext(this));
                validator.setFieldName(objType);
                validator.validate(this);

                if( hasFieldErrors() ) {
                    return objType;
                }
            }

            service.create((Location)location);
            return SUCCESS;
        }
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.SelectContestantsAction.java"
                id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import org.apache.struts2.config.ParentPackage;

import java.util.List;
import java.util.ArrayList;

@ParentPackage("enterEvent")
public class SelectContestantsAction extends BaseEventAction {

    public String execute() throws Exception {
        return INPUT;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.RemoveContestantsAction.java"
                id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import com.fdar.apress.s2.domain.Contestant;
import com.opensymphony.xwork2.validator.annotations.Validation;
import com.opensymphony.xwork2.validator.annotations.ExpressionValidator;
import com.opensymphony.xwork2.validator.annotations.Validations;

import java.util.ArrayList;
import java.util.List;

import org.apache.struts2.dispatcher.ServletActionRedirectResult;
import org.apache.struts2.config.Result;
import org.apache.struts2.config.ParentPackage;
import org.apache.struts2.config.Results;


@ParentPackage("enterEvent")
@Results( value={
    @Result(type= ServletActionRedirectResult.class,value="selectContestants"),
    @Result(name="input",value="/WEB-INF/jsp/event/selectContestants-input.jsp")
})
@Validation
public class RemoveContestantsAction extends BaseEventAction {

    private List<String> selectedContestants;

    public List<String> getSelectedContestants() {
        return selectedContestants;
    }

    public void setSelectedContestants(List<String> selectedContestants) {
        this.selectedContestants = selectedContestants;
    }

    @Validations( expressions = {
        @ExpressionValidator(message="Default message", key="validate.mustSelectOne",
            expression="selectedContestants!=null && selectedContestants.size>0" )
    })
    public String execute() throws Exception {
        List<Contestant> result = new ArrayList<Contestant>();
        for( Contestant c: event.getOptions() ) {
            if( !selectedContestants.contains(c.getName()) ) {
                result.add(c);
            }
        }
        event.setOptions(result);
        return SUCCESS;
    }
}]]>
    </c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.EnterContestantDetailsAction.java"
                id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import com.fdar.apress.s2.domain.Contestant;
import com.opensymphony.xwork2.validator.annotations.VisitorFieldValidator;
import com.opensymphony.xwork2.validator.annotations.Validation;
import org.apache.struts2.dispatcher.ServletActionRedirectResult;
import org.apache.struts2.config.Result;
import org.apache.struts2.config.ParentPackage;


@ParentPackage("enterEvent")
@Result(type= ServletActionRedirectResult.class,value="selectContestants")
@Validation
public class EnterContestantDetailsAction extends BaseEventAction {

    private Contestant contestant = new Contestant();

    @VisitorFieldValidator(message="", fieldName="contestant", appendPrefix=true)
    public Contestant getContestant() {
        return contestant;
    }

    public void setContestant(Contestant contestant) {
        this.contestant = contestant;
    }

    public String input() {
        return INPUT;
    }

    public String execute() throws Exception {
        event.addOption(contestant);
        return SUCCESS;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.actions.event.SaveEventAction.java"
                id="sourceContent1"><![CDATA[package com.s2app.actions.event;

import com.opensymphony.xwork2.validator.annotations.Validation;
import com.opensymphony.xwork2.validator.annotations.ExpressionValidator;
import com.opensymphony.xwork2.validator.annotations.Validations;
import com.fdar.apress.s2.services.EventService;
import org.apache.struts2.config.ParentPackage;
import org.apache.struts2.config.Result;
import org.apache.struts2.config.Results;
import org.apache.struts2.dispatcher.ServletActionRedirectResult;


@ParentPackage("enterEvent")
@Results( value={
    @Result(name="input",value="/WEB-INF/jsp/event/selectContestants-input.jsp"),
    @Result(type= ServletActionRedirectResult.class,value="completeEvent")
})
@Validation
public class SaveEventAction extends BaseEventAction {

    private EventService service;

    public void setEventService(EventService service) {
        this.service = service;
    }

    @Validations( expressions={
        @ExpressionValidator(message="Default message", key="validate.moreThanTwoOptions",
            expression="options!=null && options.size>1" )
    })
    public String execute() throws Exception {
        service.create(event);
        return SUCCESS;
    }
}]]></c:sourceContent>

    <c:sourceContent expand="false" type="" title="com.s2app.services.EventService.java"
                id="sourceContent1"><![CDATA[package com.s2app.services;

import com.s2app.domain.Event;

public interface EventService {

    public void create(Event event);
}]]></c:sourceContent>

    <c:sourceContent expand="false" type="" title="com.s2app.services.LocationService.java"
                id="sourceContent1"><![CDATA[package com.s2app.services;

import com.s2app.domain.Location;

import java.util.List;

public interface LocationService {

    public void create(Location loc);

    public List<Location> findAll();

    public Location findById( Long id );
}]]></c:sourceContent>

    <c:sourceContent expand="false" type="" title="com.s2app.impl.EventServiceImpl.java"
                id="sourceContent1"><![CDATA[package com.s2app.impl;

import com.s2app.domain.Event;

import javax.persistence.*;

public class EventServiceImpl implements EventService {

    private EntityManagerFactory emf;

    public EventServiceImpl() {
        emf = Persistence.createEntityManagerFactory("s2app");
    }

    public void create(Event event) {
        EntityManager entityMgr = emf.createEntityManager();
        EntityTransaction tx = null;
        try {
            tx = entityMgr.getTransaction();
            tx.begin();

            entityMgr.persist(event);

            tx.commit();
        }
        catch (RollbackException e) {
            if ( tx != null && tx.isActive() )
                tx.rollback();
            throw (RuntimeException)e.getCause();
        }
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.impl.LocationServiceImpl.java"
                id="sourceContent1"><![CDATA[package com.s2app.impl;

import com.s2app.domain.Location;

import javax.persistence.*;
import java.util.List;
import java.util.ArrayList;

public class LocationServiceImpl implements LocationService {

    private EntityManagerFactory emf;

    public LocationServiceImpl() {
        emf = Persistence.createEntityManagerFactory("s2app");
    }
    public void create(Location loc) {
        EntityManager entityMgr = emf.createEntityManager();
        EntityTransaction tx = null;
        try {
            tx = entityMgr.getTransaction();
            tx.begin();

            entityMgr.persist(loc);

            tx.commit();
        }
        catch (RollbackException e) {
            if ( tx != null && tx.isActive() )
                tx.rollback();
            throw (RuntimeException)e.getCause();
        }
    }

    public List<Location> findAll() {
        EntityManager entityMgr = emf.createEntityManager();
        // TODO: needs a polymorphic query across Address and Broadcast
        List<Location> results = new ArrayList<Location>();
        results.addAll(entityMgr.createQuery("from Address").getResultList());
        results.addAll(entityMgr.createQuery("from Broadcast").getResultList());
        return results;
    }


    public Location findById(Long id) {
        EntityManager entityMgr = emf.createEntityManager();
        return entityMgr.find(Location.class,id);
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.util.TimeUtil.java"
                id="sourceContent1"><![CDATA[package com.s2app.util;

import java.text.DateFormat;
import java.text.ParseException;
import java.util.Calendar;
import java.util.Date;
import java.util.Locale;
import java.util.TimeZone;

public class TimeUtil {

    private boolean valid = false;

    private int hour = 0;
    private int minute = 0;
    private int amOrPm = 0;

    private static final int INVALID = -1;

    /**
     * Constructor.  Creates a valid TimeUtil object.
     *
     * @param time the time as a string.
     */
    public TimeUtil( String time ) {
        parseTime(time);
    }

    /**
     * Non-argument constructor to help unit testing.
     */
    protected TimeUtil() {
    }

    protected void parseTime( String time, Locale locale ) {
        if (time != null) {
            final String lowerCaseTime = time.toLowerCase();
            int ampmIndex = lowerCaseTime.indexOf("am");
            if (ampmIndex == INVALID) {
                ampmIndex = lowerCaseTime.indexOf("pm");
            }
            int timeEnd = lowerCaseTime.indexOf(' ');
            if (timeEnd == INVALID) {
                timeEnd = ampmIndex!=INVALID ? ampmIndex : time.length();
            }
            StringBuffer timeBuffer = new StringBuffer(time.substring(0, timeEnd));
            if ( lowerCaseTime.indexOf(':')==INVALID ) {
                timeBuffer.append(":00");
            }
            if ( ampmIndex != INVALID) {
                timeBuffer.append(' ');
                timeBuffer.append(time.substring(ampmIndex));
            }
            try {
                DateFormat df = DateFormat.getTimeInstance(DateFormat.SHORT, locale);
                df.setLenient(false);
                Date parsed = df.parse(timeBuffer.toString());
                Calendar cal = Calendar.getInstance();
                cal.setTime(parsed);
                this.amOrPm = cal.get(Calendar.AM_PM);
                this.hour = cal.get(Calendar.HOUR_OF_DAY);
                this.minute = cal.get(Calendar.MINUTE);
                this.valid = true;
            } catch ( ParseException e ) {
                this.valid = false;
            }
        }
    }

    protected void parseTime( String time ) {
        parseTime( time, Locale.getDefault());
    }

    /**
     * Validates that the time is valid.
     * <ul>
     *  <li>required: A digit 0..12 / 0..24 depending on Locale</li>
     *  <li>optional: a colon and digit 00..59</li>
     *  <li>optional: space</li>
     *  <li>depending on Locale: case insensitive, either "am" or "pm" for 12 hour formats, empty for 24 hour formats</li>
     * </ul>
     *
     * Example:
     * <ul>
     *  <li>12:30 am</li>
     *  <li>12:30pm</li>
     *  <li>9</li>
     *  <li>21:00</li>
     * </ul>
     *
     * @return true if valid, otherwise false.
     */
    public boolean isValid() {
        return valid;
    }

    /**
     * Returns the hour of day in 24 hour scale.
     *
     * @return the hour
     */
    public int getHour() {
        return hour;
    }

    /**
     * Returns the hour in 12 hour scale.
     *
     * @return the hour
     */
    public int getHourAmPm() {
        return hour % 12;
    }

    /**
     * Returns the minute.
     *
     * @return the minute
     */
    public int getMinute() {
        return minute;
    }

    /**
     * Returns whether this is an Calendar.AM or Calendar.PM time.
     *
     * @return either Calendar.AM or Calendar.PM
     */
    public int getAmOrPm() {
        return amOrPm;
    }

    protected Date resolveDate( Date baseDate, int offset, int hour, int minute ) throws ParseException {
        if (baseDate != null) {
            Calendar cal = Calendar.getInstance(TimeZone.getTimeZone("GMT+0"));
            cal.setTime(baseDate);
            StringBuffer sb = new StringBuffer("GMT");
            if ( offset>=0 ) {
                sb.append("+");
            }
            sb.append(offset);
            cal.setTimeZone(TimeZone.getTimeZone(sb.toString()));
            cal.set(Calendar.HOUR_OF_DAY, hour);
            cal.set(Calendar.MINUTE, minute);
            return cal.getTime();
        } else {
            return null;
        }
    }

    public Date resolveDate( Date baseDate, int offset ) throws ParseException {
        return resolveDate( baseDate, offset, this.hour, this.minute);
    }

}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.util.TimeValidator.java"
                id="sourceContent1"><![CDATA[package com.s2app.util;

import com.opensymphony.xwork2.validator.validators.FieldValidatorSupport;
import com.opensymphony.xwork2.validator.ValidationException;

import java.util.Calendar;

/**
 * Validates a time to be of the following format -
 * <ul>
 *  <li>required: A digit 0..12</li>
 *  <li>optional: a colon and digit 00..59</li>
 *  <li>optional: space</li>
 *  <li>required: case insensitive, either "am" or "pm"</li>
 * </ul>
 *
 * Example:
 * <ul>
 *  <li>12 am</li>
 *  <li>12:30am</li>
 * </ul>
 */
public class TimeValidator extends FieldValidatorSupport {

    /**
     * @see Validator#validate(java.lang.Object)
     */
    public void validate( Object obj ) throws ValidationException {

        String fieldName = getFieldName();
        Object value = this.getFieldValue(fieldName, obj);

        if( value == null || !(value instanceof String) || !( new TimeUtil( (String)value ).isValid() ) ) {
            addFieldError( fieldName, obj );
        }

    }


 
}]]></c:sourceContent>

    <c:sourceContent expand="false" type="" title="/resources/validators.xml"
                id="sourceContent1">
          <![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!--!DOCTYPE validators PUBLIC
        "-//OpenSymphony Group//XWork Validator Config 1.0//EN"
        "http://www.opensymphony.com/xwork/xwork-validator-config-1.0.dtd"-->
<!DOCTYPE validators PUBLIC
        "-//Apache Struts//XWork Validator Config 1.0//EN"
        "http://struts.apache.org/dtds/xwork-validator-config-1.0.dtd">
<!-- START SNIPPET: validators-default -->
<validators>
    <validator name="required" class="com.opensymphony.xwork2.validator.validators.RequiredFieldValidator"/>
    <validator name="requiredstring" class="com.opensymphony.xwork2.validator.validators.RequiredStringValidator"/>
    <validator name="int" class="com.opensymphony.xwork2.validator.validators.IntRangeFieldValidator"/>
    <validator name="double" class="com.opensymphony.xwork2.validator.validators.DoubleRangeFieldValidator"/>
    <validator name="date" class="com.opensymphony.xwork2.validator.validators.DateRangeFieldValidator"/>
    <validator name="expression" class="com.opensymphony.xwork2.validator.validators.ExpressionValidator"/>
    <validator name="fieldexpression" class="com.opensymphony.xwork2.validator.validators.FieldExpressionValidator"/>
    <validator name="email" class="com.opensymphony.xwork2.validator.validators.EmailValidator"/>
    <validator name="url" class="com.opensymphony.xwork2.validator.validators.URLValidator"/>
    <validator name="visitor" class="com.opensymphony.xwork2.validator.validators.VisitorFieldValidator"/>
    <validator name="conversion" class="com.opensymphony.xwork2.validator.validators.ConversionErrorFieldValidator"/>
    <validator name="stringlength" class="com.opensymphony.xwork2.validator.validators.StringLengthFieldValidator"/>
    <validator name="regex" class="com.opensymphony.xwork2.validator.validators.RegexFieldValidator"/>
    <validator name="timeValidator" class="com.s2app.util.TimeValidator"/>
</validators>
<!--  END SNIPPET: validators-default -->]]></c:sourceContent>

    <c:sourceContent expand="false" type="" title="com.s2app.domain.Event.java"
                id="sourceContent1">
  <![CDATA[package com.s2spp.domain;

import javax.persistence.*;
import java.util.*;
import java.io.Serializable;

import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;
import com.opensymphony.xwork2.validator.annotations.RequiredFieldValidator;
import com.opensymphony.xwork2.validator.annotations.IntRangeFieldValidator;

@Entity @Table( name="EVENT", schema="S2APP" )
public class Event  implements Serializable {

    private long id;
    private String name;
    private Date startTime;
    private int timeZoneOffset = 0;
    private Date votingStartTime;
    private int duration;
    private Date lastUpdateTime;
    private Set<Voter> voters = new HashSet<Voter>();
    private Location location;
    private List<Contestant> options = new ArrayList<Contestant>();
    private Progress status;

    @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="NAME")
    public String getName() {
        return name;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setName(String name) {
        this.name = name;
    }

    @Column(name="START_TIME") @Temporal(TemporalType.TIMESTAMP)
    public Date getStartTime() {
        return startTime;
    }

    public void setStartTime(Date startTime) {
        this.startTime = startTime;
    }

    @Column(name="DURATION")
    public int getDuration() {
        return duration;
    }

    @RequiredFieldValidator(message="Validation Error", key="validate.notEmpty")
    @IntRangeFieldValidator(message = "Default message", key = "validate.between1and24", min = "1", max = "24")
    public void setDuration(int duration) {
        this.duration = duration;
    }

    @Column(name="TZ_OFFSET")
    public int getTimeZoneOffset() {
        return timeZoneOffset;
    }

    public void setTimeZoneOffset(int timeZoneOffset) {
        this.timeZoneOffset = timeZoneOffset;
    }

    @Column(name="VOTING_STARTS") @Temporal(TemporalType.TIMESTAMP)
    public Date getVotingStartTime() {
        return votingStartTime;
    }

    public void setVotingStartTime(Date votingStartTime) {
        this.votingStartTime = votingStartTime;
    }

    @Column(name="LAST_UPDATE") @Temporal(TemporalType.TIMESTAMP)
    public Date getLastUpdateTime() {
        return lastUpdateTime;
    }

    public void setLastUpdateTime(Date lastUpdateTime) {
        this.lastUpdateTime = lastUpdateTime;
    }

    @OneToMany(mappedBy="event",cascade=CascadeType.REFRESH)
    public Set<Voter> getVoters() {
        return voters;
    }

    public void setVoters(Set<Voter> voters) {
        this.voters = voters;
    }

    public void addVoter( Voter v ) {
        v.setEvent(this);
        voters.add(v);
    }

    @ManyToOne(cascade=CascadeType.REFRESH) @JoinColumn(name="LOCATION_FK")
    public Location getLocation() {
        return location;
    }

    public void setLocation(Location location) {
        this.location = location;
    }

    @OneToMany(mappedBy="event",cascade=CascadeType.REFRESH)
    public List<Contestant> getOptions() {
        return options;
    }

    public void setOptions(List<Contestant> options) {
        this.options = options;
    }

    public void addOption( Contestant c ) {
        c.setEvent(this);
        options.add(c);
    }

    @Column(name="STATE") @Enumerated(EnumType.STRING)
    public Progress getStatus() {
        return status;
    }

    public void setStatus(Progress status) {
        this.status = status;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.domain.Location.java"
                id="sourceContent1"><![CDATA[package com.s2app.domain;

import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;

import javax.persistence.*;
import java.io.Serializable;

@Entity @Table( name="LOCATION", schema="S2APP" )
@Inheritance(strategy=InheritanceType.JOINED)
public class Location implements Serializable {

    private long id;
    private String name;
    private String city;
    private String state;

    @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="NAME")
    public String getName() {
        return name;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setName(String name) {
        this.name = name;
    }

    @Column(name="CITY")
    public String getCity() {
        return city;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setCity(String city) {
        this.city = city;
    }

    @Column(name="STATE")
    public String getState() {
        return state;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setState(String state) {
        this.state = state;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.domain.Address.java"
                id="sourceContent1"><![CDATA[package com.s2app.domain;

import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;

import javax.persistence.*;

@Entity @Table( name="ADDRESS", schema="S2APP" )
@PrimaryKeyJoinColumn(name="LOCATION_PK")
public class Address extends Location {

    private String address;
    private String zipcode;

    @Column(name="ADDRESS")
    public String getAddress() {
        return address;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setAddress(String address) {
        this.address = address;
    }

    @Column(name="ZIPCODE")
    public String getZipcode() {
        return zipcode;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setZipcode(String zipcode) {
        this.zipcode = zipcode;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.domain.Broadcast.java"
                id="sourceContent1"><![CDATA[package com.s2app.domain;

import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;

import javax.persistence.*;

@Entity @Table( name="BROADCAST", schema="S2APP" )
@PrimaryKeyJoinColumn(name="LOCATION_PK")
public class Broadcast extends Location {

    private String stationIdentifier;
    private String network;

    @Column(name="CALLSIGN")
    public String getStationIdentifier() {
        return stationIdentifier;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setStationIdentifier(String stationIdentifier) {
        this.stationIdentifier = stationIdentifier;
    }

    @Column(name="NETWORK")
    public String getNetwork() {
        return network;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setNetwork(String network) {
        this.network = network;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.domain.Contestant.java"
                id="sourceContent1"><![CDATA[package com.s2app.domain;

import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;

import javax.persistence.*;

@Entity @Table( name="CONTESTANT", schema="S2APP" )
public class Contestant {

    private long id;
    private String name;
    private String description;
    private Event event;

    @Id @GeneratedValue(strategy=GenerationType.AUTO) @Column(name="ID")
    public long getId() {
        return id;
    }

    public void setId(long id) {
        this.id = id;
    }

    @Column(name="NAME")
    public String getName() {
        return name;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setName(String name) {
        this.name = name;
    }

    @Column(name="DESCRIPTION")
    public String getDescription() {
        return description;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setDescription(String description) {
        this.description = description;
    }

    @ManyToOne @JoinColumn(name="EVENT_FK")
    public Event getEvent() {
        return event;
    }

    public void setEvent(Event event) {
        this.event = event;
    }


    public int hashCode() {
        return name.hashCode();
    }

    public boolean equals(Object obj) {
        return obj instanceof Contestant && name.equals(((Contestant)obj).getName()); 
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.s2app.domain.Broadcast.java"
                id="sourceContent1"><![CDATA[package com.s2app.domain;

import com.opensymphony.xwork2.validator.annotations.RequiredStringValidator;

import javax.persistence.*;

@Entity @Table( name="BROADCAST", schema="S2APP" )
@PrimaryKeyJoinColumn(name="LOCATION_PK")
public class Broadcast extends Location {

    private String stationIdentifier;
    private String network;

    @Column(name="CALLSIGN")
    public String getStationIdentifier() {
        return stationIdentifier;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setStationIdentifier(String stationIdentifier) {
        this.stationIdentifier = stationIdentifier;
    }

    @Column(name="NETWORK")
    public String getNetwork() {
        return network;
    }

    @RequiredStringValidator(message="Validation Error", key="validate.notEmpty",trim=true)
    public void setNetwork(String network) {
        this.network = network;
    }
}]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[flash 作用域 (Struts2 中不提供 flash 作用域的实现，需借助 WebWork 中提供的实现。)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[当 EnterLocationDetailsAction 返回一个 selectType 结果提示用户没有选择场所类型，需要用户返回到前一个页面并进行选择。]]></c:desc1>
      <c:desc1> <![CDATA[由于决定将 SelectLoactionTypeAction 从 EnterLocationDetailsAction 中分割出来，分发器或者重定向结果类型将会出现问题。]]></c:desc1>
      <c:desc1> <![CDATA[对于分发结果类型，场所类型列表将不可用；而对于重定向结果类型，错误信息也将不可用；使用 flash 作用域可以解决此问题。]]></c:desc1>
      <c:desc1> <![CDATA[当结果类型是重定向时， flash 作用域提供了访问前一个 action 上下文以及当前 action 上下文的方法。]]></c:desc1>
      <c:desc1> <![CDATA[<span style="color:red;font-weight:bold;">(这一点非常重要，因为在用户刷新浏览器页面而不是点击一个链接或者按钮时，前一个 action 的上下文会随着页面的刷新而丢失。)</span>]]></c:desc1>
      <c:desc1> <![CDATA[<span style="color:red;font-weight:bold;">(这正符合提交 - 重定向模式的需求，提交将不会进行两次，保存数据的反馈信息也将被全部移除！)</span>]]></c:desc1>
      <c:desc1> <![CDATA[无论是让 action 返回 flash 结果类型，还是让 action 的配置使用 flash 拦截器。
                         在值栈中，被执行的 action 应该始终放在重定向时被调用的 action 的前面。所以最好在必要的时候才使用 flash 作用域。]]></c:desc1>
      <c:desc1>
        <![CDATA[将被调用的 action 在 struts.xml 中进行配置，这样便于 flash 拦截器的使用。
                 通过使用一个不同的 action 名，flash 拦截器就只在需要时被调用，而不是对所有的 selectEventType.action 请求都做出响应。]]>
      </c:desc1>
      <c:desc1>
        <![CDATA[(XML 配置的 action 名不能与按照约定方式命名的 action 名 [通过类型可猜到] 相同，约定大于配置。)]]>
      </c:desc1>
    </c:desc>
    <c:sourceContent expand="false" type="" title="com.opensymphony.webwork.interceptor.FlashInterceptor.java (用来保存或检索使用 flash 作用域的 action)"
                              id="sourceContent1"><![CDATA[/*
 * Copyright (c) 2002-2006 by OpenSymphony
 * All rights reserved.
 */
package com.opensymphony.webwork.interceptor;

import java.util.Map;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import com.opensymphony.webwork.dispatcher.FlashResult;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ActionContext;
import com.opensymphony.xwork2.interceptor.PreResultListener;
import com.opensymphony.xwork2.interceptor.AbstractInterceptor;
import com.opensymphony.xwork2.ognl.OgnlValueStack;

/**
 * <!-- START SNIPPET: description -->
 * Flash interceptor ({@link FlashInterceptor}) possibly with {@link FlashResult}
 * allows current action to be available even after a redirect. It does this by
 * saving the current action into http session and pushing it back into the stack
 * next request, resulting in the nett effect of the action and its related information
 * being available across redirect.
 * <!-- END SNIPPET: description -->
 *
 *
 * <!-- START SNIPPET: parameters -->
 * <ul>
 * 	<li>key - The Http Session key under which the action will be stored,
 *                     default to {@link FlashInterceptor#DEFAULT_KEY} which is
 *                     the string '__flashAction'.</li>
 *     <li>operation - The operation mode of this interceptor, either
 *     				{@link FlashInterceptor#STORE} having a string value of 'Store' or
 *     				{@link FlashInterceptor#RETRIEVE} having a string value of 'Retrieve'
 *     				The default operation mode is {@link FlashInterceptor#RETRIEVE}</li>
 * </ul>
 * <!-- END SNIPPET: parameters -->
 *
 *
 * <!-- START SNIPPET: extending -->
 * There's no intended extension points
 * <!-- END SNIPPET: extending -->
 *
 *
 * <pre>
 * <!-- START SNIPPET: example -->
 * &lt;!-- Usage 1: (Using only Flash interceptor)  --&gt;
 * &lt;action name="store" ...&gt;
 * 	&lt;interceptor-ref name="flash"&gt;
 * 		&lt;param name="operation"&gt;Store&lt;/param&gt;
 *     &lt;/interceptor-ref&gt;
 *     &lt;interceptor-ref name="defaultStack" /&gt;
 *     &lt;result type="redirect"&gt;redirectToSomeWhere.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * &lt;action name="retrieve"&gt;
 * 	&lt;interceptor-ref name="flash"&gt;
 *        &lt;param name="operation"&gt;Retrieve&lt;/param&gt;
 *     &lt;/interceptor-ref&gt;
 *     &lt;interceptor-ref name="defaultStack" /&gt;
 *     &lt;result&gt;pageWhereWeNeedFlashActionStored.jsp&lt;/result&gt;
 * &lt;/action&gt;
 *
 *
 * &lt;!-- Usage 2: (Using Flash Interceptor and Flash Result) --&gt;
 * &lt;action name="store"&gt;
 * 	<result type="flash"&lt;/redirectToSomeWhere.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * &lt;action name="retrieve"&gt;
 * 	&lt;interceptor-ref name="flash"&gt;
 *        &lt;param name="operation"&gt;Retrieve&lt;/param&gt;
 *     &lt;/interceptor-ref&gt;
 *     &lt;interceptor-ref name="defaultStack" /&gt;
 *     &lt;result&gt;pageWhereWeNeedFlashActionStored.jsp&lt;/result&gt;
 * &lt;/action&gt;
 *
 * <!-- END SNIPPET: example -->
 * </pre>
 *
 *
 * @author tmjee
 * @version $Date: 2006/12/11 12:57:12 $ $Id: FlashInterceptor.java,v 1.2 2006/12/11 12:57:12 tmjee Exp $
 */
public class FlashInterceptor extends AbstractInterceptor {

    public static final String DEFAULT_KEY = "__flashAction";
    public static final String STORE = "Store";
    public static final String RETRIEVE = "Retrieve";

    private static final Log LOG = LogFactory.getLog(FlashInterceptor.class);

    private static final long serialVersionUID = -9200319895107209641L;

    private String key = DEFAULT_KEY;
    private String operation = RETRIEVE;

    public void setKey(String key) {
        this.key = key;
    }
    public String getKey() {
        return this.key;
    }

    public void setOperation(String operation) { this.operation = operation; }
    public String getOperation() { return this.operation; }


    public String intercept(ActionInvocation invocation) throws Exception {
        Map sessionMap = ActionContext.getContext().getSession();

        if (STORE.equalsIgnoreCase(operation)) {
            invocation.addPreResultListener(new PreResultListener() {
                public void beforeResult(ActionInvocation invocation, String resultCode) {
                    Map sessionMap = ActionContext.getContext().getSession();
                    Object action = invocation.getAction();
                    if (LOG.isDebugEnabled())
                        LOG.debug("inserting action ["+action+"] into session with key ["+key+"]");
                    sessionMap.put(key, action);
                }
            });
        }

        if (RETRIEVE.equalsIgnoreCase(operation)) {
            if (sessionMap.get(key) != null) {
                Object action = sessionMap.get(key);
                if (LOG.isDebugEnabled()) {
                    LOG.debug("flash action with key ["+key+"] found in session, pushed action ["+action+"] into stack");
                }
                OgnlValueStack stack = (OgnlValueStack) ActionContext.getContext().get(ActionContext.VALUE_STACK);
                stack.push(action);
                sessionMap.remove(key);
                if (LOG.isDebugEnabled()) {
                    LOG.debug("flash action with key ["+key+"] with actual type ["+action+"] removed from session after being pushed into the stack ");
                }
            }
            else {
                if (LOG.isDebugEnabled()) {
                    LOG.debug("flash action key ["+key+"] not found in session, no action is pushed into stack");
                }
            }
        }

        return invocation.invoke();
    }
}]]></c:sourceContent>
    <c:sourceContent expand="false" type="" title="com.opensymphony.webwork.dispatcher.FlashResult.java"
                              id="sourceContent1"><![CDATA[/*
 * Copyright (c) 2002-2006 by OpenSymphony
 * All rights reserved.
 */
package com.opensymphony.webwork.dispatcher;

import java.util.Map;

import com.opensymphony.webwork.interceptor.FlashInterceptor;
import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.ActionInvocation;
import org.apache.struts2.dispatcher.ServletRedirectResult;

/**
 * <!-- START SNIPPET: description -->
 *  A flash result, that save the current action into the http session before
 *  invoking <code>super.doExecute(...)</code>, which actually just do
 *  a redirect to a specific location just as a normal {@link ServletRedirectResult}
 *  would.
 *  <!-- END SNIPPET: description -->
 *
 *  <!-- START SNIPPET: params -->
 *  <ul>
 *  	key - The key under which current action is stored in Http Session. Default to
 *              {@link FlashInterceptor#DEFAULT_KEY} which is the string '__flashAction'
 *  </ul>
 *  <!-- END SNIPPET: params -->
 *
 *  <pre>
 *  <!-- START SNIPPET: example -->
 *
 *  &lt;action name="store"&gt;
 * 	<result type="flash"&lt;/redirectToSomeWhere.jsp&lt;/result&gt;
 * &lt;/action&gt;
 * &lt;action name="retrieve"&gt;
 * 	&lt;interceptor-ref name="flash"&gt;
 *        &lt;param name="operation"&gt;Retrieve&lt;/param&gt;
 *     &lt;/interceptor-ref&gt;
 *     &lt;interceptor-ref name="defaultStack" /&gt;
 *     &lt;result&gt;pageWhereWeNeedFlashActionStored.jsp&lt;/result&gt;
 * &lt;/action&gt;
 *
 *  <!-- END SNIPPET: example -->
 *  </pre>
 *
 *
 * @author Patrick Lightbody
 * @version $Date: 2006/12/11 12:57:11 $ $Id: FlashResult.java,v 1.2 2006/12/11 12:57:11 tmjee Exp $
 */
public class FlashResult extends ServletRedirectResult {

	private static final long serialVersionUID = -8956841683709714038L;

	private String key = FlashInterceptor.DEFAULT_KEY;

	/**
	 * A flash result, that save the current action into the http session before
	 * invoking <code>super.doExecute(...)</code>.
	 *
	 * @see com.opensymphony.webwork.dispatcher.ServletRedirectResult#doExecute(java.lang.String, com.opensymphony.xwork.ActionInvocation)
	 */
	protected void doExecute(String finalLocation, ActionInvocation invocation) throws Exception {

		// before we redirect, let's save the state in to the session
        Object action = invocation.getAction();
        Map session = invocation.getInvocationContext().getSession();
        session.put(FlashInterceptor.DEFAULT_KEY, action);

		super.doExecute(finalLocation, invocation);
	}

	/**
	 * Set the key used to store the current action in http session.
	 * @param key
	 */
	public void setKey(String key) {
		this.key = key;
	}

	/**
	 * Get the key used to store the current action in http session.
	 * @return String
	 */
	public String getKey() {
		return key;
	}

}]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的自定义验证]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[在开发过程中如果个别字段在领域对象中没有对应的属性时，需要在 action 中定义该属性！(例如：partialStartDate、partialStartTime 和 partialVotingStartTime)]]></c:desc1>
      <c:desc1> <![CDATA[自定义时间验证器，例如： 8:30AM 或 3:30PM]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1"><![CDATA[<head>
    <title><s:text name="createEvent.enterEvent.title /></title>
</head>
<body>
    <s:form action="enterEventDetails" namespace="/event" method="post">
        <s:textfield label="Event Name" name="name" />
        <s:textfield label="Start Date" name="partialStartDate" />
        <s:textfield label="Start Time" name="partialStartTime" />
        <s:textfield label="Time Zone Offset" name="timeZoneOffset" />
        <s:textfield label="Voting Start Time" name="partialVotingStartTime" />
        <s:textfield label="Duration" name="duration" />
              
        <s:submit value="Create" />
    </s:form>
</body>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="EnterEventDetailaAction.java"
                                  id="sourceContent1"><![CDATA[// 该 action 的验证器由两部分组成，即 Event 领域对象的访问者验证及 action 的属性验证
// CustomValidator 的 type 属性，表明验证过程使用的是 validation.xml 配置文件中的哪个自定义验证器
public class EnterEventDetailaAction extends BaseEventAction implements Preparable {
    public void prepare() {
        // 创建一个活动并设置初始值
        event = new Event();
        event.setStatus(Progresss.NOT_STARTED);
        event.setLastUpdateTime(Calendar.getInstance().getTime());
    }
          
    public Date getPartialStartDate() {
        return partialStartDate;
    }
    
    @RequiredFieldValidator(message="Validation Error", key="validate.notEmpty")
    public void setPartialStartDate(Date partialStartDate) {
        this.partialStartDate = partialStartDate;
    }
          
    public String getPartialStartTime() {
        return this.partialStartTime;
    }
    
    @CustomValidator(type="timeValidator", key="validate.timeOfDay")
    public void setPartialStartTime(String partialStartTime) {
        this.partialStartTime = partialStartTime;
    }
          
    public String getPartialVotingStartTime() {
        return this.partialVotingStartTime;
    }
    
    @CustomValidator(type="timeValidator", key="validate.timeOfDay")
    public void setPartialVotingStartTime(String partialVotingStartTime) {
        this.partialVotingStartTime = partialVotingStartTime;
    }
    
    @VisitorFieldValidator(message="Default Message", fieldName="model", shortCircuit=false, appendPrefix=false)
    public String execute() {
        // 从表单字段中获取用户输入并将其转换成有效的 Event 领域对象日期属性
        Calendar cal = Calendar.getInstance();
        cal.setTime(partialStartDate);
              
        TimeUtil timeUtil = new TimeUtil(partialStartTime);
        event.setStartTime(timeUtil.resolveDate(partialStartDate, event.getTimeZoneOffset()));
              
        cal = Calendar.getInstance();
        cal.setTime(partialStartDate);
        timeUtil = new TimeUtil(partialVotingStartTime);
        event.setVotingStartTime(timeUtil.resolveDate(partialStartDate, event.getTimeZoneOffset()));
              
        return SUCCESS;
    }
}]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的 CustomValidator]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[如果使用的是默认提供的验证功能，那么就不需要提供 validation.xml 文件。]]></c:desc1>
      <c:desc1> <![CDATA[当使用自定义验证器时，需要将 default.xml 配置文件从 XWork JAR 的 com\opensymphony\xwork2\validator\validators 文件夹下复制到 classpath 的跟目录，并重命名为 validators.xml]]></c:desc1>
      <c:desc1> <![CDATA[开发自定义验证器需要实现 Validator 接口，可以选择继承 ValidatorSupport 类或 FieldValidatorSupport 类。 (后者用于验证特定字段且提供相关的获取方法和设置方法以获得该属性的名字)]]></c:desc1>
      <c:desc1> <![CDATA[如果验证失败可以使用 addFieldError() 或 addActionError() 方法，ValidatorContext 提供了这两个方法。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="更新后的 validators.xml 文件" style="border-bottom:none;"
                              id="sourceContent1"><![CDATA[<validators>
    .....
    .....
          
    <!-- 添加新的验证器配置，验证器的 name 属性具有唯一性 -->
    <validator name="timeValidator" class="com.s2app.validator.TimeValidator" />
</validators>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="" style="border-top:none;border-bottom:none;"
                                  id="sourceContent1"><![CDATA[public class TimeValidator extends FieldValidatorSupport {
    public void validate(Object obj) throws Exception {
        String fieldName = getFieldName();            // 取得正在验证的字段名
        Object value = getFieldValue(fieldName, obj); // 待验证的值
        
        if(value == null || !(value instanceof String)
                         || !(new TimeUtil((String) value).isValid())) {
            addFieldError(fieldName, obj);
        }
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="" style="border-top:none;"
                                  id="sourceContent1">
      <![CDATA[<h4>工作流的第一个页面：</h4>
      <img src="//c2.staticflickr.com/8/7202/13843637683_b187a7459f_b.jpg" alt="" />]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的自定义标签]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[重新定义 s:radio，令其垂直布局，而不是水平排列。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="html" title="" style="border-bottom:none;"
                              id="sourceContent1"><![CDATA[1、在 web 应用根目录下创建一个名为 /template/s2app 的子目录。<br />
      2、复制一份 theme 模板用于修改<br />
      3、修改模板文件 radiomap.ftl 和 checkboxlist.ftl ，分别加入 <br />]]> </c:sourceContent>
    <c:sourceContent expand="true" type="" title="" style="border-top:none;"
                            id="sourceContent1"><![CDATA[<s:radio theme="s2app" list="types" name="typeClass" 
    listKey="class.name" listValue="getText(class.name)" />]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[可以创建大量的 theme，例如一个模板用于创建两列布局，另一个模板用于三列布局。]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的文件上传]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1">
      <![CDATA[。。。]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[s2app 的安全： 授权 (authorization)、身份验证 (authentication)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[用户登录和注销]]></c:desc1>
      <c:desc1> <![CDATA[1、基于容器的身份验证：应用服务器或者 servlet 容器提供的身份验证服务。]]></c:desc1>
      <c:desc1> <![CDATA[2、使用现有库 <a href="http://www.acegisecurity.org" target="_blank">Acegi</a>]]></c:desc1>
      <c:desc1> <![CDATA[3、自定义身份验证、授权]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1">
      <![CDATA[。。。]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[集成 Acegi 和 Struts2]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[安全范围仅局限于 URL 和 Web 应用级别 (即针对 action 和 jsp)]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="添加 Acegi 依赖"
                              id="sourceContent1"><![CDATA[<dependency>
    <groupId>org.acegisecurity</groupId>
      <artifactId>acegi-security</artifactId>
      <version>1.0.4</version>
</dependency>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="配置 Acegi 的 Servlet 的过滤器"
                                  id="sourceContent1"><![CDATA[<!-- 该过滤器允许 Acegi 拦截那些向 Web 应用发出的 URL 请求，同时提供自定义的安全处理机制 -->
<filter>
    <filter-name>Acegi Filter Chain Proxy</filter-name>
    <filter-class>org.acegisecurity.util.FilterToBeanProxy</filter-class>
    <init-param>
        <param-name>targetClass</param-name>
        <param-value>org.acegisecurity.util.FilterChainProxy</param-value>
    </init-param>
</filter>

<!-- web.xml 中定义的过滤器映射顺序就是应用调用过滤器的顺序 -->
<!-- 该映射需要定义在 Struts2 分发过滤器的前面，否则任何用户都可以调用 Struts2 的 action -->
<filter-mapping>
    <filter-name>Acegi Filter Chain Proxy</filter-name>
    <filter-pattern>/*</filter-pattern>
</filter-mapping>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="Acegi 应用上下文配置文件 applicationContext-acegi-security.xml (在 Acegi 的示例 WAR 中可以找到该文件)"
                                  id="sourceContent1">
                  <![CDATA[<!-- 该文件也需要在 web.xml 中配置，可以使用如下通配符 -->
<!-- 任何以 applicationContext 开头且存放在 classpath 中的文件都能自动加载 -->
<context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath*:applicationContext*.xml</param-value>
</context-param>


<!-- 文件内容 -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN//EN" "http://www.springframework.org/dtd/spring-beans.dtd">

<beans>
    <!-- ======================== FILTER CHAIN ======================= -->
    <bean id="filterChainProxy" class="org.acegisecurity.util.FilterChainProxy">
        <property name="filterInvocationDefinitionSource">
            <value>
                CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
                PATTERN_TYPE_APACHE_ANT
                <!-- 该处用于说明 Acegi 如何处理 /event/** 这个 URL -->
                /**=httpSessionContextIntegrationFilter,logoutFilter,authenticationProcessingFilter,basicProcessingFilter,securityContextHolderAwareRequestFilter,anonymousProcessingFilter,exceptionTranslationFilter,filterInvocationInterceptor
            </value>
        </property>
    </bean>

    <!-- ======================== AUTHENTICATION ======================= -->
    <bean id="authenticationManager" class="org.acegisecurity.providers.ProviderManager">
        <property name="providers">
            <list>
                <ref local="daoAuthenticationProvider"/>
                <ref local="anonymousAuthenticationProvider"/>
            </list>
        </property>
    </bean>

    <!-- 1. 该配置被 authenticationManager bean 引用，然后 URL 配置中的 basicProcessingFilter 会依次访问该 bean -->
    <!-- 2. 为了向应用的特定服务返回 Acegi 所需使用的用户对象，需要修改 daoAuthenticationProvider 配置，以便它引用一个不同的 userDetailService bean -->
    <!--<bean id="passwordEncoder" class="org.acegisecurity.providers.encoding.Md5PasswordEncoder"/>-->
    <bean id="daoAuthenticationProvider" class="org.acegisecurity.providers.dao.DaoAuthenticationProvider">
        <property name="userDetailsService"><ref bean="userService"/></property>
        <!--<property name="passwordEncoder"><ref local="passwordEncoder"/></property>-->
    </bean>

    <!-- Automatically receives AuthenticationEvent messages -->
    <bean id="loggerListener" class="org.acegisecurity.event.authentication.LoggerListener"/>

    <bean id="basicProcessingFilter" class="org.acegisecurity.ui.basicauth.BasicProcessingFilter">
        <property name="authenticationManager"><ref local="authenticationManager"/></property>
        <property name="authenticationEntryPoint"><ref local="basicProcessingFilterEntryPoint"/></property>
    </bean>

    <bean id="basicProcessingFilterEntryPoint" class="org.acegisecurity.ui.basicauth.BasicProcessingFilterEntryPoint">
        <property name="realmName"><value>Contacts Realm</value></property>
    </bean>

    <bean id="anonymousProcessingFilter" class="org.acegisecurity.providers.anonymous.AnonymousProcessingFilter">
        <property name="key"><value>foobar</value></property>
        <property name="userAttribute"><value>anonymousUser,ROLE_ANONYMOUS</value></property>
    </bean>

    <bean id="anonymousAuthenticationProvider" class="org.acegisecurity.providers.anonymous.AnonymousAuthenticationProvider">
        <property name="key"><value>foobar</value></property>
    </bean>

    <bean id="httpSessionContextIntegrationFilter" class="org.acegisecurity.context.HttpSessionContextIntegrationFilter">
    </bean>

    <bean id="logoutFilter" class="org.acegisecurity.ui.logout.LogoutFilter">
        <constructor-arg value="/index.action"/> <!-- URL redirected to after logout -->
        <constructor-arg>
            <list>
                <bean class="org.acegisecurity.ui.logout.SecurityContextLogoutHandler"/>
            </list>
        </constructor-arg>
    </bean>

    <bean id="securityContextHolderAwareRequestFilter" class="org.acegisecurity.wrapper.SecurityContextHolderAwareRequestFilter"/>


    <!-- ===================== HTTP REQUEST SECURITY ==================== -->
    <bean id="exceptionTranslationFilter" class="org.acegisecurity.ui.ExceptionTranslationFilter">
        <property name="authenticationEntryPoint"><ref local="authenticationProcessingFilterEntryPoint"/></property>
        <property name="accessDeniedHandler">
            <bean class="org.acegisecurity.ui.AccessDeniedHandlerImpl" />
        </property>
    </bean>

    <bean id="authenticationProcessingFilter" class="org.acegisecurity.ui.webapp.AuthenticationProcessingFilter">
        <property name="authenticationManager"><ref bean="authenticationManager"/></property>
        <property name="authenticationFailureUrl"><value>/acegilogin.action?login_error=1</value></property>
        <property name="defaultTargetUrl"><value>/</value></property>
        <property name="filterProcessesUrl"><value>/j_acegi_security_check</value></property>
    </bean>

    <bean id="authenticationProcessingFilterEntryPoint" class="org.acegisecurity.ui.webapp.AuthenticationProcessingFilterEntryPoint">
        <property name="loginFormUrl"><value>/acegilogin.action</value></property>
        <property name="forceHttps"><value>false</value></property>
    </bean>

    <bean id="httpRequestAccessDecisionManager" class="org.acegisecurity.vote.AffirmativeBased">
        <property name="allowIfAllAbstainDecisions"><value>false</value></property>
        <property name="decisionVoters">
            <list>
                <ref bean="roleVoter"/>
            </list>
        </property>
    </bean>

    <!-- Note the order that entries are placed against the objectDefinitionSource is critical.
      The FilterSecurityInterceptor will work from the top of the list down to the FIRST pattern that matches the request URL.
      Accordingly, you should place MOST SPECIFIC (ie a/b/c/d.*) expressions first, with LEAST SPECIFIC (ie a/.*) expressions last -->
    <bean id="filterInvocationInterceptor" class="org.acegisecurity.intercept.web.FilterSecurityInterceptor">
        <property name="authenticationManager"><ref bean="authenticationManager"/></property>
        <property name="accessDecisionManager"><ref local="httpRequestAccessDecisionManager"/></property>
        <property name="objectDefinitionSource">
            <value>
                CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
                PATTERN_TYPE_APACHE_ANT
                /event/**=ROLE_USER
                /**=ROLE_ANONYMOUS,ROLE_USER
            </value>
        </property>
    </bean>

    <!-- An access decision voter that reads ROLE_* configuration settings -->
    <bean id="roleVoter" class="org.acegisecurity.vote.RoleVoter"/>
</beans>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="实现 org.acegisecurity.userdetails.UserDetailsService 接口" style="border-bottom:none;"
                                  id="sourceContent1"><![CDATA[package com.s2app.services;

import com.fdar.apress.s2.domain.User;

import javax.persistence.*;

import org.acegisecurity.userdetails.UserDetailsService;
import org.acegisecurity.userdetails.UserDetails;
import org.acegisecurity.userdetails.UsernameNotFoundException;
import org.springframework.dao.DataAccessException;

public class UserServiceImpl implements UserService, UserDetailsService {

    private EntityManagerFactory emf;

    public UserServiceImpl() {
        emf = Persistence.createEntityManagerFactory("s2app");
    }

    public User findByEmail(String email) {
        EntityManager entityMgr = emf.createEntityManager();
        return entityMgr.find(User.class,email);
    }

    public void persist(User user,String emailId) {

        EntityManager entityMgr = emf.createEntityManager();
        EntityTransaction tx = null;
        try {
            tx = entityMgr.getTransaction();
            tx.begin();

            if( "".equals(emailId) ) {
                entityMgr.persist(user);
            } else {
                entityMgr.merge(user);
            }

            tx.commit();
        }
        catch (Exception e) {
            if ( tx != null && tx.isActive() )
                tx.rollback();
            throw (RuntimeException)e.getCause();
        }
    }

    public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException, DataAccessException {
        User u = findByEmail(s);
        if( s==null || "".equals(s.trim()) || u==null ) {
            throw new UsernameNotFoundException(s);
        }
        return new PermissionedUser(u);
    }
}
]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="" style="border-top:none;border-bottom:none;"
                              id="sourceContent1">
      <![CDATA[<div style="color:red;font-weight:bold;">org.acegisecurity.userdetails.UserDetailsService 包含一个 loadUserByUsername() 方法，如果找到了一个 User 对象，该方法就返回一个 PermissionedUser 对象。
      该对象封装了 User 对象，提供身份验证与授权信息，同时实现了 Acegi 的 UserDetails 接口。</div>]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="com.s2app.services.PermissionedUser 对象" style="border-top:none;"
                                      id="sourceContent1"><![CDATA[package com.fdar.apress.s2.services;

import org.acegisecurity.userdetails.UserDetails;
import org.acegisecurity.GrantedAuthority;
import org.acegisecurity.GrantedAuthorityImpl;
import com.fdar.apress.s2.domain.User;

/**
 * @author Ian Roughley
 * @version $Id$
 */
public class PermissionedUser implements UserDetails {

    private User user;

    public PermissionedUser( User user ) {
        this.user = user;
    }

    public User getUser() {
        return user;
    }

    public String getPassword() {
        return user==null ? "" : user.getPassword();
    }

    // 该方法返回身份验证信息，在本例中身份验证信息是用户已授权的角色
    // 在本例中仅使用 ROLE_ANONYMOUS 和 ROLE_USER 两个角色，任何已注册的用户都会被自动指定为 ROLE_USER 角色
    public GrantedAuthority[] getAuthorities() {
        return new GrantedAuthority[] { new GrantedAuthorityImpl("ROLE_USER") };
    }

    public String getUsername() {
        return user==null ? "" : user.getEmail();
    }

    public boolean isAccountNonExpired() {
        return true;
    }

    public boolean isAccountNonLocked() {
        return true;
    }

    public boolean isCredentialsNonExpired() {
        return true;
    }

    public boolean isEnabled() {
        return true;
    }

}]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[Acegi 的用户身份验证]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[当用户初次登陆或者是输入用户名密码错误时，都会被定向到 acegilogon.jsp。此页面的 url 在 authenticationProcessingFilterEntryPoint 以及 authenticationProcessingFilter bean 中配置.]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="配置 acegilogon.action"
                              id="sourceContent1"><![CDATA[<action name="acegilogin" class="com.fdar.apress.s2.actions.BaseAction" >
    <result name="success">/acegilogin.jsp?login_error=${login_error}</result>
</action>]]></c:sourceContent>


    <c:sourceContent expand="true" type="" title="/acegilogin.jsp" style="border-bottom:none;"
                              id="sourceContent1"><![CDATA[<%@ page import="org.acegisecurity.AuthenticationException" %>
<%@ page import="org.acegisecurity.ui.AbstractProcessingFilter" %>
<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="home.logon" /></title>
</head>
<body>

<s:if test="#parameters.size()>0">
    <s:text name="text.error.reason" />:  
    <s:property value="#session['ACEGI_SECURITY_LAST_EXCEPTION'].message" /><br/>
    <s:text name="text.register"/><br/><br/>
</s:if>

<form action="<%=request.getContextPath()%>/j_acegi_security_check" method="POST" >
    <s:text name="logon.username"/> <input type="text" name="j_username" /> <br/>
    <s:text name="logon.password"/> <input type="password" name="j_password" /> <br/>
    <input type="submit" value="<s:text name="button.logon" />" />
</form>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="" style="border-top:none;border-bottom:none;"
                                  id="sourceContent1"><![CDATA[
<div style="color:red;font-weight:bold;">基于 Acegi 身份验证的登陆页面与基于容器管理的登陆页面的不同之处在于：
用于提供身份验证的 URL 是 /j_acegi_security_check 而不是 /j_security_check，而且错误的获取方式也不一样。
此处的 jsp 页面通过测试参数的个数来判定是否发生错误而不是检查特定参数的值。
如果 URL 中存在一个以上的参数，那么就会显示身份验证消息。</div>]]>
</c:sourceContent>

    <c:sourceContent expand="true" type="" title="" style="border-top:none;"
                                  id="sourceContent1"><![CDATA[<!-- Acegi 也提供特定身份验证问题的消息，可以使用 struts 标签或 OGNL 表达式获得: -->
<s:property value="#session['ACEGI_SECURITY_LAST_EXCEPTION'].message" />
<%= ((AuthenticationException) session
    .getAttribute("AbstractProcessingFilter.ACEGI_SECURITY_LAST_EXCEPTION_KET")).gewtMessage() %>]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[自定义 authenticated 栈用于身份验证]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="struts.xml"
                              id="sourceContent1"><![CDATA[<package name="home-package" extends="struts-default" namespace="/">
    <interceptors>
    
        <interceptor name="acegi" class="com.s2app.util.AcegiInterceptor" />  <!-- 该拦截器可以将用户赋给 action -->
        <interceptor-stack name="authenticated">
            <interceptor-ref name="acegi"/>
            <interceptor-ref name="paramsPrepareParamsStack"/>
        </interceptor-stack>
    </interceptors>

    <default-interceptor-ref name="authenticated" />
        
    <action name="index" class="com.s2app.actions.BaseAction" >
        <result name="success">/WEB-INF/jsp/index.jsp</result>
    </action>

    <action name="acegilogin" class="com.s2app.actions.BaseAction" >
        <result name="success">/acegilogin.jsp?login_error=${login_error}</result>
    </action>
</package>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="BaseAction.java"
                              id="sourceContent1"><![CDATA[/*
    所有需要身份验证信息的 action 都需要有一个增加了注释的设置方法，这样所有继承自该类的 action 都可以访问已验证的用户信息了
*/
package com.s2app.actions;

import com.opensymphony.xwork2.ActionSupport;
import com.fdar.apress.s2.services.PermissionedUser;
import com.fdar.apress.s2.util.AcegiPrincipal;
import org.acegisecurity.Authentication;

/**
 * @author Ian Roughley
 * @version $Id$
 */
public class BaseAction extends ActionSupport {

    private PermissionedUser user;

    @AcegiPrincipal
    public void setAuthenticatedUser(PermissionedUser user) {
        this.user = user;
    }

    public PermissionedUser getAuthenticatedUser() {
        return user;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="在 /WEB-INF/jsp/index.jsp 中访问已通过身份验证的用户信息"
                              id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>
<%@ taglib prefix="authz" uri="http://acegisecurity.org/authz" %>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <title><s:text name="home.title" /></title>
</head>
<body>

<authz:authorize ifNotGranted="ROLE_USER">

    <s:url id="register" action="findUser" namespace="/user" />
    <s:a href="%{register}"><s:text name="link.register" /></s:a>

    <s:url id="login" action="acegilogin" namespace="/" />
    |  <s:a href="%{login}"><s:text name="home.logon" /></s:a>
</authz:authorize>
<authz:authorize ifAllGranted="ROLE_USER">
    <s:url id="update" action="findUser" namespace="/user" >
        <s:param name="emailId" value="authenticatedUser.username" />
    </s:url>
    <s:a href="%{update}"><s:text name="link.updateProfile" /></s:a>

    |  <a href="<%=request.getContextPath()%>/j_acegi_logout"><s:text name="link.logoff" /></a>
</authz:authorize>

<s:url id="newEvent" action="addEventFlow" namespace="/event" />
|  <s:a href="%{newEvent}"><s:text name="link.addEvent" /></s:a>

</body>
</html>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="AcegiInterceptor.java"
                              id="sourceContent1"><![CDATA[package com.s2app.util;

import com.opensymphony.xwork2.interceptor.AbstractInterceptor;
import com.opensymphony.xwork2.ActionInvocation;
import com.fdar.apress.s2.services.PermissionedUser;
import org.acegisecurity.Authentication;
import org.acegisecurity.context.SecurityContextHolder;

import java.lang.reflect.Method;

public class AcegiInterceptor extends AbstractInterceptor {

    public String intercept(ActionInvocation invocation) throws Exception {

        Object action = invocation.getAction();
        Authentication currentUser = SecurityContextHolder.getContext().getAuthentication();

        if( currentUser!=null ) {
            for( Method m: action.getClass().getDeclaredMethods() ) {
                if( m.getAnnotation(AcegiPrincipal.class)!=null                       // 使用反射查找设置了 AcegiPrincipal 标记标签的方法
                        && currentUser.getPrincipal() instanceof PermissionedUser ) { // 如果找到了，
                                                                                      // 将会从 Acegi 安全环境中获取的用户对象作为参数来调用设置方法
                                                                                      // 此处只判断用户是否注册，而不管它是某个特定角色
                                                                                      // 因此只需从 Authentication 对象里检索 principal 主体，
                                                                                      // 然后将这个不带任何角色信息的主题赋给 action 
                    m.invoke(action,currentUser.getPrincipal());                      // getPrincipal() 方法的返回类型与 
                                                                                      // UserServiceImpl 服务中的 loadUserByUsername() 
                                                                                      // 返回类型一样， 都是 PermissionedUser 类
                }
            }
        }

        return invocation.invoke();
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="AcegiPrincipal.java"
                                  id="sourceContent1"><![CDATA[package com.s2app.util;

import java.lang.annotation.Target;
import java.lang.annotation.ElementType;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Retention;

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AcegiPrincipal {

}]]></c:sourceContent>

    <c:sourceContent expand="true" type="html" title="测试拦截器"
                                  id="sourceContent1">
      <![CDATA[。。。。]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[自定义身份验证、授权]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1">
      <![CDATA[。。。]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[更新页面布局]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[当需要将很多不想关的部分结合起来以构建 Web 页面时，一个更好的方法是使用 Struts2 的 action 标签在 JSP 模板里调用 action。]]></c:desc1>
      <c:desc1> <![CDATA[当在 JSP 模板里使用 action 标签时，开发人员可以选择是否将 action 调用之后产生的结果包含到当前 JSP 里来。即使结果没有被包含进来，被调用的 action 在值栈里仍然可用。action 标签还可以嵌套 param 标签以便向 action 传递参数信息。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="s:action"
                              id="sourceContent1"><![CDATA[<s:action name="myactionname" namespace="/user" executeResult="true">
    <s:param name="number">10</s:param>
</s:action>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="s:component -- eventListing.jsp"
                                  id="sourceContent1"><![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<p>
<h3><s:property value="parameters.event.name" /></h3>
<s:text name="display.event.date"/>  <s:date name="parameters.event.startTime" format="MMM d, yyyy"/> <br/>
<s:text name="display.event.start"/> <s:date name="parameters.event.startTime" format="hh:mm a" /> <br/>
<s:text name="display.event.voting"/> <s:date name="parameters.event.votingStartTime" format="hh:mm a"/> <br/>
</p>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="s:component -- listEvents-partial.jsp"
                                  id="sourceContent1">
  <![CDATA[<%@ page contentType="text/html; charset=UTF-8" %>
<%@ taglib uri="/struts-tags" prefix="s" %>

<s:if test="results.size()==0">
    <s:text name="text.noEvents" />
</s:if>
<s:else>
    <s:iterator id="next" value="results">
        <!-- c:component 使用两个属性确定模板位置 template 和 theme： /template/apress/eventListing.jsp-->
        <s:component template="eventListing.jsp" theme="apress">
            <s:param name="event" value="#next" />
        </s:component>
    </s:iterator>
</s:else>]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[利用 c:component 将呈现代码从迭代逻辑中分离出来，以达到呈现逻辑的重用，即利用 c:component 将视图分隔成多个 jsp。]]>
      </c:comment1>
      <c:comment1>
        <![CDATA[在开发过程中，实现细节不能影响结果的获取方式以及结果的呈现方式。]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[搜索]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title=""
                              id="sourceContent1">
      <![CDATA[。。。]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[聚合与集成]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[使用 RSS feed 创建 mashup，并提供 REST 风格的 Web 服务来访问数据。]]></c:desc1>
      <c:desc1> <![CDATA[Google Maps 就是使用 mashup 的典范，它从一个 API 或 RSS Fees 获取数据，然后和 Google Maps 合并将存文本的信息显示为地图！]]></c:desc1>
      <c:desc1> <![CDATA[可以使用 <a href="http://rome.dev.java.net" target="_blank">Rome</a> 开源库生成 RSS，它支持所有 RSS 版本的格式，同时也支持 Atom。]]></c:desc1>
      <c:desc1> <![CDATA[可以定义一个新的结果类型用于呈现 RSS，是用该结果类型允许任何包含 User 对象列表的 action 快速而又容易的将列表转换成 RSS feed.]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="Rome 库依赖"
                              id="sourceContent1"><![CDATA[<!-- Rome -->
<dependency>
	<groupId>rome</groupId>
	<artifactId>rome</artifactId>
	<version>0.9</version>
</dependency>
<dependency>
	<groupId>rome</groupId>
	<artifactId>georss-rome</artifactId>
	<version>0.9.8</version>
</dependency>


<dependency>
  <groupId>com.totsp.feedpod</groupId>
  <artifactId>purl-org-content</artifactId>
  <version>0.3</version>
</dependency>]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="配置 GeoRSS 模块, 用于描述地理信息"
                              id="sourceContent1">
      <![CDATA[1、下载并安装 GeoRSS 库文件：<a href="http://georss.geonames.org/georss-rome-0.9.8.jar">http://georss.geonames.org/georss-rome-0.9.8.jar</a><br />
      2、使用 maven 命令将该库安装到本地库中: <br />
       <span style="color:red;font-weight:bold;">mvn install:install-file -DgroupId=rome -DartifactId=georss-rome -Dversion=0.9.8 -Dpackaging=jar -Dfile=georss-rome-0.9.8.jar</span>]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="开发自定义 RSS 结果类型"
                                  id="sourceContent1"><![CDATA[<result-types>
    <result-type name="eventRss" class="com.s2app.myresults.EventRssResult" />
</result-types>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="配置 action 使用新的结果类型"
                                  id="sourceContent1"><![CDATA[<action name="rss" class="com.s2app.myaction">
    <param name="number">10</param>
    <result name="success" type="eventRss">
        <param name="inputName">results</param>
        <param name=“feedType">rss_2.0</param>
        <param name="title">Most Recent Events</param>
        <param name="link">http://localhost:8080/s2app/rss.action</param>
        <param name="desc">The most recent events in RSS format.</param>
    </result>
</action>]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="com.s2app.myresults.EventRssResult"
                                  id="sourceContent1">
  <![CDATA[package com.s2app.myresults;

import com.opensymphony.xwork2.ActionInvocation;
import com.opensymphony.xwork2.TextProvider;
import com.opensymphony.xwork2.Result;

import com.sun.syndication.feed.synd.*;
import com.sun.syndication.feed.module.georss.GeoRSSModule;
import com.sun.syndication.feed.module.georss.W3CGeoModuleImpl;
import com.sun.syndication.feed.module.georss.geometries.Position;
import com.sun.syndication.io.FeedException;
import com.sun.syndication.io.SyndFeedOutput;
import com.fdar.apress.s2.domain.Event;

import com.totsp.xml.syndication.content.ContentItem;
import com.totsp.xml.syndication.content.ContentModule;
import com.totsp.xml.syndication.content.ContentModuleImpl;
import com.totsp.xml.syndication.content.io.ContentModuleParser;
import com.totsp.xml.syndication.content.io.ContentModuleGenerator;

import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.List;
import java.util.ArrayList;
import java.text.SimpleDateFormat;
import java.text.DateFormat;
import java.net.URL;

import org.apache.struts2.StrutsStatics;
import sun.net.www.protocol.http.HttpURLConnection;

public class EventRssResult implements Result {
    private static final String MIME_TYPE = "application/xml";

    private String inputName = "inputList";
    private String feedType = "rss_2.0";

    private String title;
    private String link;
    private String description;

    public void setInputName(String inputName) {
        this.inputName = inputName;
    }

    public void setFeedType(String feedType) {
        this.feedType = feedType;
    }

    public void setTitle(String title) {
        this.title = title;
    }

    public void setLink(String link) {
        this.link = link;
    }

    public void setDescription(String description) {
        this.description = description;
    }

    public void execute(ActionInvocation invocation) throws Exception {
        HttpServletResponse response = (HttpServletResponse) invocation.getInvocationContext().get(StrutsStatics.HTTP_RESPONSE);
        response.setContentType(MIME_TYPE);

        List<Event> events = (List<Event>) invocation.getStack().findValue(inputName);

        try {

            SyndFeedOutput feedOutput = new SyndFeedOutput();
            feedOutput.output(createFeed(events,feedType, (TextProvider)invocation.getAction()),response.getWriter());
            response.getWriter().flush();

        } finally {
            if( response.getWriter() != null ) {
                response.getWriter().close();
            }
        }
    }

    protected SyndFeed createFeed(List<Event> events,String feedType, TextProvider textProvider) throws IOException,FeedException {
        SyndFeed feed = new SyndFeedImpl();
        feed.setFeedType(feedType);

        feed.setTitle(title);
        feed.setLink(link);
        feed.setDescription(description);

        List entries = new ArrayList();
        for( Event next: events ) {
            entries.add( createEntry(next,textProvider) );
        }

        feed.setEntries(entries);
        return feed;
    }

    private SyndEntry createEntry(Event event, TextProvider textProvider) {
        SyndEntry entry = new SyndEntryImpl();
        entry.setTitle(event.getName());
        entry.setLink(link.substring(0,link.lastIndexOf("/")+1)+"api/event/"+event.getId());
        entry.setPublishedDate(event.getStartTime());

       /* SyndContent description = new SyndContentImpl();
        description.setType("text/html");
        description.setValue(createDescription(event,textProvider));
        entry.setDescription(description);*/

        entry.getModules().add(geoCodeLocation(event));


        List<String> contents = new ArrayList<String>();
        contents.add("<h1>jjjjjddd</h2>");
        ContentModule module = new ContentModuleImpl();
        module.setEncodeds(contents);
        entry.getModules().add(module);
      
        return entry;
    }

    private String createDescription(Event event, TextProvider textProvider) {
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd");
        StringBuilder sb = new StringBuilder();

        sb.append("<ul>");
        sb.append("<li>")
                .append(textProvider.getText("event.startDate"))
                .append(": ")
                .append(df.format(event.getStartTime()))
                .append("</li>");
        sb.append("<li>")
                .append(textProvider.getText("event.timeZoneOffset"))
                .append(": ")
                .append(event.getTimeZoneOffset())
                .append("</li>");
        sb.append("<li>")
                .append(textProvider.getText("event.duration"))
                .append(": ")
                .append(event.getDuration())
                .append("</li>");
        sb.append("<li>")
                .append(textProvider.getText("event.location"))
                .append(": ")
                .append(event.getLocation().getCity())
                .append(", ")
                .append(event.getLocation().getState())
                .append("</li>");
        sb.append("</ul>");

        return sb.toString();
    }

    private GeoRSSModule geoCodeLocation(Event event) {
        // GeoCode the address
        StringBuilder sb = new StringBuilder()
                .append("http://maps.google.com/maps/geo?q=")
                .append(event.getLocation().getCity().replaceAll(" ","+"))
                .append(",")
                .append(event.getLocation().getState().replaceAll(" ","+"))
                .append("&output=csv")
                .append("&key={googleKey}");

        String[] data = null;
        try {
            HttpURLConnection url = new HttpURLConnection(new URL(sb.toString()),"maps.google.com",80);
            url.connect();
            BufferedReader br = new BufferedReader(new InputStreamReader(url.getInputStream()));

            String buffer = br.readLine();
            data = buffer.split(",");
        } catch (Exception e) {
            e.printStackTrace();
        }

        double latitude = Double.parseDouble(data[2]);
        double longitude = Double.parseDouble(data[3]);

        // Add RSS GeoCoding
        GeoRSSModule geoRSSModule = new W3CGeoModuleImpl();
        Position pos = new Position(latitude,longitude);
        geoRSSModule.setPosition(pos);

        return geoRSSModule;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="实现 Atom Feed"
                              id="sourceContent1"><![CDATA[<action name="atom" class="com.s2app.myaction">
    <param name="number">10</param>
    <result name="success" type="eventRss">
        <param name="inputName">results</param>
        <param name=“feedType">atom_0.3</param>
        <param name="title">Most Recent Events</param>
        <param name="link">http://localhost:8080/s2app/rss.action</param>
        <param name="desc">The most recent events in RSS format.</param>
    </result>
</action>]]></c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[实现 REST 式的 web 服务]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[REST 架构性的 Web 服务主要围绕 URL 的概念来标识集成点。为了修改访问对象的状态，需要使用 HTTP 的 POST、GET、PUT、DELETE 等方法。]]></c:desc1>
    </c:desc>
    <c:sourceContent expand="true" type="" title="将 URL 映射到 action"
                              id="sourceContent1"><![CDATA[<!-- 在 Struts2 中默认使用 DefaultActionMapper 类映射 HTTP 请求 -->
<!-- 在 struts-default.xml 中已经定义了若干 action 映射器的实现： -->
<bean type="org.apache.struts2.dispatcher.mapper.ActionMapper" name="struts"
      class="org.apache.struts2.dispatcher.mapper.DefaultActionMapper" />
<bean type="org.apache.struts2.dispatcher.mapper.ActionMapper" name="composite"
      class="org.apache.struts2.dispatcher.mapper.CompositeActionMapper" />
<bean type="org.apache.struts2.dispatcher.mapper.ActionMapper" name="restful2"
      class="org.apache.struts2.dispatcher.mapper.Restful2ActionMapper" />]]></c:sourceContent>
    <c:sourceContent expand="true" type="html" title="restful2-mapping" style="border-bottom:none;"
                                  id="sourceContent1">
      <![CDATA[<img src="//c1.staticflickr.com/3/2935/13920932285_af90dee01b_b.jpg" alt="" /><br /><br />
      
      <span style="color:red;font-weight:bold;">因为 http 不支持 PUT 和 DELETE 方法，所以一个额外的 HTTP 参数 __http_method 用来模拟 PUT 和 DELETE：</span><br />
      <span style="color:green;font-weight:bold;"><input type="hidden" name="__http_method" value="DELETE" /></span>]]>
    </c:sourceContent>
    <c:sourceContent expand="true" type="" title="" style="border-top:none;"
                                  id="sourceContent1"><![CDATA[<input type="hidden" name="__http_method" value="DELETE" />]]></c:sourceContent>

    <c:sourceContent expand="true" type="" title="更新 struts.xml"
                              id="sourceContent1"><![CDATA[<struts>
    <!--constant name="struts.action.extension" value="" /-->                        <!-- URL 扩展名，默认是 .action -->           
    
    <constant name="struts.enable.SlashesInActionNames" value="true" />         <!-- 不会使用 / 来区分命名空间和 action 的名字 -->
    <constant name="struts.mapper.alwaysSelectFullNamespace" value="false" />   <!-- 最后一个 / 字符前面的所有内容是否就是某个命名空间的名字 -->
    <constant name="struts.mapper.composite" value="struts,restful2" />         <!-- 映射器的名字，可以实现自定义的映射器 -->
    <constant name="struts.mapper.class" value="composite" />                   
</struts>]]></c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[创建自定义 action 映射器]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[当应用即要实现一个 REST 式的 URL，同时又保留 .action 扩展名时，就需要编写自定义映射器]]></c:desc1>
    </c:desc>
    
    
    

    <c:sourceContent expand="true" type="" title="org.apache.struts2.dispatcher.mapper.FallbackRestful2ActionMapper.java"
                              id="sourceContent1"><![CDATA[package org.apache.struts2.dispatcher.mapper;

import org.apache.struts2.dispatcher.mapper.Restful2ActionMapper;
import org.apache.struts2.dispatcher.mapper.ActionMapping;

import javax.servlet.http.HttpServletRequest;
import java.util.*;
import java.net.URLDecoder;

import com.opensymphony.xwork2.config.ConfigurationManager;


public class FallbackRestful2ActionMapper extends Restful2ActionMapper {
    List<String> knownExtenstions = new ArrayList() {{ add("css"); add("html"); add("js"); }};

    String dropExtension(String name) {
        Iterator it = knownExtenstions.iterator();
        while (it.hasNext()) {
            String extension = "." + (String) it.next();
            if (name.endsWith(extension)) {
                return null;
            }
        }
        return name;
    }

    public ActionMapping getMapping(HttpServletRequest request, ConfigurationManager configManager) {
        if (!isSlashesInActionNames()) {
            throw new IllegalStateException("This action mapper requires the setting 'slashesInActionNames' to be set to 'true'");
        }

        // ---- from DefaultActionMapper ----------------------------------------------------
        ActionMapping mapping = new ActionMapping();
        String uri = getUri(request);

        uri = dropExtension(uri);
        if (uri == null) {
            // 返回 null 就可以阻止 Struts2 做进一步的处理
            return null;
        }

        parseNameAndNamespace(uri, mapping, configManager);

        handleSpecialParameters(request, mapping);

        if ( mapping == null || mapping.getName() == null) {
            return null;
        }

        // ---- from Restful2ActionMapper ---------------------------------------------------
        String actionName = mapping.getName();

        // Only try something if the action name is specified
        if (actionName != null && actionName.length() > 0) {
            int lastSlashPos = actionName.lastIndexOf('/');

            // If a method hasn't been explicitly named, try to guess using ReST-style patterns
            if (mapping.getMethod() == null) {

                if (lastSlashPos == actionName.length() -1) {

                    // Index e.g. foo/
                    if (isGet(request)) {
                        mapping.setMethod("index");

                    // Creating a new entry on POST e.g. foo/
                    } else if (isPost(request)) {
                        mapping.setMethod("create");
                    }

                } else if (lastSlashPos > -1) {
                    String id = actionName.substring(lastSlashPos+1);

                    // Viewing the form to create a new item e.g. foo/new
                    if (isGet(request) && "new".equals(id)) {
                        mapping.setMethod("editNew");

                    // Viewing an item e.g. foo/1
                    } else if (isGet(request)) {
                        mapping.setMethod("view");

                    // Removing an item e.g. foo/1
                    } else if (isDelete(request)) {
                        mapping.setMethod("remove");

                    // Updating an item e.g. foo/1
                    }  else if (isPut(request)) {
                        mapping.setMethod("update");
                    }

                    if (getIdParameterName() != null) {
                    	if (mapping.getParams() == null) {
                            mapping.setParams(new HashMap());
                        }
                    	mapping.getParams().put(getIdParameterName(), id);
                    }
                } 

                if (getIdParameterName() != null && lastSlashPos > -1) {
                	actionName = actionName.substring(0, lastSlashPos);
                }
            }

            // Try to determine parameters from the url before the action name
            int actionSlashPos = actionName.lastIndexOf('/', lastSlashPos - 1);
            if (actionSlashPos > 0 && actionSlashPos < lastSlashPos) {
                String params = actionName.substring(0, actionSlashPos);
                HashMap<String,String> parameters = new HashMap<String,String>();
                try {
                    StringTokenizer st = new StringTokenizer(params, "/");
                    boolean isNameTok = true;
                    String paramName = null;
                    String paramValue;

                    while (st.hasMoreTokens()) {
                        if (isNameTok) {
                            paramName = URLDecoder.decode(st.nextToken(), "UTF-8");
                            isNameTok = false;
                        } else {
                            paramValue = URLDecoder.decode(st.nextToken(), "UTF-8");

                            if ((paramName != null) && (paramName.length() > 0)) {
                                parameters.put(paramName, paramValue);
                            }

                            isNameTok = true;
                        }
                    }
                    if (parameters.size() > 0) {
                        if (mapping.getParams() == null) {
                            mapping.setParams(new HashMap());
                        }
                        mapping.getParams().putAll(parameters);
                    }
                } catch (Exception e) {
                    LOG.warn(e);
                }
                mapping.setName(actionName.substring(actionSlashPos+1));
            }
        }

        return mapping;
    }
}]]></c:sourceContent>
    <c:sourceContent expand="true" type="" title="更新 struts.xml"
                              id="sourceContent1"><![CDATA[<struts>
    <!-- 为新的映射器配置一个新的 bean -->
    <bean type="org.apache.struts2.dispatcher.mapper.ActionMapper" name="fallback"
          class="org.apache.struts2.dispatcher.mapper.FallbackRestful2ActionMapper" />

    <!-- 例如: /event/2 这个 URL 将在 action 被调用时，调用 setId(2) 方法 -->
    <constant name="struts.mapper.idParameterName" value="id" />

    <constant name="struts.enable.SlashesInActionNames" value="true" />
    <constant name="struts.mapper.alwaysSelectFullNamespace" value="false" />
    <constant name="struts.mapper.composite" value="struts,fallback" />
    <constant name="struts.mapper.class" value="composite" />
</struts>]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[Ajax]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[使用 Dojo Toolkit 来提供 Ajax 特性，<a href="http://dojotoolkit.org" target="_blank">Dojo Toolkit</a> 将集中常用的库集成起来， 
      包括：<a href="http://developer.yahoo.com/yui" target="_blank">YUI</a>、<a href="http://www.prototypejs.org" target="_blank">Prototype</a> 等。]]></c:desc1>
    </c:desc>    
    <c:sourceContent expand="true" type="" title="更新 struts.xml"
                              id="sourceContent1">
      <![CDATA[...]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  </c:component>
