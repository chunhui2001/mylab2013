<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract style="font-size:1em;line-height:1.6em;">
    <![CDATA[
<img src="/images/jvm-1.jpg" style="max-width:100%" />

]]>
  </c:abstract>
  

  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[<h1 style="font-size:2.1em;color:blue;">JVM 性能调优监控工具</h1>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[JDK 本身提供了很多方便的 JVM 性能调优监控工具，除了集成式的 <b>VisualVM</b> 和 <b>jConsole</b> 外，还有 <b>jps</b>、<b>jstack</b>、<b>jmap</b>、<b>jhat</b>、<b>jstat</b> 等小巧的工具]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="jps" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
      参数选项:<br />
<b>-q</b> 不输出类名、Jar名和传入main方法的参数<br />
<b>-m</b> 输出传入main方法的参数<br />
<b>-l</b> 输出main类或Jar的全限名<br />
<b>-v</b> 输出传入JVM的参数
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
jps -m -l -v 
80130 com.strategicgains.oauth.Main
80341 sun.tools.jps.Jps -m -l -v -Dapplication.home=/usr/local/jdk1.8.0_101 -Xms8m
    ]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="jstack" id="sourceContent1"
                     style="margin-top:1.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
<b>主要用来查看某个 Java 进程内的线程堆栈信息。语法格式如下：</b><br />
jstack [option] pid<br />
jstack [option] executable core<br />
jstack [option] [server-id@]remote-hostname-or-ip</div>

<div style="margin-top:.6em;">
<b>命令行参数选项说明如下</b>：<br />
<b>-l long listings</b>，会打印出额外的锁信息，在发生死锁时可以用 <b>jstack -l pid</b> 来观察锁持有情况<br />
<b>m mixed mode</b>，不仅会输出Java堆栈信息，还会输出 C/C++ 堆栈信息（比如 Native方 法）</div>

<div style="margin-top:.6em;">
stack 可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在 JVM 性能调优中使用得非常多。下面我们来一个实例找出某个 Java 进程中最耗费 CPU 的 Java 线程并定位堆栈信息，用到的命令有 <b>ps、top、printf、jstack、grep</b>。</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
# 观察锁持有情况
$ jstack -l [pid]

# 找出该进程内最耗费 CPU 的线程
$ top -Hp [pid]

# 求线程 ID 的 16 进制值
printf "%x\n" [pid]

# 显示线程堆栈信息
$ jstack [pid] | grep [线程ID的16进制值]
  > "DestroyJavaVM" #49 prio=5 os_prio=0 tid=0x00007f3200009800 nid=0x13903 waiting on condition [0x0000000000000000]
    ]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="jmap（Memory Map）和jhat（Java Heap Analysis Tool）" id="sourceContent1"
                     style="margin-top:1.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
<b>jmap 语法格式如下：</b><br />
jmap [option] pid <br />
jmap [option] executable core <br />
jmap [option] [server-id@]remote-hostname-or-ip <br />
<i style="color:gray;">如果运行在64位JVM上，可能需要指定-J-d64命令选项参数。</i></div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
# 使用 jmap -heap pid 查看进程堆内存使用情况，包括使用的GC算法、堆配置参数和各代中堆内存使用情况:
$ jmap -heap [pid]

# 使用 jmap -histo[:live] [pid] 查看堆内存中的对象数目、大小统计直方图，如果带上 live 则只统计活对象，如下：
$ jmap -histo:live [pid] | more

# 用 jmap 把进程内存使用情况 dump 到文件中，再用 jhat 分析查看
$ jmap -dump:format=b,file=/tmp/dump.dat [pid]  

 # dump 出来的文件可以用 MAT、VisualVM 等工具查看，这里用 jhat 查看：
 $ jhat -port 9998 /tmp/dump.dat
    ]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="jstat" id="sourceContent1"
                     style="margin-top:1.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
<b>jstat 语法格式如下：：</b><br />
jstat [ generalOption | outputOptions vmid [interval[s|ms] [count]] ] <br />
<i style="color:gray;"> vmid 是虚拟机 ID，在 Linux/Unix 系统上一般就是进程 ID。interval 是采样时间间隔。count 是采样数目。比如下面输出的是 GC 信息，采样时间间隔为 250ms，采样数为 4：</i></div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<img src="/images/heap.jpg" />

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
# 要明白上面输出的意义，先看 jvm 堆内存布局.
$ jstat -gc 21711 250 4
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.8em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<img src="/images/heap-flag.jpg" style="width:100%;" />
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[<br />
堆内存 = 年轻代 + 年老代 + 永久代<br />
年轻代 = Eden区 + 两个Survivor区（From和To）<br /><br />
<b>S0C、S1C、S0U、S1U</b>：Survivor 0/1区容量（Capacity）和使用量（Used）<br />
<b>EC、EU</b>：Eden区容量和使用量<br />
<b>OC、OU</b>：年老代容量和使用量<br />
<b>PC、PU</b>：永久代容量和使用量<br />
<b>YGC、YGT</b>：年轻代GC次数和GC耗时<br />
<b>FGC、FGCT</b>：Full GC次数和Full GC耗时<br />
<b>GCT</b>：GC总耗时

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[<h1 style="font-size:2.1em;color:blue;">JVM 堆内存设置原理</h1>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[<div>JVM 堆内存分为 2 块：Permanent Space 和 Heap Space。</div>
<ul style="list-style: inherit;
    margin-left: 1.5em;">
    <li>Permanent 即 持久代（Permanent Generation），主要存放的是 Java 类定义信息，与垃圾收集器要收集的 Java 对象关系不大。</li>
    <li>Heap = { Old + NEW = {Eden, from, to} }，Old 即 年老代（Old Generation），New 即 年轻代（Young Generation）。年老代和年轻代的划分对垃圾收集影响比较大。</li>
</ul>]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="年轻代" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
      所有新生成的对象首先都是放在年轻代。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。年轻代一般分3个区，1个Eden区，2个Survivor区（from 和 to）。</div>
<div style="margin-top:.5em;">
大部分对象在Eden区中生成。当Eden区满时，还存活的对象将被复制到Survivor区（两个中的一个），当一个Survivor区满时，此区的存活对象将被复制到另外一个Survivor区，当另一个Survivor区也满了的时候，从前一个Survivor区复制过来的并且此时还存活的对象，将可能被复制到年老代。</div>

<div style="margin-top:.5em;">
2个Survivor区是对称的，没有先后关系，所以同一个Survivor区中可能同时存在从Eden区复制过来对象，和从另一个Survivor区复制过来的对象；而复制到年老区的只有从另一个Survivor区过来的对象。而且，因为需要交换的原因，Survivor区至少有一个是空的。特殊的情况下，根据程序需要，Survivor区是可以配置为多个的（多于2个），这样可以增加对象在年轻代中的存在时间，减少被放到年老代的可能。</div>
<div style="margin-top:.5em;">
针对年轻代的垃圾回收即 Young GC。</div>

<div style="margin-top:.5em;">
<img src="/images/yang-space.jpg" /> </div>

<div style="margin-top:.5em;">
对象的内存分配，往大方向上讲就是在堆上分配，对象主要分配在新生代的Eden Space和From Space，少数情况下会直接分配在老年代。如果新生代的Eden Space和From Space的空间不足，则会发起一次GC，如果进行了GC之后，Eden Space和From Space能够容纳该对象就放在Eden Space和From Space。在GC的过程中，会将Eden Space和From  Space中的存活对象移动到To Space，然后将Eden Space和From Space进行清理。如果在清理的过程中，To Space无法足够来存储某个对象，就会将该对象移动到老年代中。在进行了GC之后，使用的便是Eden space和To Space了，下次GC时会将存活对象复制到From Space，如此反复循环。当对象在Survivor区躲过一次GC的话，其对象年龄便会加1，默认情况下，如果对象年龄达到15岁，就会移动到老年代中。</div>

<div style="margin-top:.5em;">
一般来说，大对象会被直接分配到老年代，所谓的大对象是指需要大量连续存储空间的对象，最常见的一种大对象就是大数组，比如：byte[] data = new byte[4*1024*1024]</div>

<div style="margin-top:.5em;">
这种一般会直接在老年代分配存储空间。当然分配的规则并不是百分之百固定的，这要取决于当前使用的是哪种垃圾收集器组合和JVM的相关参数。</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="年老代" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
      在年轻代中经历了N次（可配置）垃圾回收后仍然存活的对象，就会被复制到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</div>
<div style="margin-top:.5em;">
针对年老代的垃圾回收即 Full GC。</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="持久代" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
      用于存放静态类型数据，如 Java Class, Method 等。持久代对垃圾回收没有显著影响。但是有些应用可能动态生成或调用一些Class，例如 hibernate CGLib 等，在这种时候往往需要设置一个比较大的持久代空间来存放这些运行过程中动态增加的类型。</div>
<div style="margin-top:.5em;">
所以，当一组对象生成时，内存申请过程如下：</div>

<ul style="list-style-type: decimal;;
    margin-left: 2.3em;">
    <li>JVM 会试图为相关 Java 对象在年轻代的 Eden 区中初始化一块内存区域。</li>
  <li>当 Eden 区空间足够时，内存申请结束。否则执行下一步。</li>
  <li>JVM 试图释放在 Eden 区中所有不活跃的对象（Young GC）。释放后若 Eden 空间仍然不足以放入新对象，JVM 则试图将部分 Eden 区中活跃对象放入 Survivor 区。</li>
  <li>Survivor 区被用来作为 Eden 区及年老代的中间交换区域。当年老代空间足够时，Survivor 区中存活了一定次数的对象会被移到年老代。</li>
  <li>当年老代空间不够时，JVM 会在年老代进行完全的垃圾回收（Full GC）。</li>
  <li>Full GC 后，若 Survivor 区及年老代仍然无法存放从 Eden 区复制过来的对象，则会导致 JVM 无法在 Eden 区为新生成的对象申请内存，即出现 “Out of Memory”。
  </li>
</ul>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="OOM（“Out of Memory”）异常一般主要有如下2种原因：" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[

<ul style="list-style-type: decimal;;
    margin-left: 2.3em;">
    <li>年老代溢出，表现为：java.lang.OutOfMemoryError:Javaheapspace
这是最常见的情况，产生的原因可能是：设置的内存参数 Xmx 过小或程序的内存泄露及使用不当问题。
例如循环上万次的字符串处理、创建上千万个对象、在一段代码内申请上百M甚至上G的内存。还有的时候虽然不会报内存溢出，却会使系统不间断的垃圾回收，也无法处理其它请求。这种情况下除了检查程序、打印堆内存等方法排查，还可以借助一些内存分析工具，比如 MAT 就很不错。</li>
  <li>持久代溢出，表现为：java.lang.OutOfMemoryError:PermGenspace
通常由于持久代设置过小，动态加载了大量Java类而导致溢出，解决办法唯有将参数 -XX:MaxPermSize 调大（一般256m能满足绝大多数应用程序需求）。将部分Java类放到容器共享区（例如 Tomcat share lib）去加载的办法也是一个思路，但前提是容器里部署了多个应用，且这些应用有大量的共享类库。</li>
</ul>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="参数说明" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[

<ul style="list-style-type: disc;;
    margin-left: 2em;">
<li>-Xmx3550m：设置JVM最大堆内存为3550M。</li>
<li>-Xms3550m：设置JVM初始堆内存为3550M。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。</li>
<li>-Xss128k：设置每个线程的栈大小。JDK5.0以后每个线程栈大小为1M，之前每个线程栈大小为256K。应当根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。需要注意的是：当这个值被设置的较大（例如>2MB）时将会在很大程度上降低系统的性能。</li>
<li>-Xmn2g：设置年轻代大小为2G。在整个堆内存大小确定的情况下，增大年轻代将会减小年老代，反之亦然。此值关系到JVM垃圾回收，对系统性能影响较大，官方推荐配置为整个堆大小的3/8。</li>
<li>-XX:NewSize=1024m：设置年轻代初始值为1024M。</li>
<li>-XX:MaxNewSize=1024m：设置年轻代最大值为1024M。</li>
<li>-XX:PermSize=256m：设置持久代初始值为256M。</li>
<li>-XX:MaxPermSize=256m：设置持久代最大值为256M。</li>
<li>-XX:NewRatio=4：设置年轻代（包括1个Eden和2个Survivor区）与年老代的比值。表示年轻代比年老代为1:4。</li>
<li>-XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的比值。表示2个Survivor区（JVM堆内存年轻代中默认有2个大小相等的Survivor区）与1个Eden区的比值为2:4，即1个Survivor区占整个年轻代大小的1/6。</li>
<li>-XX:MaxTenuringThreshold=7：表示一个对象如果在Survivor区（救助空间）移动了7次还没有被垃圾回收就进入年老代。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代，对于需要大量常驻内存的应用，这样做可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象在年轻代存活时间，增加对象在年轻代被垃圾回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。</li>
</ul>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="疑问解答" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div><b>-Xmn，-XX:NewSize/-XX:MaxNewSize，-XX:NewRatio</b> 3组参数都可以影响年轻代的大小，混合使用的情况下，优先级是什么？
如下：</div>
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li>高优先级：-XX:NewSize/-XX:MaxNewSize </li>
<li>中优先级：-Xmn（默认等效  -Xmn=-XX:NewSize=-XX:MaxNewSize=?） </li>
<li>低优先级：-XX:NewRatio </li>
</ul>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="垃圾回收器选择" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>JVM 给出了3种选择：串行收集器、并行收集器、并发收集器。串行收集器只适用于小数据量的情况，所以生产环境的选择主要是并行收集器和并发收集器。</div>
<div>默认情况下 JDK5.0 以前都是使用串行收集器，如果想使用其他收集器需要在启动时加入相应参数。JDK5.0 以后，JVM 会根据当前系统配置进行智能判断。</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="串行收集器" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>-XX:+UseSerialGC：设置串行收集器。</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="并行收集器（吞吐量优先）" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li><b>-XX:+UseParallelGC</b>：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。</li>
<li><b>-XX:ParallelGCThreads=20</b>：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收。此值建议配置与CPU数目相等。</li>
<li><b>-XX:+UseParallelOldGC</b>：配置年老代垃圾收集方式为并行收集。JDK6.0开始支持对年老代并行收集。</li>
<li><b>-XX:MaxGCPauseMillis=100</b>：设置每次年轻代垃圾回收的最长时间（单位毫秒）。如果无法满足此时间，JVM会自动调整年轻代大小，以满足此时间。</li>
<li><b>-XX:+UseAdaptiveSizePolicy</b>：设置此选项后，并行收集器会自动调整年轻代Eden区大小和Survivor区大小的比例，以达成目标系统规定的最低响应时间或者收集频率等指标。此参数建议在使用并行收集器时，一直打开。</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="并发收集器（响应时间优先）" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li><b>-XX:+UseConcMarkSweepGC</b>：即CMS收集，设置年老代为并发收集。CMS收集是JDK1.4后期版本开始引入的新GC算法。它的主要适合场景是对响应时间的重要性需求大于对吞吐量的需求，能够承受垃圾回收线程和应用线程共享CPU资源，并且应用中存在比较多的长生命周期对象。CMS收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存。</li>
<li><b>-XX:+UseParNewGC</b>：设置年轻代为并发收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此参数。</li>
<li><b>-XX:CMSFullGCsBeforeCompaction=0</b>：由于并发收集器不对内存空间进行压缩和整理，所以运行一段时间并行收集以后会产生内存碎片，内存使用效率降低。此参数设置运行0次Full GC后对内存空间进行压缩和整理，即每次Full GC后立刻开始压缩和整理内存。</li>
<li><b>-XX:+UseCMSCompactAtFullCollection</b>：打开内存空间的压缩和整理，在Full GC后执行。可能会影响性能，但可以消除内存碎片。</li>
<li><b>-XX:+CMSIncrementalMode</b>：设置为增量收集模式。一般适用于单CPU情况。</li>
<li><b>-XX:CMSInitiatingOccupancyFraction=70</b>：表示年老代内存空间使用到70%时就开始执行CMS收集，以确保年老代有足够的空间接纳来自年轻代的对象，避免Full GC的发生。</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="其它垃圾回收参数" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li><b>-XX:+ScavengeBeforeFullGC</b>：年轻代GC优于Full GC执行。</li>
<li><b>-XX:-DisableExplicitGC</b>：不响应 System.gc() 代码。</li>
<li><b>-XX:+UseThreadPriorities</b>：启用本地线程优先级API。即使 java.lang.Thread.setPriority() 生效，不启用则无效。</li>
<li><b>-XX:SoftRefLRUPolicyMSPerMB=0</b>：软引用对象在最后一次被访问后能存活0毫秒（JVM默认为1000毫秒）。</li>
<li><b>-XX:TargetSurvivorRatio=90</b>：允许90%的Survivor区被占用（JVM默认为50%）。提高对于Survivor区的使用率。</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="辅助信息参数设置" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li><b>-XX:-CITime</b>：打印消耗在JIT编译的时间。</li>
<li><b>-XX:ErrorFile=./hs_err_pid.log</b>：保存错误日志或数据到指定文件中。</li>
<li><b>-XX:HeapDumpPath=./java_pid.hprof</b>：指定Dump堆内存时的路径。</li>
<li><b>-XX:-HeapDumpOnOutOfMemoryError</b>：当首次遭遇内存溢出时Dump出此时的堆内存。</li>
<li><b>-XX:OnError=";"</b>：出现致命ERROR后运行自定义命令。</li>
<li><b>-XX:OnOutOfMemoryError=";"</b>：当首次遭遇内存溢出时执行自定义命令。</li>
<li><b>-XX:-PrintClassHistogram</b>：按下 Ctrl+Break 后打印堆内存中类实例的柱状信息，同JDK的 jmap -histo 命令。</li>
<li><b>-XX:-PrintConcurrentLocks</b>：按下 Ctrl+Break 后打印线程栈中并发锁的相关信息，同JDK的 jstack -l 命令。</li>
<li><b>-XX:-PrintCompilation</b>：当一个方法被编译时打印相关信息。</li>
<li><b>-XX:-PrintGC</b>：每次GC时打印相关信息。</li>
<li><b>-XX:-PrintGCDetails</b>：每次GC时打印详细信息。</li>
<li><b>-XX:-PrintGCTimeStamps</b>：打印每次GC的时间戳。</li>
<li><b>-XX:-TraceClassLoading</b>：跟踪类的加载信息。</li>
<li><b>-XX:-TraceClassLoadingPreorder</b>：跟踪被引用到的所有类的加载信息。</li>
<li><b>-XX:-TraceClassResolution</b>：跟踪常量池。</li>
<li><b>-XX:-TraceClassUnloading</b>：跟踪类的卸载信息。</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="关于参数名称等" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li>标准参数（-），所有JVM都必须支持这些参数的功能，而且向后兼容；例如：</li>
<li>-client —— 设置JVM使用Client模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试；在32位环境下直接运行Java程序默认启用该模式。</li>
<li>-server —— 设置JVM使Server模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64位能力的JDK环境下默认启用该模式。</li>
<li>非标准参数（-X），默认JVM实现这些参数的功能，但是并不保证所有JVM实现都满足，且不保证向后兼容；</li>
<li>非稳定参数（-XX），此类参数各个JVM实现会有所不同，将来可能会不被支持，需要慎重使用；</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="JVM 服务参数调优实战" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:red;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
承受海量访问的动态 Web 应用<br />
服务器配置：<b>8 CPU, 8G MEM, JDK 1.6.X</b><br />
参数方案：<b>-server -Xmx3550m -Xms3550m -Xmn1256m -Xss128k -XX:SurvivorRatio=6 -XX:MaxPermSize=256m -XX:ParallelGCThreads=8 -XX:MaxTenuringThreshold=0 -XX:+UseConcMarkSweepGC</b>
</div>
<div style="margin-top:.5em;">
<b>调优说明：</b>
</div>
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li><b>-Xmx</b> 与 <b>-Xms</b> 相同以避免JVM反复重新申请内存。<b>-Xmx</b> 的大小约等于系统内存大小的一半，即充分利用系统资源，又给予系统安全运行的空间。</li>
<li><b>-Xmn1256m</b> 设置年轻代大小为 1256MB。此值对系统性能影响较大，Sun官方推荐配置年轻代大小为整个堆的3/8。</li>
<li><b>-Xss128k</b> 设置较小的线程栈以支持创建更多的线程，支持海量访问，并提升系统性能。</li>
<li><b>-XX:SurvivorRatio=6</b> 设置年轻代中Eden区与Survivor区的比值。系统默认是8，根据经验设置为6，则2个Survivor区与1个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。</li>
<li><b>-XX:ParallelGCThreads=8</b> 配置并行收集器的线程数，即同时8个线程一起进行垃圾回收。此值一般配置为与CPU数目相等。</li>
<li><b>-XX:MaxTenuringThreshold=0</b> 设置垃圾最大年龄（在年轻代的存活次数）。如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。对于年老代比较多的应用，可以提高效率；如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。根据被海量访问的动态Web应用之特点，其内存要么被缓存起来以减少直接访问DB，要么被快速回收以支持高并发海量请求，因此其内存对象在年轻代存活多次意义不大，可以直接进入年老代，根据实际应用效果，在这里设置此值为0。</li>
<li><b>-XX:+UseConcMarkSweepGC</b> 设置年老代为并发收集。CMS（ConcMarkSweepGC）收集的目标是尽量减少应用的暂停时间，减少Full GC发生的几率，利用和应用程序线程并发的垃圾回收线程来标记清除年老代内存，适用于应用中存在比较多的长生命周期对象的情况。</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="内部集成构建服务器案例" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:red;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
高性能数据处理的工具应用<br />
服务器配置：<b>1 CPU, 4G MEM, JDK 1.6.X</b><br />
参数方案：<b>-server -XX:PermSize=196m -XX:MaxPermSize=196m -Xmn320m -Xms768m -Xmx1024m</b>
</div>
<div style="margin-top:.5em;">
<b>调优说明：</b>
</div>
<ul style="list-style-type: disc;
    margin-left: 2.3em;">
<li><b>-XX:PermSize=196m -XX:MaxPermSize=196m</b> 根据集成构建的特点，大规模的系统编译可能需要加载大量的Java类到内存中，所以预先分配好大量的持久代内存是高效和必要的。</li>
<li><b>-Xmn320m</b> 遵循年轻代大小为整个堆的3/8原则。</li>
<li><b>-Xms768m -Xmx1024m</b> 根据系统大致能够承受的堆内存大小设置即可。</li>
</ul>

<div style="margin-top:.5em;">在 64 位服务器上运行应用程序，构建执行时。用 <b>jmap -heap 11540</b> 命令观察 JVM 堆内存状况如下：</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="内部集成构建服务器案例" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:red;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
Attaching to process ID 11540, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 20.12-b01


using thread-local object allocation.
Parallel GC with 4 thread(s)


Heap Configuration:
   MinHeapFreeRatio = 40
   MaxHeapFreeRatio = 70
   MaxHeapSize      = 1073741824 (1024.0MB)
   NewSize          = 335544320 (320.0MB)
   MaxNewSize       = 335544320 (320.0MB)
   OldSize          = 5439488 (5.1875MB)
   NewRatio         = 2
   SurvivorRatio    = 8
   PermSize         = 205520896 (196.0MB)
   MaxPermSize      = 205520896 (196.0MB)


Heap Usage:
PS Young Generation
Eden Space:
   capacity = 255852544 (244.0MB)
   used     = 101395504 (96.69828796386719MB)
   free     = 154457040 (147.3017120361328MB)
   39.63044588683081% used
From Space:
   capacity = 34144256 (32.5625MB)
   used     = 33993968 (32.41917419433594MB)
   free     = 150288 (0.1433258056640625MB)
   99.55984397492803% used
To Space:
   capacity = 39845888 (38.0MB)
   used     = 0 (0.0MB)
   free     = 39845888 (38.0MB)
   0.0% used
PS Old Generation
   capacity = 469762048 (448.0MB)
   used     = 44347696 (42.29325866699219MB)
   free     = 425414352 (405.7067413330078MB)
   9.440459523882184% used
PS Perm Generation
   capacity = 205520896 (196.0MB)
   used     = 85169496 (81.22396087646484MB)
   free     = 120351400 (114.77603912353516MB)
   41.440796365543285% used
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:red;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[结果是比较健康的。]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  



  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[<h1 style="font-size:2.1em;color:blue;">Java 中堆内存和栈内存详解</h1>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[Java 把内存分成两种，一种叫做<b>栈内存</b>，一种叫做<b>堆内存</b>]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
      在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。</div>
<div style="margin-top:.5em;">
堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。</div>

<div style="margin-top:.5em;">
引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!</div>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[<h1 style="font-size:2.1em;color:blue;">java 中内存分配策略及堆和栈的比较</h1>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="内存分配策略 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>
      按照编译原理的观点,程序运行时的内存分配有三种策略,分别是<b>静态的</b>,<b>栈式的</b>,和<b>堆式的</b>. </div>
<div style="margin-top:.5em;"><b>静态存储分配</b>是指在编译时就能确定每个数据目标在运行时刻的存储空间需求,因而在编译时就可以给他们分配固定的内存空间.这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在,也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求. </div>

<div style="margin-top:.5em;">栈式存储分配也可称为动态存储分配,是由一个类似于堆栈的运行栈来实现的.和静态存储分配相反,在栈式存储方案中,程序对数据区的需求在编译时是完全未知的,只有到运行的时候才能够知道,但是规定在运行中进入一个程序模块时,必须知道该程序模块所需的数据区大小才能够为其分配内存.和我们在数据结构所熟知的栈一样,栈式存储分配按照先进后出的原则进行分配。 
</div>
<div style="margin-top:.5em;">静态存储分配要求在编译时能知道所有变量的存储要求,栈式存储分配要求在过程的入口处必须知道所有的存储要求,而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配,比如可变长度串和对象实例.堆由大片的可利用块或空闲块组成,堆中的内存可以按照任意顺序分配和释放. </div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="堆和栈的比较 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>上面的定义从编译原理的教材中总结而来,除静态存储分配之外,都显得很呆板和难以理解,下面撇开静态存储分配,集中比较堆和栈.</div>
<div style="margin-top:.5em;">从堆和栈的功能和作用来通俗的比较, <b style="color:deeppink;">堆主要用来存放对象的</b>，<b style="color:deeppink;">栈主要是用来执行程序的</b>.而这种不同又主要是由于堆和栈的特点决定的: 
</div>
<div style="margin-top:.5em;">在编程中，例如C/C++中，<b style="color:deeppink;">所有的方法调用都是通过栈来进行的,所有的局部变量,形式参数都是从栈中分配内存空间的。实际上也不是什么分配,只是从栈顶向上用就行,就好像工厂中的传送带(conveyor belt)一样, Stack Pointer 会自动指引你到放东西的位置, 你所要做的只是把东西放下来就行.退出函数的时候，修改栈指针就可以把栈中的内容销毁</b>.这样的模式速度最快, 当然要用来运行程序了.需要注意的是,在分配的时候,比如为一个即将要调用的程序模块分配数据区时,应事先知道这个数据区的大小,也就说是<b style="color:deeppink;">虽然内存分配是在程序运行时进行的,但是分配的大小多少是确定的,不变的,而这个"大小多少"是在编译时确定的,不是在运行时</b>. </div>
<div style="margin-top:.5em;"><b style="color:deeppink;">堆是应用程序在运行的时候请求操作系统分配给自己内存，由于从操作系统管理的内存分配,所以在分配和销毁时都要占用时间，因此用堆的效率非常低.但是堆的优点在于,编译器不必知道要从堆里分配多少存储空间，也不必知道存储的数据要在堆里停留多长的时间,因此,用堆保存数据时会得到更大的灵活性</b>。事实上,面向对象的多态性,堆内存分配是必不可少的,因为多态变量所需的存储空间只有在运行时创建了对象之后才能确定.在C++中，要求创建一个对象时，只需用 new 命令编制相关的代码即可。执行这些代码时，会在堆里自动进行数据的保存.当然，为达到这种灵活性，必然会付出一定的代价:在堆里分配存储空间时会花掉更长的时间!这也正是导致我们刚才所说的效率低的原因. </div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="JVM中的堆和栈 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>JVM是基于堆栈的虚拟机.JVM为每个新创建的线程都分配一个堆栈.也就是说,对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。</div>

<div style="margin-top:.5em;">我们知道,某个线程正在执行的方法称为此线程的当前方法.我们可能不知道,当前方法使用的帧称为当前帧。当线程激活一个Java方法,JVM就会在线程的 Java堆栈里新压入一个帧。这个帧自然成为了当前帧.在此方法执行期间,这个帧将用来保存参数,局部变量,中间计算过程和其他数据.这个帧在这里和编译原理中的活动纪录的概念是差不多的. </div>

<div style="margin-top:.5em;">从Java的这种分配机制来看,堆栈又可以这样理解:堆栈(Stack)是操作系统在建立某个进程时或者线程(在支持多线程的操作系统中是线程)为这个线程建立的存储区域，该区域具有先进后出的特性。 </div>

<div style="margin-top:.5em;">每一个Java应用都唯一对应一个JVM实例，每一个实例唯一对应一个堆。应用程序在运行中所创建的所有类实例或数组都放在这个堆中,并由应用所有的线程共享.跟C/C++ 不同，Java 中分配堆内存是自动初始化的。Java 中所有对象的存储空间都是在堆中分配的，但是这个对象的引用却是在堆栈中分配,也就是说在建立一个对象时从两个地方都分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。 </div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Java 中的堆和栈 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>Java把内存划分成两种：一种是栈内存，一种是堆内存。 </div>

<div style="margin-top:.5em;">在函数中定义的一些基本类型的变量和对象的引用变量都在函数的栈内存中分配。 </div>

<div style="margin-top:.5em;">当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，当超过变量的作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。 </div>

<div style="margin-top:.5em;">堆内存用来存放由new创建的对象和数组。 </div>

<div style="margin-top:.5em;">在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。 </div>

<div style="margin-top:.5em;">在堆中产生了一个数组或对象后，还可以在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或对象的引用变量。 </div>

<div style="margin-top:.5em;">引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。 </div>

<div style="margin-top:.5em;">具体的说： 栈与堆都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。 
</div>

<div style="margin-top:.5em;">Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。 </div>

<div style="margin-top:.5em;">栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主要存放一些基本类型的变量(,int, short, long, byte, float, double, boolean, char)和对象句柄。 </div>

<div style="margin-top:.5em;">栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：  </div>

<div style="margin-top:.5em;">int a = 3; 
<br />
int b = 3; 
 </div>

<div style="margin-top:.5em;">编译器先处理int a = 3;首先它会在栈中创建一个变量为a的引用，然后查找栈中是否有3这个值，如果没找到，就将3存放进来，然后将a指向3。接着处理int b = 3;在创建完b的引用变量后，因为在栈中已经有3这个值，便将b直接指向3。这样，就出现了a与b同时均指向3的情况。这时，如果再令a=4;那么编译器会重新搜索栈中是否有4值，如果没有，则将4存放进来，并令a指向4;如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。要注意这种数据的共享与两个对象的引用同时指向一个对象的这种共享是不同的，因为这种情况a的修改并不会影响到b, 它是由编译器完成的，它有利于节省空间。而一个对象引用变量修改了这个对象的内部状态，会影响到另一个对象引用变量 
 </div>

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>







  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[<h1 style="font-size:2.1em;color:blue;">Java 垃圾回收机制与典型的垃圾回收算法</h1>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="垃圾判定算法: 引用计数法 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
在 java 中是通过引用来和对象进行关联的，也就是说如果要操作对象，必须通过引用来进行。那么很显然一个简单的办法就是通过引用计数来判断一个对象是否可以被回收。不失一般性，<b style="color:deeppink;">如果一个对象没有任何引用与之关联，则说明该对象基本不太可能在其他地方被使用到，那么这个对象就成为可被回收的对象了</b>。这种方式成为引用计数法。这种方式的特点是实现简单，而且效率较高，<b style="color:deeppink;">但是它无法解决循环引用的问题</b>，因此在Java中并没有采用这种方式 。

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="垃圾判定算法: 可达性分析法 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
为了解决 ”引用计数法“ 问题，在Java中采取了 可达性分析法。该方法的基本思想是 <b style="color:deeppink;">通过一系列的 “GC Roots” 对象作为起点进行搜索，如果在 “GC Roots” 和一个对象之间没有可达路径，则称该对象是不可达的</b>，不过要注意的是被判定为不可达的对象不一定就会成为可回收对象。被判定为不可达的对象要成为可回收对象必须至少经历两次标记过程，如果在这两次标记过程中仍然没有逃脱成为可回收对象的可能性，则基本上就真的成为可回收对象了。

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="垃圾回收算法: Mark-Sweep（标记-清除）算法 " id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
这是最基础的垃圾回收算法，之所以说它是最基础的是因为它最容易实现，思想也是最简单的。标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间
<img src="/images/mark-sweep.jpg" />
<br />从图中可以很容易看出标记-清除算法实现起来比较容易，但是有一个比较严重的问题就是 <b style="color:deeppink;">容易产生内存碎片</b>，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="垃圾回收算法: Copying（复制）算法" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
为了解决Mark-Sweep算法的缺陷，Copying算法就被提了出来。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。具体过程如下图所示：
<img src="/images/copying.jpg" />
<br />这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying 算法的效率跟存活对象的数目多少有很大的关系，如果 <b style="color:deeppink;">存活对象很多，那么 Copying 算法的效率将会大大降低</b>。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="垃圾回收算法: Mark-Compact（标记-整理）算法" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
为了解决 Copying 算法的缺陷，充分利用内存空间，提出了 Mark-Compact 算法。该算法标记阶段和 Mark-Sweep 一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。具体过程如下图所示：：
<img src="/images/mark-compact.jpg" />    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="垃圾回收算法: Generational Collection（分代收集）算法" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
<div>分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是 <b style="color:deeppink;">根据对象存活的生命周期将内存划分为若干个不同的区域</b> 。一般情况下将堆区划分为 <b>老年代（Tenured Generation）</b>和 <b>新生代（Young Generation）</b>，老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以<b style="color:deeppink;">根据不同代的特点采取最适合的收集算法</b>。</div>

<div style="margin-top:.5em;">目前大部分垃圾收集器对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照 1：1 的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 空间和其中的一块 Survivor 空间，当进行回收时，将 Eden 和 Survivor 中还存活的对象复制到另一块 Survivor 空间中，然后清理掉 Eden 和刚才使用过的 Survivor 空间。</div>

<div style="margin-top:.5em;">而由于老年代的特点是每次回收都只回收少量对象，一般使用的是 Mark-Compact 算法。</div>

<div style="margin-top:.5em;">注意，在堆区之外还有一个代就是永久代（Permanet Generation），它用来存储 class 类、常量、方法描述等。对永久代的回收主要回收两部分内容：废弃常量和无用的类。</div>
   ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>








  <c:entry style="margin-top:2em;">
    <c:title><![CDATA[<h1 style="font-size:2.1em;color:blue;">典型的垃圾收集器</h1>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[垃圾收集算法是内存回收的理论基础，而垃圾收集器就是内存回收的具体实现。下面介绍一下HotSpot（JDK 7)虚拟机提供的几种垃圾收集器，用户可以根据自己的需求组合出各个年代使用的收集器。]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="Serial/Serial Old" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
Serial/Serial Old 收集器是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial 收集器是针对新生代的收集器，采用的是 Copying 算法，Serial Old 收集器是针对老年代的收集器，采用的是 Mark-Compact 算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="ParNew" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
ParNew收集器是Serial收集器的多线程版本，使用多个线程进行垃圾收集。

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Parallel Scavenge" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
Parallel Scavenge收集器是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Parallel Old" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
Parallel Old是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和Mark-Compact算法。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="CMS" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
CMS（Current Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是Mark-Sweep算法。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="G1" id="sourceContent1"
                     style="margin-top:.6em;"
                     titleStyle="padding-left:0;color:black;font-size:1.3em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.95em;line-height:1.6em;font-family:monospace;">
      <![CDATA[
G1收集器是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


</c:component>
