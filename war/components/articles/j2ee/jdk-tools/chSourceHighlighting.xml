<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract style="font-size:1em;line-height:1.6em;">
    <![CDATA[

]]>
  </c:abstract>
  

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之jps（JVM Process Status Tools）]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。
</div>
<div style="margin-top:.625em;">
    我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="jps 显示当前系统的java进程情况" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
$> jps
23991 Jps
23789 BossMain
23651 Resin
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$>  jps -q
28680
23789
23651
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -m
28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -l
28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-v 输出传递给JVM的参数" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -v
23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd

k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099（前提是远程服务器提供jstatd服务）" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps 192.168.0.77
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk命令之javah命令(C Header and Stub File Generator)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  javah是用于根据JAVA本地方法，生成对应的c语言头文件及相应的stub文件的命令，使用比较简单
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="首先准备一个具有本地方法的Java文件JNITest，输入内容如下：" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
package test;
public class JNITest {
    /*
     * 建立一个无返回参数的方法，该方法只在DLL方法内打印一条语句。 
     */
    public native void test();
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用Javac编译该Java文件" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ javac test/JNITest.java
# 注：编译一定要在test包外操作，否则会报错。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用Javah生成头文件" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ javah test.JNITest
# 也是要在test包外操作


操作完成后，我们可以看到 头文件 "test_JNITest.h" ，它的命令方式是以包名加类名的方式，其内容如下：
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class test_JNITest */
#ifndef _Included_test_JNITest
#define _Included_test_JNITest
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     test_JNITest
 * Method:    test
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_test_JNITest_test
  (JNIEnv *, jobject);
#ifdef __cplusplus
}
#endif
#endif
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jstack是java虚拟机自带的一种堆栈跟踪工具。]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  jstack用于生成java虚拟机当前时刻的线程快照。线程快照是当前java虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。
线程出现停顿的时候通过jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
</div>
<div style="margin-top:.425em;">
如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。另外，jstack工具还可以附属到正在运行的java程序中，看到当时运行的java程序的java stack和native stack的信息, 如果现在运行的java程序呈现hung的状态，jstack是非常有用的。
</div>
<div style="margin-top:.425em;">
注1: 不同的 JAVA虚机的线程 DUMP的创建方法和文件格式是不一样的，不同的 JVM版本， dump信息也有差别。
</div>
<div style="margin-top:.425em;">
注2: 在实际运行中，往往一次 dump的信息，还不足以确认问题。建议产生三次 dump信息，如果每次 dump都指向同一个问题，我们才确定问题的典型性。
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="案例1------ top 命令查下系统运行情况，进程31951占用CPU 80.6%。" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
<img src="/images/j2ee/jvm-utils/285763-20190111171430007-370123297.png" />
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
Mem: 3767780K used, 112476K free, 1408K shrd, 0K buff, 329400K cached
CPU:   2% usr   2% sys   0% nic  95% idle   0% io   0% irq   0% sirq
Load average: 0.56 0.52 0.59 2/1412 114
  PID  PPID USER     STAT   VSZ %VSZ CPU %CPU COMMAND
    1     0 root     S    2569m  68%   0   1% java -Djava.library.path=/usr/local/tomcat/native-jni-lib -jar /root/app/app.jar
   56     0 root     S     1584   0%   1   0% sh
  114    56 root     R     1516   0%   0   0% top
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="案例1------ jps -l 确认一下，31951负载最高的进程ID，或 cat /proc/31951/cmdline 看下进程的启用命令。" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ jps -l
31951 /root/app/app.jar -Djava.library.path=/usr/local/tomcat/native-jni-lib
103 sun.tools.jps.Jps -Dapplication.home=/opt/jdk1.8.0_202 -Xms8m
OR 
$ cat /proc/31951/cmdline
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="案例1------ top -Hp 31951 以线程模式查看下进程31951的所有线程情况" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
<div>
<img src="/images/j2ee/jvm-utils/285763-20190111171511398-2140645173.png" />
</div>
<div style="margin-top:.625em;">
假设想看下第二个线程31998的情况，31998是操作系统的线程ID，先转成16进制。（再例如：21233用计算器转换为16进制52f1，注意字母是小写）
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ printf '%x' 31998 #值为7cfe
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="案例1------ 获取该线程的信息(匹配7cf3后取20行差不多)" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ jstack 31951 | grep 7cfe -A 20
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="案例1------ 其中部分数据如下：" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
"Tomcat JDBC Pool Cleaner[11483240:1532362388783]" #31 daemon prio=5 os_prio=0 tid=0x0a29dc00 nid=0x7cfe in Object.wait() [0xa2a69000]
   java.lang.Thread.State: TIMED_WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    at java.util.TimerThread.mainLoop(Timer.java:552)
    - locked <0xaadc5a60> (a java.util.TaskQueue)
    at java.util.TimerThread.run(Timer.java:505)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:.625em;">
      <![CDATA[
注意：nid=0x7cfe中的nid指native id，是OS中线程ID，对应上面31998线程的16进制值7cfe；tid为Java中线程的ID。
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="案例2-死锁" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
在多线程程序的编写中，如果不适当的运用同步机制，则有可能造成程序的死锁，经常表现为程序的停顿，或者不再响应用户的请求。比如在下面这个示例中，是个较为典型的死锁情况：
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="案例2-死锁" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
### thread dump 结果
"Thread-1"prio=5tid=0x00acc490nid=0xe50waitingformonitorentry[0x02d3f000
..0x02d3fd68]
atdeadlockthreads.TestThread.run(TestThread.java:31)
-waitingtolock<0x22c19f18>(ajava.lang.Object)
-locked<0x22c19f20>(ajava.lang.Object)
"Thread-0"prio=5tid=0x00accdb0nid=0xdecwaitingformonitorentry[0x02cff000
..0x02cff9e8]
atdeadlockthreads.TestThread.run(TestThread.java:31)
-waitingtolock<0x22c19f20>(ajava.lang.Object)
-locked<0x22c19f18>(ajava.lang.Object)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
### 在 JAVA 5中加强了对死锁的检测。线程 Dump中可以直接报告出 Java级别的死锁，如下所示：
### thread dump 结果
FoundoneJava-leveldeadlock:
=============================
"Thread-1":
waitingtolockmonitor0x0003f334(object0x22c19f18,ajava.lang.Object),
whichisheldby"Thread-0"
"Thread-0":
waitingtolockmonitor0x0003f314(object0x22c19f20,ajava.lang.Object),
whichisheldby"Thread-1"[2]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="用jstack进行分析和结果" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
$ jstack 7404

Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00000000577c2bc8 (object 0x00000000d7149440, a com.dxz.jstack.EasyJstackResource$Resource),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00000000577c4118 (object 0x00000000d7149428, a com.dxz.jstack.EasyJstackResource$Resource),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.dxz.jstack.EasyJstackResource.read(EasyJstackResource.java:36)
        - waiting to lock <0x00000000d7149440> (a com.dxz.jstack.EasyJstackResource$Resource)
        - locked <0x00000000d7149428> (a com.dxz.jstack.EasyJstackResource$Resource)
        at com.dxz.jstack.EasyJstack.run(EasyJstack.java:41)
"Thread-0":
        at com.dxz.jstack.EasyJstackResource.write(EasyJstackResource.java:46)
        - waiting to lock <0x00000000d7149428> (a com.dxz.jstack.EasyJstackResource$Resource)
        - locked <0x00000000d7149440> (a com.dxz.jstack.EasyJstackResource$Resource)
        at com.dxz.jstack.EasyJstack.run(EasyJstack.java:42)

Found 1 deadlock.

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



</c:component>
