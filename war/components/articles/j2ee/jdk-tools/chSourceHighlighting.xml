<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract style="font-size:1em;line-height:1.6em;">
    <![CDATA[

]]>
  </c:abstract>
  

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之jps（JVM Process Status Tools）]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  jps (Java Virtual Machine Process Status Tool)是 JDK 1.5 提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前 java 进程的一些简单情况。
</div>
<div style="margin-top:.625em;">
    我想很多人都是用过 unix 系统里的 ps 命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的 java 进程情况，及其id号。我们可以通过它来查看我们到底启动了几个 java 进程（因为每一个 java 程序都会独占一个 java 虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过 opt 来查看这些进程的详细启动参数。
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="jps 显示当前系统的java进程情况" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
$> jps
23991 Jps
23789 BossMain
23651 Resin
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$>  jps -q
28680
23789
23651
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -m
28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -l
28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-v 输出传递给JVM的参数" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -v
23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd

k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099（前提是远程服务器提供jstatd服务）" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps 192.168.0.77
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk命令之javah命令(C Header and Stub File Generator)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  javah是用于根据JAVA本地方法，生成对应的c语言头文件及相应的stub文件的命令，使用比较简单
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="首先准备一个具有本地方法的Java文件JNITest，输入内容如下：" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
package test;
public class JNITest {
    /*
     * 建立一个无返回参数的方法，该方法只在DLL方法内打印一条语句。 
     */
    public native void test();
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用Javac编译该Java文件" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ javac test/JNITest.java
# 注：编译一定要在test包外操作，否则会报错。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用Javah生成头文件" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ javah test.JNITest
# 也是要在test包外操作


操作完成后，我们可以看到 头文件 "test_JNITest.h" ，它的命令方式是以包名加类名的方式，其内容如下：
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class test_JNITest */
#ifndef _Included_test_JNITest
  #define _Included_test_JNITest
  #ifdef __cplusplus
    extern "C" {
  #endif
  /*
   * Class:     test_JNITest
   * Method:    test
   * Signature: ()I
   */
  JNIEXPORT jint JNICALL Java_test_JNITest_test
    (JNIEnv *, jobject);
  #ifdef __cplusplus
    }
  #endif
#endif
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jstack 是 java 虚拟机自带的一种堆栈跟踪工具。]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
  jstack 用于生成 java 虚拟机当前时刻的线程快照 <b>Thread Dump</b>。线程快照是当前 java 虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。
线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
注1: 不同的 JAVA 虚拟机的线程 DUMP 的创建方法和文件格式是不一样的，不同的 JVM 版本， dump 信息也有差别。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
注2: 在实际运行中，往往一次 dump 的信息，还不足以确认问题。建议产生三次 dump 信息，如果每次 dump 都指向同一个问题，我们才确定问题的典型性。
</div>

<h1 style="line-height: 1.625em;color: blue;font-style: italic;margin-bottom: 0;padding-bottom: 0;">dump</h1>
<div style="margin-top:.425em;line-height: 1.625em;">
Dump 的本意是 "倾卸垃圾"、"把(垃圾桶)倒空"。在计算机技术中使用 Dump 的主要意思仍然如此, 即当电脑运行发现故障后, 无法排除而死机, 通常要重新启动。<span style="color: darkviolet;font-size: 1.2em;font-style: italic;">为了找出故障的原因, 需要分析现场(即死机时整个内存的当前状况), 在重新启动系统之前要把内存中的一片0、 1(这时它们尤如一堆垃圾)"卸出"保存起来, 以便由专家去分析引起死机的原因。</span>技术资料中 把这个"卸出"的过程叫 dump; 有时把卸出的"内容"也叫 dump。国际标准化组织(ISO)把前者定义为 To record, at a particular instant, the contents of all or part of one stora geevice in another storage device. Dumping is usually for the purpose of debuggin。"译文如下:"在某个特定时刻, 把一个存储设备中的全部或部分的内容转录进另一个存储设备之中。转储的目的通常是用于排除故障。"因此, dump 作为动词,宜译为"转储";相应的动名词, 或作为名词来看, 则译为"转储(过程、动作…)"。同时,ISO把后者定义为 "Data that as been dumped。"译文如下:"经转储而产生的那些数据"。这些数据实际上就是内存中由一片0、1组成的map(映像)。因此, 这时的dump应译为"内像"(内存中的映像)。 
</div>

<h3>示例:</h3>
<div style="margin-top:.425em;line-height: 1.625em;">
<b>$ jstack –l 23561</b>
</div>
<h1 style="margin-top: .425em;line-height: 1.625em;color: blue;font-style: italic;margin-bottom: 0;padding-bottom: 0;">线程类型</h1>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; jvm 线程</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
在线程中，有一些 JVM 内部的后台线程会在jvm启动时就会存在，来执行譬如垃圾回收，或者低内存的检测等等任务，这些线程往往在 JVM 初始化的时候就存在，如下所示：
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em;margin-top:.325em;">
  "Attach Listener" daemon prio=10 tid=0x0000000052fb8000 nid=0xb8f waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
   Locked ownable synchronizers:
        - None
destroyJavaVM" prio=10 tid=0x00002aaac1225800 nid=0x7208 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
   Locked ownable synchronizers:
        - None
</pre>
<h4 style="margin-top:.625em;line-height: 1.625em;color:crimson;">&euro; 用户级别的线程</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
还有一类线程是用户级别的，它会根据用户请求的不同而发生变化。该类线程的运行情况往往是我们所关注的重点。而且这一部分也是最容易产生死锁的地方。
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em;margin-top:.325em;">
"qtp496432309-42" prio=10 tid=0x00002aaaba2a1800 nid=0x7580 waiting on condition [0x00000000425e9000]
   java.lang.Thread.State: TIMED_WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x0000000788cfb020> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2025)
        at org.eclipse.jetty.util.BlockingArrayQueue.poll(BlockingArrayQueue.java:320)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:479)
        at java.lang.Thread.run(Thread.java:662)
   Locked ownable synchronizers:
        - None
</pre>
<h4 style="margin-top:.625em;line-height: 1.625em;">从上述的代码示例中我们可以看到该用户线程的以下几类信息：</h4>
<ul style="margin-top:.325em;list-style: none;margin-left: 1em;">
  <li>&#x278A; 线程的状态：waiting on condition(等待条件发生)</li>
  <li>&#x278B; 线程的调用情况；</li>
  <li>&#x278C; 线程对资源的锁定情况；</li>
</ul>

<h1 style="margin-top: .425em;line-height: 1.625em;color: blue;font-style: italic;margin-bottom: 0;padding-bottom: 0;">线程的状态分析</h1>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; Runnable</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。 
</div>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; Waiton condition </h4>
<div style="margin-top:.425em;line-height: 1.625em;">
  <p>
  该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace 来分析。最常见的情况是线程在等待网络的读写，比如当网络数据没有准备好读时，线程处于这种等待状态，而一旦有数据准备好读之后，线程会重新激活，读取并处理数据。在 Java 引入 NIO之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 NIO 里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。 
  </p>
  <p style="margin-top:.425em;">
  如果发现有大量的线程都在处在 Wait on condition，从线程 stack 看， 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat 统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制 ; 观察 cpu 的利用率，如果系统态的 CPU 时间，相对于用户态的 CPU 时间比例较高；如果程序运行在 Solaris 10 平台上，可以用 dtrace 工具看系统调用的情况，如果观察到 read/write 的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。 
  </p>
  <p style="margin-top:.425em;">
  另外一种出现 Wait on condition 的常见情况是该线程在 sleep，等待 sleep 的时间到了时候，将被唤醒。 
  </p>
</div>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; Waitingfor monitor entry 和 in Object.wait()</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
  <p>
  在多线程的 JAVA 程序中，实现线程之间的同步，就要说说 Monitor。Monitor 是 Java 中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class 的锁。每一个对象都有，也仅有一个 monitor。下面这个图，描述了线程和 Monitor 之间关系，以及线程的状态转换图： 
  </p>
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  <img style="max-width:450px;margin:auto;" src="/images/j2ee/jvm-utils/285763-20160512220605343-699813097.jpeg" />
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  从图中可以看出，每个 Monitor 在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set” 和 “Wait Set” 里面等候。在 “Entry Set” 中等待的线程状态是 “Waiting for monitorentry”，而在 “Wait Set” 中等待的线程状态是 “in Object.wait()”。 
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  先看 “Entry Set” 里面的线程。我们称被 synchronized 保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set” 队列。对应的 code 就像：
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
synchronized(obj) { 
  ......... 
} 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  这时有两种可能性：
  <br /> 
  &#x278A; 该 monitor 不被其它线程拥有，Entry Set 里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor 的 Owner，执行临界区的代码。此时线程将处于 Runnable 状态；
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  &#x278B; 该 monitor 被其它线程拥有，本线程在 Entry Set 队列中等待。此时 dump 的信息显示 “waiting for monitor entry”。
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
"Thread-0" prio=10 tid=0x08222eb0 nid=0x9 waiting for monitor entry [0xf927b000..0xf927bdb8] 
at testthread.WaitThread.run(WaitThread.java:39) 
- waiting to lock <0xef63bf08> (a java.lang.Object) 
- locked <0xef63beb8> (a java.util.ArrayList) 
at java.lang.Thread.run(Thread.java:595) 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中 发现了这个情况，应该审查源码，改进程序。 
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  现在我们再来看现在线程为什么会进入 “Wait Set”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ， “ Wait Set” 队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。在 “Wait Set” 中的线程， DUMP 中表现为：in Object.wait()，类似于： 
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
"Thread-1" prio=10 tid=0x08223250 nid=0xa in Object.wait() [0xef47a000..0xef47aa38] 
at java.lang.Object.wait(Native Method) 
- waiting on <0xef63beb8> (a java.util.ArrayList) 
at java.lang.Object.wait(Object.java:474) 
at testthread.MyWaitThread.run(MyWaitThread.java:40) 
- locked <0xef63beb8> (a java.util.ArrayList) 
at java.lang.Thread.run(Thread.java:595) 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  仔细观察上面的 DUMP信息，你会发现它有以下两行： 
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
locked <0xef63beb8> (ajava.util.ArrayList) 
waiting on <0xef63beb8> (ajava.util.ArrayList) 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  这里需要解释一下，为什么先 lock了这个对象，然后又 waiting on 同一个对象呢？让我们看看这个线程对应的代码： 
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
synchronized(obj){
  ......... 
  obj.wait();
  ......... 
} 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于 locked <0xef63beb8> ）。当执行到 obj.wait(), 线程即放弃了 Monitor 的所有权，进入 “wait set” 队列（对应于 waiting on<0xef63beb8> ）。 
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  往在你的程序中，会出现多个类似的线程，他们都有相似的 dump 也可能是正常的。比如，在程序中有多个服务线程，设计成从一个队列里面读取请求数据。这个队列就是 lock 以及 waiting on 的对象。当队列为空的时候，这些线程都会在这个队列上等待，直到队列有了数据，这些线程被 notify，当然只有一个线程获得了 lock，继续执行，而其它线程继续等待。 
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="案例1------ 查看 java 进程内所有线程状态" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
<div style="line-height: 1.625em;">
  场景：Java 应用持续占用很高 CPU，需要排查一下。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  模拟：造个场景简单模拟下，没什么实际意义，仅作演示。我启动了100个线程持续访问 我的博客，博客部署在 Ubuntu 16.04 上，是一个简单的 Spring Boot 应用，以 jar 包直接运行的。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  <img style="width:100%" src="/images/j2ee/jvm-utils/285763-20190111171430007-370123297.png" />
</div>
<div style="line-height: 1.625em;margin-top:.625em">
  $ jps -l ### 确认一下，31951 负载最高的进程ID，或 cat /proc/31951/cmdline 看下进程的启用命令。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ jps -l
28416 sun.tools.jps.Jps
31951 blog.jar
OR 
$ cat /proc/31951/cmdline
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
<div style="line-height: 1.625em;margin-top:.625em">
  $ ps -T 31951 ### 以线程模式查看下进程 31951 的所有线程情况
</div>
<div style="margin-top:.625em;">
<img style="width:100%" src="/images/j2ee/jvm-utils/285763-20190111171511398-2140645173.png" />
</div>
<div style="margin-top:.625em;">
假设想看下第二个线程31998的情况，31998是操作系统的线程ID，先转成16进制。（再例如：21233用计算器转换为16进制52f1，注意字母是小写）
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ printf '%x' 31998 #值为7cfe
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
### 获取该线程的信息 (匹配7cf3后取20行差不多)
$ jstack 31951 | grep 7cfe -A 20
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
### 其中部分数据如下: 
### 注意：nid=0x7cfe 中的 nid 指 native id，是 OS 中线程 ID，对应上面 31998 线程的 16 进制值 7cfe；tid 为 Java 中线程的 ID。
"Tomcat JDBC Pool Cleaner[11483240:1532362388783]" #31 daemon prio=5 os_prio=0 tid=0x0a29dc00 nid=0x7cfe in Object.wait() [0xa2a69000]
   java.lang.Thread.State: TIMED_WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    at java.util.TimerThread.mainLoop(Timer.java:552)
    - locked <0xaadc5a60> (a java.util.TaskQueue)
    at java.util.TimerThread.run(Timer.java:505)
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="案例2-死锁" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1.625em"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
在多线程程序的编写中，如果不适当的运用同步机制，则有可能造成程序的死锁，经常表现为程序的停顿，或者不再响应用户的请求。比如在下面这个示例中，是个较为典型的死锁情况：
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
### thread dump 结果
"Thread-1"prio=5tid=0x00acc490nid=0xe50waitingformonitorentry[0x02d3f000
..0x02d3fd68]
atdeadlockthreads.TestThread.run(TestThread.java:31)
-waitingtolock<0x22c19f18>(ajava.lang.Object)
-locked<0x22c19f20>(ajava.lang.Object)
"Thread-0"prio=5tid=0x00accdb0nid=0xdecwaitingformonitorentry[0x02cff000
..0x02cff9e8]
atdeadlockthreads.TestThread.run(TestThread.java:31)
-waitingtolock<0x22c19f20>(ajava.lang.Object)
-locked<0x22c19f18>(ajava.lang.Object)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
### 在 JAVA 5 中加强了对死锁的检测。线程 Dump 中可以直接报告出 Java 级别的死锁，如下所示：
### thread dump 结果
FoundoneJava-leveldeadlock:
=============================
"Thread-1":
waitingtolockmonitor0x0003f334(object0x22c19f18,ajava.lang.Object),
whichisheldby"Thread-0"
"Thread-0":
waitingtolockmonitor0x0003f314(object0x22c19f20,ajava.lang.Object),
whichisheldby"Thread-1"[2]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
#############################
### 用 jstack 进行分析和结果 ###
#############################
$ jstack 7404

Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00000000577c2bc8 (object 0x00000000d7149440, a com.dxz.jstack.EasyJstackResource$Resource),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00000000577c4118 (object 0x00000000d7149428, a com.dxz.jstack.EasyJstackResource$Resource),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.dxz.jstack.EasyJstackResource.read(EasyJstackResource.java:36)
        - waiting to lock <0x00000000d7149440> (a com.dxz.jstack.EasyJstackResource$Resource)
        - locked <0x00000000d7149428> (a com.dxz.jstack.EasyJstackResource$Resource)
        at com.dxz.jstack.EasyJstack.run(EasyJstack.java:41)
"Thread-0":
        at com.dxz.jstack.EasyJstackResource.write(EasyJstackResource.java:46)
        - waiting to lock <0x00000000d7149428> (a com.dxz.jstack.EasyJstackResource$Resource)
        - locked <0x00000000d7149440> (a com.dxz.jstack.EasyJstackResource$Resource)
        at com.dxz.jstack.EasyJstack.run(EasyJstack.java:42)

Found 1 deadlock.

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk 工具之 jstat 命令(Java Virtual Machine Statistics Monitoring Tool)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.1em;line-height:1.65em;">
  Jstat 用于监控基于 HotSpot 的 JVM，对其堆的使用情况进行实时的命令行的统计。主要是用来显示GC及PermGen相关的信息，使用 jstat 我们可以对指定的JVM做如下监控：
</div>
<ul style="margin-top:.325em;list-style:none;margin-left:.3em;font-size:1.1em;line-height:1.65em;">
  <li>&#x278A; 类的加载及卸载情况
  <li>&#x278B; 查看新生代、老生代及持久代的容量及使用情况
  <li>&#x278C; 查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间
  <li>&#x278D; 查看新生代中 Eden 区及 Survior 区中容量及分配情况等</li>
</ul>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  jstat 工具特别强大，它有众多的可选项，通过提供多种不同的监控维度，使我们可以从不同的维度来了解到当前JVM堆的使用情况。详细查看堆内各个部分的使用量，使用的时候必须加上待统计的 Java 进程号，可选的不同维度参数以及可选的统计频率参数。
</div>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  它主要是用来显示GC及PermGen相关的信息，如果对GC不怎么了解，先看这篇文章：http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx，否则其中即使你会使用 jstat 这个命令，你也看不懂它的输出。
</div>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  根据 jstat 统计的维度不同，可以使用如下表中的选项进行不同维度的统计，不同的操作系统支持的选项可能会不一样，可以通过 jstat -options 选项，查看不同操作系统所支持选项，如：
</div>

<table style="width:100%;">
  <thead>
    <tr>
      <th style="border: dashed 1px;padding: 5px 10px;width:200px;">Option</th>
      <th style="border: dashed 1px;padding: 5px 10px;">Displays</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-class</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看类加载情况的统计</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Loaded</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">加载了的类的数量</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Bytes</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">加载了的类的大小，单为Kb</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Unloaded</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">卸载了的类的数量</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Bytes</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">卸载了的类的大小，单为Kb</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Time</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">花在类的加载及卸载的时间</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-compiler</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看 HotSpot 中即时编译器编译情况的统计</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Compiled</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务执行的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Failed</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务执行失败的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Invalid</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务非法执行的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Time</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">执行编译花费的时间</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FailedType</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">最后一次编译失败的编译类型</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FailedMethod</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">最后一次编译失败的类名及方法名</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gc</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看 JVM 中堆的垃圾收集情况的统计</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;vertical-align: top;">$ jstat -gc 9 3000</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="font-size:.125em;transform:scale(.74);transform-origin: top left;width: 140%;position: absolute;">
S0C     S1C      S0U   S1U     EC       EU       OC          OU        MC      MU      CCSC    CCSU     YGC    YGCT     FGC    FGCT    GCT   
12800.0 12800.0  0.0   11851.2 760832.0 314974.7 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
12800.0 12800.0  0.0   11851.2 760832.0 317333.1 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
12800.0 12800.0  0.0   11851.2 760832.0 319062.1 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
12800.0 12800.0  0.0   11851.2 760832.0 321439.5 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
        </pre>
        <table style="width:100%;margin-top: 68px;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中Survivor space中S0当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中Survivor space中S1当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中Survivor space中S0容量使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中Survivor space中S1容量使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space容量使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Old space当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Old space使用容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Permanent space当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Permanent space使用容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Young GC 所用的时间(秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Full GC 所用的时间(秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">T从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gccapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看新生代、老生代及持久代的存储容量情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中survivor space 0的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中survivor space 1的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老生代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老生代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前老生代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前老生代的空间容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代的空间容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gccause</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看垃圾收集的统计情况（这个和 -gcutil 选项一样），如果有发生垃圾收集，它还会显示最后一次及当前正在发生垃圾收集的原因。</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">LGCC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">最后一次垃圾收集的原因，可能为“unknown GCCause”、“System.gc()”等</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前垃圾收集的原因</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcnew</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看新生代垃圾收集的情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中 survivor space 0 的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中 survivor space 1 的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0已经使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1已经使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">TT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Tenuring threshold，要了解这个参数，我们需要了解一点Java内存对象的结构，在 Sun JVM 中（除了数组之外的）对象都有两个机器字（words）的头部。第一个字中包含这个对象的标示哈希码以及其他一些类似锁状态和等标识信息，第二个字中包含一个指向对象的类的引用，其中第二个字节就会被垃圾收集算法使用到。
在新生代中做垃圾收集的时候，每次复制一个对象后，将增加这个对象的收集计数，当一个对象在新生代中被复制了一定次数后，该算法即判定该对象是长周期的对象，把他移动到老生代，这个阈值叫着 tenuring threshold。这个阈值用于表示某个/些在执行批定次数 youngGC 后还活着的对象，即使此时新生的的 Survior 没有满，也同样被认为是长周期对象，将会被移到老生代中。</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">MTT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Maximum tenuring threshold，用于表示TT的最大值。</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">DSS</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Desired survivor size (KB). 可以参与这里：http://blog.csdn.net/yangjun2/article/details/6542357</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space 已经使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcnewcapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看新生代的存储容量情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcold</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看老生代及持久代发生GC的情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcoldcapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看老生代的容量</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcpermcapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看持久代的容量</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcutil</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看新生代、老生代及持代垃圾收集的情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-printcompilation</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">HotSpot编译方法的统计</td>
    </tr>
  </tbody>
</table>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


</c:component>
