<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract style="font-size:1em;line-height:1.6em;">
    <![CDATA[

]]>
  </c:abstract>
  

  <c:entry style="margin-top:0em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之jps（JVM Process Status Tools）]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  jps (Java Virtual Machine Process Status Tool)是 JDK 1.5 提供的一个显示当前所有 java 进程 pid 的命令，简单实用，非常适合在 linux/unix 平台上简单察看当前 java 进程的一些简单情况。
</div>
<div style="margin-top:.625em;">
    我想很多人都是用过 unix 系统里的 ps 命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的 java 进程情况，及其id号。我们可以通过它来查看我们到底启动了几个 java 进程（因为每一个 java 程序都会独占一个 java 虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过 opt 来查看这些进程的详细启动参数。
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="jps 显示当前系统的java进程情况" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
$> jps
23991 Jps
23789 BossMain
23651 Resin
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$>  jps -q
28680
23789
23651
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -m
28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -l
28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-v 输出传递给JVM的参数" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps -v
23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd

k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl -

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099（前提是远程服务器提供jstatd服务）" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$> jps 192.168.0.77
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk命令之javah命令(C Header and Stub File Generator)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  javah是用于根据JAVA本地方法，生成对应的c语言头文件及相应的stub文件的命令，使用比较简单
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="首先准备一个具有本地方法的Java文件JNITest，输入内容如下：" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
package test;
public class JNITest {
    /*
     * 建立一个无返回参数的方法，该方法只在DLL方法内打印一条语句。 
     */
    public native void test();
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用Javac编译该Java文件" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ javac test/JNITest.java
# 注：编译一定要在test包外操作，否则会报错。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用Javah生成头文件" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ javah test.JNITest
# 也是要在test包外操作


操作完成后，我们可以看到 头文件 "test_JNITest.h" ，它的命令方式是以包名加类名的方式，其内容如下：
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[

/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class test_JNITest */
#ifndef _Included_test_JNITest
  #define _Included_test_JNITest
  #ifdef __cplusplus
    extern "C" {
  #endif
  /*
   * Class:     test_JNITest
   * Method:    test
   * Signature: ()I
   */
  JNIEXPORT jint JNICALL Java_test_JNITest_test
    (JNIEnv *, jobject);
  #ifdef __cplusplus
    }
  #endif
#endif
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jstack 是 java 虚拟机自带的一种堆栈跟踪工具。]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
  jstack 用于生成 java 虚拟机当前时刻的线程快照 <b>Thread Dump</b>。线程快照是当前 java 虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的主要目的是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。
线程出现停顿的时候通过 jstack 来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
如果 java 程序崩溃生成 core 文件，jstack 工具可以用来获得 core 文件的 java stack 和 native stack 的信息，从而可以轻松地知道 java 程序是如何崩溃和在程序何处发生问题。另外，jstack 工具还可以附属到正在运行的 java 程序中，看到当时运行的 java 程序的 java stack 和 native stack 的信息, 如果现在运行的 java 程序呈现 hung 的状态，jstack 是非常有用的。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
注1: 不同的 JAVA 虚拟机的线程 DUMP 的创建方法和文件格式是不一样的，不同的 JVM 版本， dump 信息也有差别。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
注2: 在实际运行中，往往一次 dump 的信息，还不足以确认问题。建议产生三次 dump 信息，如果每次 dump 都指向同一个问题，我们才确定问题的典型性。
</div>

<h1 style="line-height: 1.625em;color: blue;font-style: italic;margin-bottom: 0;padding-bottom: 0;">dump</h1>
<div style="margin-top:.425em;line-height: 1.625em;">
Dump 的本意是 "倾卸垃圾"、"把(垃圾桶)倒空"。在计算机技术中使用 Dump 的主要意思仍然如此, 即当电脑运行发现故障后, 无法排除而死机, 通常要重新启动。<span style="color: darkviolet;font-size: 1.2em;font-style: italic;">为了找出故障的原因, 需要分析现场(即死机时整个内存的当前状况), 在重新启动系统之前要把内存中的一片0、 1(这时它们尤如一堆垃圾)"卸出"保存起来, 以便由专家去分析引起死机的原因。</span>技术资料中 把这个"卸出"的过程叫 dump; 有时把卸出的"内容"也叫 dump。国际标准化组织(ISO)把前者定义为 To record, at a particular instant, the contents of all or part of one stora geevice in another storage device. Dumping is usually for the purpose of debuggin。"译文如下:"在某个特定时刻, 把一个存储设备中的全部或部分的内容转录进另一个存储设备之中。转储的目的通常是用于排除故障。"因此, dump 作为动词,宜译为"转储";相应的动名词, 或作为名词来看, 则译为"转储(过程、动作…)"。同时,ISO把后者定义为 "Data that as been dumped。"译文如下:"经转储而产生的那些数据"。这些数据实际上就是内存中由一片0、1组成的map(映像)。因此, 这时的dump应译为"内像"(内存中的映像)。 
</div>

<h3>示例:</h3>
<div style="margin-top:.425em;line-height: 1.625em;">
<b>$ jstack –l 23561</b>
</div>
<h1 style="margin-top: .425em;line-height: 1.625em;color: blue;font-style: italic;margin-bottom: 0;padding-bottom: 0;">线程类型</h1>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; jvm 线程</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
在线程中，有一些 JVM 内部的后台线程会在jvm启动时就会存在，来执行譬如垃圾回收，或者低内存的检测等等任务，这些线程往往在 JVM 初始化的时候就存在，如下所示：
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em;margin-top:.325em;">
  "Attach Listener" daemon prio=10 tid=0x0000000052fb8000 nid=0xb8f waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
   Locked ownable synchronizers:
        - None
destroyJavaVM" prio=10 tid=0x00002aaac1225800 nid=0x7208 waiting on condition [0x0000000000000000]
   java.lang.Thread.State: RUNNABLE
   Locked ownable synchronizers:
        - None
</pre>
<h4 style="margin-top:.625em;line-height: 1.625em;color:crimson;">&euro; 用户级别的线程</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
还有一类线程是用户级别的，它会根据用户请求的不同而发生变化。该类线程的运行情况往往是我们所关注的重点。而且这一部分也是最容易产生死锁的地方。
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em;margin-top:.325em;">
"qtp496432309-42" prio=10 tid=0x00002aaaba2a1800 nid=0x7580 waiting on condition [0x00000000425e9000]
   java.lang.Thread.State: TIMED_WAITING (parking)
        at sun.misc.Unsafe.park(Native Method)
        - parking to wait for  <0x0000000788cfb020> (a java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject)
        at java.util.concurrent.locks.LockSupport.parkNanos(LockSupport.java:198)
        at java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos(AbstractQueuedSynchronizer.java:2025)
        at org.eclipse.jetty.util.BlockingArrayQueue.poll(BlockingArrayQueue.java:320)
        at org.eclipse.jetty.util.thread.QueuedThreadPool$2.run(QueuedThreadPool.java:479)
        at java.lang.Thread.run(Thread.java:662)
   Locked ownable synchronizers:
        - None
</pre>
<h4 style="margin-top:.625em;line-height: 1.625em;">从上述的代码示例中我们可以看到该用户线程的以下几类信息：</h4>
<ul style="margin-top:.325em;list-style: none;margin-left: 1em;">
  <li>&#x278A; 线程的状态：waiting on condition(等待条件发生)</li>
  <li>&#x278B; 线程的调用情况；</li>
  <li>&#x278C; 线程对资源的锁定情况；</li>
</ul>

<h1 style="margin-top: .425em;line-height: 1.625em;color: blue;font-style: italic;margin-bottom: 0;padding-bottom: 0;">线程的状态分析</h1>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; Runnable</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
该状态表示线程具备所有运行条件，在运行队列中准备操作系统的调度，或者正在运行。 
</div>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; Waiton condition </h4>
<div style="margin-top:.425em;line-height: 1.625em;">
  <p>
  该状态出现在线程等待某个条件的发生。具体是什么原因，可以结合 stacktrace 来分析。最常见的情况是线程在等待网络的读写，比如当网络数据没有准备好读时，线程处于这种等待状态，而一旦有数据准备好读之后，线程会重新激活，读取并处理数据。在 Java 引入 NIO之前，对于每个网络连接，都有一个对应的线程来处理网络的读写操作，即使没有可读写的数据，线程仍然阻塞在读写操作上，这样有可能造成资源浪费，而且给操作系统的线程调度也带来压力。在 NIO 里采用了新的机制，编写的服务器程序的性能和可扩展性都得到提高。 
  </p>
  <p style="margin-top:.425em;">
  如果发现有大量的线程都在处在 Wait on condition，从线程 stack 看， 正等待网络读写，这可能是一个网络瓶颈的征兆。因为网络阻塞导致线程无法执行。一种情况是网络非常忙，几乎消耗了所有的带宽，仍然有大量数据等待网络读写；另一种情况也可能是网络空闲，但由于路由等问题，导致包无法正常的到达。所以要结合系统的一些性能观察工具来综合分析，比如 netstat 统计单位时间的发送包的数目，如果很明显超过了所在网络带宽的限制 ; 观察 cpu 的利用率，如果系统态的 CPU 时间，相对于用户态的 CPU 时间比例较高；如果程序运行在 Solaris 10 平台上，可以用 dtrace 工具看系统调用的情况，如果观察到 read/write 的系统调用的次数或者运行时间遥遥领先；这些都指向由于网络带宽所限导致的网络瓶颈。 
  </p>
  <p style="margin-top:.425em;">
  另外一种出现 Wait on condition 的常见情况是该线程在 sleep，等待 sleep 的时间到了时候，将被唤醒。 
  </p>
</div>
<h4 style="margin-top:.425em;line-height: 1.625em;color:crimson;">&euro; Waitingfor monitor entry 和 in Object.wait()</h4>
<div style="margin-top:.425em;line-height: 1.625em;">
  <p>
  在多线程的 JAVA 程序中，实现线程之间的同步，就要说说 Monitor。Monitor 是 Java 中用以实现线程之间的互斥与协作的主要手段，它可以看成是对象或者 Class 的锁。每一个对象都有，也仅有一个 monitor。下面这个图，描述了线程和 Monitor 之间关系，以及线程的状态转换图： 
  </p>
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  <img style="max-width:450px;margin:auto;" src="/images/j2ee/jvm-utils/285763-20160512220605343-699813097.jpeg" />
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  从图中可以看出，每个 Monitor 在某个时刻，只能被一个线程拥有，该线程就是 “Active Thread”，而其它线程都是 “Waiting Thread”，分别在两个队列 “ Entry Set” 和 “Wait Set” 里面等候。在 “Entry Set” 中等待的线程状态是 “Waiting for monitorentry”，而在 “Wait Set” 中等待的线程状态是 “in Object.wait()”。 
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  先看 “Entry Set” 里面的线程。我们称被 synchronized 保护起来的代码段为临界区。当一个线程申请进入临界区时，它就进入了 “Entry Set” 队列。对应的 code 就像：
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
synchronized(obj) { 
  ......... 
} 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  这时有两种可能性：
  <br /> 
  &#x278A; 该 monitor 不被其它线程拥有，Entry Set 里面也没有其它等待线程。本线程即成为相应类或者对象的 Monitor 的 Owner，执行临界区的代码。此时线程将处于 Runnable 状态；
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  &#x278B; 该 monitor 被其它线程拥有，本线程在 Entry Set 队列中等待。此时 dump 的信息显示 “waiting for monitor entry”。
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
"Thread-0" prio=10 tid=0x08222eb0 nid=0x9 waiting for monitor entry [0xf927b000..0xf927bdb8] 
at testthread.WaitThread.run(WaitThread.java:39) 
- waiting to lock <0xef63bf08> (a java.lang.Object) 
- locked <0xef63beb8> (a java.util.ArrayList) 
at java.lang.Thread.run(Thread.java:595) 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  临界区的设置，是为了保证其内部的代码执行的原子性和完整性。但是因为临界区在任何时间只允许线程串行通过，这和我们多线程的程序的初衷是相反的。如果在多线程的程序中，大量使用 synchronized，或者不适当的使用了它，会造成大量线程在临界区的入口等待，造成系统的性能大幅下降。如果在线程 DUMP中 发现了这个情况，应该审查源码，改进程序。 
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  现在我们再来看现在线程为什么会进入 “Wait Set”。当线程获得了 Monitor，进入了临界区之后，如果发现线程继续运行的条件没有满足，它则调用对象（一般就是被 synchronized 的对象）的 wait() 方法，放弃了 Monitor，进入 “Wait Set”队列。只有当别的线程在该对象上调用了 notify() 或者 notifyAll() ， “ Wait Set” 队列中线程才得到机会去竞争，但是只有一个线程获得对象的 Monitor，恢复到运行态。在 “Wait Set” 中的线程， DUMP 中表现为：in Object.wait()，类似于： 
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
"Thread-1" prio=10 tid=0x08223250 nid=0xa in Object.wait() [0xef47a000..0xef47aa38] 
at java.lang.Object.wait(Native Method) 
- waiting on <0xef63beb8> (a java.util.ArrayList) 
at java.lang.Object.wait(Object.java:474) 
at testthread.MyWaitThread.run(MyWaitThread.java:40) 
- locked <0xef63beb8> (a java.util.ArrayList) 
at java.lang.Thread.run(Thread.java:595) 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  仔细观察上面的 DUMP信息，你会发现它有以下两行： 
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
locked <0xef63beb8> (ajava.util.ArrayList) 
waiting on <0xef63beb8> (ajava.util.ArrayList) 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  这里需要解释一下，为什么先 lock了这个对象，然后又 waiting on 同一个对象呢？让我们看看这个线程对应的代码： 
</div>
<pre style="font-size:.825em;background-color:black;color:white;padding:1em 1em;margin-top:.325em;">
synchronized(obj){
  ......... 
  obj.wait();
  ......... 
} 
</pre>
<div style="margin-top:.425em;line-height: 1.625em;">
  线程的执行中，先用 synchronized 获得了这个对象的 Monitor（对应于 locked <0xef63beb8> ）。当执行到 obj.wait(), 线程即放弃了 Monitor 的所有权，进入 “wait set” 队列（对应于 waiting on<0xef63beb8> ）。 
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  往在你的程序中，会出现多个类似的线程，他们都有相似的 dump 也可能是正常的。比如，在程序中有多个服务线程，设计成从一个队列里面读取请求数据。这个队列就是 lock 以及 waiting on 的对象。当队列为空的时候，这些线程都会在这个队列上等待，直到队列有了数据，这些线程被 notify，当然只有一个线程获得了 lock，继续执行，而其它线程继续等待。 
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="案例1------ 查看 java 进程内所有线程状态" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
<div style="line-height: 1.625em;">
  场景：Java 应用持续占用很高 CPU，需要排查一下。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  模拟：造个场景简单模拟下，没什么实际意义，仅作演示。我启动了100个线程持续访问 我的博客，博客部署在 Ubuntu 16.04 上，是一个简单的 Spring Boot 应用，以 jar 包直接运行的。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
  <img style="width:100%" src="/images/j2ee/jvm-utils/285763-20190111171430007-370123297.png" />
</div>
<div style="line-height: 1.625em;margin-top:.625em">
  $ jps -l ### 确认一下，31951 负载最高的进程ID，或 cat /proc/31951/cmdline 看下进程的启用命令。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ jps -l
28416 sun.tools.jps.Jps
31951 blog.jar
OR 
$ cat /proc/31951/cmdline
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
<div style="line-height: 1.625em;margin-top:.625em">
  $ ps -T 31951 ### 以线程模式查看下进程 31951 的所有线程情况
</div>
<div style="margin-top:.625em;">
<img style="width:100%" src="/images/j2ee/jvm-utils/285763-20190111171511398-2140645173.png" />
</div>
<div style="margin-top:.625em;">
假设想看下第二个线程31998的情况，31998是操作系统的线程ID，先转成16进制。（再例如：21233用计算器转换为16进制52f1，注意字母是小写）
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ printf '%x' 31998 #值为7cfe
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
### 获取该线程的信息 (匹配7cf3后取20行差不多)
$ jstack 31951 | grep 7cfe -A 20
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
### 其中部分数据如下: 
### 注意：nid=0x7cfe 中的 nid 指 native id，是 OS 中线程 ID，对应上面 31998 线程的 16 进制值 7cfe；tid 为 Java 中线程的 ID。
"Tomcat JDBC Pool Cleaner[11483240:1532362388783]" #31 daemon prio=5 os_prio=0 tid=0x0a29dc00 nid=0x7cfe in Object.wait() [0xa2a69000]
   java.lang.Thread.State: TIMED_WAITING (on object monitor)
    at java.lang.Object.wait(Native Method)
    at java.util.TimerThread.mainLoop(Timer.java:552)
    - locked <0xaadc5a60> (a java.util.TaskQueue)
    at java.util.TimerThread.run(Timer.java:505)
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="案例2-死锁" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1.625em"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
在多线程程序的编写中，如果不适当的运用同步机制，则有可能造成程序的死锁，经常表现为程序的停顿，或者不再响应用户的请求。比如在下面这个示例中，是个较为典型的死锁情况：
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
### thread dump 结果
"Thread-1"prio=5tid=0x00acc490nid=0xe50waitingformonitorentry[0x02d3f000
..0x02d3fd68]
atdeadlockthreads.TestThread.run(TestThread.java:31)
-waitingtolock<0x22c19f18>(ajava.lang.Object)
-locked<0x22c19f20>(ajava.lang.Object)
"Thread-0"prio=5tid=0x00accdb0nid=0xdecwaitingformonitorentry[0x02cff000
..0x02cff9e8]
atdeadlockthreads.TestThread.run(TestThread.java:31)
-waitingtolock<0x22c19f20>(ajava.lang.Object)
-locked<0x22c19f18>(ajava.lang.Object)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
### 在 JAVA 5 中加强了对死锁的检测。线程 Dump 中可以直接报告出 Java 级别的死锁，如下所示：
### thread dump 结果
FoundoneJava-leveldeadlock:
=============================
"Thread-1":
waitingtolockmonitor0x0003f334(object0x22c19f18,ajava.lang.Object),
whichisheldby"Thread-0"
"Thread-0":
waitingtolockmonitor0x0003f314(object0x22c19f20,ajava.lang.Object),
whichisheldby"Thread-1"[2]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;padding-top:.325em;">
      <![CDATA[
#############################
### 用 jstack 进行分析和结果 ###
#############################
$ jstack 7404

Found one Java-level deadlock:
=============================
"Thread-1":
  waiting to lock monitor 0x00000000577c2bc8 (object 0x00000000d7149440, a com.dxz.jstack.EasyJstackResource$Resource),
  which is held by "Thread-0"
"Thread-0":
  waiting to lock monitor 0x00000000577c4118 (object 0x00000000d7149428, a com.dxz.jstack.EasyJstackResource$Resource),
  which is held by "Thread-1"

Java stack information for the threads listed above:
===================================================
"Thread-1":
        at com.dxz.jstack.EasyJstackResource.read(EasyJstackResource.java:36)
        - waiting to lock <0x00000000d7149440> (a com.dxz.jstack.EasyJstackResource$Resource)
        - locked <0x00000000d7149428> (a com.dxz.jstack.EasyJstackResource$Resource)
        at com.dxz.jstack.EasyJstack.run(EasyJstack.java:41)
"Thread-0":
        at com.dxz.jstack.EasyJstackResource.write(EasyJstackResource.java:46)
        - waiting to lock <0x00000000d7149428> (a com.dxz.jstack.EasyJstackResource$Resource)
        - locked <0x00000000d7149440> (a com.dxz.jstack.EasyJstackResource$Resource)
        at com.dxz.jstack.EasyJstack.run(EasyJstack.java:42)

Found 1 deadlock.

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk 工具之 jstat 命令(Java Virtual Machine Statistics Monitoring Tool)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.1em;line-height:1.65em;">
  Jstat 用于监控基于 HotSpot 的 JVM，对其堆的使用情况进行实时的命令行的统计。主要是用来显示GC及PermGen相关的信息，使用 jstat 我们可以对指定的JVM做如下监控：
</div>
<ul style="margin-top:.325em;list-style:none;margin-left:.3em;font-size:1.1em;line-height:1.65em;">
  <li>&#x278A; 类的加载及卸载情况
  <li>&#x278B; 查看新生代、老生代及持久代的容量及使用情况
  <li>&#x278C; 查看新生代、老生代及持久代的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间
  <li>&#x278D; 查看新生代中 Eden 区及 Survior 区中容量及分配情况等</li>
</ul>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  <h3>Oracle上关于Jstat的使用说明：</h3>
  <p>
    <a href="http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html">
    http://docs.oracle.com/javase/1.5.0/docs/tooldocs/share/jstat.html</a>
  </p>
</div>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  jstat 工具特别强大，它有众多的可选项，通过提供多种不同的监控维度，使我们可以从不同的维度来了解到当前JVM堆的使用情况。详细查看堆内各个部分的使用量，使用的时候必须加上待统计的 Java 进程号，可选的不同维度参数以及可选的统计频率参数。
</div>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  它主要是用来显示GC及PermGen相关的信息，如果对GC不怎么了解，先看这篇文章：http://blog.csdn.net/fenglibing/archive/2011/04/13/6321453.aspx，否则其中即使你会使用 jstat 这个命令，你也看不懂它的输出。
</div>
<div style="margin-top:.325em;font-size:1.1em;line-height:1.65em;">
  根据 jstat 统计的维度不同，可以使用如下表中的选项进行不同维度的统计，不同的操作系统支持的选项可能会不一样，可以通过 jstat -options 选项，查看不同操作系统所支持选项，如：
</div>

<table style="width:100%;">
  <thead>
    <tr>
      <th style="border: dashed 1px;padding: 5px 10px;width:200px;">Option</th>
      <th style="border: dashed 1px;padding: 5px 10px;">Displays</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-class</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">监视类装载、卸载数量、总空间及类装载所耗费的时间</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
        <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -class 9
Loaded  Bytes     Unloaded  Bytes     Time   
15046   27276.6   0         0.0       17.62</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Loaded</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">加载了的类的数量</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Bytes</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">加载了的类的大小，单为Kb</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Unloaded</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">卸载了的类的数量</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Bytes</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">卸载了的类的大小，单为Kb</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Time</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">花在类的加载及卸载的时间毫秒</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-compiler</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">输出JIT编译器编译过的方法耗时等信息</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -compiler 9
Compiled Failed  Invalid  Time    FailedType FailedMethod
30239    1       0        206.89  1          sun/misc/URLClassPath getLoader</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Compiled</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务执行的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Failed</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务执行失败的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Invalid</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务非法执行的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Time</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">执行编译花费的时间</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FailedType</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">最后一次编译失败的编译类型</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FailedMethod</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">最后一次编译失败的类名及方法名</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gc</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">监视JVM堆状况，包括Eden区、2个Surviror区、老年代、永久代等的容量、已使用空间、GC时间合计等信息</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;vertical-align: top;">$ jstat -gc 9 3000</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="font-size:.125em;transform:scale(.74);transform-origin: top left;width: 140%;position: absolute;">
S0C     S1C      S0U   S1U     EC       EU       OC          OU        MC      MU      CCSC    CCSU     YGC    YGCT     FGC    FGCT    GCT   
12800.0 12800.0  0.0   11851.2 760832.0 314974.7 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
12800.0 12800.0  0.0   11851.2 760832.0 317333.1 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
12800.0 12800.0  0.0   11851.2 760832.0 319062.1 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
12800.0 12800.0  0.0   11851.2 760832.0 321439.5 1572864.0   534338.9  89108.0 85979.5 10556.0 9943.9   4327   76.753   3      0.513   77.266
        </pre>
        <table style="width:100%;margin-top: 68px;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中 Survivor space 中 S0 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中 Survivor space 中 S1 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中 Survivor space 中 S0 容量使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中 Survivor space 中 S1 容量使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space 容量使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Old space 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Old space 使用容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Permanent space 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Permanent space 使用容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Young GC 所用的时间(秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Full GC 所用的时间(秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">T从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gccapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">监视内容基本与-gc相同，但输出主要关注JVM堆各区域使用到的最大和最小空间</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="font-size:.125em;transform:scale(.6);transform-origin: top left;width: 140%;position: absolute;">
$ jstat -gccapacity 9
NGCMN    NGCMX     NGC      S0C     S1C       EC        OGCMN      OGCMX       OGC         OC          MCMN  MCMX       MC        CCSMN    CCSMX      CCSC      YGC      FGC 
786432.0 786432.0  786432.0 12800.0 12800.0   760832.0  1572864.0  1572864.0   1572864.0   1572864.0   0.0   1128448.0  89108.0   0.0      1048576.0  10556.0   4327     3
        </pre>
        <table style="width:100%;margin-top:3em;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中survivor space 0的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中survivor space 1的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老生代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老生代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前老生代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前老生代的空间容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代的空间容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gccause</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">基本与 -gcutil 功能一样，但是会额外输出导致上一次GC产生的原因</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;transform:scale(.8);transform-origin: top left;width:120%;">
$ jstat -gccause 11
S0     S1     E      O      M      CCS     YGC    YGCT    FGC    FGCT     GCT     LGCC                 GCC                 
57.50  0.00   57.44  76.65  89.75  84.73   4132   49.547  1      0.516    50.064  Allocation Failure   No GC 
        </pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">LGCC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">最后一次垃圾收集的原因，可能为“unknown GCCause”、“System.gc()”等</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前垃圾收集的原因</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcnew</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看新生代GC的情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -gcnew 9
S0C     S1C        S0U    S1U     TT  MTT  DSS      EC       EU         YGC   YGCT  
12800.0 12800.0    0.0    11851.2 15  15   12800.0  760832.0 519602.9   4327  76.753</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中 survivor space 0 的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中 survivor space 1 的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0已经使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1U</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1已经使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">TT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Tenuring threshold，要了解这个参数，我们需要了解一点Java内存对象的结构，在 Sun JVM 中（除了数组之外的）对象都有两个机器字（words）的头部。第一个字中包含这个对象的标示哈希码以及其他一些类似锁状态和等标识信息，第二个字中包含一个指向对象的类的引用，其中第二个字节就会被垃圾收集算法使用到。
在新生代中做垃圾收集的时候，每次复制一个对象后，将增加这个对象的收集计数，当一个对象在新生代中被复制了一定次数后，该算法即判定该对象是长周期的对象，把他移动到老生代，这个阈值叫着 tenuring threshold。这个阈值用于表示某个/些在执行批定次数 youngGC 后还活着的对象，即使此时新生的的 Survior 没有满，也同样被认为是长周期对象，将会被移到老生代中。</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">MTT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Maximum tenuring threshold，用于表示TT的最大值。</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">DSS</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Desired survivor size (KB). 可以参与这里：http://blog.csdn.net/yangjun2/article/details/6542357</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space 当前容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Eden space 已经使用的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcnewcapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">监视内容基本与-gcnew相同，输出主要关注使用到的最大和最小空间</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -gcnewcapacity 9
NGCMN      NGCMX       NGC      S0CMX     S0C     S1CMX     S1C       ECMX       EC        YGC   FGC 
786432.0   786432.0    786432.0 262144.0  12800.0 262144.0  12800.0   785408.0   760832.0  4327  3</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">NGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0CMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中SO的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中SO的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1CMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中S1的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1C</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中S1的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">ECMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">新生代中Eden的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">EC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代中Eden的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcold</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">用于查看老生代及持久代发生GC的情况</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -gcold 9
MC       MU       CCSC      CCSU     OC          OU        YGC    FGC  FGCT    GCT   
89108.0  85979.5  10556.0   9943.9   1572864.0   534338.9  4327   3    0.513   77.266</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代使用容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前老年代容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OU</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老年代使用容量的大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcoldcapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">基本与-gcold相同，输出主要关注使用到的最大和最小空间</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -gcoldcapacity 9
OGCMN       OGCMX        OGC         OC         YGC   FGC    FGCT     GCT   
1572864.0   1572864.0    1572864.0   1572864.0  4327  3      0.513    77.266</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老生代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">老生代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前老生代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">OC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前新生代的空间容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcpermcapacity</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">输出永久代使用到的最大和最小空间</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGCMN</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代的最小容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGCMX</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">持久代的最大容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代的容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">PC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">当前持久代的空间容量大小（KB）</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-gcutil</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">监视内容基本与-gc相同，但输出主要关注已使用空间占总空间的百分比</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -gcutil 9
S0     S1    E      O      M      CCS     YGC    YGCT     FGC    FGCT     GCT   
40.55  0.00  17.43  33.97  96.49  94.20   4328   76.766   3      0.513    77.279</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S0</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Heap上的 Survivor space 0 区已使用空间的百分比</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">S1</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Heap上的 Survivor space 1 区已使用空间的百分比</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">E</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Heap上的 Eden space 区已使用空间的百分比</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">O</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Heap上的 Old space 区已使用空间的百分比</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">P</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Perm space 区已使用空间的百分比</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Young GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">YGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Young GC 所用的时间(单位秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGC</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时发生 Full GC 的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">FGCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时 Full GC 所用的时间(单位秒)</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">GCT</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-printcompilation</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">输出已经被JIT编译过的方法</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">&nbsp;</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">
        <pre style="background-color: black;color: white;padding: 1em;font-size: .8em;margin-bottom: .325em;">
$ jstat -printcompilation 9
Compiled  Size  Type Method
30243     154   1    com/fasterxml/jackson/databind/util/ClassUtil findSuperTypes</pre>
        <table style="width:100%;">
          <thead>
            <tr>
              <th style="border: dashed 1px;padding: 5px 10px;width:200px;">列名</th>
              <th style="border: dashed 1px;padding: 5px 10px;">说明</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Compiled</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译任务执行的次数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Size</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">方法的字节码所占的字节数</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Type</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">编译类型</td>
            </tr>
            <tr>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">Method</td>
              <td style="border: dashed 1px darkgray;padding: 5px 5px;">指定确定被编译方法的类名及方法名，类名中使名“/”而不是“.”做为命名分隔符，方法名是被指定的类中的方法，这两个字段的格式是由HotSpot中的“-XX:+PrintComplation”选项确定的。</td>
            </tr>
          </tbody>
        </table>
      </td>
    </tr>
  </tbody>
</table>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之jmap（java memory map）]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
  打印出某个 java 进程（使用pid）内存内的所有 ‘对象’ 的情况（如：产生那些对象，及其数量）。
</div>
<div style="margin-top:.425em;line-height: 1.625em;">
可以输出所有内存中对象的工具，甚至可以将 VM 中的 heap，以二进制输出成文本。使用方法 jmap -histo pid。如果用 SHELL jmap -histo pid>a.log 可以将其保存到文本中去，在一段时间后，使用文本对比工具，可以对比出GC回收了哪些对象。jmap -dump:format=b,file=outfile 3024 可以将 3024 进程的内存heap输出出来到 outfile 文件里，再配合MAT（内存分析工具(Memory Analysis Tool），使用参见：http://blog.csdn.net/fenglibing/archive/2011/04/02/6298326.aspx）或与 jhat (Java Heap Analysis Tool)一起使用，能够以图像的形式直观的展示当前内存是否有问题。
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;">
      <![CDATA[
### 查看该进程(pid)下堆内存的使用情况：
$ jmap -heap pid

### 快速定位内存泄漏的方法：只统计存活的对象
$ jmap -histo:live pid

### 还可以导出：
$ jmap -histo:live pid >1.txt将信息输出到指定文件中

### 打印等待回收的对象信息
$ jmap -finalizerinfo 4783
Attaching to process ID 4783, please wait...
Debugger attached successfully.
Server compiler detected.
JVM version is 25.171-b11
Number of objects pending for finalization: 0
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="-heap" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
$ jmap -heap 2464  
JVM version is 16.3-b01  
      
    using thread-local object allocation.  
    Parallel GC with 13 thread(s)  
      
    Heap Configuration:  
       MinHeapFreeRatio = 40  
       MaxHeapFreeRatio = 70  
       MaxHeapSize      = 8436842496 (8046.0MB)  
       NewSize          = 5439488 (5.1875MB)  
       MaxNewSize       = 17592186044415 MB  
       OldSize          = 5439488 (5.1875MB)  
       NewRatio         = 2  
       SurvivorRatio    = 8  
       PermSize         = 21757952 (20.75MB)  
       MaxPermSize      = 88080384 (84.0MB)  
      
    Heap Usage:  
    PS Young Generation  
    Eden Space:  
       capacity = 87883776 (83.8125MB)  
       used     = 31053080 (29.614524841308594MB)  
       free     = 56830696 (54.197975158691406MB)  
       35.33425782706469% used  
    From Space:  
       capacity = 13828096 (13.1875MB)  
       used     = 196608 (0.1875MB)  
       free     = 13631488 (13.0MB)  
       1.4218009478672986% used  
    To Space:  
       capacity = 16384000 (15.625MB)  
       used     = 0 (0.0MB)  
       free     = 16384000 (15.625MB)  
       0.0% used  
    PS Old Generation  
       capacity = 156172288 (148.9375MB)  
       used     = 27098208 (25.842864990234375MB)  
       free     = 129074080 (123.09463500976562MB)  
       17.35148299805917% used  
    PS Perm Generation  
       capacity = 88080384 (84.0MB)  
       used     = 50847592 (48.492042541503906MB)  
       free     = 37232792 (35.507957458496094MB)  
       57.728622073218936% used  

### 说明如下
Parallel GC with 13 thread(s)   # 13个gc线程  
  
Heap Configuration: ### 堆内存初始化配置  
   MinHeapFreeRatio = 40  #-XX:MinHeapFreeRatio设置JVM堆最小空闲比率  
   MaxHeapFreeRatio = 70  #-XX:MaxHeapFreeRatio设置JVM堆最大空闲比率  
   MaxHeapSize      = 8436842496 (8046.0MB)#-XX:MaxHeapSize=设置JVM堆的最大大小  
   NewSize          = 5439488 (5.1875MB) #-XX:NewSize=设置JVM堆的‘新生代’的默认大小  
   MaxNewSize       = 17592186044415 MB  #-XX:MaxNewSize=设置JVM堆的‘新生代’的最大大小  
   OldSize          = 5439488 (5.1875MB) #-XX:OldSize=设置JVM堆的‘老生代’的大小  
   NewRatio         = 2 #-XX:NewRatio=:‘新生代’和‘老生代’的大小比率  
   SurvivorRatio    = 8 #-XX:SurvivorRatio=设置年轻代中Eden区与Survivor区的大小比值  
   PermSize         = 21757952 (20.75MB) #-XX:PermSize=<value>:设置JVM堆的‘永生代’的初始大小  
   MaxPermSize      = 88080384 (84.0MB) #-XX:MaxPermSize=<value>:设置JVM堆的‘永生代’的最大大小  
  
Heap Usage:  
PS Young Generation  
Eden Space: ### Eden区内存分布  
   capacity = 87883776 (83.8125MB)  
   used     = 31053080 (29.614524841308594MB)  
   free     = 56830696 (54.197975158691406MB)  
   35.33425782706469% used  
From Space:#其中一个Survivor区的内存分布  
   capacity = 13828096 (13.1875MB)  
   used     = 196608 (0.1875MB)  
   free     = 13631488 (13.0MB)  
   1.4218009478672986% used  
To Space:#另一个Survivor区的内存分布  
   capacity = 16384000 (15.625MB)  
   used     = 0 (0.0MB)  
   free     = 16384000 (15.625MB)  
   0.0% used  
PS Old Generation ### 当前的Old区内存分布  
   capacity = 156172288 (148.9375MB)  
   used     = 27098208 (25.842864990234375MB)  
   free     = 129074080 (123.09463500976562MB)  
   17.35148299805917% used  
PS Perm Generation ### 当前的 “永生代” 内存分布  
   capacity = 88080384 (84.0MB)  
   used     = 50847592 (48.492042541503906MB)  
   free     = 37232792 (35.507957458496094MB)  
   57.728622073218936% used
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="MAT &amp;mdash; Memory Analysis Tool" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;">
      <![CDATA[
### mat 为 eclipse 的一个内存分析插件，帮助查找内存泄漏和减少内存消耗。
### 首先基于 jmap 导出的堆信息
$ jmap -dump:live,format=b,file=test.bin 29030  
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;margin-top:1em;">
      <![CDATA[
<div>
  执行之后用jmap输出堆信息, 然后导入分析工具, 我们可以看到图形化展示：
</div>
<div style="margin-top:.425em;">
  <img style="width:500px" src="/images/j2ee/jvm-utils/mat-1.png" />
</div>
<div style="margin-top:.625em;">
  然后我们点击 <b>Problem Suspect 1</b> 如下所示：
</div>
<div style="margin-top:.425em;">
  <img style="width:500px" src="/images/j2ee/jvm-utils/mat-2.png" />
</div>
<div style="margin-top:.625em;">
  然后点击详情
</div>
<div style="margin-top:0em;">
  <img style="width:500px" src="/images/j2ee/jvm-utils/mat-3.png" />
</div>
<div style="margin-top:.625em;">
  我们可以看到有很多的User对象
</div>
<div style="margin-top:0em;">
  <img style="width:500px" src="/images/j2ee/jvm-utils/mat-4.png" />
</div>
<div style="margin-top:.625em;">
  这些对象有可能会溢出，然后我们打开OQL窗口看他是否为null，执行如下OQL语句
</div>
<pre style="margin-top:0em;background-color:black;color:white;padding: .5em 0;">
  SELECT u FROM org.learn.util.User u WHERE (u.value = null)  
</pre>
<div style="margin-top:.625em;">
  结果如下：
</div>
<div style="margin-top:0em;">
  <img style="width:500px" src="/images/j2ee/jvm-utils/mat-5.png" />
</div>
<div style="margin-top:.625em;">
  也就是说这个是null，但是仍然有强引用存在，gc的时候是不能回收的，这样就会出现内存的溢出问题
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="如何用mat分析内存问题" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
<div>
我用MAT打开了heap.bin，很容易看出，char[]的数量出其意料的多，占用90%以上的内存 。一般来说，char[]在JVM确实会占用很多内存，数量也非常多，因为String对象以char[]作为内部存储。但是这次的char[]太贪婪 了，仔细一观察，发现有数万计的char[]，每个都占用数百K的内存 。这个现象说明，Java程序保存了数以万计的大String对象 。结合程序的逻辑，这个是不应该的，肯定在某个地方出了问题。
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20190111185245320-438427167.png" />
</div>
<div style="margin-top:.425em;">
  在可疑的 char[] 中，任意挑了一个，使用 Path To GC Root 功能，找到该 char[] 的引用路径，发现 String 对象是被一个 HashMap 中引用的 。这个也是意料中的事情，Java 的内存泄露多半是因为对象被遗留在全局的 HashMap 中得不到释放。不过，该 HashMap 被用作一个缓存，设置了缓 存条目的阈值，导达到阈值后会自动淘汰。从这个逻辑分析，应该不会出现内存泄露的。虽然缓存中的 String 对象已经达到数万计，但仍然没有达到预先设置的阈值（阈值设置地比较大，因为当时预估 String 对象都比较小）。
</div>
<div style="margin-top:.425em;">
但是，另一个问题引起了我的注意：为什么缓存的 String 对象如此巨大？内部 char[] 的长度达数百K。虽然缓存中的 String 对象数量还没有达到阈值，但是 String 对象大小远远超出了我们的预期，最终导致内存被大量消耗，形成内存泄露的迹象（准确说应该是内存消 耗过多）。
</div>
<div style="margin-top:.425em;">
就这个问题进一步顺藤摸瓜，看看 String 大对象是如何被放到HashMap中的。通过查看程序的源代码，我发现，确实有 String 大对象，不 过并没有把 String 大对象放到 HashMap 中，而是把 String 大对象进行 split（调用String.split方法），然后将 split 出来的 String 小对象放到 HashMap 中了。
</div>
<div style="margin-top:.425em;">
这就奇怪了，放到 HashMap 中明明是 split 之后的 String 小对象，怎么会占用那么大空间呢？难道是 String 类的 split 方法有问题？
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding:0;padding-bottom: 0;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;margin-top:1em;">
      <![CDATA[
<div>
  
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之jinfo命令(Java Configuration Info)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
jinfo 用于打印指定 Java 进程、核心文件或远程调试服务器的 Java 配置信息。配置信息包括 Java 系统属性、Java 虚拟机命令行标识参数。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
<pre style="background-color:black;color:white;padding: .5em">
$ jinfo 9328
</pre>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110122720670-1294650465.png" />
</div>
<pre style="margin-top:1em;background-color:black;color:white;padding: .5em">
### 查看 jvm 的启动参数
$ jinfo -flags process_id
</pre>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20190109201108716-1517441125.png" />
</div>
<pre style="margin-top:1em;background-color:black;color:white;padding: .5em">
### 查看 jvm 系统参数
$ jinfo -sysprops process_id
</pre>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20190109201138779-473565086.png" />
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之jconsole命令(Java Monitoring and Management Console)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-top:.425em;">
jconsole:一个java GUI监视工具，可以以图表化的形式显示各种数据。并可通过远程连接监视远程的服务器VM。用java写的GUI程序，用来监控VM，并可监控远程的VM，非常易用，而且功能非常强。命令行里打 jconsole，选则进程就可以了。
</div>
<div style="margin-top:.425em;">
需要注意的就是在运行jconsole之前，必须要先设置环境变量DISPLAY，否则会报错误，Linux下设置环境变量如下：
</div>
<div style="margin-top:.425em;">
export DISPLAY=:0.0
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
<pre style="background-color:black;color:white;padding: .5em">
$ jconsole
</pre>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145030108-630710446.png" />
</div>
<div style="margin-top:.425em;">
  那我在 window 机器上的结果是，上两个图看一下：
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145108014-1806240079.png" />
</div>
<div style="margin-top:.425em;">
  可以这里选择查看本地进程的状况，还是远程进程的状况。
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145150874-1863946978.png" />
</div>
<div style="margin-top:.425em;">
  通过这张图可以看到内存、线程、类及CPU使用的一些情况。
  <br />
  内存情况：
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145659858-1981776211.png" />
</div>
<div style="margin-top:.425em;">
  VM概要：
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145752655-1260919342.png" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="示例1" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
package mat;
public class Deadlock implements Runnable{
    private int a;
    private int b;
    public Deadlock(int a, int b) {
       super();
       this.a = a;
       this.b = b;
    }
    @Override
    public void run() {
       synchronized (Integer.valueOf(a)) {
           synchronized (Integer.valueOf(b)) {
              System.out.println("a+b="+(a+b));
           }
       }
    }
    public static void main(String[] args) {
       for(int i = 0; i < 1000; ++i){
           new Thread(new Deadlock(1, 2)).start();
           new Thread(new Deadlock(2, 1)).start();
       }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
<div style="margin-top:.425em;">
用 jconsole 连接上后，看线程页
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145438139-1676386062.png" />
</div>
<div style="margin-top:.425em;">
看死锁信息：
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110145508420-1295335681.png" />
</div>
<div style="margin-top:.425em;">
用 jvisualVM 看上面的示例：
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20161110150531889-624152997.png" />
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[jdk工具之JvisualVM、JvisualVM之二--Java程序性能分析工具Java VisualVM]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-top:.425em;">
VisualVM 是一款免费的\集成了多个JDK 命令行工具的可视化工具，它能为您提供强大的分析能力，对 Java 应用程序做性能分析和调优。这些功能包括生成和分析海量数据、跟踪内存泄漏、监控垃圾回收器、执行内存和 CPU 分析，同时它还支持在 MBeans 上进行浏览和操作。
</div>
<div style="margin-top:.425em;">
在内存分析上，Java VisualVM 的最大好处是可通过安装 Visual GC 插件来分析 GC（Gabage Collection）趋势、内存消耗详细状况。
</div>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
<div style="margin-top:.425em;">
  1. 监视界面（cpu，类，堆，线程）
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-9.png" />
</div>
<div style="margin-top:.425em;">
  2. 线程界面
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-10.png" />
</div>
<div style="margin-top:.425em;">
  3-1. Profile界面（性能剖析）&mdash; 点击CPU按钮执行cpu分析查看方法
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-11.png" />
</div>
<div style="margin-top:.425em;">
  3-2. Profile界面（性能剖析）&mdash; 点击内存按钮执行内存分析查看类
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-12.png" />
</div>
<div style="margin-top:.425em;">
  4. 堆dump和线程dump操作 &mdash; Dump文件是进程的内存镜像，可以把程序的执行状态通过调试器保存到dump文件中，堆dump的dump文件内容如下图所示
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-13.png" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="一  Visual GC(监控垃圾回收器)" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;background-color:white;"
                     bodyStyle="padding:0;font-size:.95em;line-height:1.8em;">
      <![CDATA[
<div style="margin-top:.425em;">
  Java VisualVM 默认没有安装 Visual GC 插件，需要手动安装，JDK 的安装目录的 bin 目露下双击 jvisualvm.exe，即可打开 Java VisualVM，点击菜单栏 工具->插件 安装Visual GC
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-6.png" />
</div>
<div style="margin-top:.425em;">
  打开 Java VisualVM 检查更新插件时，默认的连接连不上，通过浏览器访问之后发现默认的服务器已经404，新地址已经迁移到 github，下面这个地址里面有不同版本 jdk 对应的插件中心地址。<a href="https://visualvm.github.io/pluginscenters.html">https://visualvm.github.io/pluginscenters.html</a>
</div>
<div style="margin-top:.425em;">
  我从上面的链接中找到Visual GC的下载地址：
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20170803181654053-31139650.png" />
</div>
<div style="margin-top:.425em;">
  下载下来是一个com-sun-tools-visualvm-modules-visualgc.nbm文件，然后添加安装它
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/285763-20170803181541787-1693401610.png" />
</div>
<div style="margin-top:.425em;">
  安装完成后重启Java VisualVM，Visual GC界面自动打开，即可看到JVM中堆内存的分代情况
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-7.png" />
</div>
<div style="margin-top:.425em;">
  被监控的程序运行一段时间后Visual GC显示如下
</div>
<div style="margin-top:.425em;">
  <img style="width:100%;" src="/images/j2ee/jvm-utils/mat-8.png" />
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


</c:component>
