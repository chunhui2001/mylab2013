<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract style="font-size:1em;line-height:1.6em;">
    <![CDATA[
<div style="margin-bottom:1em;">
metamask 源码分析系列文章，基于 7.4.0 版本
</div>
<div style="margin-bottom:1em;">
<h1>GitHub: <a href="https://github.com/MetaMask/metamask-extension">https://github.com/MetaMask/metamask-extension</a></h1>
</div>
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
  <li style="margin: .325em 0;">
    <p><a href="#materials" style="color:firebrick;text-decoration: underline;">参考资料</a></p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li><a href="#chrome-extension-development" style="color:firebrick;text-decoration: underline;">Chrome Extension Development</a></li>
      <li>Stream</li>
    </ul>
  </li>
  <li style="margin: .325em 0;"><p><a href="#metamask-structrues" style="color:firebrick;text-decoration: underline;">metamask 架构</a></p></li>
  <li style="margin: .325em 0;"><p><a href="#metamask-developer" style="color:firebrick;text-decoration: underline;">metamask 开发</a></p></li>
  <li>
    <p><a href="#metamask-dependencies" style="color:firebrick;text-decoration: underline;">metamask 依赖分析</a></p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li><a href="#3box" style="color:firebrick;text-decoration: underline;">3box</a></li>
      <li><a href="#eth-block-tracker" style="color:firebrick;text-decoration: underline;">eth-block-tracker</a></li>
      <li><a href="#json-rpc-engine" style="color:firebrick;text-decoration: underline;">json-rpc-engine</a></li>
      <li><a href="#json-rpc-middleware-stream" style="color:firebrick;text-decoration: underline;">json-rpc-middleware-stream</a></li>
      <li><a href="#metamask-inpage-provider" style="color:firebrick;text-decoration: underline;">metamask-inpage-provider</a></li>
      <li><a href="#nonce-tracker" style="color:firebrick;text-decoration: underline;">nonce-tracker</a></li>
      <li><a href="#obs-store" style="color:firebrick;text-decoration: underline;">obs-store</a></li>
      <li><a href="#post-message-stream" style="color:firebrick;text-decoration: underline;">post-message-stream</a></li>
    </ul>
  </li>
  <li style="margin: .325em 0;">
    <p><a href="#metamask-dictionary" style="color:firebrick;text-decoration: underline;">metamask 目录</a></p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li>
        <p>UI</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>MetaMask UI 编写规则</li>
          <li>ui/index.js</li>
        </ul>
      </li>
      <li>
        <p>app</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>app/scripts/account-import-strategies/index.js</li>
          <li>app/scripts/controllers/network/createInfuraClient.js</li>
          <li>app/scripts/controllers/network/createJsonRpcClient.js</li>
          <li>app/scripts/controllers/network/createLocalhostClient.js</li>
          <li>app/scripts/controllers/network/createMetamaskMiddleware.js</li>
          <li>app/scripts/controllers/network/network.js</li>
          <li>app/scripts/controllers/transactions
          <li>app/scripts/controllers/transactions/lib/tx-state-history-helper.js</li>
          <li>app/scripts/controllers/transactions/lib/util.js</li>
          <li>app/scripts/controllers/transactions/tx-state-manager.js</li>
          <li>app/scripts/controllers/transactions/pending-tx-tracker.js</li>
          <li>app/scripts/controllers/transactions/tx-gas-utils.js</li>
          <li>app/scripts/controllers/transactions/index.js</li>
          <li>app/scripts/controllers/balance.js</li>
          <li>app/scripts/controllers/cached-balances.js</li>
          <li>app/scripts/controllers/detect-tokens.js</li>
          <li>app/scripts/controllers/incoming-transactions.js</li>
          <li>app/scripts/controllers/preferences.js</li>
          <li>app/scripts/controllers/provider-approval.js</li>
          <li>app/scripts/controllers/recent-blocks.js</li>
          <li>app/scripts/controllers/threebox.js</li>
          <li>app/scripts/controllers/token-rates.js</li>
          <li>app/scripts/lib/ens-ipfs/resolver.js</li>
          <li>app/scripts/lib/ens-ipfs/setup.js</li>
          <li>app/scripts/lib/migrator/index.js</li>
          <li>app/scripts/lib/account-tracker.js</li>
          <li>app/scripts/lib/diagnostics-reporter.js</li>
          <li>app/scripts/lib/message-manager.js</li>
          <li>app/scripts/lib/pending-balance-calculator.js</li>
          <li>app/scripts/lib/personal-message-manager.js</li>
          <li>app/scripts/lib/stream-utils.js</li>
          <li>app/scripts/lib/typed-message-manager.js</li>
          <li>app/scripts/lib/util.js</li>
          <li>app/scripts/background.js</li>
          <li>app/scripts/chromereload.js</li>
          <li>app/scripts/contentscript.js</li>
          <li>app/scripts/createStandardProvider.js</li>
          <li>app/scripts/edge-encryptor.js</li>
          <li>app/scripts/inpage.js</li>
          <li>app/scripts/metamask-controller.js</li>
          <li>app/scripts/ui.js</li>
          <li>app/manifest.json</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>
]]>
  </c:abstract>
  


  <c:entry style="margin-top:1em;">
    <c:title id="materials"><![CDATA[<div style="color:blue;font-size:1.625em;">参考资料</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.425em;">
官方文档：<br />
<a href="https://metamask.github.io/metamask-docs/">https://metamask.github.io/metamask-docs/</a><br />
<a href="https://github.com/MetaMask/metamask-extension/tree/develop/docs">https://github.com/MetaMask/metamask-extension/tree/develop/docs</a><br />
<a href="https://medium.com/metamask">https://medium.com/metamask</a><br />
<a href="https://github.com/MetaMask/faq">https://github.com/MetaMask/faq</a><br />
</div>
<div style="margin-top:.425em;">
未来升级计划<br />
<a href="https://medium.com/metamask/breaking-changes-to-the-metamask-inpage-provider-b4dde069dd0a">https://medium.com/metamask/breaking-changes-to-the-metamask-inpage-provider-b4dde069dd0a</a>
</div>
<div style="margin-top:.425em;">
web3.js 文档<br />
<a href="https://web3js.readthedocs.io/en/v1.2.4/">https://web3js.readthedocs.io/en/v1.2.4/</a>
</div>
<div style="margin-top:.425em;">
conflux web3<br />
<a href="https://github.com/Conflux-Chain/ConfluxWeb">https://github.com/Conflux-Chain/ConfluxWeb</a>
</div>
<div style="margin-top:.425em;">
《Mastering Ethereum》<br />
<a href="https://github.com/ethereumbook/ethereumbook/blob/develop/book.asciidoc">https://github.com/ethereumbook/ethereumbook/blob/develop/book.asciidoc</a><br />
<a href="https://github.com/inoutcode/ethereum_book">https://github.com/inoutcode/ethereum_book</a>
</div>
<div style="margin-top:.425em;">
《Mastering Bitcoin》<br />
<a href="https://wizardforcel.gitbooks.io/masterbitcoin2cn/">https://wizardforcel.gitbooks.io/masterbitcoin2cn/</a>
</div>
<div style="margin-top:.425em;">
EIPs<br />
<a href="https://eips.ethereum.org/all">https://eips.ethereum.org/all</a>
</div>
<div style="margin-top:.425em;">
WebExtensions 开发文档<br />
<a href="https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions">https://developer.mozilla.org/zh-CN/docs/Mozilla/Add-ons/WebExtensions</a>
</div>
<div style="margin-top:.425em;">
其他博客资料<br />
<a href="https://www.cnblogs.com/wanghui-garcia/category/1309162.html">https://www.cnblogs.com/wanghui-garcia/category/1309162.html</a>
</div>
<div style="margin-top:.425em;">
Stream<br />
<a href="https://nodejs.org/api/stream.html">https://nodejs.org/api/stream.html</a><br />
<a href="http://nodejs.cn/api/stream.html">http://nodejs.cn/api/stream.html</a><br />
<a href="https://github.com/jabez128/stream-handbook">https://github.com/jabez128/stream-handbook</a>
</div>
<div style="margin-top:.425em;">
0xcert<br />
<a href="https://github.com/0xcert/framework">https://github.com/0xcert/framework</a>
</div>

   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="chrome-extension-development"><![CDATA[<div style="color:blue;font-size:1.625em;">Chrome Extension Development</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;line-height:1.625em;">
官方文档: https://developer.chrome.com/extensions
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<h1 style="padding-bottom:0;">核心模块</h1>
<h2>&#x02713; manifest.json</h2>
<div style="margin-bottom:.425em;">
  Chrome 插件最重要也是必不可少的文件，用来配置所有和插件相关的配置，必须放在根目录。其中，manifest_version、name、version 3个是必不可少的，description 和 icons 是推荐的。
</div>

<h2>&#x02713; content-scripts</h2>
<div style="margin-bottom:.425em;">
Chrome 插件中向页面注入脚本的一种形式（虽然名为script，其实还可以包括css的），借助 content-scripts 我们可以实现通过配置的方式轻松向指定页面注入 JS 和 CSS。
</div>
<div style="margin-bottom:.425em;">
content-scripts 和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过 injected js来实现。
</div>

<h2>&#x02713; background</h2>
<div style="margin-bottom:.425em;">
后台（姑且这么翻译吧），是一个常驻的页面，它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在 background 里面。
</div>
<div style="margin-bottom:.425em;">
background 的权限非常高，几乎可以调用所有的 Chrome 扩展 API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。
</div>
<div style="margin-bottom:.425em;">
配置中，background 可以通过 page 指定一张网页，也可以通过 scripts 直接指定一个JS，Chrome 会自动为这个 JS 生成一个默认的网页。
</div>
<div style="margin-bottom:.425em;">
你可以打开无数个 background.html，但是真正在后台常驻的只有一个，而且这个你永远看不到它的界面，只能调试它的代码。
</div>

<h2>&#x02713; event-pages</h2>
<div style="margin-bottom:.425em;">
鉴于 background 生命周期太长，长时间挂载后台可能会影响性能，所以 Google 又弄一个 event-pages，在配置文件上，它与 background 的唯一区别就是多了一个 persistent 参数：
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
{
    "background":
    {
        "scripts": ["event-page.js"],
        "persistent": false
    },
}
</pre>
<div style="margin-bottom:.425em;margin-top:.425em;">
它的生命周期是：在被需要时加载，在空闲时被关闭，什么叫被需要时呢？比如第一次安装、插件更新、有 content-script 向它发送消息，等等。
</div>

<h2>&#x02713; popup</h2>
<div style="margin-bottom:.425em;">
popup 是点击 browser_action 或者 page_action 图标时打开的一个小窗口网页，焦点离开网页就立即关闭，一般用来做一些临时性的交互。
</div> 
<div>
  <img style="width:550px;" src="/images/ether/1577419133949-035ae8d6-f151-47a5-8f87-d446a8558527.png" />
</div>
<div style="margin-bottom:.425em;">
popup 可以包含任意你想要的 HTML 内容，并且会自适应大小。可以通过 default_popup 字段来指定 popup 页面，也可以调用 setPopup() 方法。
</div>
<div style="margin-bottom:.425em;">
需要特别注意的是，由于单击图标打开 popup，焦点离开又立即关闭，所以 popup 页面的生命周期一般很短，需要长时间运行的代码千万不要写在 popup 里面。
</div>
<div style="margin-bottom:.425em;">
在权限上，它和 background 非常类似，它们之间最大的不同是生命周期的不同，popup 中可以直接通过 chrome.extension.getBackgroundPage() 获取 background 的 window 对象。
</div> 

<h2>&#x02713; injected-script</h2>
<div style="margin-bottom:.425em;">
通过DOM操作的方式向页面注入的一种JS。
</div>
<div style="margin-bottom:.425em;">
content-script 有一个很大的“缺陷”，也就是无法访问页面中的JS，虽然它可以操作DOM，但是DOM却不能调用它，也就是无法在DOM中通过绑定事件的方式调用 content-script 中的代码。
</div>

<h2>&#x02713; homepage_url</h2>
<div>
  <img style="width:auto;" src="/images/ether/1577419123158-3a22fd54-c161-4891-a1fb-f8fe33e9c158.png" />
</div>

<h1 style="padding-bottom:0;">展示形式</h1>
<h2>&#x02713; browserAction(浏览器右上角)</h2>
<div>
  <img style="width:auto;" src="/images/ether/1577419228310-10eb3132-915e-4b38-ae44-2191851cf605.png" />
</div>

<h2>&#x02713; pageAction(地址栏右侧)</h2>
<div>
  只有当某些特定页面打开才显示的图标，它和 browserAction 最大的区别是一个始终都显示，一个只在特定情况才显示，平时置灰。
</div>

<h2>&#x02713; 右键菜单</h2>
<div>
  主要是通过chrome.contextMenusAPI实现。
</div>
<div>
  <img style="width:auto;" src="/images/ether/1577419396349-27ea3297-27db-4838-a3e7-634b45816d79.png" />
</div>

<h2>&#x02713; override(覆盖特定页面)</h2>
<div>
使用 override 页可以将 Chrome 默认的一些特定页面替换掉，改为使用扩展提供的页面。扩展可以替代如下页面：
</div>
<ul style="margin-top:.325em;list-style: disc;margin-left:1.5em;font-size: 1em;line-height: 1.625em;">
  <li>历史记录：从工具菜单上点击历史记录时访问的页面，或者从地址栏直接输入 chrome://history</li>
  <li>新标签页：当创建新标签的时候访问的页面，或者从地址栏直接输入 chrome://newtab</li>
  <li>书签：浏览器的书签，或者直接输入 chrome://bookmarks</li>
</ul>

<h2>&#x02713; devtools(开发者工具)</h2>
<div>
Chrome允许插件在开发者工具(devtools)上动手脚，主要表现在：
</div>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.625em;">
  <li><b>&#x02ABC; 自定义一个和多个和Elements、Console、Sources等同级别的面板；</li>
  <li><b>&#x02ABC; 自定义侧边栏(sidebar)，目前只能自定义Elements面板的侧边栏；</li>
</ul>
<div>
  <img style="width:auto;" src="/images/ether/1577419557354-f6a8fc7a-0a4f-44d2-a6d1-acdd55ce3f90.png" />
</div>

<h2>&#x02713; option(选项页)</h2>
<div>
所谓 options 页，就是插件的设置页面，有2个入口，一个是右键图标有一个 “选项” 菜单，还有一个在插件管理页面：
</div>
<div>
  <img style="width:auto;" src="/images/ether/1577427044275-68e54dca-fc11-4211-be67-4d6a7c02e93f.png" />
</div>

<h2>&#x02713; omnibox</h2>
<div>
omnibox 是向用户提供搜索建议的一种方式。
</div>
<div>
  <img style="width:auto;" src="/images/ether/1577427106075-c8019fb6-fb7d-4b9f-8113-72f7a7590b97.gif" />
</div>

<h2>&#x02713; 桌面通知</h2>
<div>
Chrome 提供了一个 chrome.notificationsAPI 以便插件推送桌面通知。在后台JS中，无论是使用 chrome.notifications 还是 Notification 都不需要申请权限（HTML5方式需要申请权限），直接使用即可。
</div>
<div>
  <img style="width:auto;" src="/images/ether/1577427162579-e5d32482-e702-4e1f-8df3-1ec03a9d90c7.png" />
</div>

<h2>&#x02713; 消息通信</h2>
<table style="width:100%;font-size: .8em;">
  <thead>
    <tr>
      <th style="border: dashed 1px;padding: 5px 10px;">&nbsp;</th>
      <th style="border: dashed 1px;padding: 5px 10px;">injected-script</th>
      <th style="border: dashed 1px;padding: 5px 10px;">content-script</th>
      <th style="border: dashed 1px;padding: 5px 10px;width: 225px;">popup-js</th>
      <th style="border: dashed 1px;padding: 5px 10px;">background-js</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">injected-script</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">window.postMessage</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">content-script</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">window.postMessage</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">chrome.runtime.sendMessage <br /> chrome.runtime.connect</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">chrome.runtime.sendMessage <br /> chrome.runtime.connect</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">popup-js</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">chrome.tabs.sendMessage <br /> chrome.tabs.connect</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">chrome.extension.getBackgroundPage()</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">background-js</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">chrome.tabs.sendMessage chrome.tabs.connect</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">chrome.extension.getViews</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">-</td>
    </tr>
    <tr>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">devtools-js</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">chrome.devtools. inspectedWindow.eval</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">-</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;">chrome.runtime.sendMessage</td>
      <td style="border: dashed 1px darkgray;padding: 5px 5px;word-break: break-all;">chrome.runtime.sendMessage</td>
    </tr>
  </tbody>
</table>
<div>
  <img style="width:auto;" src="/images/ether/1577432410206-e7d22a9c-1c60-4a95-bd0f-84a9a598e978.png" />
</div>
<div>
Chrome插件中有2种通信方式，一个是短连接（chrome.tabs.sendMessage和chrome.runtime.sendMessage），一个是长连接（chrome.tabs.connect和chrome.runtime.connect）。
</div>
<div style="margin-top:.625em;">
短连接的话就是挤牙膏一样，我发送一下，你收到了再回复一下，如果对方不回复，你只能重新发，而长连接类似WebSocket会一直建立连接，双方可以随时互发消息。
</div>

<h1 style="padding-bottom:0;">content script与 background 的通信</h1>
<h2>&#x02713; content-script 向 background 发送消息</h2>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// 在 content-script 端：
chrome.runtime.sendMessege(
    message,
    function(response) {…}
)
</pre>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// 在 background 端：
chrome.runtime.onMessege.addListener(
    // request 发来的消息
    // sendResponse 一个函数，用于对发来的消息进行回应，如 
    // sendResponse('我已收到你的消息：'+JSON.stringify(request));
    function(request, sender, sendResponse) {…}
)
</pre>
<div style="margin-top:.625em;">
由于 background 监听所有页面上的 content script 上发来的消息，如果多个页面同时发送同种消息，background 的 onMessage 只会处理最先收到的那个，其他的不了了之了。
</div>

<h2>&#x02713; background 向 content-script 发送消息</h2>
<div>
一个插件里只有一个 background 环境，而 content-script 有多个（一个页面一个），那么 background 怎么向特定的 content-script 发送消息？
</div>
<div style="margin-top:.625em;">
在 background 端
</div>
<div style="margin-top:.625em;">
首先我们需要知道要向哪个 content scripts 发送消息，一般一个页面一份 content scripts，而一个页面对应一个浏览器 tab，每个 tab 都有自己的 tabId，因此首先要获取要发送消息的 tab 对应的 tabId。
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
/**
 * 获取当前选项卡id
 * @param callback - 获取到id后要执行的回调函数
 */
function getCurrentTabId(callback) {
    chrome.tabs.query({active: true, currentWindow: true}, function (tabs) {
        if (callback) {
            callback(tabs.length ? tabs[0].id: null);
        }
    });
}
</pre>
<div style="margin-top:.625em;">
当知道了 tabId 后，就使用该 api 进行发送消息
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
chrome.tabs.sendMessage(tabId, message, function(response) {...});
</pre>
<div style="margin-top:.625em;">
在 content scripts 端
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
chrome.runtime.onMessege.addListener(function(request, sender, sendResponse) {…})
</pre>

<h1 style="padding-bottom:0;">popup 与 background 的通信</h1>
<div style="margin-top:.625em;">
一般地，popup 与 background 的交流，常见于 popup 要获取 background 里的某些 “东西”
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
var bg = chrome.extension.getBackgroundPage();
bg.someMethod();    //someMethod()是background中的一个方法
</pre>

<h1 style="padding-bottom:0;">popup 与 content script 的通信</h1>
<div style="margin-top:.625em;">
这里的通信，实际上跟 background 与 content script 的方式是一样的
</div>

<h1 style="padding-bottom:0;">插件 iframe 网站与插入网页的通信</h1>
<div style="margin-top:.625em;">
同域的情况下，可以通过 DOM 操作达到通信的目的，如获取 dom 元素，获取值赋值之类的。<br />
在父窗体里，用 window.contentWindow 获取到 iframe 的 window 对象 <br />
在 iframe 里，用 window.parent 获取到父窗体的 window 对象 <br />
在跨域下，使用 window 对象的 postMessage() 和 onmessage。
</div>

<h1 style="padding-bottom:0;">iframe 向父窗体发送消息</h1>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
window.parent.postMessage(message, '*');
</pre>

<h1 style="padding-bottom:0;">在父窗体端</h1>
<div style="margin-top:.625em;">
由于一个页面，可能有来自页面本身的 postMessage 来的消息，也有可能来自该页面其他 chrome extension 发送来的消息，因此用 onmessage 来监听，要做好区分来源，这里使用以下方法:
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
window.addEventListener('message', function (event, a, b) {
    // 如果没消息就退出
    if (!event.data) {
        return;
    }
    var iframes = document.getElementsByClassName('extension-iframe');
    var extensionIframe = null; // 存插件iframe节点对象
    var correctSource = false;  // 是否来源正确
    // 找出真正的插件生成的iframe
    for (var i = 0; i < iframes.length; i++) {
        if (iframes[i].contentWindow && (event.source === iframes[i].contentWindow)) {
            correctSource = true;
            extensionIframe = iframes[i];
            break;
        }
    }
    // 如果来源不是来自插件的，就退出
    if (!correctSource) {
        return;
    }
}, false);
</pre>

<h1 style="padding-bottom:0;">父窗体向iframe发送消息</h1>
<div style="margin-top:.625em;">
在父窗体端
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
extensionIframe.contentWindow.postMessage(message, '*');
// message: {from: 'content-script', other: xxx}
</pre>
<div style="margin-top:.625em;">
在 iframe 端
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
window.addEventListener('message', function (event, a, b) {
    let result = event.data;
    if (result && (result.from === 'content-script') 
        && (event.source === window.parent)) {...}
});
</pre>

<h1 style="padding-bottom:0;">本地存储</h1>
<div style="margin-top:.625em;">
本地存储建议用 chrome.storage 而不是普通的 localStorage
</div>
<div style="margin-top:.625em;">
chrome.storage 是针对插件全局的，即使你在 background 中保存的数据，在 content-script 也能获取到；
chrome.storage.sync 可以跟随当前登录用户自动同步，这台电脑修改的设置会自动同步到其它电脑，很方便，如果没有登录或者未联网则先保存到本地，等登录了再同步至网络；
</div>

<h1 style="padding-bottom:0;">webRequest</h1>
<div style="margin-top:.625em;">
通过 webRequest 系列API可以对HTTP请求进行任性地修改、定制。插件要实现一些 ajax 请求，尽量搬到 background 里实现，可以跨域。
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
iframe -> content script -> background -> content script -> iframe
</pre>

<h1 style="padding-bottom:0;">国际化</h1>
<div style="margin-top:.625em;">
插件根目录新建一个名为 _locales 的文件夹，再在下面新建一些语言的文件夹，如en、zh_CN、zh_TW，然后再在每个文件夹放入一个 messages.json，同时必须在清单文件中设置 default_locale。
</div>
<div style="margin-top:.625em;">
JS中则直接 chrome.i18n.getMessage("helloWorld")。
</div>
<div style="margin-top:.625em;">
测试时，通过给 chrome 建立一个不同的快捷方式 chrome.exe --lang=en 来切换语言。
</div>

<h1 style="padding-bottom:0;">注意事项</h1>
<h2>&#x02713; 特别注意background的报错</h2>
<div>
很多时候你发现你的代码会莫名其妙的失效，找来找去又找不到原因，这时打开 background 的控制台才发现原来某个地方写错了导致代码没生效，正式由于 background 报错的隐蔽性(需要主动打开对应的控制台才能看到错误)，所以特别注意这点。
</div>
<h2>&#x02713; 如何让 popup 页面不关闭</h2>
<div>
在对 popup 页面审查元素的时候 popup 会被强制打开无法关闭，只有控制台关闭了才可以关闭 popup，原因很简单：如果 popup 关闭了控制台就没用了。这种方法在某些情况下很实用！
</div>
<h2>&#x02713; 不支持内联JavaScript的执行</h2>
<div>
不支持将js直接写在html中。
</div>
<h2>&#x02713; 注入CSS的时候必须小心</h2>
<div>
由于通过 content_scripts 注入的CSS优先级非常高，几乎仅次于浏览器默认样式，稍不注意可能就会影响一些网站的展示效果，所以尽量不要写一些影响全局的样式。
</div>

TODOTODO
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="metamask-structrues"><![CDATA[<div style="color:blue;font-size:1.625em;">metamask 架构</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  metamask 既是钱包，也是和以太网交互的途径。
</div>
<div>
  <img style="width:550px;" src="/images/ether/1576481371539-60166627-5cd7-4717-b69d-151c289e2029.png" />
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
  通过架构图，可以知道，作为用户，要么可以在 metamask UI界面里面直接玩，要么可以在玩耍 dApp 的时候，调用 metamask，不管怎么样，都是通过 metamask-background ，最终调用 eth 的 rpc。
</div>
<div style="margin-bottom:.425em;">
  源码的类、对象等的详细解释: <br />
  <a href="https://metamask.github.io/metamask-extension/index.html">https://metamask.github.io/metamask-extension/index.html</a> 
</div>
<div style="margin-bottom:.425em;">
  Guide to Porting MetaMask to a New Environment 这篇文章大概梳理了一下流程: <br />
  <a href="https://github.com/MetaMask/metamask-extension/blob/develop/docs/porting_to_new_environment.md">https://github.com/MetaMask/metamask-extension/blob/develop/docs/porting_to_new_environment.md</a>
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="metamask-background" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.6em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
  <a href="https://github.com/MetaMask/metamask-extension/blob/develop/app/scripts/background.js">https://github.com/MetaMask/metamask-extension/blob/develop/app/scripts/background.js</a>
</div>
<div style="margin-bottom:.425em;">
<a href="https://www.yuque.com/jnoodle/ox47v8/pn8ynl">background.js</a> 里面实例化了 MetaMask Controller，MetaMask Controller 主要用于用户账户、和链的连接还有和 dapp 的交互。
</div>
<div style="margin-bottom:.425em;">
每当访问一个新站点，插件都会创建一个 ContentScript 在页面中：
</div>
<div style="margin-bottom:.425em;">
<a href="https://github.com/MetaMask/metamask-extension/blob/develop/app/scripts/contentscript.js">https://github.com/MetaMask/metamask-extension/blob/develop/app/scripts/contentscript.js</a> <br />
<a href="https://www.yuque.com/jnoodle/ox47v8/anceie">https://www.yuque.com/jnoodle/ox47v8/anceie</a>
</div>
<div style="margin-bottom:.425em;">
ContentScript 在每个页面里都注入了 web3 api，通过 Port API （使用 <a href="https://github.com/jabez128/stream-handbook">stream</a> 抽象包裹） 连接到 background，在页面加载之间注入 DOM。
</div>
<div style="margin-bottom:.425em;">
<a href="https://github.com/MetaMask/metamask-inpage-provider">https://github.com/MetaMask/metamask-inpage-provider</a> 就是一个 eth provider，MetaMask 把 metamask-inpage-provider 注入到页面中，我们自己也可以构造一个 provider：
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
const providerFromEngine = require('eth-json-rpc-middleware/providerFromEngine')

/**
 * returns a provider restricted to the requesting domain
 **/
function incomingConnection (domain) {
  const engine = metamaskController.setupProviderEngine(domain)
  const provider = providerFromEngine(engine)
  return provider
} 
</pre>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="使用 Streams Interface" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.6em;margin-top:.625em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
  可以看一下 MetaMask 如何在 <a href="https://github.com/MetaMask/metamask-extension/blob/develop/app/scripts/inpage.js">inpage.js</a> 中来创建 <a href="https://github.com/MetaMask/metamask-inpage-provider/blob/master/index.js">MetamaskInpageProvider</a>。其实 MetaMask 在 <a href="https://developer.chrome.com/extensions/runtime#property-Port-postMessage">Port postMessage API</a> 基础上做了一层封装。
</div>
<div style="margin-bottom:.425em;">
  通过 setupUntrustedCommunication(stream, domain)，可以和 MetaMaskController 通信。
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="MetaMask Controller" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.6em;margin-top:.625em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
<a href="https://github.com/MetaMask/metamask-extension/blob/master/app/scripts/metamask-controller.js">https://github.com/MetaMask/metamask-extension/blob/master/app/scripts/metamask-controller.js</a> <br />
<a href="https://www.yuque.com/jnoodle/ox47v8/xot5gg">https://www.yuque.com/jnoodle/ox47v8/xot5gg</a>
</div>

<div style="margin-bottom:.425em;">
MetaMask 的核心功能都在 MetaMask Controller 里面。创建 MetaMask Controller 的目标是让他可以导入到任何 JS 上下文中，可以管理 app 和 Ethereum 之间的关系。
</div>

<h1 style="padding-bottom:0;">Contructor</h1>
<h2>&#x02713; new MetaMask(opts)</h2>
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;font-size: 1em;line-height: 1.625em;">
  <li><b>initState:</b> The last emitted state, used for restoring persistent state between sessions. 最后发出的状态，用于在会话之间恢复持久状态</li>
  <li>
    <p><b>platform:</b> The platform object defines a variety of platform-specific functions, including opening the confirmation view, and opening websites. 平台对象定义了各种特定于平台的功能，包括打开确认视图和打开web站点。</p>
    <ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.625em;">
      <li><b>&#x02ABC; reload (function)</b> - Will be called when MetaMask would like to reload its own context. 将在MetaMask想要重新加载其自己的上下文时调用</li>
      <li><b>&#x02ABC; openWindow ({ url })</b> - Will be called when MetaMask would like to open a web page. It will be passed a single options object with a url key, with a string value. 在MetaMask想要打开web页面时调用。它将传递一个带有url键和字符串值的单一选项对象</li>
      <li><b>&#x02ABC; getVersion()</b> - Should return the current MetaMask version, as described in the current CHANGELOG.md or app/manifest.json. 应该返回当前MetaMask的版本，即在当前的 CHANGELOG.md或app/manifest.json中所述的版本号</li>
    </ul>
  </li>
  <li>
    <p><b>encryptor</b> - An object that provides access to the desired encryption methods. 供对所需加密方法的访问的对象，提供两种可以以你喜欢的任何格式进行加密的简单方法的对象。这个参数是可选的，默认为浏览器本地的WebCrypto API。</p>
    <ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.625em;">
      <li><b>&#x02ABC; encrypt(password, object)</b> - returns a Promise of a string that is ready for storage.</li>
      <li><b>&#x02ABC; decrypt(password, encryptedString)</b> - Accepts the encrypted output of encrypt and returns a Promise of a restored object as it was encrypted.</li>
    </ul>
  </li>
</ul>

<h2>&#x02713; metamask.getState()</h2>
<div style="margin-bottom:.425em;">
该方法返回一个 javascript 对象，表示当前的 MetaMask state。这包括已知的帐户、发送的交易、当前汇率等等。控制器也是一个事件发射器，所以你可以通过 metamask.on('update', handleStateUpdate) 来订阅状态更新。<a href="https://github.com/MetaMask/metamask-extension/tree/master/development/states">状态示例</a> 即一系列json文件，即 "metamask" 键下的值的信息。
</div>

<h2>&#x02713; metamask.getApi()</h2>
<div style="margin-bottom:.425em;">
返回一个JavaScript对象，该对象中包含回调函数，表示用户界面执行的每个操作。通过这些API方法提供了从创建新帐户、更改当前网络到发送交易的所有内容。我们在对象上导出这个外部API，因为它允许我们使用 dnode 在端口上轻松地公开这个API，这就是 WebExtension UI 的工作方式!
</div>


<h1 style="padding-bottom:0;">UI</h1>
<div style="margin-bottom:.425em;">
MetaMask UI本质上只是一个网站，可以通过从上面传递API和状态订阅来配置它。任何人都可以创建一个使用这些的UI，有效地重新设计MetaMask
</div>
<div style="margin-bottom:.425em;">
UI 的实现：<br />
<a href="https://github.com/MetaMask/metamask-extension/blob/master/ui/index.js">https://github.com/MetaMask/metamask-extension/blob/master/ui/index.js</a>
<a href="https://www.yuque.com/jnoodle/ox47v8/tkc19z">https://www.yuque.com/jnoodle/ox47v8/tkc19z</a>
</div>
<div style="margin-bottom:.425em;">
backgroundConnection 会被传到 UI 里，backgroundConnection 对于 MetaMask Controller 非常重要，通过访问它，UI能够初始化整个依赖于该API实现其帐户/区块链相关/持久状态的React/Redux应用程序。
</div>
<h2>&#x02713; Putting it Together</h2>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// manifest.json
...
  "background": {
    "scripts": [
      "chromereload.js",
      "bg-libs.js",
      "background.js"
    ],
    "persistent": true
  },
...
</pre>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
const controller = new MetamaskController({
    // User confirmation callbacks:
    showUnconfirmedMessage: triggerUi,
    showUnapprovedTx: triggerUi,
    // initial state
    initState,
    // platform specific api
    platform,
})
</pre>
<div style="margin-bottom:.425em;margin-top:1em;">
background.js 完成的事情：
</div>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.825em;">
  <li>&starf; Defining how to open the UI for new messages, transactions, and even requests to unlock (reveal to the site) their account. 定义如何为新消息、事务、甚至为解锁(向站点显示)其帐户的请求打开UI</li>
  <li>&starf; Provide the instance's initial state, leaving MetaMask persistence to the platform. 提供实例的初始状态，将MetaMask持久化保留到平台</li>
  <li>&starf; Providing a platform object. This is becoming our catch-all adapter for platforms to define a few other platform-variant features we require, like opening a web link. (Soon we will be moving encryption out here too, since our browser-encryption isn't portable enough!) 提供平台对象。这将成为平台的通用适配器，用于定义我们需要的其他一些平台变体特性，比如打开web链接。(不久我们也将把加密技术移到这里，因为我们的浏览器加密还不够便携!)</li>
</ul>


<h1>Ports, streams, and Web3!</h1>
<div style="margin-bottom:.425em;">
到目前为止，在几乎所有运行JS的平台上都可以创建一个MetaMask wallet，但MetaMask最独特的功能不是钱包，而是为网站提供了一个Ethereum-enabled的JavaScript环境。
</div>
<div style="margin-bottom:.425em;">
MetaMask 暴露了两种 <a href="https://github.com/substack/stream-handbook#duplex">duplex stream APIs</a>
</div>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.825em;">
  <li>&starf; <b>metamask.setupTrustedCommunication(connectionStream, originDomain)</b> - This stream is used to connect the user interface over a remote port, and may not be necessary for contexts where the interface and the metamask-controller share a process.  此流用于通过远程端口连接用户界面，对于接口和metamask控制器共享进程的上下文可能不需要此流</li>
  <li>&starf; <b>metamask.setupUntrustedCommunication(connectionStream, originDomain)</b> - This method is used to connect a new web site's web3 API to MetaMask's blockchain connection. Additionally, the originDomain is used to block detected phishing sites. 此方法用于将新web站点的web3 API连接到MetaMask的区块链连接。另外，originDomain可以用来阻止检测到的钓鱼网站</li>
</ul>


<h1>Web3 as a Stream</h1>
<div style="margin-bottom:.425em;">
如果正在为一个新平台开发一个基于 MetaMask-powered 的浏览器，那么最棘手的任务之一就是将 Web3 API 注入到访问的网站中。在 WebExtensions，我们实际上需要通过总共三个JS上下文来传输数据，只是为了让站点与我们的后台进程对话 (site -> contentscript -> background)
</div>
<div style="margin-bottom:.425em;">
可以看一下 <a href="https://github.com/MetaMask/metamask-extension/blob/master/app/scripts/inpage.js">https://github.com/MetaMask/metamask-extension/blob/master/app/scripts/inpage.js</a> 来了解是怎么往网站里面注入的。创建了一个到后台的多路复用的 stream，并使用它来初始化 <a href="https://github.com/MetaMask/metamask-inpage-provider/blob/master/index.js">MetamaskInpageProvider</a>，可以看到 inpage-provider 的一些方法输出了stubs（存根），但它的大多数方法只是通过它传递的流来传递对sendAsync的调用! 一旦你有了一个可用的 MetaMask 流，以上就是在远程上下文中创建类似 web3 的API所需要的所有操作。
</div>
<div style="margin-bottom:.425em;">
在 inpage.js 你可以看到我们创建了一个我们用来将 WebExtension 端口包装成流的 <a href="https://github.com/MetaMask/metamask-extension/blob/develop/app/scripts/inpage.js#L52">PortMessage Stream</a>，因此我们可以在 WebExtension 的更加不规则的API表面上重用我们喜欢的流抽象。在新的平台中，您可能需要以不同的方式构造这个流。关键是您需要构建一个从站点上下文到后台的流。一旦你设置好了，它就会像魔术一样运作!
</div>
<div style="margin-bottom:.425em;">
学习 stream：<br />
<a href="https://github.com/substack/stream-handbook">https://github.com/substack/stream-handbook</a>（中文：<a href="https://github.com/jabez128/stream-handbook">https://github.com/jabez128/stream-handbook</a>）
<a href="https://github.com/workshopper/stream-adventure">https://github.com/workshopper/stream-adventure</a>
</div>


<h1>MetaMask 实现了 RPC 接管</h1>
<div style="margin-bottom:.425em;">
chrome 扩展程序基本结构：
</div>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.825em;">
  <li>&starf; contentscripts.js：插件中唯一拥有操作当前活动标签页面dom权限的js</li>
  <li>&starf; background.js：全局运行的js(类似于`插件后台`)</li>
  <li>&starf; propub.html：插件界面UI</li>
</ul>
<div style="margin-bottom:.425em;margin-top:1em;">
插件中的 js 之间可以通过 postMessage 接口通信
</div>
<div style="margin-bottom:.425em;">
Metamask 在 contentscripts.js 中 injects inpage.js。
</div>
<div style="margin-bottom:.425em;">
inpage.js 中注册 MetamaskInpageProvider（metamask-inpage-provider库）为 web3。
</div>
<div style="margin-bottom:.425em;">
MetamaskInpageProvider 实现了 web3 的方法。
</div>


   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="metamask-developer"><![CDATA[<div style="color:blue;font-size:1.625em;">metamask 开发</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;line-height:1.625em;">
MetaMask 主要是用来在浏览器中直接连接 ETH 网络的插件，本身带有钱包功能。
</div>
<div style="margin-bottom:.425em;font-size:1.225em;line-height:1.625em;">
大部分 Dapp 是运行在浏览器里的，这样通过浏览器插件来使用 ETH 上面的合约很方便。这里说的开发主要是 dapp 调用 MetaMask 来进行一些链操作。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
metamask 提供了 window.ethereum 与用户应用交互。
</div>
<div style="margin-bottom:.425em;">
用 ethereum.isMetaMask 检测 metamask。
</div>
<div style="margin-bottom:.425em;">
What is the current network?  ethereum.networkVersion<br />
What is the current account?  ethereum.selectedAddress
</div>
<div style="margin-bottom:.425em;">
连接 metamask，不要在页面载入后自动连接，而是要通过用户事件触发，比如点击 “连接 MetaMask” 按钮。
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
const accounts = await ethereum.enable()
const account = accounts[0] // We currently only ever provide a single account,
                            // but the array gives us some room to grow.
</pre>

<h1 style="padding-bottom:0;">术语</h1>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.825em;">
  <li>&starf; <b>Wallet：</b>钱包是用来管理账户的 interface / client / wrapper / holder</li>
  <li>&starf; <b>Account：</b>A public & private keypair that "holds" your funds.</li>
  <li>&starf; <b>Address (“Public Key”) ：</b>You use this to send funds to an account. 0x + 40 hexadecimal characters </li>
  <li>&starf; <b>Public Key：</b>You can derive a public key from a private key. </li>
  <li>&starf; <b>Private Key：</b>You use this to send funds from an account. A string of 64 hexadecimal characters. 一般不用明文保存，而是加密下保存，比如 the Keystore File / Mnemonic Phrase</li>
  <li>&starf; <b>Keystore File：</b>Encrypted version of your private key in JSON format</li>
  <li>&starf; <b>Mnemonic Phrase / Seed Phrase / Seed Words：</b>助记词 A (typically) 12 or 24 word phrase that allows you to access infinite number of accounts.</li>
  <li>&starf; <b>Hardware Wallet：</b>注意离线备份助记词</li>
  <li>&starf; <b>Identicon / AddressIdenticon / AddressIcon：</b>通过图标快速区分地址</li>
  <li>&starf; <b>Hexadecimal：</b>十六进制</li>
  <li>&starf; <b>Seed：</b>随机产生私钥</li>
  <li>&starf; <b>Brain Wallet：</b>An account generated from a seed or password or passphrase of your choosing. Don't use brain wallets.</li>
  <li>&starf; <b>Entropy：</b>熵 Also known as "randomness". The more random something is, the more entropy it has, and the more secure it is.</li>
  <li>&starf; <b>Derive / Derivation：</b>To derive something is to obtain it from an original source.</li>
  <li>&starf; <b>Encryption：</b>加密</li>
  <li>&starf; <b>Encrypted vs Unencrypted Keys：</li>
  <li>&starf; <b>Decentralize / Decentralization：</b>分散集权</li>
  <li>&starf; <b>Trustless：</b>A distributed trustless consensus which the blockchain is responsible for. </li>
  <li>&starf; <b>Smart Contracts：</b>A piece of code (or program) that is stored on the blockchain network.</li>
  <li>&starf; <b>Blockchain：</b>A decentralized publicly owned ledger.</li>
</ul>

<h1 style="padding-bottom:0;">Dapps</h1>
<div style="margin-bottom:.425em;margin-top:.325em;">
一些 dapp 可以识别用户当前网络，自动切换合约地址。
</div>
<div style="margin-bottom:.425em;">
智能合约都要有个地址 Contract Address。
</div>
<div style="margin-bottom:.425em;">
Contract ABI：类比 API
</div>
<div style="margin-bottom:.425em;">
Contract Bytecode：字节码用来发布，没有 ABI，只有字节码，也没法交互。
</div>

<h1 style="padding-bottom:0;">访问账户</h1>
<div style="margin-bottom:.425em;margin-top:.325em;">
ethereum.selectedAddress  订阅账户变化：
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
ethereum.on('accountsChanged', function (accounts) {
  // Time to reload your interface with accounts[0]!
})
</pre>
<div style="margin-bottom:.425em;margin-top:.625em;">
下面调用钱包的方法都需要用户账户参数：
</div>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.825em;">
  <li>&starf; eth_sendTransaction</li>
  <li>&starf; eth_sign (insecure and unadvised to use)</li>
  <li>&starf; eth_personalSign</li>
  <li>&starf; eth_signTypedData</li>
</ul>

<h1 style="padding-bottom:0;">发送交易</h1>
<div style="margin-bottom:.425em;margin-top:.325em;">
在 Metamask 里使用 ethereum.sendAsync 发送交易，背后调用 eth_sendTransaction  方法
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
const transactionParameters = {
  
  // ignored by MetaMask, MetaMask 自动管理
  nonce: '0x00',
  
  // customizable by user during MetaMask confirmation. 
  // 一般自己不用管
  // MetaMask 通过 API 请求 MyCrypto，获取 “slow,” “medium,” and “fast” 的 gas price
  gasPrice: '0x09184e72a000', 
  
  // customizable by user during MetaMask confirmation.
  // 一般也不用管
  gas: '0x2710',  
  
  // Required except during contract publications.
  // 一般不是创建合约的话，都需要
  to: '0x0000000000000000000000000000000000000000', 
  
  // must match user's active address.
  from: web3.eth.accounts[0], 
  
  // Only required to send ether to the recipient from the initiating external account.
  // 单位 wei 1e-18 
  // 尽量使用 BN.js 处理
  value: '0x00', 
  
  // Optional, but used for defining smart contract creation and interaction.
  // 一般创建智能合约需要
  data: '0x7f7465737432000000000000000000000000000000000000000000000000000000600057', 
  
  // Used to prevent transaction reuse across blockchains. Auto-filled by MetaMask.
  // 现在直接用 ethereum.networkVersion，未来可能需要传
  chainId: 3 
  
}

ethereum.sendAsync({
  method: 'eth_sendTransaction',
  params: [transactionParameters],
  from: ethereum.selectedAddress,
}, callback)
</pre>

<h1 style="padding-bottom:0;">接入到一个自定义的网络</h1>
<div>
  <img style="width:330px;" src="/images/ether/1577242873553-3e536465-f9be-430d-b349-e5c687d89b77.png" />
</div>
<div style="margin-top:1em;">
  修改下面的文件：
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
app/scripts/config.js
app/scripts/lib/buy-eth-url.js
ui/app/index.js
ui/app/components/buy-button-subview.js
ui/app/components/drop-menu-item.js
ui/app/components/network.js
ui/app/components/transaction-list-item.js
ui/app/config.js
ui/app/css/lib.css
ui/lib/account-link.js
ui/lib/explorer-link.js
</pre>
<div style="margin-top:1em;">
  需要:
</div>
<ul style="margin-top:.325em;list-style: none;font-size: 1em;line-height: 1.825em;">
  <li>&starf; The network ID</li>
  <li>&starf; An RPC Endpoint url</li>
  <li>&starf; An explorer link</li>
  <li>&starf; CSS for the display icon</li>
</ul>

<h1 style="padding-bottom:0;">接口</h1>
<div>
  metamask 主要是把 web3 注入到了所有页面的 js 上下文中，如果这个页面是个 dapp，就可以直接和 eth 链交互了。
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
if (typeof window.ethereum !== 'undefined') {
  // Ethereum user detected. You can now use the provider.
  const provider = window['ethereum']
}
</pre>
<div style="margin-top:1em;">
  MetaMask 的接口总体比较简单。
</div>

<h1 style="padding-bottom:0;">属性</h1>
<div>
  &sdotb; ethereum.networkVersion 当前网络ID，未来会删除
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
'1': Ethereum Main Network
'2': Morden Test network
'3': Ropsten Test Network
'4': Rinkeby Test Network
'5': Goerli Test Network
'42': Kovan Test Network
</pre>
<div style="margin-top:.625em;">
  &sdotb; ethereum.selectedAddress 当前用户地址，未来会删除
</div>
<div>
  &sdotb; ethereum.isMetaMask 是否安装了 MetaMask
</div>

<h1 style="padding-bottom:0;">方法</h1>
<div>
  &sdotb; ethereum.enable() 返回用户 eth 地址
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
try {
  const accounts = await ethereum.enable()
  // You now have an array of accounts!
  // Currently only ever one:
  // ['0xFDEa65C8e26263F6d9A1B5de9555D2931A33b825']

} catch (error) {
  // Handle error. Likely the user rejected the login
  console.error(error)
}
</pre>
<div style="margin-top:.625em;">
  注意新的API是 ethereum.send(‘eth_requestAccounts’) 
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
try {
  const accounts = await ethereum.send('eth_requestAccounts')
  // You now have an array of accounts!
  // Currently only ever one:
  // ['0xFDEa65C8e26263F6d9A1B5de9555D2931A33b825']

} catch (error) {
  if (error.code === 4001) { // EIP 1193 userRejectedRequest error
    console.log('Please connect to MetaMask.')
  } else {
    console.error(error)
  }
}
</pre>
<div style="margin-top:.625em;">
  &sdotb; ethereum.send(options, callback)
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
params: [{
  "from": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
  "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
  "gas": "0x76c0", // 30400
  "gasPrice": "0x9184e72a000", // 10000000000000
  "value": "0x9184e72a", // 2441406250
  "data": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"
}]

ethereum.send('eth_sendTransaction', params)
.then(function (result) {
  // The result varies by method, per the JSON RPC API.
  // For example, this method will return a transaction hash on success.
})
.catch(function (error) {
 // Like a typical promise, returns an error on rejection.
})
</pre>
<div style="margin-top:.625em;">
  &sdotb; ethereum.sendAsync(options, callback) (Deprecated)
</div>
<div style="">
  向 web3 发消息，格式：the Ethereum JSON-RPC API，建议都用新的 send
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
params: [{
  "from": "0xb60e8dd61c5d32be8058bb8eb970870f07233155",
  "to": "0xd46e8dd67c5d32be8058bb8eb970870f07244567",
  "gas": "0x76c0", // 30400
  "gasPrice": "0x9184e72a000", // 10000000000000
  "value": "0x9184e72a", // 2441406250
  "data": "0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675"
}]

ethereum.sendAsync({
  method: 'eth_sendTransaction',
  params: params,
  from: accounts[0], // Provide the user's account to use.
}, function (err, result) {
  // A typical node-style, error-first callback.
  // The result varies by method, per the JSON RPC API.
  // For example, this method will return a transaction hash on success.
})
</pre>
<div style="margin-top:.625em;">
  &sdotb; ethereum.autoRefreshOnNetworkChange (To Be Removed) 切换网络会刷新页面
</div>
<div style="margin-top:.425em;">
  &sdotb; ethereum.on(eventName, callback) 监听一些事件：accountsChanged ， networkChanged ， chainChanged 
</div>
<div style="margin-top:.425em;">
  MetaMask 未来版本的 API 会更简单，主要就是 isMetaMask ， send() ， on()
</div>
<div style="margin-top:.425em;">
EIP-1193 规定了 Ethereum Provider JavaScript API：<br />
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md</a>
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
ethereum.send(method: String, params?: Array<any>): Promise<any>; 
ethereum.on('notification', listener: (result: any) => void): this; 
ethereum.on('connect', listener: () => void): this; 
ethereum.on('close', listener: (code: Number, reason: String) => void): this; 
ethereum.on('chainChanged', listener: (chainId: String) => void): this; 
ethereum.on('networkChanged', listener: (networkId: String) => void): this; 
ethereum.on('accountsChanged', listener: (accounts: Array<String>) => void): this; 
</pre>
<div style="margin-top:.425em;">
一个新 API 的例子 <a href="https://gist.github.com/rekmarks/d318677c8fc89e5f7a2f526e00a0768a">https://gist.github.com/rekmarks/d318677c8fc89e5f7a2f526e00a0768a</a>
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// 先判断是否安装了 MetaMask
if (!ethereum || !ethereum.isMetaMask) {
  throw new Error('Please install MetaMask.')
}

/*********************************************************/
/* Handle chain (network) and chainChanged, per EIP 1193 */
/*********************************************************/

let currentChainId = null
ethereum.send('eth_chainId')
  .then(handleChainChanged)
  .catch(err => console.error(err)) // This should never happen

ethereum.on('chainChanged', handleChainChanged)

function handleChainChanged (chainId) {

  if (currentChainId !== chainId) {

    currentChainId = chainId
    // Run any other necessary logic...
  }
}

/**********************************************************/
/* Handle user accounts and accountsChanged, per EIP 1193 */
/**********************************************************/

let currentAccount = null
ethereum.send('eth_accounts')
  .then(handleAccountsChanged)
  .catch(err => {
    // In the future, maybe in 2020, this will return a 4100 error if
    // the user has yet to connect
    if (err.code === 4100) { // EIP 1193 unauthorized error
      console.log('Please connect to MetaMask.')
    } else {
      console.error(err)
    }
  })

// Note that this event is emitted on page load.
// If the array of accounts is non-empty, you're already
// connected.
ethereum.on('accountsChanged', handleAccountsChanged)

// For now, 'eth_accounts' will continue to always return an array
function handleAccountsChanged (accounts) {

  if (accounts.length === 0) {

    // MetaMask is locked or the user has not connected any accounts
    console.log('Please connect to MetaMask.')

  } else if (accounts[0] !== currentAccount) {

    currentAccount = accounts[0]
    // Run any other necessary logic...
  }
}

/***********************************/
/* Handle connecting, per EIP 1102 */
/***********************************/

// You should only attempt to connect in response to user interaction,
// such as a button click. Otherwise, you're popup-spamming the user
// like it's 1999.
// If you can't retrieve the user's account(s), you should encourage the user
// to initiate a connection attempt.
document.getElementById('connectButton', connect)

function connect () {

  // This is equivalent to ethereum.enable()
  ethereum.send('eth_requestAccounts')
    .then(handleAccountsChanged)
    .catch(err => {
      if (err.code === 4001) { // EIP 1193 userRejectedRequest error
        console.log('Please connect to MetaMask.')
      } else {
        console.error(err)
      }
    })
}
</pre>

<h1 style="padding-bottom:0;">实验性质API</h1>
<div style="margin-top:.425em;">
  <b>wallet_watchAsset</b> 管理代币 <a href="https://github.com/estebanmino/EIPs/blob/master/EIPS/eip-747.md">EIP 747</a>
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
ethereum.sendAsync({
  method: 'metamask_watchAsset',
  params: {
    "type":"ERC20", // Initially only supports ERC20, but eventually more!
    "options":{
      "address": tokenAddress, // The address that the token is at.
      "symbol": tokenSymbol, // A ticker symbol or shorthand, up to 5 chars.
      "decimals": tokenDecimals, // The number of decimals in the token
      "image": tokenImage, // A string url of the token logo
    },
  },
  id: Math.round(Math.random() * 100000),
}, (err, addedBoolean) => {

})
</pre>
<div style="margin-top:.425em;">
  加入代币的一个示例：<a href="https://github.com/MetaMask/Add-Token">https://github.com/MetaMask/Add-Token</a>
</div>
<div style="margin-top:.425em;">
  <b>ethereum._metamask</b> 这个是 MetaMask 特有的，一般 dapp 编写应该兼容所有的 dapp 浏览器，其他浏览器可能没有这个属性。不建议使用。
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
ethereum._metamask.isUnlocked: () => Promise<boolean> 
</pre>

<h1 style="padding-bottom:0;">签名</h1>

<div style="margin-top:.425em;">
签名库：<a href="https://github.com/MetaMask/eth-sig-util">https://github.com/MetaMask/eth-sig-util</a><br />
使用例子：https://github.com/danfinlay/js-eth-personal-sign-examples
</div>
<div style="margin-top:.425em;">
MetaMask 目前有物种签名方法：
</div>

<div style="margin-top:.425em;">
&starf; eth_sign
</div>
<div style="margin-top:.425em;">
没有时间限制，可以用来签署交易，容易被钓鱼网站利用，受到 <a href="https://en.wikipedia.org/wiki/Chosen-ciphertext_attack">https://en.wikipedia.org/wiki/Chosen-ciphertext_attack </a> 攻击（<a href="https://www.zhihu.com/question/34624915">https://www.zhihu.com/question/34624915</a>）。
一般不建议使用，不过由于历史原因也还支持，会显示红色警告，不建议使用。
</div>

<div style="margin-top:.425em;">
&starf; personal_sign
</div>
<div style="margin-top:.425em;">
<a href="https://github.com/ethereum/go-ethereum/pull/2940">https://github.com/ethereum/go-ethereum/pull/2940</a> <br />
和 eth_sign 类似，增加了个消息，存了签名之后，以后可以知道用户签署了这个消息，比如同意了什么协议。这样即使用户没有 ETH，也可以做签名，证明自己对账户有控制权。这样可以用户网站登录之类的。
<a href="https://medium.com/metamask/the-new-secure-way-to-sign-data-in-your-browser-6af9dd2a1527">https://medium.com/metamask/the-new-secure-way-to-sign-data-in-your-browser-6af9dd2a1527</a>
</div>

<div style="margin-top:.425em;">
&starf; signTypedData
</div>
<div style="margin-top:.425em;">
不过这些签名在链上进行验证比较昂贵，就有了 <a href="https://eips.ethereum.org/EIPS/eip-712">EIP712</a> <a href="https://segmentfault.com/a/1190000015647458">中文</a>，可以用结构化的方式在签名中提示信息。
</div>
<div style="margin-top:.425em;">
  <img src="/images/ether/1577262997496-2ee6ee01-0223-4de1-b04a-56593710c84e.png" />
</div>
<div style="margin-top:.425em;">
不过 signTypedData 有不同的版本，所以 MetaMask 选择了根据版本号区分。
</div>

<div style="margin-top:.425em;">
&starf; signTypedData_v1 老版本，不用了
</div>
<div style="margin-top:.425em;">
  <a href="https://medium.com/metamask/scaling-web3-with-signtypeddata-91d6efc8b290">https://medium.com/metamask/scaling-web3-with-signtypeddata-91d6efc8b290</a>
</div>

<div style="margin-top:.425em;">
&starf; signTypedData_v3
</div>
<div style="margin-top:.425em;">
&starf; signTypedData_v4
</div>
<div style="margin-top:.425em;">
  <a href="https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26">https://medium.com/metamask/eip712-is-coming-what-to-expect-and-how-to-use-it-bb92fd1a7a26</a>
</div>
<div style="margin-top:.425em;">
  例子: <a href="https://weijiekoh.github.io/eip712-signing-demo/index.html">https://weijiekoh.github.io/eip712-signing-demo/index.html</a>
</div>

   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="metamask-dependencies"><![CDATA[<div style="color:blue;font-size:1.2em;">metamask 依赖分析</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
metamask 由于项目比较久，用的依赖有新有旧，有很多已经过时不维护了，有的功能有重复。
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="package.json" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:.625em;line-height:1em;font-family:monospace;">
      <![CDATA[
{
  "name": "metamask-crx",
  "version": "0.0.0",
  "private": true,
  "scripts": {
    // 开发构建 with logging and file watching
    "start": "gulp dev:extension",
    // 发布构建
    "dist": "gulp dist",
    // 生成文档
    "doc": "jsdoc -c development/.jsdoc.json",
    // 发布文档
    "publish-docs": "gh-pages -d docs/jsdocs",
    // 测试相关
    "start:test": "gulp dev:test",
    "build:test": "gulp build:test",
    "test": "yarn test:unit && yarn lint",
    // e2e dapp test
    "dapp": "static-server test/e2e/contract-test --port 8080",
    // e2e dapp test by ganache
    "dapp-chain": "GANACHE_ARGS='-b 2' concurrently -k -n ganache,dapp -p '[{time}][{name}]' 'yarn ganache:start' 'sleep 5 && static-server test/e2e/contract-test --port 8080'",
    "watch:test:unit": "nodemon --exec \"yarn test:unit\" ./test ./app ./ui",
    "sendwithprivatedapp": "static-server test/e2e/send-eth-with-private-key-test --port 8080",
    "test:unit": "cross-env METAMASK_ENV=test mocha --exit --require test/setup.js --recursive \"test/unit/**/*.js\" \"ui/app/**/*.test.js\"",
    "test:unit:global": "mocha test/unit-global/*",
    "test:single": "cross-env METAMASK_ENV=test mocha --require test/helper.js",
    "test:integration": "yarn test:integration:build && yarn test:flat",
    "test:integration:build": "gulp build:scss",
    "test:e2e:chrome": "SELENIUM_BROWSER=chrome test/e2e/run-all.sh",
    "test:web3:chrome": "SELENIUM_BROWSER=chrome test/e2e/run-web3.sh",
    "test:web3:firefox": "SELENIUM_BROWSER=firefox test/e2e/run-web3.sh",
    "test:e2e:firefox": "SELENIUM_BROWSER=firefox test/e2e/run-all.sh",
    "test:coverage": "nyc --reporter=text --reporter=html npm run test:unit",
    "test:coveralls-upload": "if [ $COVERALLS_REPO_TOKEN ]; then nyc report --reporter=text-lcov | coveralls; fi",
    "test:flat": "yarn test:flat:build && karma start test/flat.conf.js",
    "test:flat:build": "yarn test:flat:build:ui && yarn test:flat:build:tests && yarn test:flat:build:locales",
    "test:flat:build:tests": "node test/integration/index.js",
    "test:flat:build:states": "node development/genStates.js",
    "test:flat:build:locales": "mkdirp dist/chrome && cp -R app/_locales dist/chrome/_locales",
    "test:flat:build:ui": "yarn test:flat:build:states && browserify --transform babelify --transform brfs ./development/mock-dev.js -o ./development/bundle.js",
    "ganache:start": "./development/run-ganache",
    "sentry:publish": "node ./development/sentry-publish.js",
    // lint
    "lint": "eslint . --ext js,json",
    "lint:fix": "eslint . --ext js,json --fix",
    "lint:changed": "{ git ls-files --others --exclude-standard ; git diff-index --name-only --diff-filter=d HEAD ; } | grep --regexp='[.]js$' --regexp='[.]json$' | tr '\\n' '\\0' | xargs -0 eslint",
    "lint:changed:fix": "{ git ls-files --others --exclude-standard ; git diff-index --name-only --diff-filter=d HEAD ; } | grep --regexp='[.]js$' --regexp='[.]json$' | tr '\\n' '\\0' | xargs -0 eslint --fix",
    // 语言文件校验
    "verify-locales": "node ./development/verify-locale-strings.js",
    "mozilla-lint": "addons-linter dist/firefox",
    "watch": "cross-env METAMASK_ENV=test mocha --watch --require test/setup.js --reporter min --recursive \"test/unit/**/*.js\" \"ui/app/**/*.test.js\"",
    "devtools:react": "react-devtools",
    "devtools:redux": "remotedev --hostname=localhost --port=8000",
    // start the React DevTools and Redux DevTools Extension alongside the app
    // 主要用于开发
    "start:dev": "concurrently -k -n build,react,redux yarn:start yarn:devtools:react yarn:devtools:redux",
    "announce": "node development/announcer.js",
    "version:bump": "node development/run-version-bump.js",
    // 这里 storybook 启动有点问题
    // 需要 yarn add -D @storybook/addon-actions babel-loader 
    // 然后改造 .storybook/webpack.config.js ，增加 css rule，要不会报错
    "storybook": "start-storybook -p 6006 -c .storybook",
    "update-changelog": "./development/auto-changelog.sh",
    "rollback": "./development/rollback.sh"
  },
  "resolutions": {
    "3box/ipfs/ipld-zcash/zcash-bitcore-lib/lodash": "^4.17.12",
    "pubnub/superagent-proxy": "^2.0.0"
  },
  "dependencies": {
    "3box": "^1.10.2",
    "@babel/runtime": "^7.5.5",
    "@material-ui/core": "1.0.0",
    "@sentry/browser": "^4.1.1",
    "@zxing/library": "^0.8.0",
    "abi-decoder": "^1.2.0",
    "abortcontroller-polyfill": "^1.3.0",
    "asmcrypto.js": "^2.3.2",
    "await-semaphore": "^0.1.1",
    "bignumber.js": "^4.1.0",
    "bip39": "^2.2.0",
    "bluebird": "^3.5.0",
    "bn.js": "^4.11.7",
    "boron": "^0.2.3",
    "browser-passworder": "^2.0.3",
    "browserify-derequire": "^0.9.4",
    "browserify-unibabel": "^3.0.0",
    "c3": "^0.6.7",
    "classnames": "^2.2.5",
    "clone": "^2.1.2",
    "content-hash": "^2.4.4",
    "copy-to-clipboard": "^3.0.8",
    "currency-formatter": "^1.4.2",
    "d3": "^5.7.0",
    "debounce": "1.1.0",
    "debounce-stream": "^2.0.0",
    "deep-extend": "^0.5.1",
    "deep-freeze-strict": "1.1.1",
    "detect-node": "^2.0.3",
    "detectrtc": "^1.3.6",
    "dnode": "^1.2.2",
    "end-of-stream": "^1.1.0",
    "eth-block-tracker": "^4.4.2",
    "eth-contract-metadata": "^1.9.2",
    "eth-ens-namehash": "^2.0.8",
    "eth-json-rpc-errors": "^1.1.0",
    "eth-json-rpc-filters": "^4.1.1",
    "eth-json-rpc-infura": "^4.0.1",
    "eth-json-rpc-middleware": "^4.2.0",
    "eth-keyring-controller": "^5.3.0",
    "eth-ledger-bridge-keyring": "^0.2.0",
    "eth-method-registry": "^1.2.0",
    "eth-phishing-detect": "^1.1.4",
    "eth-query": "^2.1.2",
    "eth-sig-util": "^2.3.0",
    "eth-token-tracker": "^1.1.10",
    "eth-trezor-keyring": "^0.4.0",
    "ethereumjs-abi": "^0.6.4",
    "ethereumjs-tx": "1.3.7",
    "ethereumjs-util": "5.1.0",
    "ethereumjs-wallet": "^0.6.0",
    "etherscan-link": "^1.0.2",
    "ethjs": "^0.4.0",
    "ethjs-contract": "^0.2.3",
    "ethjs-ens": "^2.0.0",
    "ethjs-query": "^0.3.4",
    "extension-port-stream": "^1.0.0",
    "extensionizer": "^1.0.1",
    "fast-json-patch": "^2.0.4",
    "fuse.js": "^3.2.0",
    "gaba": "^1.8.0",
    "human-standard-token-abi": "^2.0.0",
    "jazzicon": "^1.2.0",
    "json-rpc-engine": "^5.1.4",
    "json-rpc-middleware-stream": "^2.1.1",
    "jsonschema": "^1.2.4",
    "lodash.debounce": "^4.0.8",
    "lodash.shuffle": "^4.2.0",
    "loglevel": "^1.4.1",
    "luxon": "^1.8.2",
    "metamask-inpage-provider": "^3.0.0",
    "metamask-logo": "^2.1.4",
    "mkdirp": "^0.5.1",
    "multihashes": "^0.4.12",
    "nonce-tracker": "^1.0.0",
    "number-to-bn": "^1.7.0",
    "obj-multiplex": "^1.0.0",
    "obs-store": "^4.0.3",
    "percentile": "^1.2.0",
    "pify": "^3.0.0",
    "polyfill-crypto.getrandomvalues": "^1.0.0",
    "post-message-stream": "^3.0.0",
    "promise-filter": "^1.1.0",
    "promise-to-callback": "^1.0.0",
    "prop-types": "^15.6.1",
    "pubnub": "4.24.4",
    "pump": "^3.0.0",
    "punycode": "^2.1.1",
    "qrcode-generator": "1.4.1",
    "ramda": "^0.24.1",
    "react": "^15.6.2",
    "react-dnd": "^3.0.2",
    "react-dnd-html5-backend": "^7.4.4",
    "react-dom": "^15.6.2",
    "react-hyperscript": "^3.0.0",
    "react-idle-timer": "^4.2.5",
    "react-inspector": "^2.3.0",
    "react-media": "^1.8.0",
    "react-redux": "^5.0.5",
    "react-router-dom": "^4.2.2",
    "react-select": "^1.0.0",
    "react-simple-file-input": "^2.0.0",
    "react-tippy": "^1.2.2",
    "react-toggle-button": "^2.2.0",
    "react-tooltip-component": "^0.3.0",
    "react-transition-group": "^1.2.1",
    "react-trigger-change": "^1.0.2",
    "reactify": "^1.1.1",
    "readable-stream": "^2.3.3",
    "recompose": "^0.25.0",
    "redux": "^3.0.5",
    "redux-logger": "^3.0.6",
    "redux-thunk": "^2.2.0",
    "request-promise": "^4.2.1",
    "reselect": "^3.0.1",
    "safe-event-emitter": "^1.0.1",
    "single-call-balance-checker-abi": "^1.0.0",
    "string.prototype.matchall": "^3.0.1",
    "swappable-obj-proxy": "^1.1.0",
    "textarea-caret": "^3.0.1",
    "valid-url": "^1.0.9",
    "web3": "^0.20.7",
    "web3-stream-provider": "^4.0.0",
    "webrtc-adapter": "^6.3.0",
    "xtend": "^4.0.1"
  },
  "devDependencies": {
    "@babel/core": "^7.5.5",
    "@babel/plugin-proposal-class-properties": "^7.5.5",
    "@babel/plugin-proposal-object-rest-spread": "^7.5.5",
    "@babel/plugin-transform-runtime": "^7.5.5",
    "@babel/preset-env": "^7.5.5",
    "@babel/preset-react": "^7.0.0",
    "@babel/register": "^7.5.5",
    "@sentry/cli": "^1.30.3",
    "@storybook/addon-info": "^5.1.1",
    "@storybook/addon-knobs": "^3.4.2",
    "@storybook/react": "^5.1.1",
    "addons-linter": "1.14.0",
    "babel-eslint": "^10.0.2",
    "babelify": "^10.0.0",
    "brfs": "^1.6.1",
    "browserify": "^16.2.3",
    "browserify-transform-tools": "^1.7.0",
    "chai": "^4.1.0",
    "chromedriver": "^2.41.0",
    "concurrently": "^4.1.1",
    "coveralls": "^3.0.0",
    "cross-env": "^5.1.4",
    "css-loader": "^2.1.1",
    "del": "^3.0.0",
    "deps-dump": "^1.1.0",
    "envify": "^4.0.0",
    "enzyme": "^3.4.4",
    "enzyme-adapter-react-15": "^1.0.6",
    "eslint": "^6.0.1",
    "eslint-plugin-chai": "0.0.1",
    "eslint-plugin-json": "^1.2.0",
    "eslint-plugin-mocha": "^5.0.0",
    "eslint-plugin-react": "^7.4.0",
    "fetch-mock": "^6.5.2",
    "file-loader": "^1.1.11",
    "fs-extra": "^6.0.1",
    "fs-promise": "^2.0.3",
    "ganache-cli": "^6.4.4",
    "ganache-core": "2.8.0",
    "geckodriver": "^1.16.2",
    "gh-pages": "^1.2.0",
    "gulp": "^4.0.0",
    "gulp-autoprefixer": "^5.0.0",
    "gulp-babel": "^7.0.0",
    "gulp-debug": "^3.2.0",
    "gulp-eslint": "^4.0.0",
    "gulp-imagemin": "^6.1.0",
    "gulp-json-editor": "^2.2.1",
    "gulp-livereload": "4.0.0",
    "gulp-multi-process": "^1.3.1",
    "gulp-rename": "^1.4.0",
    "gulp-replace": "^0.6.1",
    "gulp-rtlcss": "^1.4.0",
    "gulp-sass": "^4.0.0",
    "gulp-sourcemaps": "^2.6.0",
    "gulp-stylelint": "^7.0.0",
    "gulp-terser-js": "^5.0.0",
    "gulp-util": "^3.0.7",
    "gulp-watch": "^5.0.1",
    "gulp-zip": "^4.0.0",
    "http-server": "^0.11.1",
    "isomorphic-fetch": "^2.2.1",
    "jsdoc": "^3.6.2",
    "jsdom": "^11.2.0",
    "jsdom-global": "^3.0.2",
    "karma": "^4.1.0",
    "karma-chrome-launcher": "^2.2.0",
    "karma-cli": "^1.0.1",
    "karma-firefox-launcher": "^1.0.1",
    "karma-qunit": "^1.2.1",
    "lodash.assign": "^4.0.6",
    "mocha": "^5.0.0",
    "mocha-eslint": "^4.0.0",
    "mocha-jsdom": "^1.1.0",
    "mocha-sinon": "^2.0.0",
    "nock": "^9.0.14",
    "node-sass": "^4.12.0",
    "nyc": "^13.0.0",
    "path": "^0.12.7",
    "prepend-file": "^1.3.1",
    "proxyquire": "2.0.1",
    "qs": "^6.2.0",
    "qunitjs": "^2.4.1",
    "radgrad-jsdoc-template": "^1.1.3",
    "react-devtools": "^3.6.1",
    "react-test-renderer": "^15.6.2",
    "read-installed": "^4.0.3",
    "redux-mock-store": "^1.5.3",
    "redux-test-utils": "^0.2.2",
    "remote-redux-devtools": "^0.5.16",
    "remotedev-server": "^0.3.1",
    "resolve-url-loader": "^2.3.0",
    "rimraf": "^2.6.2",
    "sass-loader": "^7.0.1",
    "selenium-webdriver": "^3.5.0",
    "sesify": "^4.2.1",
    "sesify-viz": "^3.0.5",
    "sinon": "^5.0.0",
    "source-map": "^0.7.2",
    "source-map-explorer": "^2.0.1",
    "static-server": "^2.2.1",
    "style-loader": "^0.21.0",
    "stylelint": "^9.10.1",
    "stylelint-config-standard": "^18.2.0",
    "testem": "^2.16.0",
    "through2": "^2.0.3",
    "vinyl-buffer": "^1.0.1",
    "vinyl-source-stream": "^2.0.0",
    "watchify": "^3.11.1"
  },
  "engines": {
    // 注意：Node 和 Yarn 版本
    "node": "^10.16.0",
    "yarn": "^1.16.0"
  }
}
   ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:0.85em;line-height:1em;font-family:monospace;">
      <![CDATA[
<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 构建相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>@babel/runtime</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">babel 相关</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>browserify-derequire</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">
Browserify plugin for renaming require() calls in the output bundle. <br />
<a href="https://github.com/rse/browserify-derequire">https://github.com/rse/browserify-derequire</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 日志相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>@sentry/browser</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Sentry SDK for Browsers  错误记录 <br />
<a href="https://sentry.io">https://sentry.io</a> <br />
<a href="https://github.com/getsentry/sentry-javascript">https://github.com/getsentry/sentry-javascript</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>loglevel</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Minimal lightweight logging for JavaScript, adding reliable log level methods to wrap any available console.log methods <br />
<a href="https://github.com/pimterry/loglevel">https://github.com/pimterry/loglevel</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 二维码</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>@zxing/library</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">1/2维码库 <br />
<a href="https://github.com/zxing-js/library">https://github.com/zxing-js/library</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>qrcode-generator</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">QR Code Generator implementation in JavaScript, Java and more.<br />
<a href="https://github.com/kazuhikoarase/qrcode-generator">https://github.com/kazuhikoarase/qrcode-generator</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 加密相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>asmcrypto.js</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">JavaScript Cryptographic Library 性能比较好<br />
<a href="https://github.com/asmcrypto/asmcrypto.js">https://github.com/asmcrypto/asmcrypto.js</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>await-semaphore</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Awaitable semaphore/mutex js 信号量控制实现<br />
<a href="https://github.com/notenoughneon/await-semaphore">https://github.com/notenoughneon/await-semaphore</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>browser-passworder</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple browserifiable module for encrypting and decrypting JSON-serializable objects with a password. AES-GCM algorithm: <br />
<a href="https://github.com/danfinlay/browser-passworder">https://github.com/danfinlay/browser-passworder</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>multihashes</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">multihash implementation in JavaScript 同样的 hash，不同的算法生成，为未来扩展<br />
<a href="https://github.com/multiformats/js-multihash">https://github.com/multiformats/js-multihash</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 大数处理</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>bignumber.js</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A JavaScript library for arbitrary-precision decimal and non-decimal arithmetic
高精度数字处理，注意数字格式 Number, String or BigNumber<br />
<a href="https://github.com/MikeMcl/bignumber.js">https://github.com/MikeMcl/bignumber.js</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>bn.js</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">BigNum in pure javascript 处理大数的计算<br />
<a href="https://github.com/indutny/bn.js">https://github.com/indutny/bn.js</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>number-to-bn</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Converts a number to a BN.js object, throw if invalid number.<br />
<a href="https://github.com/SilentCicero/number-to-bn">https://github.com/SilentCicero/number-to-bn</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; bluebird 相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>bluebird</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">full featured promise library with unmatched performance<br />
<a href="https://github.com/petkaantonov/bluebird">https://github.com/petkaantonov/bluebird</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>request-promise</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">The simplified HTTP request client 'request' with Promise support. Powered by Bluebird.<br />
<a href="https://github.com/request/request-promise">https://github.com/request/request-promise</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>promise-filter</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Filter an array and return a Promise 和 bluebird.filter 一样<br />
<a href="https://github.com/yoshuawuyts/promise-filter">https://github.com/yoshuawuyts/promise-filter</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; JS基础功能增强</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>clone</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">deeply clone arbitrary objects in javascript<br />
<a href="https://github.com/pvorb/clone">https://github.com/pvorb/clone</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>debounce</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">防抖的一个实现<br />
<a href="https://github.com/component/debounce">https://github.com/component/debounce</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>debounce-stream</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Debounces a stream. 用户输入流去抖<br />
<a href="https://github.com/fardog/debounce-stream">https://github.com/fardog/debounce-stream</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>deep-extend</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Recursive extend module 递归扩展 obj 属性<br />
<a href="https://github.com/unclechu/node-deep-extend">https://github.com/unclechu/node-deep-extend</a>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>deep-freeze-strict</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">recursively Object.freeze() on objects and functions<br />
<a href="https://github.com/jsdf/deep-freeze">https://github.com/jsdf/deep-freeze</a>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>lodash.debounce</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">The lodash method _.debounce<br />
<a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>lodash.shuffle</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">The lodash method _.shuffle<br />
<a href="https://github.com/lodash/lodash">https://github.com/lodash/lodash</a>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>xtend</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">xtend is a basic utility library which allows you to extend an object by appending all of the properties from each object in a list.<br />
<a href="https://github.com/Raynos/xtend">https://github.com/Raynos/xtend</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; JSON增强</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>fast-json-patch</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Lean and mean Javascript implementation of the JSON-Patch standard (RFC 6902). Update JSON documents using delta patches.<br />
<a href="https://github.com/Starcounter-Jack/JSON-Patch">https://github.com/Starcounter-Jack/JSON-Patch</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>jsonschema</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">JSON Schema validation 校验 json 文档<br />
<a href="https://github.com/tdegrunt/jsonschema">https://github.com/tdegrunt/jsonschema</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; RPC相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>dnode</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">turtles all the way down rpc RPC调用<br />
<a href="https://github.com/substack/dnode">https://github.com/substack/dnode</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>json-rpc-engine -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">a tool for processing JSON RPC<br />
<a href="https://github.com/MetaMask/json-rpc-engine">https://github.com/MetaMask/json-rpc-engine</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>json-rpc-middleware-stream -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A small toolset for streaming json rpc and matching requests and responses. Made to be used with json-rpc-engine.
metamask 封装了很多 stream 操作<br />
<a href="https://github.com/MetaMask/json-rpc-middleware-stream">https://github.com/MetaMask/json-rpc-middleware-stream</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; Shim / polyfill</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>abortcontroller-polyfill</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Polyfill for the AbortController DOM API and abortable fetch 中止fetch<br />
<a href="https://github.com/mo/abortcontroller-polyfill">https://github.com/mo/abortcontroller-polyfill</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>polyfill-crypto.getrandomvalues</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">This is a polyfill for window.crypto.getRandomValues() .<br />
<a href="https://github.com/kumavis/polyfill-crypto.getrandomvalues">https://github.com/kumavis/polyfill-crypto.getrandomvalues</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>string.prototype.matchall</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Spec-compliant polyfill for String.prototype.matchAll ESnext proposal.<br />
<a href="https://github.com/ljharb/String.prototype.matchAll">https://github.com/ljharb/String.prototype.matchAll</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; WebRTC</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>detectrtc</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">detect WebRTC features e.g. system having speakers, microphone or webcam, screen capturing is supported, number of audio/video devices etc.<br />
<a href="https://github.com/muaz-khan/DetectRTC">https://github.com/muaz-khan/DetectRTC</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>webrtc-adapter</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">adapter.js is a shim to insulate apps from spec changes and prefix differences.<br />
<a href="https://github.com/webrtchacks/adapter">https://github.com/webrtchacks/adapter</a>
</p>

<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; Stream 相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>end-of-stream</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A node module that calls a callback when a readable/writable/duplex stream has completed or failed.<br />
<a href="https://github.com/mafintosh/end-of-stream">https://github.com/mafintosh/end-of-stream</a>
</p>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// Usage
var eos = require('end-of-stream');

eos(readableStream, function(err) {
  // this will be set to the stream instance
  if (err) return console.log('stream had an error or closed early');
  console.log('stream has ended', this === readableStream);
});

eos(writableStream, function(err) {
  if (err) return console.log('stream had an error or closed early');
  console.log('stream has finished', this === writableStream);
});

eos(duplexStream, function(err) {
  if (err) return console.log('stream had an error or closed early');
  console.log('stream has ended and finished', this === duplexStream);
});

eos(duplexStream, {readable:false}, function(err) {
  if (err) return console.log('stream had an error or closed early');
  console.log('stream has finished but might still be readable');
});

eos(duplexStream, {writable:false}, function(err) {
  if (err) return console.log('stream had an error or closed early');
  console.log('stream has ended but might still be writable');
});

eos(readableStream, {error:false}, function(err) {
  // do not treat emit('error', err) as a end-of-stream
});
</pre>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>extension-port-stream -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A module for creating a node style stream over a WebExtension port object.<br />
<a href="https://github.com/MetaMask/extension-port-stream">https://github.com/MetaMask/extension-port-stream</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>obj-multiplex</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">simple stream multiplexing for objectMode  多路复用<br />
其实就是一个多路复用流能够使用name来区分各个子流，以达到一个parent流下其实有多个子流在运行，可以通过多个子流来读入写出数据，效率更高。而且parent流结束了，则所有子流也会被销毁<br />
<a href="https://github.com/kumavis/obj-multiplex">https://github.com/kumavis/obj-multiplex</a><br />
<a href="https://github.com/zoubin/streamify-your-node-program/blob/master/docs/objectMode.md">https://github.com/zoubin/streamify-your-node-program/blob/master/docs/objectMode.md</a>
</p>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// usage
// create multiplexer
const mux = new ObjMultiplex()

// setup substreams
const streamA = mux.createStream('hello')
const streamB = mux.createStream('world')

// pipe over transport (and back)
mux.pipe(transport).pipe(mux)

// send values over the substreams
streamA.write({ thisIsAn: 'object' })
streamA.write(123)

// or pipe together normally
streamB.pipe(evilAiBrain).pipe(streamB)
</pre>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>pump</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">pipe streams together and close all of them if one of them closes<br />
<a href="https://github.com/mafintosh/pump">https://github.com/mafintosh/pump</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>readable-stream</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Node-core streams for userland<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/nodejs/readable-stream</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 其他工具库</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>copy-to-clipboard</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Copy stuff into clipboard from your browser using JS<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/sudodoki/copy-to-clipboard</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>currency-formatter</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple Javascript utility that helps you to display currency properly<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/smirzaei/currency-formatter</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>detect-node</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Detect Node.JS 就是看看有没有定义process属性<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/iliakan/detect-node</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>extensionizer -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A JS module for writing cross-browser extensions.
把各浏览器的一些隐藏 API 实现暴露出来<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/MetaMask/extensionizer</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>fuse.js</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Lightweight fuzzy-search, in JavaScript https://fusejs.io/<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/krisk/Fuse</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>browserify-unibabel</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple browserify style version of Unibabel<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/Daplie/unibabel-js</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>luxon</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A library for working with dates and times in JS moment的一个替代品<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/moment/luxon</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>mkdirp</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Recursively mkdir, like `mkdir -p`, but in node.js<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/substack/node-mkdirp</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>obs-store -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">ObservableStore is a synchronous in-memory store for a single value, that you can subscribe to updates on.<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/MetaMask/obs-store</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>percentile</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Calculate percentile for given array of values<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/d4rkr00t/percentile</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>post-message-stream</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Sets up a duplex object stream over window.postMessage<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/kumavis/post-message-stream</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>pify</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Promisify a callback-style function<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/sindresorhus/pify</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>promise-to-callback</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Convert promise to callback interface 和 pify 相反<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/stevemao/promise-to-callback</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>pubnub</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">PubNub JavaScript SDK https://www.pubnub.com/<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/pubnub/javascript</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ramda</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A practical functional library for JavaScript programmers.<br />
<a href="https://github.com/nodejs/readable-stream">https://github.com/ramda/ramda</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>safe-event-emitter -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">An EventEmitter that isolates the emitter from errors in handlers. If an error is thrown in a handler it is caught and re-thrown inside of a setTimeout so as to not interupt the emitter's code flow. 
如果在处理程序中抛出错误，就会被捕获并在setTimeout中重新抛出，以便不会中断发射器的代码流<br />
<a href="https://github.com/MetaMask/safe-event-emitter">https://github.com/MetaMask/safe-event-emitter</a>
</p>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// usage
const SafeEventEmitter = require('safe-event-emitter')

const ee = new SafeEventEmitter()
ee.on('boom', () => { throw new Error() })
ee.emit('boom') // no error here

// error is thrown after setTimeout
</pre>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// 源码分析
const util = require('util')
const EventEmitter = require('events/')

var R = typeof Reflect === 'object' ? Reflect : null
// 定义 ReflectApply，对一个函数进行调用操作 http://es6.ruanyifeng.com/#docs/reflect
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
}

module.exports = SafeEventEmitter


function SafeEventEmitter() {
  EventEmitter.call(this)
}

util.inherits(SafeEventEmitter, EventEmitter)

SafeEventEmitter.prototype.emit = function (type) {
  // copied from https://github.com/Gozala/events/blob/master/events.js
  // modified lines are commented with "edited:"
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    // edited: using safeApply, source: ReflectApply(handler, this, args)
    safeApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      // edited: using safeApply
      safeApply(listeners[i], this, args);
  }

  return true;
}

function safeApply(handler, context, args) {
  try {
    ReflectApply(handler, context, args)
  } catch (err) {
    // throw error after timeout so as not to interupt the stack
    setTimeout(() => {
      throw err
    })
  }
}

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}
</pre>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>swappable-obj-proxy</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Creates a Proxy around any object / EventEmitter.<br />
<a href="https://github.com/kumavis/swappable-obj-proxy">https://github.com/kumavis/swappable-obj-proxy</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>valid-url</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Node module that provides URI validation functions<br />
<a href="https://github.com/ogt/valid-url">https://github.com/ogt/valid-url</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 钱包相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>bip39</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">JavaScript implementation of Bitcoin BIP39: Mnemonic code for generating deterministic keys<br />
如果对个人隐私比较注重，就需要为每一次交易生成一个新的地址，仅需要记住助记词便可保证拥有对所有地址的操作权。<br />
<a href="https://github.com/bitcoinjs/bip39">https://github.com/bitcoinjs/bip39</a><br />
<a href="https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md">https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-keyring-controller -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A module for managing groups of Ethereum accounts called "Keyrings", defined originally for MetaMask's multiple-account-type feature.<br />
<a href="https://github.com/MetaMask/KeyringController">https://github.com/MetaMask/KeyringController</a><br />
<a href="https://github.com/MetaMask/eth-simple-keyring">https://github.com/MetaMask/eth-simple-keyring</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-ledger-bridge-keyring -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A javascript wrapper around LedgerJS libraries, to support the KeyringController protocol used by MetaMask<br />
<a href="https://github.com/MetaMask/KeyringController">https://github.com/MetaMask/eth-ledger-bridge-keyring</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-sig-util -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A collection of functions for signing and verifying data with Ethereum keys.<br />
<a href="https://github.com/MetaMask/eth-sig-util">https://github.com/MetaMask/eth-sig-util</a><br />
例子：<a href="https://github.com/danfinlay/js-eth-personal-sign-examples">https://github.com/danfinlay/js-eth-personal-sign-examples</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-token-tracker -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A JS module for tracking Ethereum token balances over block changes. 轮询查余额<br />
<a href="https://github.com/MetaMask/eth-token-tracker">https://github.com/MetaMask/eth-token-tracker</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-trezor-keyring -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A javascript wrapper around Trezor Connect javascript libraries, to support the KeyringController protocol used by MetaMask Trezor硬件钱包<br />
<a href="https://github.com/metamask/eth-trezor-keyring">https://github.com/metamask/eth-trezor-keyring</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethereumjs-tx</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple module for creating, manipulating and signing ethereum transactions 签名交易, 用于 web3 的 sendRawTransaction<br />
<a href="https://github.com/ethereumjs/ethereumjs-tx">https://github.com/ethereumjs/ethereumjs-tx</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethereumjs-util</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A collection of utility functions for Ethereum 一些 eth 用到的工具方法<br />
<a href="https://github.com/ethereumjs/ethereumjs-util">https://github.com/ethereumjs/ethereumjs-util</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethereumjs-wallet</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Utilities for handling Ethereum keys 产生和管理公私钥<br />
HD Wallet: var hdkey = require('ethereumjs-wallet/hdkey')<br />
<a href="https://github.com/ethereumjs/ethereumjs-wallet">https://github.com/ethereumjs/ethereumjs-wallet</a>
</p>
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;font-size: 1.5em;line-height: 1.325em;">
  <li>ethereumjs-tx 签名交易</li>
  <li>ethereumjs-util 工具方法</li>
  <li>ethereumjs-wallet 管理公私钥</li>
  <li>web3 发送交易</li>
</ul>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>gaba -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Collection of platform-agnostic modules for creating secure data models for cryptocurrency wallets
<br />
<a href="https://github.com/MetaMask/gaba">https://github.com/MetaMask/gaba</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>metamask-inpage-provider</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">An ethereum provider that connects over a stream, as injected into websites by MetaMask.
Used to initialize the inpage ethereum provider injected by MetaMask.<br />
这个库的作用有设置浏览器本地信息存储publicConfig流、构建RpcProvider双向传送json rpc及其结果流，以及对从浏览器中得到的json rpc进行处理，send/sendsync的处理是不同的，然后将他们根据得到的特殊id存储到数组中，等待传送到区块链进行处理。<br />
<a href="https://github.com/MetaMask/metamask-inpage-provider/blob/master/index.js">https://github.com/MetaMask/metamask-inpage-provider/blob/master/index.js</a><br />
<a href="https://github.com/MetaMask/metamask-inpage-provider">metamask 自有库
: https://github.com/MetaMask/metamask-inpage-provider</a>
</p>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;">
// usage
// Create a stream to a remote provider:
var metamaskStream = new LocalMessageDuplexStream({
  name: 'inpage',
  target: 'contentscript',
})

// compose the inpage provider
var inpageProvider = new MetamaskInpageProvider(metamaskStream)
</pre>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>nonce-tracker -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">How metamask calculates nonces<br />
<a href="https://github.com/MetaMask/nonce-tracker">https://github.com/MetaMask/nonce-tracker</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 合约相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>abi-decoder</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Nodejs and Javascript library for decoding data params and events from etherem transactions<br />
<a href="https://github.com/ConsenSys/abi-decoder">https://github.com/ConsenSys/abi-decoder</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-contract-metadata -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A mapping of ethereum contract addresses to broadly accepted icons for those addresses. 合约和图标映射<br />
<a href="https://github.com/MetaMask/eth-contract-metadata">https://github.com/MetaMask/eth-contract-metadata</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-method-registry -- metamask 自有库</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A javascript library for getting Solidity method data from a four-byte method signature.<br />
<a href="https://github.com/MetaMask/nonce-tracker">https://github.com/MetaMask/eth-method-registry</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-query</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">minimal rpc wrapper<br />
<a href="https://github.com/ethereumjs/eth-query">https://github.com/ethereumjs/eth-query</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethereumjs-abi</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Decoder and encoder for the Ethereum ABI<br />
<a href="https://github.com/ethereumjs/ethereumjs-abi">https://github.com/ethereumjs/ethereumjs-abi</a>
</p>
<div>
  <img src="/images/ether/1576745460249-8e0eaa4a-0392-4e50-8f67-654577204111.png" />
</div>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethjs-contract</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple contract object for the Ethereum RPC layer.<br />
<a href="https://github.com/ethjs/ethjs-contract">https://github.com/ethjs/ethjs-contract</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>human-standard-token-abi</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A JSON ABI for the Ethereum ERC 20 Token Standard , ERC 20 Token 的 abi<br />
<a href="https://github.com/danfinlay/human-standard-token-abi">https://github.com/danfinlay/human-standard-token-abi</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>single-call-balance-checker-abi</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple node module that exports the [Ethereum ABI] for eth-balance-checker smart contract<br />
<a href="https://etherscan.io/address/0xb1f8e55c7f64d203c1400b9d8555d050f94adf39#code">https://etherscan.io/address/0xb1f8e55c7f64d203c1400b9d8555d050f94adf39#code</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; RPC相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-block-tracker</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A JS module for keeping track of the latest Ethereum block by polling an ethereum provider.<br />
<a href="https://github.com/MetaMask/eth-block-tracker">https://github.com/MetaMask/eth-block-tracker</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-json-rpc-errors</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Errors for JSON RPC 2.0 and ETH JSON RPC.<br />
<a href="https://github.com/MetaMask/eth-json-rpc-errors">https://github.com/MetaMask/eth-json-rpc-errors</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-json-rpc-filters</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">json-rpc-engine middleware implementing ethereum filter methods eth的过滤器实现，接收事件通知<br />
<a href="https://github.com/MetaMask/eth-json-rpc-filters">https://github.com/MetaMask/eth-json-rpc-filters</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-json-rpc-infura</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">json-rpc-engine middleware for infura's REST endpoints.
metamask 利用 infura 的节点来广播交易<br />
https://infura.io/ infura 用于 dApp 快速接入以太坊<br />
<a href="https://github.com/MetaMask/eth-json-rpc-infura">https://github.com/MetaMask/eth-json-rpc-infura</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-json-rpc-middleware</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Ethereum middleware for composing an ethereum provider using json-rpc-engine. Intended to replace provider-engine.<br />
<a href="https://github.com/MetaMask/eth-json-rpc-middleware">https://github.com/MetaMask/eth-json-rpc-middleware</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethjs</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A highly optimised, light-weight JS utility for Ethereum.
web3 的一个替代品，还有个类似的是 ethers.js<br />
<a href="https://github.com/ethjs/ethjs">https://github.com/ethjs/ethjs</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethjs-query</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple query module for the Ethereum RPC.<br />
<a href="https://github.com/ethjs/ethjs-query">https://github.com/ethjs/ethjs-query</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>web3</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Ethereum JavaScript API
metamask 用的是 0.20.7 版本，未来有改进计划<br />
<a href="https://github.com/ethereum/web3.js">https://github.com/ethereum/web3.js</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>web3-stream-provider</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">creates an Ethereum web3 provider that forwards payloads through a stream<br />
<a href="https://github.com/kumavis/web3-stream-provider">https://github.com/kumavis/web3-stream-provider</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; ENS相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>content-hash</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">simple tool to encode/decode content hash for EIP 1577 compliant ENS Resolvers<br />
参考：https://learnblockchain.cn/docs/ens/contract-api-reference/publicresolver.html#%E8%8E%B7%E5%8F%96%E5%86%85%E5%AE%B9%E6%95%A3%E5%88%97<br />
<a href="https://github.com/pldespaigne/content-hash">https://github.com/pldespaigne/content-hash</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-ens-namehash</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A javascript library for generating Ethereum Name Service (ENS) namehashes per spec.<br />
<a href="https://github.com/danfinlay/eth-ens-namehash">https://github.com/danfinlay/eth-ens-namehash</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>ethjs-ens</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">An Ethereum Name Service interface module built on EthJS<br />
<a href="https://github.com/ethjs/ethjs-ens">https://github.com/ethjs/ethjs-ens</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 其他</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>3box</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">set, get, and remove private and public data associated with an ethereum account<br />
<a href="https://github.com/3box/3box-js">https://github.com/3box/3box-js</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>eth-phishing-detect</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Utility for detecting phishing domains targeting Ethereum users 钓鱼网站检测<br />
<a href="https://github.com/MetaMask/eth-phishing-detect">https://github.com/MetaMask/eth-phishing-detect</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>etherscan-link</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A library for generating etherscan links.<br />
<a href="https://github.com/MetaMask/etherscan-link">https://github.com/MetaMask/etherscan-link</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>metamask-logo</b> -- metamask 自有库</h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A 3d take on the metamask logo, in browser, as a browserifyable module.<br />
<a href="https://github.com/MetaMask/metamask-logo">https://github.com/MetaMask/metamask-logo</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 通用UI库</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>@material-ui/core</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">React components that implement Google's Material Design.<br />
<a href="https://github.com/mui-org/material-ui">https://github.com/mui-org/material-ui</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>d3</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Bring data to life with SVG, Canvas and HTML. https://d3js.org<br />
<a href="https://github.com/d3/d3">https://github.com/d3/d3</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>c3</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A D3-based reusable chart library. http://c3js.org<br />
<a href="https://github.com/c3js/c3">https://github.com/c3js/c3</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>jazzicon</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Jazzy deterministic identicons for a more entertaining future. 生成五颜六色头像图标<br />
<a href="https://github.com/flyswatter/jazzicon">https://github.com/flyswatter/jazzicon</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>textarea-caret</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">xy coordinates of a textarea or input's caret<br />
<a href="https://github.com/component/textarea-caret-position">https://github.com/component/textarea-caret-position</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; React 相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">
<a href="https://github.com/facebook/react">https://github.com/facebook/react</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-dom</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">This package serves as the entry point to the DOM and server renderers for React.</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>classnames</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A simple javascript utility for conditionally joining classNames together<br />
<a href="https://github.com/JedWatson/classnames">https://github.com/JedWatson/classnames</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>prop-types</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Runtime type checking for React props and similar objects<br />
<a href="https://github.com/facebook/prop-types">https://github.com/facebook/prop-types</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-hyperscript</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Hyperscript syntax for React.js markup. <br />
<a href="https://github.com/mlmorg/react-hyperscript">https://github.com/mlmorg/react-hyperscript</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-idle-timer</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">User activity timer component 检测用户是否发呆<br />
<a href="https://github.com/supremetechnopriest/react-idle-timer">https://github.com/supremetechnopriest/react-idle-timer</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-inspector</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Power of Browser DevTools inspectors right inside your React app<br />
<a href="https://github.com/xyc/react-inspector">https://github.com/xyc/react-inspector</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-media</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">CSS media queries for React<br />
<a href="https://github.com/ReactTraining/react-media">https://github.com/ReactTraining/react-media</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-router-dom</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Declarative routing for React<br />
<a href="https://github.com/ReactTraining/react-router">https://github.com/ReactTraining/react-router</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-trigger-change</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Trigger React's synthetic change events on input, textarea and select elements 主要用来测试<br />
<a href="https://github.com/vitalyq/react-trigger-change">https://github.com/vitalyq/react-trigger-change</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>reactify [DEPRECATED]</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">[DEPRECATED] Browserify transform for JSX (superset of JavaScript used in React library by Facebook)<br />
<a href="https://github.com/andreypopp/reactify">https://github.com/andreypopp/reactify</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>recompose</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A React utility belt for function components and higher-order components.
react 的 lodash<br />
<a href="https://github.com/acdlite/recompose">https://github.com/acdlite/recompose</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; React UI 组件</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>boron</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A collection of dialog animations with React.js<br />
<a href="https://github.com/yuanyan/boron">https://github.com/yuanyan/boron</a>
</p>


<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-dnd</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Drag and Drop for React  <br />
<a href="https://github.com/react-dnd/react-dnd">https://github.com/react-dnd/react-dnd</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-dnd-html5-backend</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">The officially supported HTML5 backend for React DnD.</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-select</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">The Select Component for React.js https://react-select.com/home<br />
<a href="https://github.com/JedWatson/react-select">https://github.com/JedWatson/react-select</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-simple-file-input</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Simple wrapper for the HTML input tag and HTML5 FileReader API<br />
<a href="https://github.com/greena13/react-simple-file-input">https://github.com/greena13/react-simple-file-input</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-tippy</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">A lightweight tooltip for React.<br />
<a href="https://github.com/tvkhoa/react-tippy">https://github.com/tvkhoa/react-tippy</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-toggle-button</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">It's a toggle button<br />
<a href="https://github.com/gdowens/react-toggle-button">https://github.com/gdowens/react-toggle-button</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-tooltip-component</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">React tooltip component.<br />
<a href="https://github.com/minhtranite/react-tooltip-component">https://github.com/minhtranite/react-tooltip-component</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-transition-group</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">An easy way to perform animations when a React component enters or leaves the DOM<br />
<a href="https://github.com/reactjs/react-transition-group">https://github.com/reactjs/react-transition-group</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; Redux相关</h2>
<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>react-redux</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Official React bindings for Redux<br />
<a href="https://github.com/reduxjs/react-redux">https://github.com/reduxjs/react-redux</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>redux</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Predictable state container for JavaScript apps<br />
<a href="https://github.com/reduxjs/redux">https://github.com/reduxjs/redux</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>redux-logger</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Logger for Redux<br />
<a href="https://github.com/LogRocket/redux-logger">https://github.com/LogRocket/redux-logger</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>redux-thunk</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Thunk middleware for Redux<br />
<a href="https://github.com/reduxjs/redux-thunk">https://github.com/reduxjs/redux-thunk</a>
</p>

<h3 style="font-size: 1.325em;padding-bottom: 0;color: brown;"><b>reselect</b></h3>
<p style="font-size: 1.325em;line-height: 1.625em;">Selector library for Redux<br />
<a href="https://github.com/reduxjs/reselect">https://github.com/reduxjs/reselect</a>
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; ETH测试</h2>
<p style="font-size: 1.325em;line-height: 1.625em;">ganache-cli: <a href="https://www.trufflesuite.com/ganache">https://www.trufflesuite.com/ganache</a> Ganache 是一个为开发者提供的私有 Ethereum 区块链客户端, 可以用于本地部署, 开发, 测试应用程序, 测试代码.
ganache-core
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 增强</h2>
<p style="font-size: 1.325em;line-height: 1.625em;">
<b>fs-extra:</b> fs-extra adds file system methods that aren't included in the native fs module and adds promise support to the fs methods.<br />
<b>fs-promise[DEPRECATED]</b> <br />
<b>lodash.assign:</b> The lodash method _.assign exported as a Node.js module.<br />
<b>path:</b> This is an exact copy of the NodeJS ’path’ module published to the NPM registry.<br />
<b>prepend-file:</b> Prepend data to a file, creating the file if it not yet exists.<br />
<b>qs:</b> A querystring parsing and stringifying library with some added security.
</p>


<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; 其他</h2>
<p style="font-size: 1.325em;line-height: 1.625em;">
<b>@sentry/cli</b><br />
<b>gh-pages:</b> Publish files to a gh-pages branch on GitHub<br />
<b>http-server:</b> a command-line http server<br />
<b>jsdoc:</b> An API documentation generator for JavaScript.<br />
<b>radgrad-jsdoc-template:</b> A Semantic UI documentation template theme for JSDoc 3.<br />
<b>read-installed:</b> Read all the installed packages in a folder, and return a tree structure with all the data.<br />
<b>source-map</b><br />
<b>source-map-explorer</b><br />
<b>static-server:</b> A simple http server to serve static resource files from a local directory.
</p>
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="3box"><![CDATA[<div style="color:blue;font-size:1.625em;">3box</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/3box/3box-js
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
  3box 可让您设置，获取和删除与以太坊账户相关的私人和公共数据。使用启用了Web3的浏览器的dapp可以使用它存储身份数据，用户设置等。只要用户可以访问已使用的以太坊账户的私钥，就可以检索数据。数据已加密，未经用户授权的任何第三方都无法读取。默认情况下，所有授权的dapp都有一个共享的数据空间，然后dapp必须请求明确同意访问这些空间。
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1.425em;background-color:white;margin-top:.25em;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.25em;font-family:monospace;">
      <![CDATA[
const profile = await Box.getProfile('0x12345abcde')
console.log(profile)
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1.425em;background-color:white;margin-top:.25em;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.25em;font-family:monospace;">
      <![CDATA[
// 1. Create a 3Box instance
const box = await Box.create(provider)

// 2. Authenticate user
const address = '0x12345abcde'
const spaces = ['myDapp']
await box.auth(spaces, { address })

// 3. Sync user's available 3Box data from the network
await box.syncDone

// 4. Interact with 3Box profile data
// use the public profile
// get
const nickname = await box.public.get('name')
console.log(nickname)
// set
await box.public.set('name', 'oed')
// remove
await box.public.remove('name')

// use the private store
// get
const email = await box.private.get('email')
console.log(email)
// set
await box.private.set('email', 'oed@email.service')
// remove
await box.private.remove('email')

const fields = ['name', 'website', 'employer']
const values = ['Jon Schwartz', 'openworklabs.com', 'Open Work Labs']

await box.public.setMultiple(fields, values)

const privateFields = ['age', 'coinBalance']
const privateValues = ['xxx', 'yyy']

await box.private.setMultiple(privateFields, privateValues)
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="eth-block-tracker"><![CDATA[<div style="color:blue;font-size:1.625em;">eth-block-tracker</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/MetaMask/eth-block-tracker
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;">
  A JS module for keeping track of the latest Ethereum block by polling an ethereum provider.
通过拉取以太坊的provider来跟踪最新的以太坊区块
</div>
<div style="margin-bottom:.425em;">
  This module walks the Ethereum blockchain, keeping track of the latest block. It uses a web3 provider as a data source and will continuously poll for the next block.
使用web3 provider作为其数据源，并不停地从最新的区块中拉取数据
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1.425em;background-color:white;margin-top:.25em;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.25em;font-family:monospace;">
      <![CDATA[
const HttpProvider = require('ethjs-provider-http')
const PollingBlockTracker = require('eth-block-tracker')

const provider = new HttpProvider('https://mainnet.infura.io')
const blockTracker = new PollingBlockTracker({ provider })
blockTracker.on('latest', console.log)
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1.425em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.25em;font-family:monospace;margin-top:.65em;">
      <![CDATA[

<h2 style="font-size: 1.625em;margin-top:.625em;">&diams; methods</h2>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;">
/**
 * creates a new block tracker with provider as a data source and
 * pollingInterval (ms) timeout between polling for the latest block.
 * If an Error is encountered when fetching blocks, it will wait retryTimeout (ms) before attempting again.
 * If keepEventLoopActive is false, in Node.js it will unref the polling timeout, allowing the process to exit during the polling interval. defaults to true, meaning the process will be kept alive.
 */

new PollingBlockTracker({ provider, pollingInterval, retryTimeout, keepEventLoopActive })
</pre>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
创建了一个指定 provider 数据源的区块追踪器，并在 pollingInterval 的间隔时间内拉取最新区块。当获取区块的时候如果出现了错误，那么她就会等待 retryTimeout (ms)再重新获取。如果 keepEventLoopActive 是 false，在 nodejs 中它会取消轮询超时，即在拉取的间隔中允许进程退出。默认是 true，意味着进程始终保持活跃
</div>

<h3 style="font-size: 1.425em;padding-bottom: 0;color: brown;"><b>getCurrentBlock()</b></h3>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
synchronous returns the current block. may be null. 同步获取当前的区块
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;margin-bottom:.25em;">
console.log(blockTracker.getCurrentBlock())
</pre>

<h3 style="font-size: 1.425em;padding-bottom: 0;color: brown;"><b>async getLatestBlock()</b></h3>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
Asynchronously returns the latest block. 异步获取最新区块
if not immediately available, it will fetch one.
</div>

<h3 style="font-size: 1.425em;padding-bottom: 0;color: brown;"><b>async checkForLatestBlock()</b></h3>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
Tells the block tracker to ask for a new block immediately, in addition to its normal polling interval.
Useful if you received a hint of a new block (e.g. via tx.blockNumber from getTransactionByHash).
</div>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
Will resolve to the new latest block when its done polling.
要求区块追踪器马上去取新的区块，除非现在正处于正常的polling间隔。如果你收到了新的区块的暗示时这个功能就十分有用（via tx.blockNumber from getTransactionByHash）。当其拉取完后，将释放最新的区块
</div>

<h2 style="font-size: 1.625em;margin-top:.625em;padding-bottom: 0;">&diams; EVENTS</h2>
<h3 style="font-size: 1.425em;padding-bottom: 0;color: brown;"><b>latest</b></h3>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
The latest event is emitted for whenever a new latest block is detected.
This may mean skipping blocks if there were two created since the last polling period.
当新的区块被检测到时，这个事件就会被触发。如果在上一个拉取周期中生成了两个区块，那么将会跳过，不会触发事件
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;margin-bottom:.25em;">
blockTracker.on('latest', (newBlock) => console.log(newBlock))
</pre>

<h3 style="font-size: 1.425em;padding-bottom: 0;color: brown;"><b>sync</b></h3>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
The sync event is emitted the same as "latest" but includes the previous block.
它跟"latest"是相同的，不同在与它还返回了之前的一个区块
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;margin-bottom:.25em;">
blockTracker.on('sync', ({ newBlock, oldBlock }) => console.log(newBlock, oldBlock))
</pre>

<h3 style="font-size: 1.425em;padding-bottom: 0;color: brown;"><b>error</b></h3>
<div style="margin-top:.425em;font-size:1.1em;line-height:1.625em;">
The error event means an error occurred while polling for the latest block.
当拉取最新的区块的时候出现错误时触发
</div>
<pre style="background-color:darkblue;color:cadetblue;padding:.625em 1em;margin-top:.325em;margin-bottom:.25em;">
blockTracker.on('error', (err) => console.error(err))
</pre>
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="json-rpc-engine"><![CDATA[<div style="color:blue;font-size:1.625em;">json-rpc-engine</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.425em;">
  A tool for processing JSON RPC: https://github.com/MetaMask/json-rpc-engine
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="使用" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const RpcEngine = require('json-rpc-engine')

let engine = new RpcEngine()

// Build a stack of json rpc processors by pushing in RpcEngine middleware.
engine.push(function(req, res, next, end){
  res.result = 42
  end()
})

// JSON RPC are handled asynchronously, stepping down the stack until complete.
let request = { id: 1, jsonrpc: '2.0', method: 'hello' }

engine.handle(request, function(err, res){
  // do something with res.result
})

// RpcEngine middleware has direct access to the request and response objects. It can let processing continue down the stack with next() or complete the request with end().
engine.push(function(req, res, next, end){
  if (req.skipCache) return next()
  res.result = getResultFromCache(req)
  end()
})

// By passing a 'return handler' to the next function, you can get a peek at the result before it returns.
engine.push(function(req, res, next, end){
  next(function(cb){
    insertIntoCache(res, cb)
  })
})

// RpcEngines can be nested by converting them to middleware asMiddleware(engine)
const asMiddleware = require('json-rpc-engine/lib/asMiddleware')

let engine = new RpcEngine()
let subengine = new RpcEngine()
engine.push(asMiddleware(subengine))
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="gotchas" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1.425em;background-color:white;margin-top:.25em;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.25em;font-family:monospace;">
      <![CDATA[
// Handle errors via end(err), NOT next(err).
// That said, next() will detect errors on the RPC response, and cause end(res.error) to be called.
/* INCORRECT */
engine.push(function(req, res, next, end){
  next(new Error())
})

/* CORRECT */
engine.push(function(req, res, next, end){
  end(new Error())
})
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="json-rpc-middleware-stream"><![CDATA[<div style="color:blue;font-size:1.625em;">json-rpc-middleware-stream</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  A small toolset for streaming json rpc and matching requests and responses. Made to be used with json-rpc-engine.
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
  可以用来与json-rpc-engine结合使用，对输入的json rpc进行读入、写出处理
</div>
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/MetaMask/json-rpc-middleware-stream
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="metamask-inpage-provider"><![CDATA[<div style="color:blue;font-size:1.625em;">metamask-inpage-provider</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  Used to initialize the inpage ethereum provider injected by MetaMask.
</div>
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/MetaMask/metamask-inpage-provider
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="使用" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
// Create a stream to a remote provider:
var metamaskStream = new LocalMessageDuplexStream({
  name: 'inpage',
  target: 'contentscript',
})

// compose the inpage provider
var inpageProvider = new MetamaskInpageProvider(metamaskStream)
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="核心源码" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
// https://github.com/MetaMask/metamask-inpage-provider/blob/master/index.js
const pump = require('pump')
const RpcEngine = require('json-rpc-engine')
const createIdRemapMiddleware = require('json-rpc-engine/src/idRemapMiddleware')
const createJsonRpcStream = require('json-rpc-middleware-stream')
const ObservableStore = require('obs-store')
const asStream = require('obs-store/lib/asStream')
const ObjectMultiplex = require('obj-multiplex')
const { inherits } = require('util')
const SafeEventEmitter = require('safe-event-emitter')
const dequal = require('fast-deep-equal')
const { ethErrors } = require('eth-json-rpc-errors')
const log = require('loglevel')

const messages = require('./src/messages')
const { sendSiteMetadata } = require('./src/siteMetadata')
const {
  createErrorMiddleware,
  logStreamDisconnectWarning,
  makeThenable,
} = require('./src/utils')

// resolve response.result, reject errors
const getRpcPromiseCallback = (resolve, reject) => (error, response) => {
  error || response.error
    ? reject(error || response.error)
    : Array.isArray(response)
      ? resolve(response)
      : resolve(response.result)
}

module.exports = MetamaskInpageProvider

inherits(MetamaskInpageProvider, SafeEventEmitter)

function MetamaskInpageProvider (connectionStream) {

  // super constructor
  SafeEventEmitter.call(this)

  // private state, kept here in part for use in the _metamask proxy
  this._state = {
    sentWarnings: {
      enable: false,
      experimentalMethods: false,
      isConnected: false,
      sendAsync: false,
      // TODO:deprecate:2020-Q1
      autoReload: false,
      sendSync: false,
    },
    isConnected: undefined,
    accounts: undefined,
    isUnlocked: undefined,
  }

  this._metamask = getExperimentalApi(this)

  // public state
  this.selectedAddress = null
  this.networkVersion = undefined
  this.chainId = undefined

  // setup connectionStream multiplexing
  const mux = this.mux = new ObjectMultiplex()
  pump(
    connectionStream,
    mux,
    connectionStream,
    this._handleDisconnect.bind(this, 'MetaMask'),
  )

  // subscribe to metamask public config (one-way)
  this._publicConfigStore = new ObservableStore({ storageKey: 'MetaMask-Config' })

  // handle isUnlocked changes, and chainChanged and networkChanged events
  this._publicConfigStore.subscribe(state => {

    if ('isUnlocked' in state && state.isUnlocked !== this._state.isUnlocked) {
      this._state.isUnlocked = state.isUnlocked
      this.emit('wallet_isUnlocked', this._state.isUnlocked)
      if (!this._state.isUnlocked) {
        // accounts are never exposed when the extension is locked
        this._handleAccountsChanged([])
      } else {
        // this will get the exposed accounts, if any
        try {
          this._sendAsync(
            { method: 'eth_accounts', params: [] },
            () => {},
          )
        } catch (_) {}
      }
    }

    // Emit chainChanged event on chain change
    if ('chainId' in state && state.chainId !== this.chainId) {
      this.chainId = state.chainId
      this.emit('chainChanged', this.chainId)
      this.emit('chainIdChanged', this.chainId) // TODO:deprecate:2020-Q1
    }

    // Emit networkChanged event on network change
    if ('networkVersion' in state && state.networkVersion !== this.networkVersion) {
      this.networkVersion = state.networkVersion
      this.emit('networkChanged', this.networkVersion)
    }
  })

  pump(
    mux.createStream('publicConfig'),
    asStream(this._publicConfigStore),
    // RPC requests should still work if only this stream fails
    logStreamDisconnectWarning.bind(this, 'MetaMask PublicConfigStore'),
  )

  // ignore phishing warning message (handled elsewhere)
  mux.ignoreStream('phishing')

  // setup own event listeners

  // EIP-1193 connect
  this.on('connect', () => {
    this._state.isConnected = true
  })

  // connect to async provider

  const jsonRpcConnection = createJsonRpcStream()
  pump(
    jsonRpcConnection.stream,
    mux.createStream('provider'),
    jsonRpcConnection.stream,
    this._handleDisconnect.bind(this, 'MetaMask RpcProvider'),
  )

  // handle RPC requests via dapp-side rpc engine
  const rpcEngine = new RpcEngine()
  rpcEngine.push(createIdRemapMiddleware())
  rpcEngine.push(createErrorMiddleware())
  rpcEngine.push(jsonRpcConnection.middleware)
  this._rpcEngine = rpcEngine

  // json rpc notification listener
  jsonRpcConnection.events.on('notification', payload => {
    if (payload.method === 'wallet_accountsChanged') {
      this._handleAccountsChanged(payload.result)
    } else if (payload.method === 'eth_subscription') {
      // EIP 1193 subscriptions, per eth-json-rpc-filters/subscriptionManager
      this.emit('notification', payload.params.result)
    }
  })

  // send website metadata
  const domContentLoadedHandler = () => {
    sendSiteMetadata(this._rpcEngine)
    window.removeEventListener('DOMContentLoaded', domContentLoadedHandler)
  }
  window.addEventListener('DOMContentLoaded', domContentLoadedHandler)

  // indicate that we've connected, for EIP-1193 compliance
  setTimeout(() => this.emit('connect'))

  // TODO:deprecate:2020-Q1
  // wait a second to attempt to send this, so that the warning can be silenced
  // moved this here because there's another warning in .enable() discouraging
  // the use thereof per EIP 1102
  setTimeout(() => {
    if (this.autoRefreshOnNetworkChange && !this._state.sentWarnings.autoReload) {
      log.warn(messages.warnings.autoReloadDeprecation)
      this._state.sentWarnings.autoReload = true
    }
  }, 1000)
}

// TODO:deprecate:2020-Q1
MetamaskInpageProvider.prototype._web3Ref = undefined

// TODO:deprecate:2020-Q1
// give the dapps control of a refresh they can toggle this off on the window.ethereum
// this will be default true so it does not break any old apps.
MetamaskInpageProvider.prototype.autoRefreshOnNetworkChange = true

MetamaskInpageProvider.prototype.isMetaMask = true

/**
 * Deprecated.
 * Returns whether the inpage provider is connected to MetaMask.
 */
MetamaskInpageProvider.prototype.isConnected = function () {

  if (!this._state.sentWarnings.isConnected) {
    log.warn(messages.warnings.isConnectedDeprecation)
    this._state.sentWarnings.isConnected = true
  }
  return this._state.isConnected
}

/**
 * Sends an RPC request to MetaMask. Resolves to the result of the method call.
 * May reject with an error that must be caught by the caller.
 *
 * @param {(string|Object)} methodOrPayload - The method name, or the RPC request object.
 * @param {Array<any>} [params] - If given a method name, the method's parameters.
 * @returns {Promise<any>} - A promise resolving to the result of the method call.
 */
MetamaskInpageProvider.prototype.send = function (methodOrPayload, params) {

  // preserve original params for later error if necessary
  const _params = params

  // construct payload object
  let payload
  if (
    typeof methodOrPayload === 'object' &&
    !Array.isArray(methodOrPayload)
  ) {

    // TODO:deprecate:2020-Q1
    // handle send(object, callback), an alias for sendAsync(object, callback)
    if (typeof params === 'function') {
      return this._sendAsync(methodOrPayload, params)
    }

    payload = methodOrPayload

    // TODO:deprecate:2020-Q1
    // backwards compatibility: "synchronous" methods
    if (!params && [
      'eth_accounts',
      'eth_coinbase',
      'eth_uninstallFilter',
      'net_version',
    ].includes(payload.method)) {
      return this._sendSync(payload)
    }
  } else if (
    typeof methodOrPayload === 'string' &&
    typeof params !== 'function'
  ) {

    // wrap params in array out of kindness
    if (params === undefined) {
      params = []
    } else if (!Array.isArray(params)) {
      params = [params]
    }

    payload = {
      method: methodOrPayload,
      params,
    }
  }

  // typecheck payload and payload.method
  if (
    Array.isArray(payload) ||
    typeof params === 'function' ||
    typeof payload !== 'object' ||
    typeof payload.method !== 'string'
  ) {
    throw ethErrors.rpc.invalidRequest({
      message: messages.errors.invalidParams(),
      data: [methodOrPayload, _params],
    })
  }

  return new Promise((resolve, reject) => {
    try {
      this._sendAsync(
        payload,
        getRpcPromiseCallback(resolve, reject),
      )
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Deprecated.
 * Equivalent to: ethereum.send('eth_requestAccounts')
 *
 * @returns {Promise<Array<string>>} - A promise that resolves to an array of addresses.
 */
MetamaskInpageProvider.prototype.enable = function () {

  if (!this._state.sentWarnings.enable) {
    log.warn(messages.warnings.enableDeprecation)
    this._state.sentWarnings.enable = true
  }
  return new Promise((resolve, reject) => {
    try {
      this._sendAsync(
        { method: 'eth_requestAccounts', params: [] },
        getRpcPromiseCallback(resolve, reject),
      )
    } catch (error) {
      reject(error)
    }
  })
}

/**
 * Deprecated.
 * Backwards compatibility. ethereum.send() with callback.
 *
 * @param {Object} payload - The RPC request object.
 * @param {Function} callback - The callback function.
 */
MetamaskInpageProvider.prototype.sendAsync = function (payload, cb) {

  if (!this._state.sentWarnings.sendAsync) {
    log.warn(messages.warnings.sendAsyncDeprecation)
    this._state.sentWarnings.sendAsync = true
  }
  this._sendAsync(payload, cb)
}

/**
 * TODO:deprecate:2020-Q1
 * Internal backwards compatibility method.
 */
MetamaskInpageProvider.prototype._sendSync = function (payload) {

  if (!this._state.sentWarnings.sendSync) {
    log.warn(messages.warnings.sendSyncDeprecation)
    this._state.sentWarnings.sendSync = true
  }

  let result
  switch (payload.method) {

    case 'eth_accounts':
      result = this.selectedAddress ? [this.selectedAddress] : []
      break

    case 'eth_coinbase':
      result = this.selectedAddress || null
      break

    case 'eth_uninstallFilter':
      this._sendAsync(payload, () => {})
      result = true
      break

    case 'net_version':
      result = this.networkVersion || null
      break

    default:
      throw new Error(messages.errors.unsupportedSync(payload.method))
  }

  // looks like a plain object, but behaves like a Promise if someone calls .then on it :evil_laugh:
  return makeThenable({
    id: payload.id,
    jsonrpc: payload.jsonrpc,
    result,
  }, 'result')
}

/**
 * Internal RPC method. Forwards requests to background via the RPC engine.
 * Also remap ids inbound and outbound.
 */
MetamaskInpageProvider.prototype._sendAsync = function (payload, userCallback) {

  let cb = userCallback

  if (!Array.isArray(payload)) {

    if (!payload.jsonrpc) {
      payload.jsonrpc = '2.0'
    }

    if (
      payload.method === 'eth_accounts' ||
      payload.method === 'eth_requestAccounts'
    ) {

      // handle accounts changing
      cb = (err, res) => {
        this._handleAccountsChanged(
          res.result || [],
          payload.method === 'eth_accounts',
        )
        userCallback(err, res)
      }
    }
  }

  this._rpcEngine.handle(payload, cb)
}

/**
 * Called when connection is lost to critical streams.
 */
MetamaskInpageProvider.prototype._handleDisconnect = function (streamName, err) {

  logStreamDisconnectWarning.bind(this)(streamName, err)
  if (this._state.isConnected) {
    this.emit('close', {
      code: 1011,
      reason: 'MetaMask background communication error.',
    })
  }
  this._state.isConnected = false
}

/**
 * Called when accounts may have changed.
 */
MetamaskInpageProvider.prototype._handleAccountsChanged = function (accounts, isEthAccounts = false) {

  // defensive programming
  if (!Array.isArray(accounts)) {
    log.error(
      'MetaMask: Received non-array accounts parameter. Please report this bug.',
      accounts,
    )
    accounts = []
  }

  // emit accountsChanged if anything about the accounts array has changed
  if (!dequal(this._state.accounts, accounts)) {

    // we should always have the correct accounts even before eth_accounts
    // returns, except if the method is called before we're fully initialized
    if (isEthAccounts && this._state.accounts !== undefined) {
      log.warn(
        `MetaMask: 'eth_accounts' updated accounts. Please report this bug.`,
        accounts,
      )
    }

    this.emit('accountsChanged', accounts)
    this._state.accounts = accounts
  }

  // handle selectedAddress
  if (this.selectedAddress !== accounts[0]) {
    this.selectedAddress = accounts[0] || null
  }

  // TODO:deprecate:2020-Q1
  // handle web3
  if (this._web3Ref) {
    this._web3Ref.defaultAccount = this.selectedAddress
  } else if (window.web3 && typeof window.web3.eth === 'object') {
    window.web3.eth.defaultAccount = this.selectedAddress
  }
}

/**
 * Gets experimental _metamask API as Proxy.
 */
function getExperimentalApi (instance) {
  return new Proxy(
    {

      /**
       * Determines if MetaMask is unlocked by the user.
       *
       * @returns {Promise<boolean>} - Promise resolving to true if MetaMask is currently unlocked
       */
      isUnlocked: async () => {
        if (instance._state.isUnlocked === undefined) {
          await new Promise(
            (resolve) => instance._publicConfigStore.once('update', () => resolve()),
          )
        }
        return instance._state.isUnlocked
      },

      /**
       * Make a batch request.
       */
      sendBatch: async (requests) => {

        // basic input validation
        if (!Array.isArray(requests)) {
          throw ethErrors.rpc.invalidRequest({
            message: 'Batch requests must be made with an array of request objects.',
            data: requests,
          })
        }

        return new Promise((resolve, reject) => {
          try {
            instance._sendAsync(
              requests,
              getRpcPromiseCallback(resolve, reject),
            )
          } catch (error) {
            reject(error)
          }
        })
      },

      // TODO:deprecate:2020-Q1 isEnabled, isApproved
      /**
       * Deprecated. Will be removed in Q1 2020.
       * Synchronously determines if this domain is currently enabled, with a potential false negative if called to soon
       *
       * @returns {boolean} - returns true if this domain is currently enabled
       */
      isEnabled: () => {
        return Array.isArray(instance._state.accounts) && instance._state.accounts.length > 0
      },

      /**
       * Deprecated. Will be removed in Q1 2020.
       * Asynchronously determines if this domain is currently enabled
       *
       * @returns {Promise<boolean>} - Promise resolving to true if this domain is currently enabled
       */
      isApproved: async () => {
        if (instance._state.accounts === undefined) {
          await new Promise(
            (resolve) => instance.once('accountsChanged', () => resolve()),
          )
        }
        return Array.isArray(instance._state.accounts) && instance._state.accounts.length > 0
      },
    },
    {

      get: (obj, prop) => {

        if (!instance._state.sentWarnings.experimentalMethods) {
          log.warn(messages.warnings.experimentalMethods)
          instance._state.sentWarnings.experimentalMethods = true
        }
        return obj[prop]
      },
    },
  )
}
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;">
    <c:title id="nonce-tracker"><![CDATA[<div style="color:blue;font-size:1.625em;">nonce-tracker</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  How metamask calculates nonces
</div>
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/MetaMask/nonce-tracker
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="使用" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const NonceTracker = require('nonce-tracker')

const nonceTracker = new NonceTracker(config)

nonceLock = nonceTracker.getNonceLock('0xselectedEthereumAddress')

nonce = nonceLock.nextNonce
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  主要是得到 address 账户下一个交易的 nonce 值，核心就是下面三个值取最大的：
</div>
<ul style="margin-bottom:.425em;margin-top:.325em;list-style: disc;margin-left: 1.5em;font-size:1.225em;">
      <li>_getNetworkNextNonce(address)</li>
      <li>_getHighestLocallyConfirmed(address)</li>
      <li>localNonceResult.nonce</li>
    </ul>
<div style="margin-bottom:.425em;font-size:1.225em;">
  因为取值过程中涉及到 nonce++，所以使用了 await-semaphore 控制，防止多次执行。
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="await-semaphore" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  信号量控制实现，主要是为了保护共享资源，使得资源在一个时刻只有一个进程（线程）所拥有。
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
使用 Seamphore，创建了多少线程，实际就会有多少线程进行执行，只是可同时执行的线程数量会受到限制。但使用线程池，不管你创建多少线程，实际可执行的线程数是一定的。
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
var semaphore = new Semaphore(10);

async function niceFetch(url) {
    var release = await semaphore.acquire();
    var result = await fetch(url);
    release();
    return result;
}
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="核心代码" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const EthQuery = require('ethjs-query')
const assert = require('assert')
const Mutex = require('await-semaphore').Mutex
/**
  @param opts {Object}
    @param {Object} opts.provider a ethereum provider
    @param {Function} opts.getPendingTransactions a function that returns an array of txMeta
    whosee status is `submitted`
    @param {Function} opts.getConfirmedTransactions a function that returns an array of txMeta
    whose status is `confirmed`
  @class
*/
class NonceTracker {

  constructor ({ provider, blockTracker, getPendingTransactions, getConfirmedTransactions }) {
    this.provider = provider
    this.blockTracker = blockTracker
    this.ethQuery = new EthQuery(provider)
    this.getPendingTransactions = getPendingTransactions
    this.getConfirmedTransactions = getConfirmedTransactions
    this.lockMap = {}
  }

  /**
    @returns {Promise<Object>} with the key releaseLock (the gloabl mutex)
  */
  async getGlobalLock () {
    const globalMutex = this._lookupMutex('global')
    // await global mutex free
    const releaseLock = await globalMutex.acquire()
    return { releaseLock }
  }

  /**
   * @typedef NonceDetails
   * @property {number} highestLocallyConfirmed - A hex string of the highest nonce on a confirmed transaction.
   * @property {number} nextNetworkNonce - The next nonce suggested by the eth_getTransactionCount method.
   * @property {number} highestSuggested - The maximum between the other two, the number returned.
   */

  /**
  this will return an object with the `nextNonce` `nonceDetails`, and the releaseLock
  Note: releaseLock must be called after adding a signed tx to pending transactions (or discarding).

  @param address {string} the hex string for the address whose nonce we are calculating
  @returns {Promise<NonceDetails>}
  */
  async getNonceLock (address) {
    // await global mutex free
    await this._globalMutexFree()
    // await lock free, then take lock
    const releaseLock = await this._takeMutex(address)
    try {
      // evaluate multiple nextNonce strategies
      const nonceDetails = {}
      const networkNonceResult = await this._getNetworkNextNonce(address)
      const highestLocallyConfirmed = this._getHighestLocallyConfirmed(address)
      const nextNetworkNonce = networkNonceResult.nonce
      const highestSuggested = Math.max(nextNetworkNonce, highestLocallyConfirmed)

      const pendingTxs = this.getPendingTransactions(address)
      const localNonceResult = this._getHighestContinuousFrom(pendingTxs, highestSuggested) || 0

      nonceDetails.params = {
        highestLocallyConfirmed,
        highestSuggested,
        nextNetworkNonce,
      }
      nonceDetails.local = localNonceResult
      nonceDetails.network = networkNonceResult

      const nextNonce = Math.max(networkNonceResult.nonce, localNonceResult.nonce)
      assert(Number.isInteger(nextNonce), `nonce-tracker - nextNonce is not an integer - got: (${typeof nextNonce}) "${nextNonce}"`)

      // return nonce and release cb
      return { nextNonce, nonceDetails, releaseLock }
    } catch (err) {
      // release lock if we encounter an error
      releaseLock()
      throw err
    }
  }

  async _globalMutexFree () {
    const globalMutex = this._lookupMutex('global')
    const releaseLock = await globalMutex.acquire()
    releaseLock()
  }

  async _takeMutex (lockId) {
    const mutex = this._lookupMutex(lockId)
    const releaseLock = await mutex.acquire()
    return releaseLock
  }

  _lookupMutex (lockId) {
    let mutex = this.lockMap[lockId]
    if (!mutex) {
      mutex = new Mutex()
      this.lockMap[lockId] = mutex
    }
    return mutex
  }

  async _getNetworkNextNonce (address) {
    // calculate next nonce
    // we need to make sure our base count
    // and pending count are from the same block
    const blockNumber = await this.blockTracker.getLatestBlock()
    const baseCountBN = await this.ethQuery.getTransactionCount(address, blockNumber)
    const baseCount = baseCountBN.toNumber()
    assert(Number.isInteger(baseCount), `nonce-tracker - baseCount is not an integer - got: (${typeof baseCount}) "${baseCount}"`)
    const nonceDetails = { blockNumber, baseCount }
    return { name: 'network', nonce: baseCount, details: nonceDetails }
  }

  _getHighestLocallyConfirmed (address) {
    const confirmedTransactions = this.getConfirmedTransactions(address)
    const highest = this._getHighestNonce(confirmedTransactions)
    return Number.isInteger(highest) ? highest + 1 : 0
  }

  _getHighestNonce (txList) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })
    const highestNonce = Math.max.apply(null, nonces)
    return highestNonce
  }

  /**
    @typedef {object} highestContinuousFrom
    @property {string} - name the name for how the nonce was calculated based on the data used
    @property {number} - nonce the next suggested nonce
    @property {object} - details the provided starting nonce that was used (for debugging)
  */
  /**
    @param txList {array} - list of txMeta's
    @param startPoint {number} - the highest known locally confirmed nonce
    @returns {highestContinuousFrom}
  */
  _getHighestContinuousFrom (txList, startPoint) {
    const nonces = txList.map((txMeta) => {
      const nonce = txMeta.txParams.nonce
      assert(typeof nonce, 'string', 'nonces should be hex strings')
      return parseInt(nonce, 16)
    })

    let highest = startPoint
    while (nonces.includes(highest)) {
      highest++
    }

    return { name: 'local', nonce: highest, details: { startPoint, highest } }
  }

}

module.exports = NonceTracker
   ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;">
    <c:title id="obs-store"><![CDATA[<div style="color:blue;font-size:1.625em;">obs-store</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  ObservableStore is a synchronous in-memory store for a single value, that you can subscribe to updates on.
</div>
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/MetaMask/obs-store
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const store = new ObservableStore(initState)
store.subscribe(function showValue(value) {
  console.log('saw value:', value)
})

store.putState(5) // "saw value: 5"
store.putState(true) // "saw value: true"
store.putState({ hello: 'world' }) // "saw value: { hello: 'world' }"

console.log(store.getState().hello) // "world"
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="streams" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  Each ObservableStore can be turned into an ObservableStoreStream. An ObservableStoreStream is a duplex stream that you can pipe new values into it or pipe its updated values out of it
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;margin-top:1em;">
      <![CDATA[
// Special behavior: Doesnt buffer outgoing updates, writes latest state to dest on pipe.
const pipe = require('pump')
const asStream = require('obs-store/lib/asStream')

const storeOne = new ObservableStore(initState)
const storeTwo = new ObservableStore()

pipe(
  asStream(storeOne),
  transformStream,
  asStream(storeTwo)
)
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;">
    <c:title id="post-message-stream"><![CDATA[<div style="color:blue;font-size:1.625em;">post-message-stream</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
  Sets up a duplex object stream over window.postMessage
</div>
<div style="margin-bottom:.425em;font-size:1.425em;">
  https://github.com/kumavis/post-message-stream
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
var streamA = new PostMessageStream({
  name: 'thing one',
  target: 'thing two',
})

var streamB = new PostMessageStream({
  name: 'thing two',
  target: 'thing one',
})

streamB.on('data', (data) => console.log(data))
streamA.write(chunk)
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="constructor arguments" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
var messageStream = new PostMessageStream({

  // required

  // name of stream, used to differentiate
  // when multiple streams are on the same window 
  name: 'source',

  // name of target stream 
  target: 'sink',

  // optional

  // window to send the message to
  // default is `window`
  window: iframe.contentWindow,
  
})
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="window.postMessage" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;">
      <![CDATA[
// https://developer.mozilla.org/zh-CN/docs/Web/API/Window/postMessage
// window.postMessage() 方法可以安全地实现跨源通信。

// otherWindow 其他窗口的一个引用
// message 将要发送到其他 window的数据
// targetOrigin 通过窗口的origin属性来指定哪些窗口能接收到消息事件
                其值可以是字符串"*"（表示无限制）或者一个URI。
// transfer 是一串和message 同时传递的 Transferable 对象
otherWindow.postMessage(message, targetOrigin, [transfer]);

// 执行如下代码, 其他window可以监听分发的message:
window.addEventListener("message", receiveMessage, false);

// event
// data 从其他 window 中传递过来的对象
// origin 调用 postMessage  时消息发送方窗口的 origin
// source 对发送消息的窗口对象的引用
function receiveMessage(event) {
  var origin = event.origin || event.originalEvent.origin; 
  if (origin !== "http://example.org:8080")
    return;

  // ...
}
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;margin-top:1em;">
      <![CDATA[
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
  <li>如果您不希望从其他网站接收 message，请不要为 message 事件添加任何事件侦听器。 </li>
  <li>如果您确实希望从其他网站接收 message，请始终使用 origin 和 source 属性验证发件人的身份。</li>
  <li>当您使用 postMessage 将数据发送到其他窗口时，始终指定精确的目标 origin，而不是*。</li>
</ul>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="核心源码" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;">
      <![CDATA[
// https://github.com/kumavis/post-message-stream/blob/master/index.js
const DuplexStream = require('readable-stream').Duplex
const inherits = require('util').inherits

module.exports = PostMessageStream

inherits(PostMessageStream, DuplexStream)

function PostMessageStream (opts) {
  DuplexStream.call(this, {
    objectMode: true,
  })

  this._name = opts.name
  this._target = opts.target
  this._targetWindow = opts.targetWindow || window
  this._origin = (opts.targetWindow ? '*' : location.origin)

  // initialization flags
  this._init = false
  this._haveSyn = false

  window.addEventListener('message', this._onMessage.bind(this), false)
  // send syncorization message
  this._write('SYN', null, noop)
  // 调用 writable.cork() 方法将强制所有写入数据都内存中的缓冲区里。
  // 直到调用 stream.uncork() 或 stream.end() 方法时，缓冲区里的数据才会被输出。
  this.cork()
}

// private
PostMessageStream.prototype._onMessage = function (event) {
  var msg = event.data

  // validate message
  if (this._origin !== '*' && event.origin !== this._origin) return
  if (event.source !== this._targetWindow) return
  if (typeof msg !== 'object') return
  if (msg.target !== this._name) return
  if (!msg.data) return

  if (!this._init) {
    // listen for handshake 模拟三次握手，再消费消息
    if (msg.data === 'SYN') {
      this._haveSyn = true
      this._write('ACK', null, noop)
    } else if (msg.data === 'ACK') {
      this._init = true
      if (!this._haveSyn) {
        this._write('ACK', null, noop)
      }
      // writable.uncork() 将输出在 stream.cork() 方法被调用之后缓冲在内存中的所有数据。
      // 如果一个流多次调用了 writable.cork() 方法，
      //   那么也必须调用同样次数的 writable.uncork() 方法以输出缓冲区数据。
      this.uncork()
    }
  } else {
    // forward message
    try {
      this.push(msg.data)
    } catch (err) {
      this.emit('error', err)
    }
  }
}

// stream plumbing
PostMessageStream.prototype._read = noop

PostMessageStream.prototype._write = function (data, encoding, cb) {
  var message = {
    target: this._target,
    data: data,
  }
  this._targetWindow.postMessage(message, this._origin)
  cb()
}

// util

function noop () {}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;">
    <c:title id="metamask-dictionary"><![CDATA[<div style="color:blue;font-size:1.625em;">metamask 目录</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;line-height:1.625em;">
  可以好好看看 <a href="https://metamask.github.io/metamask-extension/index.html">https://metamask.github.io/metamask-extension/index.html</a> 看看有哪些类，模块和全局方法
</div>
<div style="margin-bottom:.425em;font-size:1.225em;line-height:1.625em;">
  简单文件用一句话描述，稍微复杂的文件都有链接，点进去有全部代码、详细解析和说明，参考 <a href="https://github.com/jnoodle/metamask-extension">https://github.com/jnoodle/metamask-extension</a>
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
  <li>
    <p>.circleci/  持续集成配置</p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li>scripts/</li>
      <li>config.yml</li>
    </ul>
  </li>
  <li>
    <p>.github/    Issue and PR templates</p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li>ISSUE_TEMPLATE/</li>
    </ul>
  </li> 
  <li>
    <p>.storybook/  storybook配置</p>
  </li> 
  <li>
    <p>app/  主应用</p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li>
        <p>_locales/  多语言/</p>
      <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
        <li>
          &lt;lang&gt;/message.json  多语言文件
          </li>
      </ul>
        </li>
      <li>
        <p>fonts/  字体文件</p>
        </li>
      <li>
        <p>images/   图片资源</p>
        </li>
      <li>
        <p>scripts/  Metamask 脚本文件</p>
      <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
        <li>
          <p>account-import-strategies/  钱包导入处理</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>
            <p>index.js 支持 Private Key 和 JSON File 导入</p>
            </li>
        </ul>
          </li>
        <li>
          <p>controllers/ 不同的 controllers，严格来说是 ViewController</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>
            <p>network/ NetworkController</p>
            </li>
          <li>
            <p>transactions/ Transaction Controller</p>
            <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
            <li>
              <p>lib/</p>  
              <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
              <li>recipient-blacklist.js  收件人地址黑名单，一般都是钓鱼地址</li>
              <li>recipient-blacklist-checker.js  收件人是否在黑名单检查器</li>
              <li>tx-state-history-helper.js  对 txMeta history 处理的一些工具方法</li>
              <li>util.js  </li>
            </ul>
            </li>
            <li>enums.js  交易目前的状态枚举</li>
            <li>index.js  整合 transactions 里所有 tracker 和 controller</li>
            <li>pending-tx-tracker.js  </li>
            <li>README.md</li>
            <li>tx-gas-utils.js  gas计算和安全缓存</li>
            <li>tx-state-manager.js  负责交易的状态和存储交易</li>
          </ul>
            </li>
              <li>
            <p>ab-test.js  进行 a/b 测试，比如全屏显示是否会增加成功确认率</p>
            </li>
          <li>
            <p>app-state.js  设置 app 激活，非激活，超时之类的</p>
            </li>
          <li>
            <p>balance.js  存储和更新账户余额</p>
            </li>
          <li>
            <p>cached-balances.js  维护本地存储中帐户余额的缓存</p>
            </li>
          <li>
            <p>detect-tokens.js  根据用户当前的 token 列表轮询 token 汇率</p>
            </li>
          <li>
            <p>incoming-transactions.js  处理收入交易</p>
            </li>
          <li>
            <p>infura.js  每10分钟检测下 infura 联通情况（https://api.infura.io/v1/status/metamask）</p>
            </li>
          <li>
            <p>onboarding.js  设置用户是否已完成种子短语备份挑战 seedPhraseBackedUp: t/f</p>
            </li>
          <li>
            <p>preferences.js   用户首选项设置</p>
            </li>
          <li>
            <p>provider-approval.js  为用户认可的 ETH provider API 请求提供服务</p>
            </li>
          <li>
            <p>README.md </p>
            </li> 
          <li>
            <p>recent-blocks.js  负责存储，更新和管理最近的 block</p>
            </li>
          <li>
            <p>threebox.js  3box Controller</p>
            </li>
          <li>
            <p>token-rates.js  轮询获取用户 token 的汇率</p>
            </li>
        </ul>
          </li>
          <li>
            <p>lib/</p>
        <li>
          <p>ens-ipfs/  EIP1577 标准，ENS 解析到 IPFS</p>
          <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
            <li>
              <p>contracts/  ABIs</p>
              <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
              <li>registry.js  registryAbi</li>
              <li>resolver.js  resolverAbi</li>
            </ul>
            </li>
            <li>resolver.js  ENS to IPFS contentId</li>
            <li>setup.js  设置 ens ipfs 解析器</li>
          </ul>
        </li>
        <li>
          <p>migrator/  </p>
          <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
            <li>index.js  处理 MetaMask 迁移</li>
          </ul>
        </li>
        <li>account-tracker.js  负责跟踪任意数量的帐户并缓存其当前余额和交易数</li>
        <li>auto-reload.js  处理页面何时重新加载</li>
        <li>backend-metametrics.js  连接 metamask 分析服务（metametrics），统计、错误分析等</li>
        <li>buy-eth-url.js  获取可以买 ETH 的地址，比如 faucet</li>
        <li>cleanErrorStack.js  去掉错误中的堆栈信息，以更好地显示在UI</li>
        <li>ComposableObservableStore.js  可组合的 obs-store</li>
        <li>createDnodeRemoteGetter.js  获取 dnode Server 端的 remote</li>
        <li>createLoggerMiddleware.js  记录RPC活动日志的中间件</li>
        <li>createOriginMiddleware.js  把 DApp 的 origin 添加到请求报文里</li>
        <li>createStreamSink.js  创建异步 writable stream</li>
        <li>diagnostics-reporter.js  诊断报告</li>
        <li>enums.js  常用枚举：环境类型，平台，网络 chainId</li>
        <li>extractEthjsErrorMessage.js  提取 ethjs-rpc 里可读的错误信息</li>
        <li>fetch-with-timeout.js  带超时中断的 fetch</li>
        <li>freezeGlobals.js  阻止 Promise 重新定义</li>
        <li>get-first-preferred-lang-code.js  根据用户浏览器中的设置返回首选语言码（小写）</li>
        <li>getObjStructure.js  获取 obj 结构，即将 key 值替换成 key 类型</li>
        <li>hex-to-bn.js  十六进制转换成 BN ethereumjs-util.BN</li>
        <li>local-store.js  extension 本地存储的包装</li>
        <li>message-manager.js  eth_sign 接口数据制备</li>
        <li>nodeify.js  把 Promise 转换成 node callback 风格，主要为了更好处理错误</li>
        <li>notification-manager.js  一组用于控制通知弹出窗口的显示和隐藏的方法</li>
        <li>pending-balance-calculator.js  计算用户的待处理余额（当前余额 - 处理中的花费）</li>
        <li>personal-message-manager.js  personal_sign 接口数据制备</li>
        <li>random-id.js  生成随机id（初始id++）</li>
        <li>reportFailedTxToSentry.js  格式化失败的 tx message，发给 sentry</li>
        <li>seed-phrase-verifier.js  验证助记词是否可以还原帐户</li>
        <li>select-chain-id.js  获取 chainId（1，3，4，42，5）</li>
        <li>setupFetchDebugging.js  对 fetch 进行封装，抛错时附带上下文和堆栈，参考issue</li>
        <li>setupMetamaskMeshMetrics.js  将 iframe 注入当前文档以进行测试</li>
        <li>setupSentry.js  设置 sentry 远程错误报告</li>
        <li>stream-utils.js  stream 处理工具方法</li>
        <li>typed-message-manager.js  eth_signTypedData 接口数据制备</li>
        <li>util.js  一些常用工具方法</li>
          </li>
          <li>
            <p>migrations/  版本迁移：数据（用户数据，配置文件等）从一个版本迁移到另一个版本</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>0xx.js  版本迁移文件 002.js - 038.js，每个迁移文件必须有 version 属性和 migrate 方法</li>
          <li>fail-tx.js  迁移时作废掉 tx，在版本 029.js 时使用到了</li>
          <li>index.js  导出版本</li>
          <li>README.md  </li>
          <li>template.js  迁移及其作用说明</li>
        </ul>
            </li>
          <li>
            <p>platforms/  统一标准化 extension 方法，屏蔽各浏览器差异</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>extension.js  标准化 extension 方法，比如：刷新、打开窗口、显示消息等</li>
          <li>sw.js  暂时没用到</li>
          <li>window.js  暂时没用到</li>
        </ul>
            </li>
          <li>background.js   页面和区块链进行交互的中间部分</li>
        <li>chromereload.js  重新加载Chrome应用和扩展程序的客户端 http://livereload.com/</li>
        <li>contentscript.js   把 inpage.js 注入到页面中，并通过流把页面和后台脚本连接</li>
        <li>createStandardProvider.js  将传统 provider 转换为符合 EIP-1193 的 provider</li>
        <li>edge-encryptor.js  微软 Edge 浏览器特定的加解密 API</li>
        <li>first-time-state.js  首次进入初始 state，主要用于测试</li>
        <li>inpage.js  注入全局 Web3</li>
        <li>metamask-controller.js   MetaMask Controller 聚合其他控制器并导出api</li>
        <li>phishing-detect.js  通过 https://etherscamdb.info 检测钓鱼网站 </li>
        <li>README.md</li>
        <li>ui.js  UI 相关方法</li>
      </ul>
        </li>
        <li>
          <p>vendor/  第三方</p>
      <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
        <li>
          <p>trezor/  trezor 硬件钱包</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>content-script.js  popop 和 background 建立连接（name:trezor-connect)</li>
          <li>usb-permissions.js  处理来自USB权限iframe的消息</li>
        </ul>
          </li>
      </ul>
        </li>
        <li>home.html  MetaMask 首页，载入 ui-libs.js 和 ui.js</li>
      <li>loading.html  请求 ENS 中页面</li>
      <li>manifest.json   插件配置文件</li>
      <li>notification.html  提示信息页面</li>
      <li>phishing.html  检测出钓鱼网站后显示的页面</li>
      <li>popup.html  popup 弹框，和 home.html 一样，不过加了尺寸限制 width:357px; height:600px;</li>
      <li>trezor-usb-permissions.html  trezor usb 权限申请页面</li>
      <li>unsupport.html  ENS 不支持（只支持主网）</li>
    </ul>
  </li> 
  <li>builds/  生成的插件压缩包</li>
  <li>development/  用于开发的一些文件</li>
  <li>dist/  生成的插件代码</li>
  <li>docs/  官方文档</li>
  <li>fonts/  --> app/fonts</li>
  <li>images/  --> app/images</li>
  <li>test/  测试用例</li>
  <li>
    <p>ui/  UI 代码，参考 MetaMask UI 编写通用规则</p>
    <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
      <li>
        <p>app/  代码</p>
      <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
        <li>
          <p>components/  所有组件</p>
        <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
          <li>
            <p>app/  容器组件</p>
          <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
            <li>account-details/  账户详细信息</li>
           <li>account-menu/  切换账户</li>
           <li>add-token-button/  新增 Token</li>
           <li>app-header/  App 头部信息</li>
           <li>confirm-page-container/  确认页</li>
           <li>contact-list/  联系人列表</li>
           <li>customize-gas-modal/  自定义 gas Modal 框</li>
           <li>dropdowns/  各种下拉菜单，比如选择网络，选择账户，选择token等</li>
           <li>gas-customization/  自定义 gas 时的一些相关组件：输入框、按钮组、slider等</li>
           <li>home-notification/  首页消息提示</li>
           <li>info-box/  信息提示框</li>
           <li>loading-network-screen/  网络载入中提示</li>
           <li>menu-bar/  菜单</li>
           <li>modal/  Modal 弹框</li>
           <li>modals/  各种 modal 集合：账户详情、添加联系人、取消交易、扫描二维码、各种确认等</li>
           <li>multiple-notifications/  多条消息提示</li>
           <li>network-display/  网络显示</li>
           <li>provider-page-container/  provider 设置</li>
           <li>selected-account/  选择账户</li>
           <li>sidebars/  侧边菜单，打开带动画效果</li>
           <li>transaction-action/  交易动作</li>
           <li>transaction-activity-log/  交易活动日志</li>
           <li>transaction-breakdown/  交易明细</li>
           <li>transaction-list/  交易列表</li>
           <li>transaction-list-item/  交易列表条目</li>
           <li>transaction-list-item-details/  交易列表条目详细信息</li>
           <li>transaction-status/  交易状态</li>
           <li>transaction-view/  交易视图：包含交易列表和交易余额</li>
           <li>transaction-view-balance/  交易余额</li>
           <li>user-preferenced-currency-display/  用户首选货币显示</li>
           <li>user-preferenced-currency-input/  用户首选货币输入</li>
           <li>user-preferenced-token-input/  用户首选 token 输入</li>
           <li>account-panel.js  账户面板</li>
           <li>bn-as-decimal-input.js  大数输入</li>
           <li>copyable.js  可以拷贝</li>
           <li>index.scss  所有组件样式整合</li>
           <li>input-number.js  数字输入框</li>
           <li>menu-droppo.js  下拉菜单</li>
           <li>network.js  网络下拉选择</li>
           <li>shift-list-item.js  https://shapeshift.io/</li>
           <li>signature-request.js  签名请求</li>
           <li>tab-bar.js  标签条</li>
           <li>token-cell.js  token展示</li>
           <li>token-list.js  token列表</li>
           <li>wallet-view.js  钱包视图</li>
          </ul>
          </li>
          <li>
            <p>ui/  UI组件</p>
          <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
            <li>alert/  警告框</li>
            <li>balance/  余额展示</li>
            <li>breadcrumbs/  面包屑导航</li>
            <li>button/  按钮</li>
            <li>button-group/  按钮组</li>
            <li>card/  卡片</li>
            <li>currency-display/  货币显示</li>
            <li>currency-input/  货币输入</li>
            <li>dialog/  对话框</li>
            <li>error-message/  错误信息</li>
            <li>export-text-container/  导出框</li>
            <li>hex-to-decimal/  16进制转为10进制</li>
            <li>identicon/  用户头像</li>
            <li>jazzicon/  https://github.com/danfinlay/jazzicon</li>
            <li>loading-screen/  载入框</li>
            <li>lock-icon/  锁定图标</li>
            <li>metafox-logo/  MetaMask Logo</li>
            <li>page-container/  页面容器</li>
            <li>sender-to-recipient/  发送到收件人</li>
            <li>spinner/  loading 旋转指示</li>
            <li>tabs/  tab页</li>
            <li>text-field/  多行文本框</li>
            <li>toggle-button/  切换按钮</li>
            <li>token-balance/  token 余额</li>
            <li>token-currency-display/  token 货币显示</li>
            <li>token-input/  token输入</li>
            <li>unit-input/  单位输入</li>
            <li>copyButton.js  拷贝按钮</li>
            <li>editable-label.js  可编辑标签</li>
            <li>eth-balance.js  ETH余额</li>
            <li>fiat-value.js  法定价值</li>
            <li>mascot.js  MetaMask 吉祥物</li>
            <li>qr-code.js  二维码</li>
            <li>readonly-input.js  只读输入框</li>
            <li>tooltip.js  toolTip</li>
            <li>tooltip-v2.js  toolTip v2 使用 https://github.com/tvkhoa/react-tippy</li>
          </ul>
          </li>
        </ul>
        </li>
        <li>css/  样式文件</li>
        <li>
          <p>ducks/  主要为了应用扩展，没有把 actions，reducer 之类的分开写，参考</p>
          <ul>
            <li>app/  app相关</li>
            <li>confirm-transaction/  交易确认相关</li>
            <li>gas/  gas相关</li>
            <li>locale/  语言相关</li>
            <li>metamask/  metamask相关</li>
            <li>send/  发送相关</li>
            <li>index.js  导出所有 ducks</li>
        </ul>
        </li>
        <li>
          <p>helpers/  辅助方法</p>
          <ul>
            <li>
              <p>constants/  常量</p>
            <ul>
                <li>common.js  网络类型、单位等</li>
              <li>error-keys.js  错误key</li>
              <li>infura-conversion.json  infura token</li>
              <li>routes.js  路由</li>
              <li>transactions.js  交易相关</li>
            </ul>
          </li>
            <li>
              <p>higher-order-components/  高阶组件</p>
            <ul>
                <li>authenticated/  认证</li>
            <li>initialized/  初始化</li>
            <li>metametrics/  MetaMetrics</li>
            <li>with-method-data/  添加 methodData（transactions.util）</li>
            <li>with-modal-props/  添加 modalProps</li>
            <li>with-token-tracker/  添加 token tracker</li>
            <li>i18n-provider.js/  添加多语言</li>
            </ul>
          </li>
            <li>
            <p>utils/</p>
            <ul>
                <li>common.util.js  camelCase转大写</li>
            <li>confirm-tx.util.js  一些常用的转换和格式化</li>
            <li>conversion-util.js  货币换算工具</li>
            <li>conversions.util.js  货币换算常用方法</li>
            <li>fetch-with-cache.js  从缓存取值</li>
            <li>formatters.js  格式化ethFee，加上 ETH 单位</li>
            <li>i18n-helper.js  多语言 helper，根据 key 获取消息文本</li>
            <li>metametrics.util.js  metametrics 工具</li>
            <li>switch-direction.js  在“ rtl”和“ ltr”之间切换CSS样式表</li>
            <li>token-util.js  token相关工具方法</li>
            <li>transactions.util.js  交易相关工具方法</li>
            <li>util.js 常用工具方法</li>
            </ul>
              
          </li>
        </ul>
        </li>
        <li>
          <p>pages/  所有页面组件</p>
        <ul>
            <li>add-token/  添加 token</li>
          <li>confirm-add-suggested-token/  确认增加推荐的token</li>
          <li>confirm-add-token/  确认增加token</li>
          <li>confirm-approve/  确认 token 交易，使用 confirm-token-transaction-base</li>
          <li>confirm-deploy-contract/  确认部署合约</li>
          <li>confirm-send-ether/  确认发送 eth</li>
          <li>confirm-send-token/  确认发送 token</li>
          <li>confirm-token-transaction-base/  确认 token 交易（base 组件）</li>
          <li>confirm-transaction/  确认交易</li>
          <li>confirm-transaction-base/  确认交易（base 组件）</li>
          <li>confirm-transaction-switch/  确认交易切换</li>
          <li>create-account/  创建账户</li>
          <li>first-time-flow/  第一次进入流程，欢迎，创建密码，记录助记词等</li>
          <li>home/  首页</li>
          <li>keychains/  恢复账户，显示seed</li>
          <li>lock/  锁定 MetaMask</li>
          <li>mobile-sync/  移动端同步</li>
          <li>provider-approval/  自定义 provider 核准</li>
          <li>routes/  路由</li>
          <li>send/  发送交易</li>
          <li>settings/  各种设置页面</li>
          <li>unlock-page/  解锁 MetaMask</li>
          <li>index.js  入口页</li>
          <li>index.scss  page 样式集合</li>
        </ul>
        </li>
        <li>
        <p>selectors/  所有的 selector，参考 reselect</p>
          <ul>
            <li>tests/  测试</li>
          <li>confirm-transaction.js  确认交易</li>
          <li>custom-gas.js  自定义gas</li>
          <li>selectors.js  其他 selector</li>
          <li>tokens.js  token</li>
          <li>transactions.js  交易</li>
        </ul>
        </li>
        <li>
        <p>store/  redux store & actions</p>
          <ul>
            <li>actions.js  redux actions</li>
          <li>store.js  redux createStore</li>
        </ul>
        </li>
      </ul>
        </li>
        <li>
          <p>lib/  </p>
      <ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
        <li>account-link.js  查看账户链接，etherscan链接</li>
        <li>blockies.js  计算颜色值</li>
        <li>etherscan-prefix-for-network.js  etherscan网络前缀，如 ropsten.</li>
        <li>feature-toggle-utils.js  检查功能切换</li>
        <li>icon-factory.js  生成icon</li>
        <li>is-mobile-view.js  判断是否是移动设备浏览</li>
        <li>local-storage-helpers.js  localStorage 封装</li>
        <li>persistent-form.js  持久化表单输入</li>
        <li>shallow-with-context.js  https://github.com/airbnb/enzyme 用于单元测试</li>
        <li>test-timeout.js  测试超时</li>
        <li>tx-helper.js  连接所有未确认的操作</li>
        <li>webcam-utils.js  检查摄像头状态</li>
      </ul>
        </li>
        <li>index.js  运行 MetaMask UI</li>
    </ul>
  </li>
  <li>.dockerignore  排除不需要上传到 docker 服务端的文件或目录</li>
  <li>.editorconfig  统一代码格式</li>
  <li>.eslintignore  ESLint 忽略特定的文件和目录</li>
  <li>.eslintrc  ESLint 配置文件</li>
  <li>.gitattributes  定义git文件的一些属性，比如不折叠差异 linguist-generated=false</li>
  <li>.gitignore  git忽略</li>
  <li>.nvmrc  约定 nvm run 启动的 node 版本</li>
  <li>.stylelintignore  Stylelint忽略</li>
  <li>.stylelintrc  Stylelint 规则</li>
  <li>babel.config.js  Babel 配置</li>
  <li>CHANGELOG.md  更新日志</li>
  <li>CONTRIBUTING.md  贡献说明</li>
  <li>gulpfile.js  gulp 配置文件</li>
  <li>ISSUE_TEMPLATE Issue 模板</li>
  <li>LICENSE  </li>
  <li>MISSION.md  使命</li>
  <li>package.json  详见 MetaMask 依赖分析</li>
  <li>README.md  </li>
  <li>USER_AGREEMENT.md  </li>
  <li>yarn.lock   </li>
</ul>
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="account-import-strategies"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/account-import-strategies/index.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  用户导入账户可以选择 Private Key 或者 JSON File，这个文件是对导入钱包的处理。
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const Wallet = require('ethereumjs-wallet')
const importers = require('ethereumjs-wallet/thirdparty')
const ethUtil = require('ethereumjs-util')

const accountImporter = {

  importAccount (strategy, args) {
    try {
      // 使用的是哪种 import 方法
      const importer = this.strategies[strategy]
      // args就是输入的值，如privateKey或者input, password
      const privateKeyHex = importer.apply(null, args)
      return Promise.resolve(privateKeyHex)
    } catch (e) {
      return Promise.reject(e)
    }
  },

  strategies: {
    /**
     * Private Key 方式导入
     * @param privateKey 私钥
     * @return {String}
     */
    'Private Key': (privateKey) => {
      if (!privateKey) {
        throw new Error('Cannot import an empty key.')
      }

      const prefixed = ethUtil.addHexPrefix(privateKey) // 加入0x前缀
      const buffer = ethUtil.toBuffer(prefixed)

      if (!ethUtil.isValidPrivate(buffer)) {
        throw new Error('Cannot import invalid private key.')
      }

      const stripped = ethUtil.stripHexPrefix(prefixed) // 去掉前缀
      return stripped
    },
    /**
     * JSON File 方式导入
     * @param input
     * @param password
     * @return {String}
     */
    'JSON File': (input, password) => {
      let wallet
      try {
        // https://github.com/ethereumjs/ethereumjs-wallet#thirdparty-api
        // import a wallet generated by EtherWallet
        wallet = importers.fromEtherWallet(input, password)
      } catch (e) {
        console.log('Attempt to import as EtherWallet format failed, trying V3...')
      }

      if (!wallet) {
        // https://github.com/ethereumjs/ethereumjs-wallet#wallet-api
        // import a wallet (Version 3 of the Ethereum wallet format).
        // Set nonStrict true to accept files with mixed-caps.
        wallet = Wallet.fromV3(input, password, true)
      }

      return walletToPrivateKey(wallet)
    },
  },

}

function walletToPrivateKey (wallet) {
  // https://github.com/ethereumjs/ethereumjs-wallet#wallet-api
  // getPrivateKey() - return the private key
  const privateKeyBuffer = wallet.getPrivateKey()
  return ethUtil.bufferToHex(privateKeyBuffer)
}

module.exports = accountImporter
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="createInfuraClient"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/network/createInfuraClient.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
<a href="https://infura.io/">https://infura.io/</a> Ethereum & IPFS APIs
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
接口：<a href="https://infura.io/docs/ethereum/json-rpc/">https://infura.io/docs/ethereum/json-rpc/</a>
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
使用库：<br />
<a href="https://github.com/MetaMask/json-rpc-engine">https://github.com/MetaMask/json-rpc-engine</a><br />
<a href="https://github.com/MetaMask/eth-json-rpc-middleware">https://github.com/MetaMask/eth-json-rpc-middleware</a>  // TODO 重点研究<br />
<a href="https://github.com/MetaMask/eth-json-rpc-infura">https://github.com/MetaMask/eth-json-rpc-infura</a><br />
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const mergeMiddleware = require('json-rpc-engine/src/mergeMiddleware')
const createScaffoldMiddleware = require('json-rpc-engine/src/createScaffoldMiddleware')
const createBlockReRefMiddleware = require('eth-json-rpc-middleware/block-ref')
const createRetryOnEmptyMiddleware = require('eth-json-rpc-middleware/retryOnEmpty')
const createBlockCacheMiddleware = require('eth-json-rpc-middleware/block-cache')
const createInflightMiddleware = require('eth-json-rpc-middleware/inflight-cache')
const createBlockTrackerInspectorMiddleware = require('eth-json-rpc-middleware/block-tracker-inspector')
const providerFromMiddleware = require('eth-json-rpc-middleware/providerFromMiddleware')
const createInfuraMiddleware = require('eth-json-rpc-infura')
const BlockTracker = require('eth-block-tracker')

module.exports = createInfuraClient

// https://infura.io/ Infura 是一个 Web3 Provider
// https://github.com/MetaMask/json-rpc-engine
//  a tool for processing JSON RPC

/**
 * createInfuraClient
 * @param network
 * @param onRequest
 * @return {{networkMiddleware: *, blockTracker: *}}
 */
function createInfuraClient ({ network, onRequest }) {
  // mergeMiddleware add middleware to JsonRpcEngine
  // 所谓的 middleware 就是 function(req, res, next, end){} 这样一个 function
  const infuraMiddleware = mergeMiddleware([
    createRequestHookMiddleware(onRequest),

    // https://github.com/MetaMask/eth-json-rpc-infura#usage-as-middleware
    //  json-rpc-engine middleware for infura's REST endpoints.
    createInfuraMiddleware({ network, maxAttempts: 5, source: 'metamask' }),
  ])

  // https://github.com/MetaMask/eth-json-rpc-middleware
  //  Ethereum middleware for composing an ethereum provider using json-rpc-engine.
  // providerFromMiddleware 将 middleware 转换成 provider
  const infuraProvider = providerFromMiddleware(infuraMiddleware)

  // https://github.com/MetaMask/eth-block-tracker
  //  A JS module for keeping track of the latest Ethereum block by polling an ethereum provider.
  // creates a new block tracker with infuraProvider as a data source
  const blockTracker = new BlockTracker({ provider: infuraProvider })

  const networkMiddleware = mergeMiddleware([
    // network to eth_chainId, net_version
    createNetworkAndChainIdMiddleware({ network }),

    // block cache: 分为 permanently，until fork，for block，never 几种策略
    createBlockCacheMiddleware({ blockTracker }),

    // inflight cache
    createInflightMiddleware(),

    // 根据 Block 在 infura rpc 接口请求参数中的位置，获取 block，如果没有，请求最新的
    createBlockReRefMiddleware({ blockTracker, provider: infuraProvider }),

    // RetryOnEmptyMiddleware will retry any request with an empty response
    createRetryOnEmptyMiddleware({ blockTracker, provider: infuraProvider }),

    // inspect if response contains a block ref higher than our latest block
    createBlockTrackerInspectorMiddleware({ blockTracker }),

    infuraMiddleware,
  ])
  return { networkMiddleware, blockTracker }
}

function createNetworkAndChainIdMiddleware ({ network }) {
  let chainId
  let netId

  switch (network) {
    case 'mainnet':
      netId = '1'
      chainId = '0x01'
      break
    case 'ropsten':
      netId = '3'
      chainId = '0x03'
      break
    case 'rinkeby':
      netId = '4'
      chainId = '0x04'
      break
    case 'kovan':
      netId = '42'
      chainId = '0x2a'
      break
    case 'goerli':
      netId = '5'
      chainId = '0x05'
      break
    default:
      throw new Error(`createInfuraClient - unknown network "${network}"`)
  }

  return createScaffoldMiddleware({
    eth_chainId: chainId,
    net_version: netId,
  })
}

function createRequestHookMiddleware (onRequest) {
  return (req, _, next) => {
    onRequest(req)
    next()
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="createJsonRpcClient"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/network/createJsonRpcClient.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const mergeMiddleware = require('json-rpc-engine/src/mergeMiddleware')
const createFetchMiddleware = require('eth-json-rpc-middleware/fetch')
const createBlockRefRewriteMiddleware = require('eth-json-rpc-middleware/block-ref-rewrite')
const createBlockCacheMiddleware = require('eth-json-rpc-middleware/block-cache')
const createInflightMiddleware = require('eth-json-rpc-middleware/inflight-cache')
const createBlockTrackerInspectorMiddleware = require('eth-json-rpc-middleware/block-tracker-inspector')
const providerFromMiddleware = require('eth-json-rpc-middleware/providerFromMiddleware')
const BlockTracker = require('eth-block-tracker')

module.exports = createJsonRpcClient

// https://github.com/MetaMask/json-rpc-engine

function createJsonRpcClient ({ rpcUrl }) {
  const fetchMiddleware = createFetchMiddleware({ rpcUrl })
  const blockProvider = providerFromMiddleware(fetchMiddleware)
  const blockTracker = new BlockTracker({ provider: blockProvider })

  const networkMiddleware = mergeMiddleware([
    // rewrite blockRef to block-tracker's block number if necessary
    createBlockRefRewriteMiddleware({ blockTracker }),
    // block cache
    createBlockCacheMiddleware({ blockTracker }),
    // inflight cache
    createInflightMiddleware(),
    // inspect if response contains a block ref higher than our latest block
    createBlockTrackerInspectorMiddleware({ blockTracker }),
    // do fetch, 出现超时错误会重试
    fetchMiddleware,
  ])
  return { networkMiddleware, blockTracker }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="createLocalhostClient"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/network/createLocalhostClient.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const mergeMiddleware = require('json-rpc-engine/src/mergeMiddleware')
const createFetchMiddleware = require('eth-json-rpc-middleware/fetch')
const createBlockRefRewriteMiddleware = require('eth-json-rpc-middleware/block-ref-rewrite')
const createBlockTrackerInspectorMiddleware = require('eth-json-rpc-middleware/block-tracker-inspector')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const providerFromMiddleware = require('eth-json-rpc-middleware/providerFromMiddleware')
const BlockTracker = require('eth-block-tracker')

const inTest = process.env.IN_TEST === 'true'

module.exports = createLocalhostClient

function createLocalhostClient () {
  const fetchMiddleware = createFetchMiddleware({ rpcUrl: 'http://localhost:8545/' })
  const blockProvider = providerFromMiddleware(fetchMiddleware)
  const blockTracker = new BlockTracker({ provider: blockProvider, pollingInterval: 1000 })

  const networkMiddleware = mergeMiddleware([
    // 估算交易需要的gas用量，delay 2秒？
    createEstimateGasMiddleware(),
    // rewrite blockRef to block-tracker's block number if necessary
    createBlockRefRewriteMiddleware({ blockTracker }),
    // inspect if response contains a block ref higher than our latest block
    createBlockTrackerInspectorMiddleware({ blockTracker }),
    // do fetch
    fetchMiddleware,
  ])
  return { networkMiddleware, blockTracker }
}

function delay (time) {
  return new Promise(resolve => setTimeout(resolve, time))
}


function createEstimateGasMiddleware () {
  return createAsyncMiddleware(async (req, _, next) => {
    if (req.method === 'eth_estimateGas' && inTest) {
      await delay(2000)
    }
    return next()
  })
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="createMetamaskMiddleware"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/network/createMetamaskMiddleware.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const mergeMiddleware = require('json-rpc-engine/src/mergeMiddleware')
const createScaffoldMiddleware = require('json-rpc-engine/src/createScaffoldMiddleware')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const createWalletSubprovider = require('eth-json-rpc-middleware/wallet')

module.exports = createMetamaskMiddleware

/**
 * createMetamaskMiddleware
 * @param version `MetaMask/v${version}`
 * @param getAccounts(req) lookupAccounts middleware next
 * @param processTransaction(txParams, req) sendTransaction middleware next
 * @param processEthSignMessage(msgParams, req) message signatures middleware next
 * @param processTypedMessage(msgParams, req, version) signTypedData middleware next
 * @param processTypedMessageV3(msgParams, req, version) signTypedDataV3 middleware next
 * @param processTypedMessageV4(msgParams, req, version) signTypedDataV4 middleware next
 * @param processPersonalMessage(msgParams, req) personalSign middleware next
 * @param getPendingNonce(address) get pending nonce
 */
function createMetamaskMiddleware ({
  version,
  getAccounts,
  processTransaction,
  processEthSignMessage,
  processTypedMessage,
  processTypedMessageV3,
  processTypedMessageV4,
  processPersonalMessage,
  getPendingNonce,
}) {
  const metamaskMiddleware = mergeMiddleware([
    // createScaffoldMiddleware - if handler is fn, call as middleware
    // if handler is some other value, use as result
    createScaffoldMiddleware({
      // staticSubprovider
      eth_syncing: false,
      web3_clientVersion: `MetaMask/v${version}`,
    }),

    createWalletSubprovider({
      getAccounts,
      processTransaction,
      processEthSignMessage,
      processTypedMessage,
      processTypedMessageV3,
      processTypedMessageV4,
      processPersonalMessage,
    }),

    // if pending, get pending nonce
    createPendingNonceMiddleware({ getPendingNonce }),
  ])
  return metamaskMiddleware
}

function createPendingNonceMiddleware ({ getPendingNonce }) {
  return createAsyncMiddleware(async (req, res, next) => {
    // eth_getTransactionCount 返回指定地址发起的交易总数
    if (req.method !== 'eth_getTransactionCount') return next()
    const address = req.params[0]
    const blockRef = req.params[1]
    if (blockRef !== 'pending') return next()
    res.result = await getPendingNonce(address)
  })
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="network"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/network/network.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const assert = require('assert')
const EventEmitter = require('events')
// https://github.com/MetaMask/obs-store
//  ObservableStore is a synchronous in-memory store for a single value,
//  that you can subscribe to updates on.
const ObservableStore = require('obs-store')
const ComposedStore = require('obs-store/lib/composed')
const EthQuery = require('eth-query')
const JsonRpcEngine = require('json-rpc-engine')
const providerFromEngine = require('eth-json-rpc-middleware/providerFromEngine')
const log = require('loglevel')
const createMetamaskMiddleware = require('./createMetamaskMiddleware')
const createInfuraClient = require('./createInfuraClient')
const createJsonRpcClient = require('./createJsonRpcClient')
const createLocalhostClient = require('./createLocalhostClient')
const { createSwappableProxy, createEventEmitterProxy } = require('swappable-obj-proxy')
const extend = require('extend')
const networks = { networkList: {} }

const {
  ROPSTEN, // Ropsten 是以太坊官方提供的测试网络，共识机制为PoW，支持geth和parity
  RINKEBY, // Rinkeby 是以太坊官方提供的测试网络，使用PoA共识机制，只支持geth
  KOVAN, // Kovan 是Parity的开发团队发起的测试网络，使用了PoA，只支持parity
  MAINNET,
  LOCALHOST,
  GOERLI, // Görli 以太坊2.0
} = require('./enums')
const INFURA_PROVIDER_TYPES = [ROPSTEN, RINKEBY, KOVAN, MAINNET, GOERLI]

const env = process.env.METAMASK_ENV
const METAMASK_DEBUG = process.env.METAMASK_DEBUG

let defaultProviderConfigType
// 根据环境设置默认网络
if (process.env.IN_TEST === 'true') {
  defaultProviderConfigType = LOCALHOST
} else if (METAMASK_DEBUG || env === 'test') {
  defaultProviderConfigType = RINKEBY
} else {
  defaultProviderConfigType = MAINNET
}

const defaultProviderConfig = {
  type: defaultProviderConfigType,
}

const defaultNetworkConfig = {
  ticker: 'ETH',
}

// EventEmitter - 所有能触发事件的对象都是 EventEmitter 类的实例
// 这些对象有一个 eventEmitter.on() 函数，用于将一个或多个函数绑定到命名事件上
module.exports = class NetworkController extends EventEmitter {

  constructor (opts = {}) {
    super()

    // parse options
    const providerConfig = opts.provider || defaultProviderConfig
    // create stores
    this.providerStore = new ObservableStore(providerConfig)
    this.networkStore = new ObservableStore('loading')
    this.networkConfig = new ObservableStore(defaultNetworkConfig)
    // compose all observable store
    this.store = new ComposedStore({ provider: this.providerStore, network: this.networkStore, settings: this.networkConfig })
    this.on('networkDidChange', this.lookupNetwork)
    // provider and block tracker
    this._provider = null
    this._blockTracker = null
    // provider and block tracker proxies - because the network changes
    this._providerProxy = null
    this._blockTrackerProxy = null
  }

  // 初始化 Provider
  initializeProvider (providerParams) {
    this._baseProviderParams = providerParams
    const { type, rpcTarget, chainId, ticker, nickname } = this.providerStore.getState()
    // type: ROPSTEN, RINKEBY, KOVAN, MAINNET, GOERLI
    // rpcTarget: rpcUrl
    // chainId: eg 88
    // ticker: ticker || 'ETH'
    // nickname: 网络昵称
    this._configureProvider({ type, rpcTarget, chainId, ticker, nickname })
    // 查找当前的网络ID by net_version 并 setNetworkState
    this.lookupNetwork()
  }

  // return the proxies so the references will always be good
  getProviderAndBlockTracker () {
    const provider = this._providerProxy
    const blockTracker = this._blockTrackerProxy
    return { provider, blockTracker }
  }

  verifyNetwork () {
    // Check network when restoring connectivity:
    if (this.isNetworkLoading()) this.lookupNetwork()
  }

  getNetworkState () {
    return this.networkStore.getState()
  }

  getNetworkConfig () {
    return this.networkConfig.getState()
  }

  setNetworkState (network, type) {
    // 出错或者在切换过程中，network === 'loading'
    if (network === 'loading') {
      return this.networkStore.putState(network)
    }

    // type must be defined
    if (!type) {
      return
    }
    network = networks.networkList[type] && networks.networkList[type].chainId ? networks.networkList[type].chainId : network
    return this.networkStore.putState(network)
  }

  isNetworkLoading () {
    return this.getNetworkState() === 'loading'
  }

  // 查找当前的网络ID by net_version 并 setNetworkState
  lookupNetwork () {
    // Prevent firing when provider is not defined.
    if (!this._provider) {
      return log.warn('NetworkController - lookupNetwork aborted due to missing provider')
    }
    const { type } = this.providerStore.getState()
    // https://github.com/ethereumjs/eth-query
    //  minimal rpc wrapper
    const ethQuery = new EthQuery(this._provider)
    const initialNetwork = this.getNetworkState()
    ethQuery.sendAsync({ method: 'net_version' }, (err, network) => {
      const currentNetwork = this.getNetworkState()
      if (initialNetwork === currentNetwork) {
        if (err) {
          return this.setNetworkState('loading')
        }
        log.info('web3.getNetwork returned ' + network)
        this.setNetworkState(network, type)
      }
    })
  }

  setRpcTarget (rpcTarget, chainId, ticker = 'ETH', nickname = '', rpcPrefs) {
    const providerConfig = {
      type: 'rpc',
      rpcTarget,
      chainId,
      ticker,
      nickname,
      rpcPrefs,
    }
    this.providerConfig = providerConfig
  }

  async setProviderType (type, rpcTarget = '', ticker = 'ETH', nickname = '') {
    assert.notEqual(type, 'rpc', `NetworkController - cannot call "setProviderType" with type 'rpc'. use "setRpcTarget"`)
    assert(INFURA_PROVIDER_TYPES.includes(type) || type === LOCALHOST, `NetworkController - Unknown rpc type "${type}"`)
    const providerConfig = { type, rpcTarget, ticker, nickname }
    this.providerConfig = providerConfig
  }

  resetConnection () {
    this.providerConfig = this.getProviderConfig()
  }

  set providerConfig (providerConfig) {
    this.providerStore.updateState(providerConfig)
    this._switchNetwork(providerConfig)
  }

  getProviderConfig () {
    return this.providerStore.getState()
  }

  //
  // Private
  //

  _switchNetwork (opts) {
    this.setNetworkState('loading')
    this._configureProvider(opts)
    this.emit('networkDidChange', opts.type)
  }

  // 设置 provider
  _configureProvider (opts) {
    const { type, rpcTarget, chainId, ticker, nickname } = opts
    // infura type-based endpoints
    const isInfura = INFURA_PROVIDER_TYPES.includes(type)
    if (isInfura) {
      this._configureInfuraProvider(opts)
    // other type-based rpc endpoints
    } else if (type === LOCALHOST) {
      this._configureLocalhostProvider()
    // url-based rpc endpoints
    } else if (type === 'rpc') {
      this._configureStandardProvider({ rpcUrl: rpcTarget, chainId, ticker, nickname })
    } else {
      throw new Error(`NetworkController - _configureProvider - unknown type "${type}"`)
    }
  }

  _configureInfuraProvider ({ type }) {
    log.info('NetworkController - configureInfuraProvider', type)
    // ref createInfuraClient.js
    const networkClient = createInfuraClient({
      network: type,
      onRequest: (req) => this.emit('rpc-req', { network: type, req }),
    })
    this._setNetworkClient(networkClient)
    // setup networkConfig
    var settings = {
      ticker: 'ETH',
    }
    this.networkConfig.putState(settings)
  }

  _configureLocalhostProvider () {
    log.info('NetworkController - configureLocalhostProvider')
    // ref createLocalhostClient.js
    const networkClient = createLocalhostClient()
    this._setNetworkClient(networkClient)
  }

  _configureStandardProvider ({ rpcUrl, chainId, ticker, nickname }) {
    log.info('NetworkController - configureStandardProvider', rpcUrl)
    // ref createJsonRpcClient.js
    const networkClient = createJsonRpcClient({ rpcUrl })
    // hack to add a 'rpc' network with chainId
    networks.networkList['rpc'] = {
      chainId: chainId,
      rpcUrl,
      ticker: ticker || 'ETH',
      nickname,
    }
    // setup networkConfig
    var settings = {
      network: chainId,
    }
    settings = extend(settings, networks.networkList['rpc'])
    this.networkConfig.putState(settings)
    this._setNetworkClient(networkClient)
  }

  _setNetworkClient ({ networkMiddleware, blockTracker }) {
    // ref createMetamaskMiddleware.js
    const metamaskMiddleware = createMetamaskMiddleware(this._baseProviderParams)
    const engine = new JsonRpcEngine()
    engine.push(metamaskMiddleware)
    engine.push(networkMiddleware)
    const provider = providerFromEngine(engine)
    this._setProviderAndBlockTracker({ provider, blockTracker })
  }

  _setProviderAndBlockTracker ({ provider, blockTracker }) {
    // update or intialize proxies
    if (this._providerProxy) {
      this._providerProxy.setTarget(provider)
    } else {
      // https://github.com/kumavis/swappable-obj-proxy#createswappableproxy
      //  Creates a Proxy around any object. Retarget the proxy with setTarget.
      this._providerProxy = createSwappableProxy(provider)
    }
    if (this._blockTrackerProxy) {
      this._blockTrackerProxy.setTarget(blockTracker)
    } else {
      // https://github.com/kumavis/swappable-obj-proxy#createeventemitterproxy
      //  Creates a Proxy around an EventEmitter.
      //  If the proxy has setTarget called with a different EventEmitter,
      //  all events will be removed from the old target and transferred to the new EventEmitter.
      //  eventFilter: do not contain 'newListener', 'removeListener' events
      this._blockTrackerProxy = createEventEmitterProxy(blockTracker, { eventFilter: 'skipInternal' })
    }
    // set new provider and blockTracker
    this._provider = provider
    this._blockTracker = blockTracker
  }

  _logBlock (block) {
    log.info(`BLOCK CHANGED: #${block.number.toString('hex')} 0x${block.hash.toString('hex')}`)
    this.verifyNetwork()
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="transactions"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
Transaction Controller
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
Transaction Controller is an aggregate of sub-controllers and trackers exposed to the MetaMask controller.
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
交易控制器是暴露于 metamask 控制器的子控制器和跟踪器的集合。
</div>
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;">
  <li><b>txStateManager</b> responsible for the state of a transaction and storing the transaction 负责交易状态和存储交易</li>
  <li><b>pendingTxTracker</b> watching blocks for transactions to be include and emitting confirmed events 监视包含交易的块并触发已确认的事件</li>
  <li><b>txGasUtil</b> gas calculations and safety buffering gas计算和安全缓存</li>
  <li><b>nonceTracker</b> calculating nonces 计算nonce</li>
</ul>
<div style="margin-bottom:.425em;font-size:1.225em;">
Flow diagram of processing a transaction 
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
<img style="width:100%;" src="/images/ether/1578105958614-b492435b-6a8a-4044-965c-0ab059baf1de.png" />
</div>
<h3><b>txMeta's & txParams</b></h3>
<div style="margin-bottom:.425em;font-size:1.225em;">
A txMeta is the "meta" object it has all the random bits of info we need about a transaction on it. txParams are sacred every thing on txParams gets signed so it must be a valid key and be hex prefixed except for the network number. Extra stuff must go on the txMeta!
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
txMeta “元”对象包含我们需要的有关交易的所有信息。 txParams 里面是原始参数，签名后的参数放在 txMeta 里面，额外的东西必须放在 txMeta 上！
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
Here is a txMeta too look at:
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
txMeta = {
  "id": 2828415030114568, // unique id for this txMeta used for look ups
  "time": 1524094064821, // time of creation
  "status": "confirmed",
  "metamaskNetworkId": "1524091532133", //the network id for the transaction
  "loadingDefaults": false, // used to tell the ui when we are done calculatyig gass defaults
  "txParams": { // the txParams object
    "from": "0x8acce2391c0d510a6c5e5d8f819a678f79b7e675",
    "to": "0x8acce2391c0d510a6c5e5d8f819a678f79b7e675",
    "value": "0x0",
    "gasPrice": "0x3b9aca00",
    "gas": "0x7b0c",
    "nonce": "0x0"
  },
  "history": [{ //debug
            "id": 2828415030114568,
            "time": 1524094064821,
            "status": "unapproved",
            "metamaskNetworkId": "1524091532133",
            "loadingDefaults": true,
            "txParams": {
              "from": "0x8acce2391c0d510a6c5e5d8f819a678f79b7e675",
              "to": "0x8acce2391c0d510a6c5e5d8f819a678f79b7e675",
              "value": "0x0"
            }
          },
          [
            {
              "op": "add",
              "path": "/txParams/gasPrice",
              "value": "0x3b9aca00"
            },
            ...], // I've removed most of history for this
  "gasPriceSpecified": false, //whether or not the user/dapp has specified gasPrice
  "gasLimitSpecified": false, //whether or not the user/dapp has specified gas
  "estimatedGas": "5208",
  "origin": "MetaMask", //debug
  "nonceDetails": {
    "params": {
      "highestLocallyConfirmed": 0,
      "highestSuggested": 0,
      "nextNetworkNonce": 0
    },
    "local": {
      "name": "local",
      "nonce": 0,
      "details": {
        "startPoint": 0,
        "highest": 0
      }
    },
    "network": {
      "name": "network",
      "nonce": 0,
      "details": {
        "baseCount": 0
      }
    }
  },
  "rawTx": "0xf86980843b9aca00827b0c948acce2391c0d510a6c5e5d8f819a678f79b7e67580808602c5b5de66eea05c01a320b96ac730cb210ca56d2cb71fa360e1fc2c21fa5cf333687d18eb323fa02ed05987a6e5fd0f2459fcff80710b76b83b296454ad9a37594a0ccb4643ea90", // used for rebroadcast
  "hash": "0xa45ba834b97c15e6ff4ed09badd04ecd5ce884b455eb60192cdc73bcc583972a",
  "submittedTime": 1524094077902 // time of the attempt to submit the raw tx to the network, used in the ui to show the retry button
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;">
    <c:title id="transactions"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions/lib/tx-state-history-helper.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;">
先要了解 fast-json-patch 库
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
https://github.com/Starcounter-Jack/JSON-Patch
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
fast-json-patch 可以生成一个 JSON 补丁，用来增量更新 json。
</div>
<div style="margin-bottom:.425em;font-size:1.225em;">
compare：https://github.com/Starcounter-Jack/JSON-Patch#jsonpatchcomparedocument1-any-document2-any-invertible--false-operation 比较两个 json，将差异作为数组返回
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
var documentA = {user: {firstName: "Albert", lastName: "Einstein"}};
var documentB = {user: {firstName: "Albert", lastName: "Collins"}};
var diff = jsonpatch.compare(documentA, documentB);
//diff == [{op: "replace", path: "/user/lastName", value: "Collins"}]
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.825em;font-family:monospace;">
      <![CDATA[
<div style="margin-bottom:.425em;font-size:1.225em;margin-top:.625em;">
applyPatch：<a href="https://github.com/Starcounter-Jack/JSON-Patch#function-applypatchtdocument-t-patch-operation-validateoperation-boolean--validatort-mutatedocument-boolean--true-banprototypemodifications-boolean--true-patchresultt">https://github.com/Starcounter-Jack/JSON-Patch#function-applypatchtdocument-t-patch-operation-validateoperation-boolean--validatort-mutatedocument-boolean--true-banprototypemodifications-boolean--true-patchresultt</a> 应用 patch
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
var document = { firstName: "Albert", contactDetails: { phoneNumbers: [] } };
var patch = [
  { op: "replace", path: "/firstName", value: "Joachim" },
  { op: "add", path: "/lastName", value: "Wester" },
  { op: "add", path: "/contactDetails/phoneNumbers/0", value: { number: "555-123" }  }
];
document = jsonpatch.applyPatch(document, patch).newDocument;
// document == { firstName: "Joachim", lastName: "Wester", 
//                contactDetails: { phoneNumbers: [{number:"555-123"}] } };
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="tx-state-history-helper.js" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const jsonDiffer = require('fast-json-patch')
const clone = require('clone')
/** @module*/
module.exports = {
  generateHistoryEntry,
  replayHistory,
  snapshotFromTxMeta,
  migrateFromSnapshotsToDiffs,
}

/**
  converts non-initial history entries into diffs
  将非第一条（index===0）的历史记录条目转换为差异数组
  @param longHistory {array}
  @returns {array}
*/
function migrateFromSnapshotsToDiffs (longHistory) {
  return (
    longHistory
    // convert non-initial history entries into diffs
      .map((entry, index) => {
        if (index === 0) return entry
        return generateHistoryEntry(longHistory[index - 1], entry)
      })
  )
}

/**
  Generates an array of history objects sense the previous state.
  生成可检测先前状态的历史对象数组
  The object has the keys
    op (the operation performed), 执行的操作
    path (the key and if a nested object then each key will be seperated with a `/`)
          键，如果是嵌套对象，每个键用`/`分隔
    value 值
  with the first entry having the note and a timestamp when the change took place
  第一个条目具有注释和更改发生时的时间戳
  @param previousState {object} - the previous state of the object
  @param newState {object} - the update object
  @param note {string} - a optional note for the state change
  @returns {array}
*/
function generateHistoryEntry (previousState, newState, note) {
  // 比较两个 json，将差异作为数组返回
  const entry = jsonDiffer.compare(previousState, newState)
  // Add a note to the first op, since it breaks if we append it to the entry
  if (entry[0]) {
    if (note) entry[0].note = note

    entry[0].timestamp = Date.now()
  }
  return entry
}

/**
  Recovers previous txMeta state obj 恢复之前的 txMeta state obj
  @returns {object}
*/
function replayHistory (_shortHistory) {
  const shortHistory = clone(_shortHistory)
  // 应用差异
  return shortHistory.reduce((val, entry) => jsonDiffer.applyPatch(val, entry).newDocument)
}

/**
  生成 txMeta 快照，不包含 history
  @param txMeta {Object}
  @returns {object} a clone object of the txMeta with out history
*/
function snapshotFromTxMeta (txMeta) {
  // create txMeta snapshot for history
  const snapshot = clone(txMeta)
  // dont include previous history in this snapshot
  delete snapshot.history
  return snapshot
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;">
    <c:title id="transactions"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions/lib/util.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;padding-bottom: 0;color:green;font-size:1em;background-color:white;font-size:1.2em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
const {
  addHexPrefix,
  isValidAddress,
} = require('ethereumjs-util')

/**
@module
*/
module.exports = {
  normalizeTxParams,
  validateTxParams,
  validateFrom,
  validateRecipient,
  getFinalStates,
}


// functions that handle normalizing of that key in txParams
// 对 txParams 的一些格式化处理
const normalizers = {
  from: (from, LowerCase = true) => LowerCase ? addHexPrefix(from).toLowerCase() : addHexPrefix(from),
  to: (to, LowerCase = true) => LowerCase ? addHexPrefix(to).toLowerCase() : addHexPrefix(to),
  nonce: nonce => addHexPrefix(nonce),
  value: value => addHexPrefix(value),
  data: data => addHexPrefix(data),
  gas: gas => addHexPrefix(gas),
  gasPrice: gasPrice => addHexPrefix(gasPrice),
}

/**
  normalizes txParams 格式化 txParams
  @param txParams {object}
  @returns {object} normalized txParams
 */
function normalizeTxParams (txParams, LowerCase) {
  // apply only keys in the normalizers
  const normalizedTxParams = {}
  for (const key in normalizers) {
    if (txParams[key]) normalizedTxParams[key] = normalizers[key](txParams[key], LowerCase)
  }
  return normalizedTxParams
}

/**
  validates txParams 验证 txParams
  @param txParams {object}
 */
function validateTxParams (txParams) {
  validateFrom(txParams)
  validateRecipient(txParams)
  if ('value' in txParams) {
    const value = txParams.value.toString()
    if (value.includes('-')) {
      throw new Error(`Invalid transaction value of ${txParams.value} not a positive number.`)
    }

    if (value.includes('.')) {
      throw new Error(`Invalid transaction value of ${txParams.value} number must be in wei`)
    }
  }
}

/**
  validates the from field in  txParams
  from 字段验证
  @param txParams {object}
 */
function validateFrom (txParams) {
  if (!(typeof txParams.from === 'string')) throw new Error(`Invalid from address ${txParams.from} not a string`)
  if (!isValidAddress(txParams.from)) throw new Error('Invalid from address')
}

/**
  validates the to field in  txParams
  to 字段验证
  @param txParams {object}
 */
function validateRecipient (txParams) {
  if (txParams.to === '0x' || txParams.to === null) {
    if (txParams.data) {
      delete txParams.to
    } else {
      throw new Error('Invalid recipient address')
    }
  } else if (txParams.to !== undefined && !isValidAddress(txParams.to)) {
    throw new Error('Invalid recipient address')
  }
  return txParams
}

/**
    返回可以被认定为最终态的状态
    @returns an {array} of states that can be considered final
  */
function getFinalStates () {
  return [
    'rejected', // the user has responded no! 用户拒绝
    'confirmed', // the tx has been included in a block. 已确认
    'failed', // the tx failed for some reason, included on tx data. 交易失败
    'dropped', // the tx nonce was already used nonce已经被使用
  ]
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="transactions"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions/tx-state-manager.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
TransactionStateManager 负责交易的状态和存储交易，它还具有一些方便的方法来查找交易的子集
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const extend = require('xtend')
const EventEmitter = require('safe-event-emitter')
const ObservableStore = require('obs-store')
const log = require('loglevel')
const txStateHistoryHelper = require('./lib/tx-state-history-helper')
const createId = require('../../lib/random-id')
const { getFinalStates, normalizeTxParams } = require('./lib/util')
/**
  TransactionStateManager is responsible for the state of a transaction and
  storing the transaction
  it also has some convenience methods for finding subsets of transactions
  TransactionStateManager 负责交易的状态和存储交易，它还具有一些方便的方法来查找交易的子集
  *
  *STATUS METHODS
  <br>statuses: 交易状态
  <br>   - `'unapproved'` the user has not responded 用户未响应
  <br>   - `'rejected'` the user has responded no! 用户拒绝
  <br>   - `'approved'` the user has approved the tx 用户批准
  <br>   - `'signed'` the tx is signed 已签名
  <br>   - `'submitted'` the tx is sent to a server 已提交
  <br>   - `'confirmed'` the tx has been included in a block. 已确认
  <br>   - `'failed'` the tx failed for some reason, included on tx data. 失败
  <br>   - `'dropped'` the tx nonce was already used nonce相同，被丢弃
  @param opts {object}
  @param {object} [opts.initState={ transactions: [] }] initial transactions list with the key transaction {array}
  @param {number} [opts.txHistoryLimit] limit for how many finished
  transactions can hang around in state
  @param {function} opts.getNetwork return network number
  @class
*/
class TransactionStateManager extends EventEmitter {
  constructor ({ initState, txHistoryLimit, getNetwork }) {
    super()

    this.store = new ObservableStore(
      extend({
        transactions: [],
      }, initState))
    this.txHistoryLimit = txHistoryLimit
    this.getNetwork = getNetwork
  }

  /**
    生成 txMeta
    @param opts {object} - the object to use when overwriting defaults
    @returns {txMeta} the default txMeta object
  */
  generateTxMeta (opts) {
    const netId = this.getNetwork()
    if (netId === 'loading') throw new Error('MetaMask is having trouble connecting to the network')
    return extend({
      id: createId(),
      time: (new Date()).getTime(),
      status: 'unapproved', // 生成时用户还没有response
      metamaskNetworkId: netId,
      loadingDefaults: true,
    }, opts)
  }

  /**
    获取当前网络下的所有 txMeta[]
    @returns {array} of txMetas that have been filtered for only the current network
  */
  getTxList () {
    const network = this.getNetwork()
    const fullTxList = this.getFullTxList()
    return fullTxList.filter((txMeta) => txMeta.metamaskNetworkId === network)
  }

  /**
    获取所有交易
    @returns {array} of all the txMetas in store
  */
  getFullTxList () {
    return this.store.getState().transactions
  }

  /**
    获得所有 unapproved 状态 txList
    @returns {array} the tx list whos status is unapproved
  */
  getUnapprovedTxList () {
    const txList = this.getTxsByMetaData('status', 'unapproved')
    // 返回 { txid: tx ... } 这种格式
    return txList.reduce((result, tx) => {
      result[tx.id] = tx
      return result
    }, {})
  }

  /**
    获取 approved 状态的 txList
    @param [address] {string} - hex prefixed address to sort the txMetas for [optional]
    @returns {array} the tx list whos status is approved if no address is provide
    returns all txMetas who's status is approved for the current network
  */
  getApprovedTransactions (address) {
    const opts = { status: 'approved' }
    if (address) opts.from = address
    return this.getFilteredTxList(opts)
  }

  /**
    获取 submitted 状态的 txList
    @param [address] {string} - hex prefixed address to sort the txMetas for [optional]
    @returns {array} the tx list whos status is submitted if no address is provide
    returns all txMetas who's status is submitted for the current network
  */
  getPendingTransactions (address) {
    const opts = { status: 'submitted' }
    if (address) opts.from = address
    return this.getFilteredTxList(opts)
  }

  /**
    获取 confirmed 状态的 txList
    @param [address] {string} - hex prefixed address to sort the txMetas for [optional]
    @returns {array} the tx list whos status is confirmed if no address is provide
    returns all txMetas who's status is confirmed for the current network
  */
  getConfirmedTransactions (address) {
    const opts = { status: 'confirmed' }
    if (address) opts.from = address
    return this.getFilteredTxList(opts)
  }

  /**
    把 txMeta 加入到 store 的 transactions 里
    如果 list 超过 txHistoryLimit，会移除一个 final state 的交易
    还会添加 txMeta 快照到 txMeta.history
    Adds the txMeta to the list of transactions in the store.
    if the list is over txHistoryLimit it will remove a transaction that
    is in its final state
    it will allso add the key `history` to the txMeta with the snap shot of the original
    object
    @param txMeta {Object}
    @returns {object} the txMeta
  */
  addTx (txMeta) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = this.normalizeAndValidateTxParams(txMeta.txParams)
    }

    this.once(`${txMeta.id}:signed`, function () {
      this.removeAllListeners(`${txMeta.id}:rejected`)
    })
    this.once(`${txMeta.id}:rejected`, function () {
      this.removeAllListeners(`${txMeta.id}:signed`)
    })
    // initialize history
    txMeta.history = []
    // capture initial snapshot of txMeta for history
    const snapshot = txStateHistoryHelper.snapshotFromTxMeta(txMeta)
    txMeta.history.push(snapshot)

    const transactions = this.getFullTxList()
    const txCount = transactions.length
    const txHistoryLimit = this.txHistoryLimit

    // checks if the length of the tx history is
    // longer then desired persistence limit
    // and then if it is removes only confirmed
    // or rejected tx's.
    // not tx's that are pending or unapproved
    if (txCount > txHistoryLimit - 1) {
      const index = transactions.findIndex((metaTx) => {
        return getFinalStates().includes(metaTx.status)
      })
      if (index !== -1) {
        transactions.splice(index, 1)
      }
    }
    transactions.push(txMeta)
    this._saveTxList(transactions)
    return txMeta
  }
  /**
    根据 txId 获取 txMeta
    @param txId {number}
    @returns {object} the txMeta who matches the given id if none found
    for the network returns undefined
  */
  getTx (txId) {
    const txMeta = this.getTxsByMetaData('id', txId)[0]
    return txMeta
  }

  /**
    updates the txMeta in the list and adds a history entry
    更新列表中的txMeta并添加历史记录条目
    @param txMeta {Object} - the txMeta to update
    @param [note] {string} - a note about the update for history
  */
  updateTx (txMeta, note) {
    // normalize and validate txParams if present
    if (txMeta.txParams) {
      txMeta.txParams = this.normalizeAndValidateTxParams(txMeta.txParams)
    }

    // create txMeta snapshot for history
    const currentState = txStateHistoryHelper.snapshotFromTxMeta(txMeta)
    // recover previous tx state obj
    const previousState = txStateHistoryHelper.replayHistory(txMeta.history)
    // generate history entry and add to history
    const entry = txStateHistoryHelper.generateHistoryEntry(previousState, currentState, note)
    txMeta.history.push(entry)

    // commit txMeta to state
    const txId = txMeta.id
    const txList = this.getFullTxList()
    const index = txList.findIndex(txData => txData.id === txId)
    txList[index] = txMeta
    this._saveTxList(txList)
  }


  /**
    merges txParams obj onto txMeta.txParams
    use extend to ensure that all fields are filled
    @param txId {number} - the id of the txMeta
    @param txParams {object} - the updated txParams
  */
  updateTxParams (txId, txParams) {
    const txMeta = this.getTx(txId)
    txMeta.txParams = extend(txMeta.txParams, txParams)
    this.updateTx(txMeta, `txStateManager#updateTxParams`)
  }

  /**
   * normalize and validate txParams members
   * @param txParams {object} - txParams
   */
  normalizeAndValidateTxParams (txParams) {
    if (typeof txParams.data === 'undefined') {
      delete txParams.data
    }
    txParams = normalizeTxParams(txParams, false)
    this.validateTxParams(txParams)
    return txParams
  }

  /**
    validates txParams members by type
    @param txParams {object} - txParams to validate
  */
  validateTxParams (txParams) {
    Object.keys(txParams).forEach((key) => {
      const value = txParams[key]
      // validate types
      switch (key) {
        case 'chainId':
          if (typeof value !== 'number' && typeof value !== 'string') throw new Error(`${key} in txParams is not a Number or hex string. got: (${value})`)
          break
        default:
          if (typeof value !== 'string') throw new Error(`${key} in txParams is not a string. got: (${value})`)
          break
      }
    })
  }

  /**
   对 txList 进行过滤
   注意这里如果 opts 有多个条件，要全都满足，交集
  @param opts {object} -  an object of fields to search for eg:<br>
  let <code>thingsToLookFor = {<br>
    to: '0x0..',<br>
    from: '0x0..',<br>
    status: 'signed', \\ (status) => status !== 'rejected' give me all txs who's status is not rejected<br>
    err: undefined,<br>
  }<br></code>
  optionally the values of the keys can be functions for situations like where
  you want all but one status.
  @param [initialList=this.getTxList()]
  @returns a {array} of txMeta with all
  options matching
  */
  /*
  ****************HINT****************
  | `err: undefined` is like looking |
  | for a tx with no err             |
  | so you can also search txs that  |
  | dont have something as well by   |
  | setting the value as undefined   |
  ************************************

  this is for things like filtering a the tx list
  for only tx's from 1 account
  or for filtering for all txs from one account
  and that have been 'confirmed'
  */
  getFilteredTxList (opts, initialList) {
    let filteredTxList = initialList
    Object.keys(opts).forEach((key) => {
      filteredTxList = this.getTxsByMetaData(key, opts[key], filteredTxList)
    })
    return filteredTxList
  }
  /**
    根据 meta 条件过滤 txList
    @param key {string} - the key to check
    @param value - the value your looking for can also be a function that returns a bool
    @param [txList=this.getTxList()] {array} - the list to search. default is the txList
    from txStateManager#getTxList
    @returns {array} a list of txMetas who matches the search params
  */
  getTxsByMetaData (key, value, txList = this.getTxList()) {
    const filter = typeof value === 'function' ? value : (v) => v === value

    return txList.filter((txMeta) => {
      if (key in txMeta.txParams) {
        return filter(txMeta.txParams[key])
      } else {
        return filter(txMeta[key])
      }
    })
  }

  // get::set status 下面是一些简单的对状态的get和set

  /**
    @param txId {number} - the txMeta Id
    @return {string} the status of the tx.
  */
  getTxStatus (txId) {
    const txMeta = this.getTx(txId)
    return txMeta.status
  }

  /**
    should update the status of the tx to 'rejected'.
    @param txId {number} - the txMeta Id
  */
  setTxStatusRejected (txId) {
    this._setTxStatus(txId, 'rejected')
    this._removeTx(txId)
  }

  /**
    should update the status of the tx to 'unapproved'.
    @param txId {number} - the txMeta Id
  */
  setTxStatusUnapproved (txId) {
    this._setTxStatus(txId, 'unapproved')
  }
  /**
    should update the status of the tx to 'approved'.
    @param txId {number} - the txMeta Id
  */
  setTxStatusApproved (txId) {
    this._setTxStatus(txId, 'approved')
  }

  /**
    should update the status of the tx to 'signed'.
    @param txId {number} - the txMeta Id
  */
  setTxStatusSigned (txId) {
    this._setTxStatus(txId, 'signed')
  }

  /**
    submitted 更新的时候，记录下时间
    should update the status of the tx to 'submitted'.
    and add a time stamp for when it was called
    @param txId {number} - the txMeta Id
  */
  setTxStatusSubmitted (txId) {
    const txMeta = this.getTx(txId)
    txMeta.submittedTime = (new Date()).getTime()
    this.updateTx(txMeta, 'txStateManager - add submitted time stamp')
    this._setTxStatus(txId, 'submitted')
  }

  /**
    should update the status of the tx to 'confirmed'.
    @param txId {number} - the txMeta Id
  */
  setTxStatusConfirmed (txId) {
    this._setTxStatus(txId, 'confirmed')
  }

  /**
    should update the status of the tx to 'dropped'.
    @param txId {number} - the txMeta Id
  */
  setTxStatusDropped (txId) {
    this._setTxStatus(txId, 'dropped')
  }


  /**
    failed 更新的时候，记录错误信息
    should update the status of the tx to 'failed'.
    and put the error on the txMeta
    @param txId {number} - the txMeta Id
    @param err {erroObject} - error object
  */
  setTxStatusFailed (txId, err) {
    const error = !err ? new Error('Internal metamask failure') : err

    const txMeta = this.getTx(txId)
    txMeta.err = {
      message: error.toString(),
      rpc: error.value,
      stack: error.stack,
    }
    this.updateTx(txMeta, 'transactions:tx-state-manager#fail - add error')
    this._setTxStatus(txId, 'failed')
  }

  /**
    删掉指定 address 在当前网络发起的所有 txList
    Removes transaction from the given address for the current network
    from the txList
    @param address {string} - hex string of the from address on the txParams to remove
  */
  wipeTransactions (address) {
    // network only tx
    const txs = this.getFullTxList()
    const network = this.getNetwork()

    // Filter out the ones from the current account and network
    const otherAccountTxs = txs.filter((txMeta) => !(txMeta.txParams.from === address && txMeta.metamaskNetworkId === network))

    // Update state
    this._saveTxList(otherAccountTxs)
  }
  //
  //           PRIVATE METHODS
  //

  // STATUS METHODS
  // statuses:
  //    - `'unapproved'` the user has not responded
  //    - `'rejected'` the user has responded no!
  //    - `'approved'` the user has approved the tx
  //    - `'signed'` the tx is signed
  //    - `'submitted'` the tx is sent to a server
  //    - `'confirmed'` the tx has been included in a block.
  //    - `'failed'` the tx failed for some reason, included on tx data.
  //    - `'dropped'` the tx nonce was already used

  /**
    更新交易状态会触发一系列事件
    @param txId {number} - the txMeta Id
    @param status {string} - the status to set on the txMeta
    @emits tx:status-update - passes txId and status
    @emits ${txMeta.id}:finished - if it is a finished state. Passes the txMeta
    @emits update:badge
  */
  _setTxStatus (txId, status) {
    const txMeta = this.getTx(txId)

    if (!txMeta) {
      return
    }

    txMeta.status = status
    setTimeout(() => {
      try {
        this.updateTx(txMeta, `txStateManager: setting status to ${status}`)
        this.emit(`${txMeta.id}:${status}`, txId)
        this.emit(`tx:status-update`, txId, status)
        if (['submitted', 'rejected', 'failed'].includes(status)) {
          this.emit(`${txMeta.id}:finished`, txMeta)
        }
        this.emit('update:badge')
      } catch (error) {
        log.error(error)
      }
    })
  }

  /**
    Saves the new/updated txList. 更新 transactions
    @param transactions {array} - the list of transactions to save
  */
  // Function is intended only for internal use
  _saveTxList (transactions) {
    this.store.updateState({ transactions })
  }

  _removeTx (txId) {
    const transactionList = this.getFullTxList()
    this._saveTxList(transactionList.filter((txMeta) => txMeta.id !== txId))
  }
}

module.exports = TransactionStateManager
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;">
    <c:title id="pending-tx-tracker"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions/pending-tx-tracker.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
监视包含交易的块并发出已确认的事件
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EventEmitter = require('safe-event-emitter')
const log = require('loglevel')
const EthQuery = require('ethjs-query')

/**
  监视包含交易的块并触发已确认的事件
  Event emitter utility class for tracking the transactions as they<br>
  go from a pending state to a confirmed (mined in a block) state<br>
<br>
  As well as continues broadcast while in the pending state
<br>
@param config {object} - non optional configuration object consists of:
    @param {Object} config.provider - A network provider.
    @param {Object} config.nonceTracker see nonce tracker
    @param {function} config.getPendingTransactions a function for getting an array of transactions,
    @param {function} config.publishTransaction a async function for publishing raw transactions,


@class
*/

class PendingTransactionTracker extends EventEmitter {
  constructor (config) {
    super()
    this.droppedBuffer = {}
    this.query = new EthQuery(config.provider)
    this.nonceTracker = config.nonceTracker
    this.getPendingTransactions = config.getPendingTransactions
    this.getCompletedTransactions = config.getCompletedTransactions
    this.publishTransaction = config.publishTransaction
    this.approveTransaction = config.approveTransaction
    this.confirmTransaction = config.confirmTransaction
  }

  /**
    检查网络中是否有已签名的TX，如果有，释放 nonce 全局锁
    checks the network for signed txs and releases the nonce global lock if it is
  */
  async updatePendingTxs () {
    // in order to keep the nonceTracker accurate we block it while updating pending transactions
    const nonceGlobalLock = await this.nonceTracker.getGlobalLock()
    try {
      const pendingTxs = this.getPendingTransactions()
      await Promise.all(pendingTxs.map((txMeta) => this._checkPendingTx(txMeta)))
    } catch (err) {
      log.error('PendingTransactionTracker - Error updating pending transactions')
      log.error(err)
    }
    nonceGlobalLock.releaseLock()
  }

  /**
    将重新提交尚未在区块中确认的交易
    Will resubmit any transactions who have not been confirmed in a block
    @param block {object} - a block object
    @emits tx:warning
  */
  resubmitPendingTxs (blockNumber) {
    const pending = this.getPendingTransactions()
    // only try resubmitting if their are transactions to resubmit
    if (!pending.length) return
    pending.forEach((txMeta) => this._resubmitTx(txMeta, blockNumber).catch((err) => {
      /*
      Dont marked as failed if the error is a "known" transaction warning
      "there is already a transaction with the same sender-nonce
      but higher/same gas price"

      Also don't mark as failed if it has ever been broadcast successfully.
      A successful broadcast means it may still be mined.
      */
      const errorMessage = err.message.toLowerCase()
      const isKnownTx = (
        // geth
        errorMessage.includes('replacement transaction underpriced') ||
        errorMessage.includes('known transaction') ||
        // parity
        errorMessage.includes('gas price too low to replace') ||
        errorMessage.includes('transaction with the same hash was already imported') ||
        // other
        errorMessage.includes('gateway timeout') ||
        errorMessage.includes('nonce too low')
      )
      // ignore resubmit warnings, return early
      if (isKnownTx) return
      // encountered real error - transition to error state
      txMeta.warning = {
        error: errorMessage,
        message: 'There was an error when resubmitting this transaction.',
      }
      this.emit('tx:warning', txMeta, err)
    }))
  }

  /**
    resubmits the individual txMeta used in resubmitPendingTxs
    @param txMeta {Object} - txMeta object
    @param latestBlockNumber {string} - hex string for the latest block number
    @emits tx:retry
    @returns txHash {string}
  */
  async _resubmitTx (txMeta, latestBlockNumber) {
    if (!txMeta.firstRetryBlockNumber) {
      this.emit('tx:block-update', txMeta, latestBlockNumber)
    }

    const firstRetryBlockNumber = txMeta.firstRetryBlockNumber || latestBlockNumber
    const txBlockDistance = Number.parseInt(latestBlockNumber, 16) - Number.parseInt(firstRetryBlockNumber, 16)

    const retryCount = txMeta.retryCount || 0

    // Exponential backoff to limit retries at publishing
    if (txBlockDistance <= Math.pow(2, retryCount) - 1) return

    // Only auto-submit already-signed txs:
    if (!('rawTx' in txMeta)) return this.approveTransaction(txMeta.id)

    const rawTx = txMeta.rawTx
    const txHash = await this.publishTransaction(rawTx)

    // Increment successful tries:
    this.emit('tx:retry', txMeta)
    return txHash
  }

  /**
    要求网络进行交易以查看其是否已包含在区块中
    Ask the network for the transaction to see if it has been include in a block
    @param txMeta {Object} - the txMeta object
    @emits tx:failed
    @emits tx:confirmed
    @emits tx:warning
  */
  async _checkPendingTx (txMeta) {
    const txHash = txMeta.hash
    const txId = txMeta.id

    // Only check submitted txs
    if (txMeta.status !== 'submitted') return

    // extra check in case there was an uncaught error during the
    // signature and submission process
    if (!txHash) {
      const noTxHashErr = new Error('We had an error while submitting this transaction, please try again.')
      noTxHashErr.name = 'NoTxHashError'
      this.emit('tx:failed', txId, noTxHashErr)

      return
    }

    // If another tx with the same nonce is mined, set as dropped.
    const taken = await this._checkIfNonceIsTaken(txMeta)
    let dropped
    try {
      // check the network if the nonce is ahead the tx
      // and the tx has not been mined into a block

      dropped = await this._checkIftxWasDropped(txMeta)
      // the dropped buffer is in case we ask a node for the tx
      // that is behind the node we asked for tx count
      // IS A SECURITY FOR HITTING NODES IN INFURA THAT COULD GO OUT
      // OF SYNC.
      // on the next block event it will return fire as dropped
      // 先扔到 droppedBuffer
      // https://github.com/MetaMask/metamask-extension/pull/6388/files
      if (dropped && !this.droppedBuffer[txHash]) {
        this.droppedBuffer[txHash] = true
        dropped = false
      } else if (dropped && this.droppedBuffer[txHash]) {
        // clean up
        delete this.droppedBuffer[txHash]
      }

    } catch (e) {
      log.error(e)
    }
    if (taken || dropped) {
      return this.emit('tx:dropped', txId)
    }

    // get latest transaction status
    try {
      const { blockNumber } = await this.query.getTransactionByHash(txHash) || {}
      if (blockNumber) {
        this.emit('tx:confirmed', txId)
      }
    } catch (err) {
      txMeta.warning = {
        error: err.message,
        message: 'There was a problem loading this transaction.',
      }
      this.emit('tx:warning', txMeta, err)
    }
  }
  /**
    检查是否 nonce 已被另一笔交易使用
    checks to see if if the tx's nonce has been used by another transaction
    @param txMeta {Object} - txMeta object
    @emits tx:dropped
    @returns {boolean}
  */

  async _checkIftxWasDropped (txMeta) {
    const { txParams: { nonce, from }, hash } = txMeta
    const nextNonce = await this.query.getTransactionCount(from)
    const { blockNumber } = await this.query.getTransactionByHash(hash) || {}
    if (!blockNumber && parseInt(nextNonce) > parseInt(nonce)) {
      return true
    }
    return false
  }

  /**
    检查是否有已确认的 txMeta 包含相同的 nonce
    checks to see if a confirmed txMeta has the same nonce
    @param txMeta {Object} - txMeta object
    @returns {boolean}
  */


  async _checkIfNonceIsTaken (txMeta) {
    const address = txMeta.txParams.from
    const completed = this.getCompletedTransactions(address)
    const sameNonce = completed.filter((otherMeta) => {
      return otherMeta.txParams.nonce === txMeta.txParams.nonce
    })
    return sameNonce.length > 0
  }
}

module.exports = PendingTransactionTracker
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;">
    <c:title id="tx-gas-utils"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions/tx-gas-utils.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
gas计算和安全缓存
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EthQuery = require('ethjs-query')
const {
  hexToBn,
  BnMultiplyByFraction,
  bnToHex,
} = require('../../lib/util')
const log = require('loglevel')
const { addHexPrefix } = require('ethereumjs-util')
const { SEND_ETHER_ACTION_KEY } = require('../../../../ui/app/helpers/constants/transactions.js')
const SIMPLE_GAS_COST = '0x5208' // Hex for 21000, cost of a simple send.

import { TRANSACTION_NO_CONTRACT_ERROR_KEY } from '../../../../ui/app/helpers/constants/error-keys'

/**
 提供了一些 gas 相关的工具方法
tx-gas-utils are gas utility methods for Transaction manager
its passed ethquery
and used to do things like calculate gas of a tx.
@param {Object} provider - A network provider.
*/

class TxGasUtil {

  constructor (provider) {
    this.query = new EthQuery(provider)
  }

  /**
    @param txMeta {Object} - the txMeta object
    @returns {object} the txMeta object with the gas written to the txParams
  */
  async analyzeGasUsage (txMeta, getCodeResponse) {
    const block = await this.query.getBlockByNumber('latest', false)
    let estimatedGasHex
    try {
      estimatedGasHex = await this.estimateTxGas(txMeta, block.gasLimit, getCodeResponse)
    } catch (err) {
      log.warn(err)
      txMeta.simulationFails = {
        reason: err.message,
        errorKey: err.errorKey,
        debug: { blockNumber: block.number, blockGasLimit: block.gasLimit },
      }

      if (err.errorKey === TRANSACTION_NO_CONTRACT_ERROR_KEY) {
        txMeta.simulationFails.debug.getCodeResponse = err.getCodeResponse
      }

      return txMeta
    }
    this.setTxGas(txMeta, block.gasLimit, estimatedGasHex)
    return txMeta
  }

  /**
    Estimates the tx's gas usage 估算gas
    @param txMeta {Object} - the txMeta object
    @param blockGasLimitHex {string} - hex string of the block's gas limit
    @returns {string} the estimated gas limit as a hex string
  */
  async estimateTxGas (txMeta, blockGasLimitHex, getCodeResponse) {
    const txParams = txMeta.txParams

    // check if gasLimit is already specified
    txMeta.gasLimitSpecified = Boolean(txParams.gas)

    // if it is, use that value
    if (txMeta.gasLimitSpecified) {
      return txParams.gas
    }

    const recipient = txParams.to
    const hasRecipient = Boolean(recipient)

    // see if we can set the gas based on the recipient
    if (hasRecipient) {
      // For an address with no code, geth will return '0x', and ganache-core v2.2.1 will return '0x0'
      const categorizedAsSimple = txMeta.transactionCategory === SEND_ETHER_ACTION_KEY

      if (categorizedAsSimple) {
        // if there's data in the params, but there's no contract code, it's not a valid transaction
        // 发给零地址的都是智能合约，必须有 data
        if (txParams.data) {
          const err = new Error('TxGasUtil - Trying to call a function on a non-contract address')
          // set error key so ui can display localized error message
          err.errorKey = TRANSACTION_NO_CONTRACT_ERROR_KEY

          // set the response on the error so that we can see in logs what the actual response was
          err.getCodeResponse = getCodeResponse
          throw err
        }

        // This is a standard ether simple send, gas requirement is exactly 21k
        txParams.gas = SIMPLE_GAS_COST
        // prevents buffer addition
        txMeta.simpleSend = true
        return SIMPLE_GAS_COST
      }
    }

    // fallback to block gasLimit
    const blockGasLimitBN = hexToBn(blockGasLimitHex)
    const saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20)
    txParams.gas = bnToHex(saferGasLimitBN)

    // estimate tx gas requirements
    return await this.query.estimateGas(txParams)
  }

  /**
    Writes the gas on the txParams in the txMeta
    @param txMeta {Object} - the txMeta object to write to
    @param blockGasLimitHex {string} - the block gas limit hex
    @param estimatedGasHex {string} - the estimated gas hex
  */
  setTxGas (txMeta, blockGasLimitHex, estimatedGasHex) {
    txMeta.estimatedGas = addHexPrefix(estimatedGasHex)
    const txParams = txMeta.txParams

    // if gasLimit was specified and doesnt OOG,
    // use original specified amount
    if (txMeta.gasLimitSpecified || txMeta.simpleSend) {
      txMeta.estimatedGas = txParams.gas
      return
    }
    // if gasLimit not originally specified,
    // try adding an additional gas buffer to our estimation for safety
    const recommendedGasHex = this.addGasBuffer(txMeta.estimatedGas, blockGasLimitHex)
    txParams.gas = recommendedGasHex
    return
  }

  /**
    添加 gas buffer，且不超过 gas limit
    Adds a gas buffer with out exceeding the block gas limit

    @param initialGasLimitHex {string} - the initial gas limit to add the buffer too
    @param blockGasLimitHex {string} - the block gas limit
    @returns {string} the buffered gas limit as a hex string
  */
  addGasBuffer (initialGasLimitHex, blockGasLimitHex) {
    const initialGasLimitBn = hexToBn(initialGasLimitHex)
    const blockGasLimitBn = hexToBn(blockGasLimitHex)
    const upperGasLimitBn = blockGasLimitBn.muln(0.9)
    const bufferedGasLimitBn = initialGasLimitBn.muln(1.5)

    // if initialGasLimit is above blockGasLimit, dont modify it
    if (initialGasLimitBn.gt(upperGasLimitBn)) return bnToHex(initialGasLimitBn)
    // if bufferedGasLimit is below blockGasLimit, use bufferedGasLimit
    if (bufferedGasLimitBn.lt(upperGasLimitBn)) return bnToHex(bufferedGasLimitBn)
    // otherwise use blockGasLimit
    return bnToHex(upperGasLimitBn)
  }
}

module.exports = TxGasUtil
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="transactions-index"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/transactions/index.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
txStateManage、pendingTxTracker、txGasUtil、nonceTracker 的集合，这个文件里本身的注释非常全面
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EventEmitter = require('safe-event-emitter')
const ObservableStore = require('obs-store')
const ethUtil = require('ethereumjs-util')
const Transaction = require('ethereumjs-tx')
const EthQuery = require('ethjs-query')
const { errors: rpcErrors } = require('eth-json-rpc-errors')
const abi = require('human-standard-token-abi')
const abiDecoder = require('abi-decoder')
abiDecoder.addABI(abi)
const {
  TOKEN_METHOD_APPROVE,
  TOKEN_METHOD_TRANSFER,
  TOKEN_METHOD_TRANSFER_FROM,
  SEND_ETHER_ACTION_KEY,
  DEPLOY_CONTRACT_ACTION_KEY,
  CONTRACT_INTERACTION_KEY,
} = require('../../../../ui/app/helpers/constants/transactions.js')
const TransactionStateManager = require('./tx-state-manager')
const TxGasUtil = require('./tx-gas-utils')
const PendingTransactionTracker = require('./pending-tx-tracker')
const NonceTracker = require('nonce-tracker')
const txUtils = require('./lib/util')
const cleanErrorStack = require('../../lib/cleanErrorStack')
const log = require('loglevel')
const recipientBlacklistChecker = require('./lib/recipient-blacklist-checker')
const {
  TRANSACTION_TYPE_CANCEL,
  TRANSACTION_TYPE_RETRY,
  TRANSACTION_TYPE_STANDARD,
  TRANSACTION_STATUS_APPROVED,
} = require('./enums')

const { hexToBn, bnToHex, BnMultiplyByFraction } = require('../../lib/util')

/**
  Transaction Controller is an aggregate of sub-controllers and trackers
  composing them in a way to be exposed to the metamask controller
    <br>- txStateManager
      responsible for the state of a transaction and
      storing the transaction
    <br>- pendingTxTracker
      watching blocks for transactions to be include
      and emitting confirmed events
    <br>- txGasUtil
      gas calculations and safety buffering
    <br>- nonceTracker
      calculating nonces


  @class
  @param {object} - opts
  @param {object}  opts.initState - initial transaction list default is an empty array
  @param {Object}  opts.networkStore - an observable store for network number
  @param {Object}  opts.blockTracker - An instance of eth-blocktracker
  @param {Object}  opts.provider - A network provider.
  @param {Function}  opts.signTransaction - function the signs an ethereumjs-tx
  @param {Function}  [opts.getGasPrice] - optional gas price calculator
  @param {Function}  opts.signTransaction - ethTx signer that returns a rawTx
  @param {Number}  [opts.txHistoryLimit] - number *optional* for limiting how many transactions are in state
  @param {Object}  opts.preferencesStore
*/

class TransactionController extends EventEmitter {
  constructor (opts) {
    super()
    this.networkStore = opts.networkStore || new ObservableStore({})
    this.preferencesStore = opts.preferencesStore || new ObservableStore({})
    this.provider = opts.provider
    this.blockTracker = opts.blockTracker
    this.signEthTx = opts.signTransaction
    this.getGasPrice = opts.getGasPrice
    this.inProcessOfSigning = new Set()

    this.memStore = new ObservableStore({})
    this.query = new EthQuery(this.provider)

    // txGasUtil
    this.txGasUtil = new TxGasUtil(this.provider)

    this._mapMethods()

    // txStateManager
    this.txStateManager = new TransactionStateManager({
      initState: opts.initState,
      txHistoryLimit: opts.txHistoryLimit,
      getNetwork: this.getNetwork.bind(this),
    })
    this._onBootCleanUp()

    this.store = this.txStateManager.store

    // nonceTracker
    this.nonceTracker = new NonceTracker({
      provider: this.provider,
      blockTracker: this.blockTracker,
      getPendingTransactions: this.txStateManager.getPendingTransactions.bind(this.txStateManager),
      getConfirmedTransactions: this.txStateManager.getConfirmedTransactions.bind(this.txStateManager),
    })

    // pendingTxTracker
    this.pendingTxTracker = new PendingTransactionTracker({
      provider: this.provider,
      nonceTracker: this.nonceTracker,
      publishTransaction: (rawTx) => this.query.sendRawTransaction(rawTx),
      getPendingTransactions: () => {
        const pending = this.txStateManager.getPendingTransactions()
        const approved = this.txStateManager.getApprovedTransactions()
        return [...pending, ...approved]
      },
      approveTransaction: this.approveTransaction.bind(this),
      getCompletedTransactions: this.txStateManager.getConfirmedTransactions.bind(this.txStateManager),
    })

    this.txStateManager.store.subscribe(() => this.emit('update:badge'))
    this._setupListeners()
    // memstore is computed from a few different stores
    this._updateMemstore()
    this.txStateManager.store.subscribe(() => this._updateMemstore())
    this.networkStore.subscribe(() => {
      this._onBootCleanUp()
      this._updateMemstore()
    })
    this.preferencesStore.subscribe(() => this._updateMemstore())

    // request state update to finalize initialization
    this._updatePendingTxsAfterFirstBlock()
  }

  /** @returns {number} the chainId*/
  getChainId () {
    const networkState = this.networkStore.getState()
    const getChainId = parseInt(networkState)
    if (Number.isNaN(getChainId)) {
      return 0
    } else {
      return getChainId
    }
  }

  /**
  Adds a tx to the txlist
  @emits ${txMeta.id}:unapproved
*/
  addTx (txMeta) {
    this.txStateManager.addTx(txMeta)
    this.emit(`${txMeta.id}:unapproved`, txMeta)
  }

  /**
  Wipes the transactions for a given account
  @param {string} address - hex string of the from address for txs being removed
  */
  wipeTransactions (address) {
    this.txStateManager.wipeTransactions(address)
  }

  /**
  add a new unapproved transaction to the pipeline

  @returns {Promise<string>} the hash of the transaction after being submitted to the network
  @param txParams {object} - txParams for the transaction
  @param opts {object} - with the key origin to put the origin on the txMeta
  */

  async newUnapprovedTransaction (txParams, opts = {}) {
    log.debug(`MetaMaskController newUnapprovedTransaction ${JSON.stringify(txParams)}`)
    const initialTxMeta = await this.addUnapprovedTransaction(txParams)
    initialTxMeta.origin = opts.origin
    this.txStateManager.updateTx(initialTxMeta, '#newUnapprovedTransaction - adding the origin')
    // listen for tx completion (success, fail)
    return new Promise((resolve, reject) => {
      this.txStateManager.once(`${initialTxMeta.id}:finished`, (finishedTxMeta) => {
        switch (finishedTxMeta.status) {
          case 'submitted':
            return resolve(finishedTxMeta.hash)
          case 'rejected':
            return reject(cleanErrorStack(rpcErrors.eth.userRejectedRequest('MetaMask Tx Signature: User denied transaction signature.')))
          case 'failed':
            return reject(cleanErrorStack(rpcErrors.internal(finishedTxMeta.err.message)))
          default:
            return reject(cleanErrorStack(rpcErrors.internal(`MetaMask Tx Signature: Unknown problem: ${JSON.stringify(finishedTxMeta.txParams)}`)))
        }
      })
    })
  }

  /**
  Validates and generates a txMeta with defaults and puts it in txStateManager
  store

  @returns {txMeta}
  */

  async addUnapprovedTransaction (txParams) {
    // validate
    const normalizedTxParams = txUtils.normalizeTxParams(txParams)
    // Assert the from address is the selected address
    if (normalizedTxParams.from !== this.getSelectedAddress()) {
      throw new Error(`Transaction from address isn't valid for this account`)
    }
    txUtils.validateTxParams(normalizedTxParams)
    // construct txMeta
    const { transactionCategory, getCodeResponse } = await this._determineTransactionCategory(txParams)
    let txMeta = this.txStateManager.generateTxMeta({
      txParams: normalizedTxParams,
      type: TRANSACTION_TYPE_STANDARD,
      transactionCategory,
    })
    this.addTx(txMeta)
    this.emit('newUnapprovedTx', txMeta)

    try {
      // check whether recipient account is blacklisted
      recipientBlacklistChecker.checkAccount(txMeta.metamaskNetworkId, normalizedTxParams.to)
      // add default tx params
      txMeta = await this.addTxGasDefaults(txMeta, getCodeResponse)
    } catch (error) {
      log.warn(error)
      txMeta.loadingDefaults = false
      this.txStateManager.updateTx(txMeta, 'Failed to calculate gas defaults.')
      throw error
    }

    txMeta.loadingDefaults = false

    // save txMeta
    this.txStateManager.updateTx(txMeta)

    return txMeta
  }
  /**
  adds the tx gas defaults: gas && gasPrice
  @param txMeta {Object} - the txMeta object
  @returns {Promise<object>} resolves with txMeta
*/
  async addTxGasDefaults (txMeta, getCodeResponse) {
    const txParams = txMeta.txParams
    // ensure value
    txParams.value = txParams.value ? ethUtil.addHexPrefix(txParams.value) : '0x0'
    txMeta.gasPriceSpecified = Boolean(txParams.gasPrice)
    let gasPrice = txParams.gasPrice
    if (!gasPrice) {
      gasPrice = this.getGasPrice ? this.getGasPrice() : await this.query.gasPrice()
    }
    txParams.gasPrice = ethUtil.addHexPrefix(gasPrice.toString(16))
    // set gasLimit
    return await this.txGasUtil.analyzeGasUsage(txMeta, getCodeResponse)
  }

  /**
    Creates a new txMeta with the same txParams as the original
    to allow the user to resign the transaction with a higher gas values
    @param  originalTxId {number} - the id of the txMeta that
    you want to attempt to retry
    @param  gasPrice {string=} - Optional gas price to be increased to use as the retry
    transaction's gas price
    @return {txMeta}
  */

  async retryTransaction (originalTxId, gasPrice) {
    const originalTxMeta = this.txStateManager.getTx(originalTxId)
    const { txParams } = originalTxMeta
    const lastGasPrice = gasPrice || originalTxMeta.txParams.gasPrice
    const suggestedGasPriceBN = new ethUtil.BN(ethUtil.stripHexPrefix(this.getGasPrice()), 16)
    const lastGasPriceBN = new ethUtil.BN(ethUtil.stripHexPrefix(lastGasPrice), 16)
    // essentially lastGasPrice * 1.1 but
    // dont trust decimals so a round about way of doing that
    const lastGasPriceBNBumped = lastGasPriceBN.mul(new ethUtil.BN(110, 10)).div(new ethUtil.BN(100, 10))
    // transactions that are being retried require a >=%10 bump or the clients will throw an error
    txParams.gasPrice = suggestedGasPriceBN.gt(lastGasPriceBNBumped) ? `0x${suggestedGasPriceBN.toString(16)}` : `0x${lastGasPriceBNBumped.toString(16)}`

    const txMeta = this.txStateManager.generateTxMeta({
      txParams: originalTxMeta.txParams,
      lastGasPrice,
      loadingDefaults: false,
      type: TRANSACTION_TYPE_RETRY,
    })
    this.addTx(txMeta)
    this.emit('newUnapprovedTx', txMeta)
    return txMeta
  }

  /**
   * 取消交易其实就是向相同的地址发送 0x value，然后使用更大的 gasPrice
   * Creates a new approved transaction to attempt to cancel a previously submitted transaction. The
   * new transaction contains the same nonce as the previous, is a basic ETH transfer of 0x value to
   * the sender's address, and has a higher gasPrice than that of the previous transaction.
   * @param {number} originalTxId - the id of the txMeta that you want to attempt to cancel
   * @param {string=} customGasPrice - the hex value to use for the cancel transaction
   * @returns {txMeta}
   */
  async createCancelTransaction (originalTxId, customGasPrice) {
    const originalTxMeta = this.txStateManager.getTx(originalTxId)
    const { txParams } = originalTxMeta
    const { gasPrice: lastGasPrice, from, nonce } = txParams

    const newGasPrice = customGasPrice || bnToHex(BnMultiplyByFraction(hexToBn(lastGasPrice), 11, 10))
    const newTxMeta = this.txStateManager.generateTxMeta({
      txParams: {
        from,
        to: from,
        nonce,
        gas: '0x5208',
        value: '0x0',
        gasPrice: newGasPrice,
      },
      lastGasPrice,
      loadingDefaults: false,
      status: TRANSACTION_STATUS_APPROVED,
      type: TRANSACTION_TYPE_CANCEL,
    })

    this.addTx(newTxMeta)
    await this.approveTransaction(newTxMeta.id)
    return newTxMeta
  }

  // gasPrice 大，交易速度就快
  async createSpeedUpTransaction (originalTxId, customGasPrice) {
    const originalTxMeta = this.txStateManager.getTx(originalTxId)
    const { txParams } = originalTxMeta
    const { gasPrice: lastGasPrice } = txParams

    const newGasPrice = customGasPrice || bnToHex(BnMultiplyByFraction(hexToBn(lastGasPrice), 11, 10))

    const newTxMeta = this.txStateManager.generateTxMeta({
      txParams: {
        ...txParams,
        gasPrice: newGasPrice,
      },
      lastGasPrice,
      loadingDefaults: false,
      status: TRANSACTION_STATUS_APPROVED,
      type: TRANSACTION_TYPE_RETRY,
    })

    this.addTx(newTxMeta)
    await this.approveTransaction(newTxMeta.id)
    return newTxMeta
  }

  /**
  updates the txMeta in the txStateManager
  @param txMeta {Object} - the updated txMeta
  */
  async updateTransaction (txMeta) {
    this.txStateManager.updateTx(txMeta, 'confTx: user updated transaction')
  }

  /**
  updates and approves the transaction
  @param txMeta {Object}
  */
  async updateAndApproveTransaction (txMeta) {
    this.txStateManager.updateTx(txMeta, 'confTx: user approved transaction')
    await this.approveTransaction(txMeta.id)
  }

  /**
  sets the tx status to approved
  auto fills the nonce
  signs the transaction
  publishes the transaction
  if any of these steps fails the tx status will be set to failed
    @param txId {number} - the tx's Id
  */
  async approveTransaction (txId) {
    // TODO: Move this safety out of this function.
    // Since this transaction is async,
    // we need to keep track of what is currently being signed,
    // So that we do not increment nonce + resubmit something
    // that is already being incrmented & signed.
    if (this.inProcessOfSigning.has(txId)) {
      return
    }
    this.inProcessOfSigning.add(txId)
    let nonceLock
    try {
      // approve
      this.txStateManager.setTxStatusApproved(txId)
      // get next nonce
      const txMeta = this.txStateManager.getTx(txId)
      const fromAddress = txMeta.txParams.from
      // wait for a nonce
      let { customNonceValue = null } = txMeta
      customNonceValue = Number(customNonceValue)
      nonceLock = await this.nonceTracker.getNonceLock(fromAddress)
      // add nonce to txParams
      // if txMeta has lastGasPrice then it is a retry at same nonce with higher
      // gas price transaction and their for the nonce should not be calculated
      const nonce = txMeta.lastGasPrice ? txMeta.txParams.nonce : nonceLock.nextNonce
      const customOrNonce = customNonceValue || nonce

      txMeta.txParams.nonce = ethUtil.addHexPrefix(customOrNonce.toString(16))
      // add nonce debugging information to txMeta
      txMeta.nonceDetails = nonceLock.nonceDetails
      if (customNonceValue) {
        txMeta.nonceDetails.customNonceValue = customNonceValue
      }
      this.txStateManager.updateTx(txMeta, 'transactions#approveTransaction')
      // sign transaction
      const rawTx = await this.signTransaction(txId)
      await this.publishTransaction(txId, rawTx)
      // must set transaction to submitted/failed before releasing lock
      nonceLock.releaseLock()
    } catch (err) {
      // this is try-catch wrapped so that we can guarantee that the nonceLock is released
      try {
        this.txStateManager.setTxStatusFailed(txId, err)
      } catch (err) {
        log.error(err)
      }
      // must set transaction to submitted/failed before releasing lock
      if (nonceLock) nonceLock.releaseLock()
      // continue with error chain
      throw err
    } finally {
      this.inProcessOfSigning.delete(txId)
    }
  }
  /**
    adds the chain id and signs the transaction and set the status to signed
    @param txId {number} - the tx's Id
    @returns - rawTx {string}
  */
  async signTransaction (txId) {
    const txMeta = this.txStateManager.getTx(txId)
    // add network/chain id
    const chainId = this.getChainId()
    const txParams = Object.assign({}, txMeta.txParams, { chainId })
    // sign tx
    const fromAddress = txParams.from
    const ethTx = new Transaction(txParams)
    await this.signEthTx(ethTx, fromAddress)
    // set state to signed
    this.txStateManager.setTxStatusSigned(txMeta.id)
    const rawTx = ethUtil.bufferToHex(ethTx.serialize())
    return rawTx
  }

  /**
    publishes the raw tx and sets the txMeta to submitted
    @param txId {number} - the tx's Id
    @param rawTx {string} - the hex string of the serialized signed transaction
    @returns {Promise<void>}
  */
  async publishTransaction (txId, rawTx) {
    const txMeta = this.txStateManager.getTx(txId)
    txMeta.rawTx = rawTx
    this.txStateManager.updateTx(txMeta, 'transactions#publishTransaction')
    const txHash = await this.query.sendRawTransaction(rawTx)
    this.setTxHash(txId, txHash)
    this.txStateManager.setTxStatusSubmitted(txId)
  }

  /**
   * Sets the status of the transaction to confirmed and sets the status of nonce duplicates as
   * dropped if the txParams have data it will fetch the txReceipt
   * @param {number} txId - The tx's ID
   * @returns {Promise<void>}
   */
  async confirmTransaction (txId) {
    // get the txReceipt before marking the transaction confirmed
    // to ensure the receipt is gotten before the ui revives the tx
    const txMeta = this.txStateManager.getTx(txId)

    if (!txMeta) {
      return
    }

    try {
      const txReceipt = await this.query.getTransactionReceipt(txMeta.hash)

      // It seems that sometimes the numerical values being returned from
      // this.query.getTransactionReceipt are BN instances and not strings.
      const gasUsed = typeof txReceipt.gasUsed !== 'string'
        ? txReceipt.gasUsed.toString(16)
        : txReceipt.gasUsed

      txMeta.txReceipt = {
        ...txReceipt,
        gasUsed,
      }

      this.txStateManager.updateTx(txMeta, 'transactions#confirmTransaction - add txReceipt')
    } catch (err) {
      log.error(err)
    }

    this.txStateManager.setTxStatusConfirmed(txId)
    this._markNonceDuplicatesDropped(txId)
  }

  /**
    Convenience method for the ui thats sets the transaction to rejected
    @param txId {number} - the tx's Id
    @returns {Promise<void>}
  */
  async cancelTransaction (txId) {
    this.txStateManager.setTxStatusRejected(txId)
  }

  /**
    Sets the txHas on the txMeta
    @param txId {number} - the tx's Id
    @param txHash {string} - the hash for the txMeta
  */
  setTxHash (txId, txHash) {
    // Add the tx hash to the persisted meta-tx object
    const txMeta = this.txStateManager.getTx(txId)
    txMeta.hash = txHash
    this.txStateManager.updateTx(txMeta, 'transactions#setTxHash')
  }

  //
  //           PRIVATE METHODS
  //
  /** maps methods for convenience*/
  _mapMethods () {
    /** @returns the state in transaction controller */
    this.getState = () => this.memStore.getState()
    /** @returns the network number stored in networkStore */
    this.getNetwork = () => this.networkStore.getState()
    /** @returns the user selected address */
    this.getSelectedAddress = () => this.preferencesStore.getState().selectedAddress
    /** Returns an array of transactions whos status is unapproved */
    this.getUnapprovedTxCount = () => Object.keys(this.txStateManager.getUnapprovedTxList()).length
    /**
      @returns a number that represents how many transactions have the status submitted
      @param account {String} - hex prefixed account
    */
    this.getPendingTxCount = (account) => this.txStateManager.getPendingTransactions(account).length
    /** see txStateManager */
    this.getFilteredTxList = (opts) => this.txStateManager.getFilteredTxList(opts)
  }

  // called once on startup
  async _updatePendingTxsAfterFirstBlock () {
    // wait for first block so we know we're ready
    await this.blockTracker.getLatestBlock()
    // get status update for all pending transactions (for the current network)
    await this.pendingTxTracker.updatePendingTxs()
  }

  /**
    If transaction controller was rebooted with transactions that are uncompleted
    in steps of the transaction signing or user confirmation process it will either
    transition txMetas to a failed state or try to redo those tasks.
  */

  _onBootCleanUp () {
    this.txStateManager.getFilteredTxList({
      status: 'unapproved',
      loadingDefaults: true,
    }).forEach((tx) => {
      this.addTxGasDefaults(tx)
        .then((txMeta) => {
          txMeta.loadingDefaults = false
          this.txStateManager.updateTx(txMeta, 'transactions: gas estimation for tx on boot')
        }).catch((error) => {
          tx.loadingDefaults = false
          this.txStateManager.updateTx(tx, 'failed to estimate gas during boot cleanup.')
          this.txStateManager.setTxStatusFailed(tx.id, error)
        })
    })

    this.txStateManager.getFilteredTxList({
      status: TRANSACTION_STATUS_APPROVED,
    }).forEach((txMeta) => {
      const txSignError = new Error('Transaction found as "approved" during boot - possibly stuck during signing')
      this.txStateManager.setTxStatusFailed(txMeta.id, txSignError)
    })
  }

  /**
    is called in constructor applies the listeners for pendingTxTracker txStateManager
    and blockTracker
  */
  _setupListeners () {
    this.txStateManager.on('tx:status-update', this.emit.bind(this, 'tx:status-update'))
    this._setupBlockTrackerListener()
    this.pendingTxTracker.on('tx:warning', (txMeta) => {
      this.txStateManager.updateTx(txMeta, 'transactions/pending-tx-tracker#event: tx:warning')
    })
    this.pendingTxTracker.on('tx:failed', this.txStateManager.setTxStatusFailed.bind(this.txStateManager))
    this.pendingTxTracker.on('tx:confirmed', (txId) => this.confirmTransaction(txId))
    this.pendingTxTracker.on('tx:dropped', this.txStateManager.setTxStatusDropped.bind(this.txStateManager))
    this.pendingTxTracker.on('tx:block-update', (txMeta, latestBlockNumber) => {
      if (!txMeta.firstRetryBlockNumber) {
        txMeta.firstRetryBlockNumber = latestBlockNumber
        this.txStateManager.updateTx(txMeta, 'transactions/pending-tx-tracker#event: tx:block-update')
      }
    })
    this.pendingTxTracker.on('tx:retry', (txMeta) => {
      if (!('retryCount' in txMeta)) txMeta.retryCount = 0
      txMeta.retryCount++
      this.txStateManager.updateTx(txMeta, 'transactions/pending-tx-tracker#event: tx:retry')
    })
  }

  /**
    Returns a "type" for a transaction out of the following list: simpleSend, tokenTransfer, tokenApprove,
    contractDeployment, contractMethodCall
  */
  async _determineTransactionCategory (txParams) {
    const { data, to } = txParams
    const { name } = data && abiDecoder.decodeMethod(data) || {}
    const tokenMethodName = [
      TOKEN_METHOD_APPROVE,
      TOKEN_METHOD_TRANSFER,
      TOKEN_METHOD_TRANSFER_FROM,
    ].find(tokenMethodName => tokenMethodName === name && name.toLowerCase())

    let result
    if (txParams.data && tokenMethodName) {
      result = tokenMethodName
    } else if (txParams.data && !to) {
      result = DEPLOY_CONTRACT_ACTION_KEY
    }

    let code
    if (!result) {
      try {
        code = await this.query.getCode(to)
      } catch (e) {
        code = null
        log.warn(e)
      }

      const codeIsEmpty = !code || code === '0x' || code === '0x0'

      result = codeIsEmpty ? SEND_ETHER_ACTION_KEY : CONTRACT_INTERACTION_KEY
    }

    return { transactionCategory: result, getCodeResponse: code }
  }

  /**
    Sets other txMeta statuses to dropped if the txMeta that has been confirmed has other transactions
    in the list have the same nonce

    @param txId {Number} - the txId of the transaction that has been confirmed in a block
  */
  _markNonceDuplicatesDropped (txId) {
    // get the confirmed transactions nonce and from address
    const txMeta = this.txStateManager.getTx(txId)
    const { nonce, from } = txMeta.txParams
    const sameNonceTxs = this.txStateManager.getFilteredTxList({nonce, from})
    if (!sameNonceTxs.length) return
    // mark all same nonce transactions as dropped and give i a replacedBy hash
    sameNonceTxs.forEach((otherTxMeta) => {
      if (otherTxMeta.id === txId) return
      otherTxMeta.replacedBy = txMeta.hash
      this.txStateManager.updateTx(txMeta, 'transactions/pending-tx-tracker#event: tx:confirmed reference to confirmed txHash with same nonce')
      this.txStateManager.setTxStatusDropped(otherTxMeta.id)
    })
  }

  _setupBlockTrackerListener () {
    let listenersAreActive = false
    const latestBlockHandler = this._onLatestBlock.bind(this)
    const blockTracker = this.blockTracker
    const txStateManager = this.txStateManager

    txStateManager.on('tx:status-update', updateSubscription)
    updateSubscription()

    function updateSubscription () {
      const pendingTxs = txStateManager.getPendingTransactions()
      if (!listenersAreActive && pendingTxs.length > 0) {
        blockTracker.on('latest', latestBlockHandler)
        listenersAreActive = true
      } else if (listenersAreActive && !pendingTxs.length) {
        blockTracker.removeListener('latest', latestBlockHandler)
        listenersAreActive = false
      }
    }
  }

  async _onLatestBlock (blockNumber) {
    try {
      await this.pendingTxTracker.updatePendingTxs()
    } catch (err) {
      log.error(err)
    }
    try {
      await this.pendingTxTracker.resubmitPendingTxs(blockNumber)
    } catch (err) {
      log.error(err)
    }
  }

  /**
    Updates the memStore in transaction controller
  */
  _updateMemstore () {
    this.pendingTxTracker.updatePendingTxs()
    const unapprovedTxs = this.txStateManager.getUnapprovedTxList()
    const selectedAddressTxList = this.txStateManager.getFilteredTxList({
      from: this.getSelectedAddress(),
      metamaskNetworkId: this.getNetwork(),
    })
    this.memStore.updateState({ unapprovedTxs, selectedAddressTxList })
  }
}

module.exports = TransactionController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="transactions-index"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/balance.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
存储和更新账户余额
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const PendingBalanceCalculator = require('../lib/pending-balance-calculator')
const BN = require('ethereumjs-util').BN

class BalanceController {

  /**
   * 存储和更新账户余额
   * Controller responsible for storing and updating an account's balance.
   *
   * @typedef {Object} BalanceController
   * @param {Object} opts Initialize various properties of the class.
   * @property {string} address A base 16 hex string. The account address which has the balance managed by this
   * BalanceController.
   * @property {AccountTracker} accountTracker Stores and updates the users accounts
   * for which this BalanceController manages balance.
   * @property {TransactionController} txController Stores, tracks and manages transactions. Here used to create a listener for
   * transaction updates.
   * @property {BlockTracker} blockTracker Tracks updates to blocks. On new blocks, this BalanceController updates its balance
   * @property {Object} store The store for the ethBalance
   * @property {string} store.ethBalance A base 16 hex string. The balance for the current account.
   * @property {PendingBalanceCalculator} balanceCalc Used to calculate the accounts balance with possible pending
   * transaction costs taken into account.
   *
   */
  constructor (opts = {}) {
    this._validateParams(opts)
    const { address, accountTracker, txController, blockTracker } = opts

    this.address = address
    this.accountTracker = accountTracker
    this.txController = txController
    this.blockTracker = blockTracker

    const initState = {
      ethBalance: undefined,
    }
    this.store = new ObservableStore(initState)

    this.balanceCalc = new PendingBalanceCalculator({
      getBalance: () => this._getBalance(),
      getPendingTransactions: this._getPendingTransactions.bind(this),
    })

    this._registerUpdates()
  }

  /**
   * Updates the ethBalance property to the current pending balance
   *
   * @returns {Promise<void>} Promises undefined
   */
  async updateBalance () {
    const balance = await this.balanceCalc.getBalance()
    this.store.updateState({
      ethBalance: balance,
    })
  }

  /**
   * 设置一些触发 ethBalance 更新的 listener
   * Sets up listeners and subscriptions which should trigger an update of ethBalance. These updates include:
   * - when a transaction changes state to 'submitted', 'confirmed' or 'failed'
   * - when the current account changes (i.e. a new account is selected)
   * - when there is a block update
   *
   * @private
   *
   */
  _registerUpdates () {
    const update = this.updateBalance.bind(this)

    this.txController.on('tx:status-update', (_, status) => {
      switch (status) {
        case 'submitted':
        case 'confirmed':
        case 'failed':
          update()
          return
        default:
          return
      }
    })
    this.accountTracker.store.subscribe(update)
    this.blockTracker.on('latest', update)
  }

  /**
   * 获取余额，没有余额返回 undefined
   * Gets the balance, as a base 16 hex string, of the account at this BalanceController's current address.
   * If the current account has no balance, returns undefined.
   *
   * @returns {Promise<BN|void>} Promises a BN with a value equal to the balance of the current account, or undefined
   * if the current account has no balance
   *
   */
  async _getBalance () {
    const { accounts } = this.accountTracker.store.getState()
    const entry = accounts[this.address]
    const balance = entry.balance
    return balance ? new BN(balance.substring(2), 16) : undefined
  }

  /**
   * 获取处理中的tx TransactionController.getFilteredTxList
   * Gets the pending transactions (i.e. those with a 'submitted' status). These are accessed from the
   * TransactionController passed to this BalanceController during construction.
   *
   * @private
   * @returns {Promise<array>} Promises an array of transaction objects.
   *
   */
  async _getPendingTransactions () {
    const pending = this.txController.getFilteredTxList({
      from: this.address,
      status: 'submitted',
      err: undefined,
    })
    return pending
  }

  /**
   * 必要属性验证
   * Validates that the passed options have all required properties.
   *
   * @param {Object} opts The options object to validate
   * @throws {string} Throw a custom error indicating that address, accountTracker, txController and blockTracker are
   * missing and at least one is required
   *
   */
  _validateParams (opts) {
    const { address, accountTracker, txController, blockTracker } = opts
    if (!address || !accountTracker || !txController || !blockTracker) {
      const error = 'Cannot construct a balance checker without address, accountTracker, txController, and blockTracker.'
      throw new Error(error)
    }
  }

}

module.exports = BalanceController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="transactions-index"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/cached-balances.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
维护本地存储中帐户余额的缓存
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const extend = require('xtend')

/**
 * @typedef {Object} CachedBalancesOptions
 * @property {Object} accountTracker An {@code AccountTracker} reference
 * @property {Function} getNetwork A function to get the current network
 * @property {Object} initState The initial controller state
 */

/**
 * 后台 controller 负责维护本地存储中帐户余额的缓存
 * Background controller responsible for maintaining
 * a cache of account balances in local storage
 */
class CachedBalancesController {
  /**
   * Creates a new controller instance
   *
   * @param {CachedBalancesOptions} [opts] Controller configuration parameters
   */
  constructor (opts = {}) {
    const { accountTracker, getNetwork } = opts

    this.accountTracker = accountTracker
    this.getNetwork = getNetwork

    const initState = extend({
      cachedBalances: {},
    }, opts.initState)
    this.store = new ObservableStore(initState)

    this._registerUpdates()
  }

  /**
   * Updates the cachedBalances property for the current network. Cached balances will be updated to those in the passed accounts
   * if balances in the passed accounts are truthy.
   *
   * @param {Object} obj The the recently updated accounts object for the current network
   * @returns {Promise<void>}
   */
  async updateCachedBalances ({ accounts }) {
    const network = await this.getNetwork()
    const balancesToCache = await this._generateBalancesToCache(accounts, network)
    this.store.updateState({
      cachedBalances: balancesToCache,
    })
  }

  _generateBalancesToCache (newAccounts, currentNetwork) {
    const { cachedBalances } = this.store.getState()
    const currentNetworkBalancesToCache = { ...cachedBalances[currentNetwork] }

    Object.keys(newAccounts).forEach(accountID => {
      const account = newAccounts[accountID]

      if (account.balance) {
        currentNetworkBalancesToCache[accountID] = account.balance
      }
    })
    const balancesToCache = {
      ...cachedBalances,
      [currentNetwork]: currentNetworkBalancesToCache,
    }

    return balancesToCache
  }

  /**
   * Account Tracker store 变化时更新余额缓存
   * Sets up listeners and subscriptions which should trigger an update of cached balances. These updates will
   * happen when the current account changes. Which happens on block updates, as well as on network and account
   * selections.
   *
   * @private
   *
   */
  _registerUpdates () {
    const update = this.updateCachedBalances.bind(this)
    this.accountTracker.store.subscribe(update)
  }
}

module.exports = CachedBalancesController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="transactions-index"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/detect-tokens.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
注意 0xb1f8e55c7f64d203c1400b9d8555d050f94adf39 这个地址是个智能合约，用于查询余额
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const Web3 = require('web3')
const contracts = require('eth-contract-metadata')
const { warn } = require('loglevel')
const { MAINNET } = require('./network/enums')
// By default, poll every 3 minutes
const DEFAULT_INTERVAL = 180 * 1000
const ERC20_ABI = [{'constant': true, 'inputs': [{'name': '_owner', 'type': 'address'}], 'name': 'balanceOf', 'outputs': [{'name': 'balance', 'type': 'uint256'}], 'payable': false, 'type': 'function'}]

// https://etherscan.io/address/0xb1f8e55c7f64d203c1400b9d8555d050f94adf39#code
const SINGLE_CALL_BALANCES_ABI = require('single-call-balance-checker-abi')
const SINGLE_CALL_BALANCES_ADDRESS = '0xb1f8e55c7f64d203c1400b9d8555d050f94adf39'
/**
 * 根据用户当前的 token 列表轮询 token 汇率
 * A controller that polls for token exchange rates based on a user's current token list
 */
class DetectTokensController {
  /**
   * Creates a DetectTokensController
   *
   * @param {Object} [config] - Options to configure controller
   */
  constructor ({ interval = DEFAULT_INTERVAL, preferences, network, keyringMemStore } = {}) {
    this.preferences = preferences
    this.interval = interval
    this.network = network
    this.keyringMemStore = keyringMemStore
  }

  /**
   * eth-contract-metadata 里面有所有的 token contract 信息，比如：
       "0x86Fa049857E0209aa7D9e616F7eb3b3B78ECfdb0": {
        "name": "EOS",
        "logo": "eos-logo.jpeg",
        "erc20": true,
        "symbol": "EOS",
        "decimals": 18
      }
     遍历查余额
   * For each token in eth-contract-metadata, find check selectedAddress balance.
   *
   */
  async detectNewTokens () {
    if (!this.isActive) { return }
    if (this._network.store.getState().provider.type !== MAINNET) { return }
    const tokensToDetect = []
    this.web3.setProvider(this._network._provider)
    for (const contractAddress in contracts) {
      if (contracts[contractAddress].erc20 && !(this.tokenAddresses.includes(contractAddress.toLowerCase()))) {
        tokensToDetect.push(contractAddress)
      }
    }

    const ethContract = this.web3.eth.contract(SINGLE_CALL_BALANCES_ABI).at(SINGLE_CALL_BALANCES_ADDRESS)
    ethContract.balances([this.selectedAddress], tokensToDetect, (error, result) => {
      if (error) {
        warn(`MetaMask - DetectTokensController single call balance fetch failed`, error)
        return
      }
      tokensToDetect.forEach((tokenAddress, index) => {
        const balance = result[index]
        if (balance && !balance.isZero()) {
          this._preferences.addToken(tokenAddress, contracts[tokenAddress].symbol, contracts[tokenAddress].decimals)
        }
      })
    })
  }

  /**
   * Find if selectedAddress has tokens with contract in contractAddress.
   *
   * @param {string} contractAddress Hex address of the token contract to explore.
   * @returns {boolean} If balance is detected, token is added.
   *
   */
  async detectTokenBalance (contractAddress) {
    const ethContract = this.web3.eth.contract(ERC20_ABI).at(contractAddress)
    ethContract.balanceOf(this.selectedAddress, (error, result) => {
      if (!error) {
        if (!result.isZero()) {
          this._preferences.addToken(contractAddress, contracts[contractAddress].symbol, contracts[contractAddress].decimals)
        }
      } else {
        warn(`MetaMask - DetectTokensController balance fetch failed for ${contractAddress}.`, error)
      }
    })
  }

  /**
   * 重新检测
   * Restart token detection polling period and call detectNewTokens
   * in case of address change or user session initialization.
   *
   */
  restartTokenDetection () {
    if (!(this.isActive && this.selectedAddress)) { return }
    this.detectNewTokens()
    this.interval = DEFAULT_INTERVAL
  }

  /**
   * @type {Number}
   */
  set interval (interval) {
    this._handle && clearInterval(this._handle)
    if (!interval) { return }
    this._handle = setInterval(() => { this.detectNewTokens() }, interval)
  }

  /**
   * 地址变了，重新轮询查余额
   * In setter when selectedAddress is changed, detectNewTokens and restart polling
   * @type {Object}
   */
  set preferences (preferences) {
    if (!preferences) { return }
    this._preferences = preferences
    preferences.store.subscribe(({ tokens = [] }) => { this.tokenAddresses = tokens.map((obj) => { return obj.address }) })
    preferences.store.subscribe(({ selectedAddress }) => {
      if (this.selectedAddress !== selectedAddress) {
        this.selectedAddress = selectedAddress
        this.restartTokenDetection()
      }
    })
  }

  /**
   * @type {Object}
   */
  set network (network) {
    if (!network) { return }
    this._network = network
    this.web3 = new Web3(network._provider)
  }

  /**
   * isUnlocked 变成 true 时重新轮询
   * In setter when isUnlocked is updated to true, detectNewTokens and restart polling
   * @type {Object}
   */
  set keyringMemStore (keyringMemStore) {
    if (!keyringMemStore) { return }
    this._keyringMemStore = keyringMemStore
    this._keyringMemStore.subscribe(({ isUnlocked }) => {
      if (this.isUnlocked !== isUnlocked) {
        this.isUnlocked = isUnlocked
        if (isUnlocked) { this.restartTokenDetection() }
      }
    })
  }

  /**
   * Internal isActive state
   * @type {Object}
   */
  get isActive () {
    return this.isOpen && this.isUnlocked
  }
}

module.exports = DetectTokensController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="incoming-transactions"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/incoming-transactions.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
处理收入交易
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const log = require('loglevel')
const BN = require('bn.js')
const createId = require('../lib/random-id')
const { bnToHex } = require('../lib/util')
import fetchWithTimeout from '../lib/fetch-with-timeout'
const {
  MAINNET_CODE,
  ROPSTEN_CODE,
  RINKEBY_CODE,
  KOVAN_CODE,
  GOERLI_CODE,
  ROPSTEN,
  RINKEBY,
  KOVAN,
  GOERLI,
  MAINNET,
} = require('./network/enums')
const networkTypeToIdMap = {
  [ROPSTEN]: String(ROPSTEN_CODE),
  [RINKEBY]: String(RINKEBY_CODE),
  [KOVAN]: String(KOVAN_CODE),
  [GOERLI]: String(GOERLI_CODE),
  [MAINNET]: String(MAINNET_CODE),
}
const fetch = fetchWithTimeout({
  timeout: 30000,
})


// 处理收入交易
// preferencesController: 用户首选项, 参考 preferences.js
class IncomingTransactionsController {

  constructor (opts = {}) {
    const {
      blockTracker,
      networkController,
      preferencesController,
    } = opts
    this.blockTracker = blockTracker
    this.networkController = networkController
    this.preferencesController = preferencesController
    this.getCurrentNetwork = () => networkController.getProviderConfig().type

    this._onLatestBlock = async (newBlockNumberHex) => {
      const selectedAddress = this.preferencesController.getSelectedAddress()
      const newBlockNumberDec = parseInt(newBlockNumberHex, 16)
      await this._update({
        address: selectedAddress,
        newBlockNumberDec,
      })
    }

    const initState = Object.assign({
      incomingTransactions: {},
      incomingTxLastFetchedBlocksByNetwork: {
        [ROPSTEN]: null,
        [RINKEBY]: null,
        [KOVAN]: null,
        [GOERLI]: null,
        [MAINNET]: null,
      },
    }, opts.initState)
    this.store = new ObservableStore(initState)

    this.preferencesController.store.subscribe(pairwise((prevState, currState) => {
      const { featureFlags: { showIncomingTransactions: prevShowIncomingTransactions } = {} } = prevState
      const { featureFlags: { showIncomingTransactions: currShowIncomingTransactions } = {} } = currState

      if (currShowIncomingTransactions === prevShowIncomingTransactions) {
        return
      }

      if (prevShowIncomingTransactions && !currShowIncomingTransactions) {
        this.stop()
        return
      }

      this.start()
    }))

    this.preferencesController.store.subscribe(pairwise(async (prevState, currState) => {
      const { selectedAddress: prevSelectedAddress } = prevState
      const { selectedAddress: currSelectedAddress } = currState

      if (currSelectedAddress === prevSelectedAddress) {
        return
      }

      await this._update({
        address: currSelectedAddress,
      })
    }))

    // 网络切换
    this.networkController.on('networkDidChange', async (newType) => {
      const address = this.preferencesController.getSelectedAddress()
      await this._update({
        address,
        networkType: newType,
      })
    })
  }

  start () {
    const { featureFlags = {} } = this.preferencesController.store.getState()
    const { showIncomingTransactions } = featureFlags

    if (!showIncomingTransactions) {
      return
    }

    this.blockTracker.removeListener('latest', this._onLatestBlock)
    this.blockTracker.addListener('latest', this._onLatestBlock)
  }

  stop () {
    this.blockTracker.removeListener('latest', this._onLatestBlock)
  }

  async _update ({ address, newBlockNumberDec, networkType } = {}) {
    try {
      const dataForUpdate = await this._getDataForUpdate({ address, newBlockNumberDec, networkType })
      await this._updateStateWithNewTxData(dataForUpdate)
    } catch (err) {
      log.error(err)
    }
  }

  async _getDataForUpdate ({ address, newBlockNumberDec, networkType } = {}) {
    const {
      incomingTransactions: currentIncomingTxs,
      incomingTxLastFetchedBlocksByNetwork: currentBlocksByNetwork,
    } = this.store.getState()

    const network = networkType || this.getCurrentNetwork()
    const lastFetchBlockByCurrentNetwork = currentBlocksByNetwork[network]
    let blockToFetchFrom = lastFetchBlockByCurrentNetwork || newBlockNumberDec
    if (blockToFetchFrom === undefined) {
      blockToFetchFrom = parseInt(this.blockTracker.getCurrentBlock(), 16)
    }

    const { latestIncomingTxBlockNumber, txs: newTxs } = await this._fetchAll(address, blockToFetchFrom, network)

    return {
      latestIncomingTxBlockNumber,
      newTxs,
      currentIncomingTxs,
      currentBlocksByNetwork,
      fetchedBlockNumber: blockToFetchFrom,
      network,
    }
  }

  async _updateStateWithNewTxData ({
    latestIncomingTxBlockNumber,
    newTxs,
    currentIncomingTxs,
    currentBlocksByNetwork,
    fetchedBlockNumber,
    network,
  }) {
    const newLatestBlockHashByNetwork = latestIncomingTxBlockNumber
      ? parseInt(latestIncomingTxBlockNumber, 10) + 1
      : fetchedBlockNumber + 1
    const newIncomingTransactions = {
      ...currentIncomingTxs,
    }
    newTxs.forEach(tx => { newIncomingTransactions[tx.hash] = tx })

    this.store.updateState({
      incomingTxLastFetchedBlocksByNetwork: {
        ...currentBlocksByNetwork,
        [network]: newLatestBlockHashByNetwork,
      },
      incomingTransactions: newIncomingTransactions,
    })
  }

  async _fetchAll (address, fromBlock, networkType) {
    const fetchedTxResponse = await this._fetchTxs(address, fromBlock, networkType)
    return this._processTxFetchResponse(fetchedTxResponse)
  }

  // 通过 etherscan.io 获取最新 tx
  async _fetchTxs (address, fromBlock, networkType) {
    let etherscanSubdomain = 'api'
    const currentNetworkID = networkTypeToIdMap[networkType]
    const supportedNetworkTypes = [ROPSTEN, RINKEBY, KOVAN, GOERLI, MAINNET]

    if (supportedNetworkTypes.indexOf(networkType) === -1) {
      return {}
    }

    if (networkType !== MAINNET) {
      etherscanSubdomain = `api-${networkType}`
    }
    const apiUrl = `https://${etherscanSubdomain}.etherscan.io`
    let url = `${apiUrl}/api?module=account&action=txlist&address=${address}&tag=latest&page=1`

    if (fromBlock) {
      url += `&startBlock=${parseInt(fromBlock, 10)}`
    }
    const response = await fetch(url)
    const parsedResponse = await response.json()

    return {
      ...parsedResponse,
      address,
      currentNetworkID,
    }
  }

  // 处理 fetch tx 返回结果
  _processTxFetchResponse ({ status, result = [], address, currentNetworkID }) {
    if (status !== '0' && result.length > 0) {
      const remoteTxList = {}
      const remoteTxs = []
      result.forEach((tx) => {
        if (!remoteTxList[tx.hash]) {
          remoteTxs.push(this._normalizeTxFromEtherscan(tx, currentNetworkID))
          remoteTxList[tx.hash] = 1
        }
      })

      // 只关心收入交易 to === address，并按时间排序
      const incomingTxs = remoteTxs.filter(tx => tx.txParams.to && tx.txParams.to.toLowerCase() === address.toLowerCase())
      incomingTxs.sort((a, b) => (a.time < b.time ? -1 : 1))

      let latestIncomingTxBlockNumber = null
      incomingTxs.forEach((tx) => {
        if (
          tx.blockNumber &&
          (!latestIncomingTxBlockNumber ||
            parseInt(latestIncomingTxBlockNumber, 10) < parseInt(tx.blockNumber, 10))
        ) {
          latestIncomingTxBlockNumber = tx.blockNumber
        }
      })
      return {
        latestIncomingTxBlockNumber,
        txs: incomingTxs,
      }
    }
    return {
      latestIncomingTxBlockNumber: null,
      txs: [],
    }
  }

  // 格式化 tx
  _normalizeTxFromEtherscan (txMeta, currentNetworkID) {
    const time = parseInt(txMeta.timeStamp, 10) * 1000
    const status = txMeta.isError === '0' ? 'confirmed' : 'failed'
    return {
      blockNumber: txMeta.blockNumber,
      id: createId(),
      metamaskNetworkId: currentNetworkID,
      status,
      time,
      txParams: {
        from: txMeta.from,
        gas: bnToHex(new BN(txMeta.gas)),
        gasPrice: bnToHex(new BN(txMeta.gasPrice)),
        nonce: bnToHex(new BN(txMeta.nonce)),
        to: txMeta.to,
        value: bnToHex(new BN(txMeta.value)),
      },
      hash: txMeta.hash,
      transactionCategory: 'incoming',
    }
  }
}

module.exports = IncomingTransactionsController


// pairwise 每次会缓存上一次的值
// 每次只需要传入 currState，就可以实现 fn(prevState, currState)
function pairwise (fn) {
  let first = true
  let cache
  return (value) => {
    try {
      if (first) {
        first = false
        return fn(value, value)
      } else {
        return fn(cache, value)
      }
    } finally {
      cache = value
    }
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="preferences"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/preferences.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
用户首选项设置
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const normalizeAddress = require('eth-sig-util').normalize
const { isValidAddress, sha3, bufferToHex } = require('ethereumjs-util')
const extend = require('xtend')


class PreferencesController {

  /**
   * 用户首选项设置
   * 里面是一大堆属性和这些属性的 getter，setter
   * @typedef {Object} PreferencesController
   * @param {object} opts Overrides the defaults for the initial state of this.store
   * @property {object} store The stored object containing a users preferences, stored in local storage
   * @property {array} store.frequentRpcList A list of custom rpcs to provide the user
   * @property {string} store.currentAccountTab Indicates the selected tab in the ui
   * @property {array} store.tokens The tokens the user wants display in their token lists
   * @property {object} store.accountTokens The tokens stored per account and then per network type
   * @property {object} store.assetImages Contains assets objects related to assets added
   * @property {boolean} store.useBlockie The users preference for blockie identicons within the UI
   * @property {boolean} store.useNonceField The users preference for nonce field within the UI
   * @property {object} store.featureFlags A key-boolean map, where keys refer to features and booleans to whether the
   * user wishes to see that feature.
   * 可以通过全局方法 setPreference(feature, enabled) 设置，所以不要在 featureFlags 设置安全敏感的属性
   * Feature flags can be set by the global function `setPreference(feature, enabled)`, and so should not expose any sensitive behavior.
   * @property {object} store.knownMethodData Contains all data methods known by the user
   * @property {string} store.currentLocale The preferred language locale key
   * @property {string} store.selectedAddress A hex string that matches the currently selected address in the app
   *
   */
  constructor (opts = {}) {
    // 初始首选项
    const initState = extend({
      frequentRpcListDetail: [], // 用户自定义 rpc 列表
      currentAccountTab: 'history',
      accountTokens: {},
      assetImages: {},
      tokens: [],
      suggestedTokens: {},
      useBlockie: false,
      useNonceField: false,

      // WARNING: Do not use feature flags for security-sensitive things.
      // Feature flag toggling is available in the global namespace
      // for convenient testing of pre-release features, and should never
      // perform sensitive operations.
      // 不要在这里设置安全敏感的属性
      featureFlags: {
        showIncomingTransactions: true,
      },
      knownMethodData: {},
      participateInMetaMetrics: null,
      firstTimeFlowType: null,
      currentLocale: opts.initLangCode,
      identities: {},
      lostIdentities: {},
      forgottenPassword: false,
      preferences: {
        useNativeCurrencyAsPrimaryCurrency: true,
      },
      completedOnboarding: false,
      migratedPrivacyMode: false,
      metaMetricsId: null,
      metaMetricsSendCount: 0,
    }, opts.initState)

    this.diagnostics = opts.diagnostics
    this.network = opts.network
    this.store = new ObservableStore(initState)
    this.openPopup = opts.openPopup
    this._subscribeProviderType()

    global.setPreference = (key, value) => {
      return this.setFeatureFlag(key, value)
    }
  }
  // PUBLIC METHODS

  /**
   * Sets the {@code forgottenPassword} state property
   * @param {boolean} forgottenPassword whether or not the user has forgotten their password
   */
  setPasswordForgotten (forgottenPassword) {
    this.store.updateState({ forgottenPassword })
  }

  /**
   * Setter for the `useBlockie` property
   *
   * @param {boolean} val Whether or not the user prefers blockie indicators
   *
   */
  setUseBlockie (val) {
    this.store.updateState({ useBlockie: val })
  }

  /**
   * Setter for the `useNonceField` property
   *
   * @param {boolean} val Whether or not the user prefers to set nonce
   *
   */
  setUseNonceField (val) {
    this.store.updateState({ useNonceField: val })
  }

  /**
   * Setter for the `participateInMetaMetrics` property
   *
   * @param {boolean} bool Whether or not the user wants to participate in MetaMetrics
   * @returns {string|null} the string of the new metametrics id, or null if not set
   *
   */
  setParticipateInMetaMetrics (bool) {
    this.store.updateState({ participateInMetaMetrics: bool })
    let metaMetricsId = null
    if (bool && !this.store.getState().metaMetricsId) {
      metaMetricsId = bufferToHex(sha3(String(Date.now()) + String(Math.round(Math.random() * Number.MAX_SAFE_INTEGER))))
      this.store.updateState({ metaMetricsId })
    } else if (bool === false) {
      this.store.updateState({ metaMetricsId })
    }
    return metaMetricsId
  }

  getMetaMetricsId () {
    return this.store.getState().metaMetricsId
  }

  getParticipateInMetaMetrics () {
    return this.store.getState().participateInMetaMetrics
  }

  setMetaMetricsSendCount (val) {
    this.store.updateState({ metaMetricsSendCount: val })
  }

  getMetaMetricsSendCount () {
    return this.store.getState().metaMetricsSendCount
  }

  /**
   * Setter for the `firstTimeFlowType` property
   *
   * @param {String} type Indicates the type of first time flow - create or import - the user wishes to follow
   *
   */
  setFirstTimeFlowType (type) {
    this.store.updateState({ firstTimeFlowType: type })
  }


  getSuggestedTokens () {
    return this.store.getState().suggestedTokens
  }

  getAssetImages () {
    return this.store.getState().assetImages
  }

  addSuggestedERC20Asset (tokenOpts) {
    this._validateERC20AssetParams(tokenOpts)
    const suggested = this.getSuggestedTokens()
    const { rawAddress, symbol, decimals, image } = tokenOpts
    const address = normalizeAddress(rawAddress)
    const newEntry = { address, symbol, decimals, image }
    suggested[address] = newEntry
    this.store.updateState({ suggestedTokens: suggested })
  }

  /**
   * Add new methodData to state, to avoid requesting this information again through Infura
   *
   * @param {string} fourBytePrefix Four-byte method signature
   * @param {string} methodData Corresponding data method
   */
  addKnownMethodData (fourBytePrefix, methodData) {
    const knownMethodData = this.store.getState().knownMethodData
    knownMethodData[fourBytePrefix] = methodData
    this.store.updateState({ knownMethodData })
  }

  /**
   * RPC engine middleware for requesting new asset added
   *
   * @param req
   * @param res
   * @param {Function} - next
   * @param {Function} - end
   */
  async requestWatchAsset (req, res, next, end) {
    if (req.method === 'metamask_watchAsset' || req.method === 'wallet_watchAsset') {
      const { type, options } = req.params
      switch (type) {
        case 'ERC20':
          const result = await this._handleWatchAssetERC20(options)
          if (result instanceof Error) {
            end(result)
          } else {
            res.result = result
            end()
          }
          break
        default:
          end(new Error(`Asset of type ${type} not supported`))
      }
    } else {
      next()
    }
  }

  /**
   * Getter for the `useBlockie` property
   *
   * @returns {boolean} this.store.useBlockie
   *
   */
  getUseBlockie () {
    return this.store.getState().useBlockie
  }

  /**
   * Getter for the `getUseNonceField` property
   *
   * @returns {boolean} this.store.getUseNonceField
   *
   */
  getUseNonceField () {
    return this.store.getState().useNonceField
  }

  /**
   * Setter for the `currentLocale` property
   *
   * @param {string} key he preferred language locale key
   *
   */
  setCurrentLocale (key) {
    const textDirection = (['ar', 'dv', 'fa', 'he', 'ku'].includes(key)) ? 'rtl' : 'auto'
    this.store.updateState({
      currentLocale: key,
      textDirection: textDirection,
    })
    return textDirection
  }

  /**
   * Updates identities to only include specified addresses. Removes identities
   * not included in addresses array
   *
   * @param {string[]} addresses An array of hex addresses
   *
   */
  setAddresses (addresses) {
    const oldIdentities = this.store.getState().identities
    const oldAccountTokens = this.store.getState().accountTokens

    const identities = addresses.reduce((ids, address, index) => {
      const oldId = oldIdentities[address] || {}
      ids[address] = {name: `Account ${index + 1}`, address, ...oldId}
      return ids
    }, {})
    const accountTokens = addresses.reduce((tokens, address) => {
      const oldTokens = oldAccountTokens[address] || {}
      tokens[address] = oldTokens
      return tokens
    }, {})
    this.store.updateState({ identities, accountTokens })
  }

  /**
   * Removes an address from state
   *
   * @param {string} address A hex address
   * @returns {string} the address that was removed
   */
  removeAddress (address) {
    const identities = this.store.getState().identities
    const accountTokens = this.store.getState().accountTokens
    if (!identities[address]) {
      throw new Error(`${address} can't be deleted cause it was not found`)
    }
    delete identities[address]
    delete accountTokens[address]
    this.store.updateState({ identities, accountTokens })

    // If the selected account is no longer valid,
    // select an arbitrary other account:
    if (address === this.getSelectedAddress()) {
      const selected = Object.keys(identities)[0]
      this.setSelectedAddress(selected)
    }
    return address
  }


  /**
   * Adds addresses to the identities object without removing identities
   *
   * @param {string[]} addresses An array of hex addresses
   *
   */
  addAddresses (addresses) {
    const identities = this.store.getState().identities
    const accountTokens = this.store.getState().accountTokens
    addresses.forEach((address) => {
      // skip if already exists
      if (identities[address]) return
      // add missing identity
      const identityCount = Object.keys(identities).length

      accountTokens[address] = {}
      identities[address] = { name: `Account ${identityCount + 1}`, address }
    })
    this.store.updateState({ identities, accountTokens })
  }

  /*
   * Synchronizes identity entries with known accounts.
   * Removes any unknown identities, and returns the resulting selected address.
   *
   * @param {Array<string>} addresses known to the vault.
   * @returns {Promise<string>} selectedAddress the selected address.
   */
  syncAddresses (addresses) {
    const { identities, lostIdentities } = this.store.getState()

    const newlyLost = {}
    Object.keys(identities).forEach((identity) => {
      if (!addresses.includes(identity)) {
        newlyLost[identity] = identities[identity]
        delete identities[identity]
      }
    })

    // Identities are no longer present.
    if (Object.keys(newlyLost).length > 0) {

      // Notify our servers:
      if (this.diagnostics) this.diagnostics.reportOrphans(newlyLost)

      // store lost accounts
      for (const key in newlyLost) {
        lostIdentities[key] = newlyLost[key]
      }
    }

    this.store.updateState({ identities, lostIdentities })
    this.addAddresses(addresses)

    // If the selected account is no longer valid,
    // select an arbitrary other account:
    let selected = this.getSelectedAddress()
    if (!addresses.includes(selected)) {
      selected = addresses[0]
      this.setSelectedAddress(selected)
    }

    return selected
  }

  removeSuggestedTokens () {
    return new Promise((resolve) => {
      this.store.updateState({ suggestedTokens: {} })
      resolve({})
    })
  }

  /**
   * Setter for the `selectedAddress` property
   *
   * @param {string} _address A new hex address for an account
   * @returns {Promise<void>} Promise resolves with tokens
   *
   */
  setSelectedAddress (_address) {
    const address = normalizeAddress(_address)
    this._updateTokens(address)
    this.store.updateState({ selectedAddress: address })
    const tokens = this.store.getState().tokens
    return Promise.resolve(tokens)
  }

  /**
   * Getter for the `selectedAddress` property
   *
   * @returns {string} The hex address for the currently selected account
   *
   */
  getSelectedAddress () {
    return this.store.getState().selectedAddress
  }

  /**
   * Contains data about tokens users add to their account.
   * @typedef {Object} AddedToken
   * @property {string} address - The hex address for the token contract. Will be all lower cased and hex-prefixed.
   * @property {string} symbol - The symbol of the token, usually 3 or 4 capitalized letters
   *  {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#symbol}
   * @property {boolean} decimals - The number of decimals the token uses.
   *  {@link https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#decimals}
   */

  /**
   * Adds a new token to the token array, or updates the token if passed an address that already exists.
   * Modifies the existing tokens array from the store. All objects in the tokens array array AddedToken objects.
   * @see AddedToken {@link AddedToken}
   *
   * @param {string} rawAddress Hex address of the token contract. May or may not be a checksum address.
   * @param {string} symbol The symbol of the token
   * @param {number} decimals  The number of decimals the token uses.
   * @returns {Promise<array>} Promises the new array of AddedToken objects.
   *
   */
  async addToken (rawAddress, symbol, decimals, image) {
    const address = normalizeAddress(rawAddress)
    const newEntry = { address, symbol, decimals }
    const tokens = this.store.getState().tokens
    const assetImages = this.getAssetImages()
    const previousEntry = tokens.find((token) => {
      return token.address === address
    })
    const previousIndex = tokens.indexOf(previousEntry)

    if (previousEntry) {
      tokens[previousIndex] = newEntry
    } else {
      tokens.push(newEntry)
    }
    assetImages[address] = image
    this._updateAccountTokens(tokens, assetImages)
    return Promise.resolve(tokens)
  }

  /**
   * Removes a specified token from the tokens array.
   *
   * @param {string} rawAddress Hex address of the token contract to remove.
   * @returns {Promise<array>} The new array of AddedToken objects
   *
   */
  removeToken (rawAddress) {
    const tokens = this.store.getState().tokens
    const assetImages = this.getAssetImages()
    const updatedTokens = tokens.filter(token => token.address !== rawAddress)
    delete assetImages[rawAddress]
    this._updateAccountTokens(updatedTokens, assetImages)
    return Promise.resolve(updatedTokens)
  }

  /**
   * A getter for the `tokens` property
   *
   * @returns {array} The current array of AddedToken objects
   *
   */
  getTokens () {
    return this.store.getState().tokens
  }

  /**
   * Sets a custom label for an account
   * @param {string} account the account to set a label for
   * @param {string} label the custom label for the account
   * @return {Promise<string>}
   */
  setAccountLabel (account, label) {
    if (!account) throw new Error('setAccountLabel requires a valid address, got ' + String(account))
    const address = normalizeAddress(account)
    const {identities} = this.store.getState()
    identities[address] = identities[address] || {}
    identities[address].name = label
    this.store.updateState({ identities })
    return Promise.resolve(label)
  }

  /**
   * Setter for the `currentAccountTab` property
   *
   * @param {string} currentAccountTab Specifies the new tab to be marked as current
   * @returns {Promise<void>} Promise resolves with undefined
   *
   */
  setCurrentAccountTab (currentAccountTab) {
    return new Promise((resolve) => {
      this.store.updateState({ currentAccountTab })
      resolve()
    })
  }

  /**
   * updates custom RPC details
   *
   * @param {string} url The RPC url to add to frequentRpcList.
   * @param {number} chainId Optional chainId of the selected network.
   * @param {string} ticker   Optional ticker symbol of the selected network.
   * @param {string} nickname Optional nickname of the selected network.
   * @returns {Promise<array>} Promise resolving to updated frequentRpcList.
   *
   */


  updateRpc (newRpcDetails) {
    const rpcList = this.getFrequentRpcListDetail()
    const index = rpcList.findIndex((element) => { return element.rpcUrl === newRpcDetails.rpcUrl })
    if (index > -1) {
      const rpcDetail = rpcList[index]
      const updatedRpc = extend(rpcDetail, newRpcDetails)
      rpcList[index] = updatedRpc
      this.store.updateState({ frequentRpcListDetail: rpcList })
    } else {
      const { rpcUrl, chainId, ticker, nickname, rpcPrefs = {} } = newRpcDetails
      return this.addToFrequentRpcList(rpcUrl, chainId, ticker, nickname, rpcPrefs)
    }
    return Promise.resolve(rpcList)
  }
  /**
   * Adds custom RPC url to state.
   *
   * @param {string} url The RPC url to add to frequentRpcList.
   * @param {number} chainId Optional chainId of the selected network.
   * @param {string} ticker   Optional ticker symbol of the selected network.
   * @param {string} nickname Optional nickname of the selected network.
   * @returns {Promise<array>} Promise resolving to updated frequentRpcList.
   *
   */
  addToFrequentRpcList (url, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const rpcList = this.getFrequentRpcListDetail()
    const index = rpcList.findIndex((element) => { return element.rpcUrl === url })
    if (index !== -1) {
      rpcList.splice(index, 1)
    }
    if (url !== 'http://localhost:8545') {
      let checkedChainId
      if (!!chainId && !Number.isNaN(parseInt(chainId))) {
        checkedChainId = chainId
      }
      rpcList.push({ rpcUrl: url, chainId: checkedChainId, ticker, nickname, rpcPrefs })
    }
    this.store.updateState({ frequentRpcListDetail: rpcList })
    return Promise.resolve(rpcList)
  }

  /**
   * Removes custom RPC url from state.
   *
   * @param {string} url The RPC url to remove from frequentRpcList.
   * @returns {Promise<array>} Promise resolving to updated frequentRpcList.
   *
   */
  removeFromFrequentRpcList (url) {
    const rpcList = this.getFrequentRpcListDetail()
    const index = rpcList.findIndex((element) => { return element.rpcUrl === url })
    if (index !== -1) {
      rpcList.splice(index, 1)
    }
    this.store.updateState({ frequentRpcListDetail: rpcList })
    return Promise.resolve(rpcList)
  }

  /**
   * Getter for the `frequentRpcListDetail` property.
   *
   * @returns {array<array>} An array of rpc urls.
   *
   */
  getFrequentRpcListDetail () {
    return this.store.getState().frequentRpcListDetail
  }

  /**
   * Updates the `featureFlags` property, which is an object. One property within that object will be set to a boolean.
   *
   * @param {string} feature A key that corresponds to a UI feature.
   * @param {boolean} activated Indicates whether or not the UI feature should be displayed
   * @returns {Promise<object>} Promises a new object; the updated featureFlags object.
   *
   */
  setFeatureFlag (feature, activated) {
    const currentFeatureFlags = this.store.getState().featureFlags
    const updatedFeatureFlags = {
      ...currentFeatureFlags,
      [feature]: activated,
    }

    this.store.updateState({ featureFlags: updatedFeatureFlags })

    return Promise.resolve(updatedFeatureFlags)
  }

  /**
   * A getter for the `featureFlags` property
   *
   * @returns {object} A key-boolean map, where keys refer to features and booleans to whether the
   * user wishes to see that feature
   *
   */
  getFeatureFlags () {
    return this.store.getState().featureFlags
  }

  /**
   * Updates the `preferences` property, which is an object. These are user-controlled features
   * found in the settings page.
   * @param {string} preference The preference to enable or disable.
   * @param {boolean} value Indicates whether or not the preference should be enabled or disabled.
   * @returns {Promise<object>} Promises a new object; the updated preferences object.
   */
  setPreference (preference, value) {
    const currentPreferences = this.getPreferences()
    const updatedPreferences = {
      ...currentPreferences,
      [preference]: value,
    }

    this.store.updateState({ preferences: updatedPreferences })
    return Promise.resolve(updatedPreferences)
  }

  /**
   * A getter for the `preferences` property
   * @returns {object} A key-boolean map of user-selected preferences.
   */
  getPreferences () {
    return this.store.getState().preferences
  }

  /**
   * Sets the completedOnboarding state to true, indicating that the user has completed the
   * onboarding process.
   */
  completeOnboarding () {
    this.store.updateState({ completedOnboarding: true })
    return Promise.resolve(true)
  }

  unsetMigratedPrivacyMode () {
    this.store.updateState({
      migratedPrivacyMode: false,
    })
    return Promise.resolve()
  }

  //
  // PRIVATE METHODS
  //

  /**
   * Subscription to network provider type.
   *
   *
   */
  _subscribeProviderType () {
    this.network.providerStore.subscribe(() => {
      const { tokens } = this._getTokenRelatedStates()
      this.store.updateState({ tokens })
    })
  }

  /**
   * Updates `accountTokens` and `tokens` of current account and network according to it.
   *
   * @param {array} tokens Array of tokens to be updated.
   *
   */
  _updateAccountTokens (tokens, assetImages) {
    const { accountTokens, providerType, selectedAddress } = this._getTokenRelatedStates()
    accountTokens[selectedAddress][providerType] = tokens
    this.store.updateState({ accountTokens, tokens, assetImages })
  }

  /**
   * Updates `tokens` of current account and network.
   *
   * @param {string} selectedAddress Account address to be updated with.
   *
   */
  _updateTokens (selectedAddress) {
    const { tokens } = this._getTokenRelatedStates(selectedAddress)
    this.store.updateState({ tokens })
  }

  /**
   * A getter for `tokens` and `accountTokens` related states.
   *
   * @param {string} selectedAddress A new hex address for an account
   * @returns {Object.<array, object, string, string>} States to interact with tokens in `accountTokens`
   *
   */
  _getTokenRelatedStates (selectedAddress) {
    const accountTokens = this.store.getState().accountTokens
    if (!selectedAddress) selectedAddress = this.store.getState().selectedAddress
    const providerType = this.network.providerStore.getState().type
    if (!(selectedAddress in accountTokens)) accountTokens[selectedAddress] = {}
    if (!(providerType in accountTokens[selectedAddress])) accountTokens[selectedAddress][providerType] = []
    const tokens = accountTokens[selectedAddress][providerType]
    return { tokens, accountTokens, providerType, selectedAddress }
  }

  /**
   * Handle the suggestion of an ERC20 asset through `watchAsset`
   * *
   * @param {Promise} promise Promise according to addition of ERC20 token
   *
   */
  async _handleWatchAssetERC20 (options) {
    const { address, symbol, decimals, image } = options
    const rawAddress = address
    try {
      this._validateERC20AssetParams({ rawAddress, symbol, decimals })
    } catch (err) {
      return err
    }
    const tokenOpts = { rawAddress, decimals, symbol, image }
    this.addSuggestedERC20Asset(tokenOpts)
    return this.openPopup().then(() => {
      const tokenAddresses = this.getTokens().filter(token => token.address === normalizeAddress(rawAddress))
      return tokenAddresses.length > 0
    })
  }

  /**
   * Validates that the passed options for suggested token have all required properties.
   *
   * @param {Object} opts The options object to validate
   * @throws {string} Throw a custom error indicating that address, symbol and/or decimals
   * doesn't fulfill requirements
   *
   */
  _validateERC20AssetParams (opts) {
    const { rawAddress, symbol, decimals } = opts
    if (!rawAddress || !symbol || typeof decimals === 'undefined') throw new Error(`Cannot suggest token without address, symbol, and decimals`)
    if (!(symbol.length < 7)) throw new Error(`Invalid symbol ${symbol} more than six characters`)
    const numDecimals = parseInt(decimals, 10)
    if (isNaN(numDecimals) || numDecimals > 36 || numDecimals < 0) {
      throw new Error(`Invalid decimals ${decimals} must be at least 0, and not over 36`)
    }
    if (!isValidAddress(rawAddress)) throw new Error(`Invalid address ${rawAddress}`)
  }
}

module.exports = PreferencesController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="preferences"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/provider-approval.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
为用户认可的 ETH provider API 请求提供服务
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const SafeEventEmitter = require('safe-event-emitter')
const createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')
const { errors: rpcErrors } = require('eth-json-rpc-errors')

/**
 * 为用户认可的 ETH provider API 请求提供服务
 * A controller that services user-approved requests for a full Ethereum provider API
 */
class ProviderApprovalController extends SafeEventEmitter {
  /**
   * Creates a ProviderApprovalController
   *
   * approvedOrigins 授权的来源
   *
   * @param {Object} [config] - Options to configure controller
   */
  constructor ({ closePopup, initState, keyringController, openPopup, preferencesController } = {}) {
    super()
    this.closePopup = closePopup
    this.keyringController = keyringController
    this.openPopup = openPopup
    this.preferencesController = preferencesController
    this.memStore = new ObservableStore({
      providerRequests: [],
    })

    const defaultState = { approvedOrigins: {} }
    this.store = new ObservableStore(Object.assign(defaultState, initState))
  }

  /**
   * Called when a user approves access to a full Ethereum provider API
   *
   * @param {object} opts - opts for the middleware contains the origin for the middleware
   */
  createMiddleware ({ senderUrl, extensionId, getSiteMetadata }) {
    return createAsyncMiddleware(async (req, res, next) => {
      // only handle requestAccounts
      if (req.method !== 'eth_requestAccounts') return next()
      // if already approved or privacy mode disabled, return early
      const isUnlocked = this.keyringController.memStore.getState().isUnlocked
      const origin = senderUrl.hostname
      if (this.shouldExposeAccounts(origin) && isUnlocked) {
        res.result = [this.preferencesController.getSelectedAddress()]
        return
      }
      // register the provider request
      const metadata = { hostname: senderUrl.hostname, origin }
      if (extensionId) {
        metadata.extensionId = extensionId
      } else {
        const siteMetadata = await getSiteMetadata(origin)
        Object.assign(metadata, { siteTitle: siteMetadata.name, siteImage: siteMetadata.icon})
      }
      this._handleProviderRequest(metadata)
      // wait for resolution of request
      const approved = await new Promise(resolve => this.once(`resolvedRequest:${origin}`, ({ approved }) => resolve(approved)))
      if (approved) {
        res.result = [this.preferencesController.getSelectedAddress()]
      } else {
        throw rpcErrors.eth.userRejectedRequest('User denied account authorization')
      }
    })
  }

  /**
  * @typedef {Object} SiteMetadata
  * @param {string} hostname - The hostname of the site
  * @param {string} origin - The origin of the site
  * @param {string} [siteTitle] - The title of the site
  * @param {string} [siteImage] - The icon for the site
  * @param {string} [extensionId] - The extension ID of the extension
  */
  /**
   * 当标签页请求访问完整的以太坊提供商API时调用
   * Called when a tab requests access to a full Ethereum provider API
   *
   * @param {SiteMetadata} siteMetadata - The metadata for the site requesting full provider access
   */
  _handleProviderRequest (siteMetadata) {
    const { providerRequests } = this.memStore.getState()
    const origin = siteMetadata.origin
    this.memStore.updateState({
      providerRequests: [
        ...providerRequests,
        siteMetadata,
      ],
    })
    const isUnlocked = this.keyringController.memStore.getState().isUnlocked
    const { approvedOrigins } = this.store.getState()
    const originAlreadyHandled = approvedOrigins[origin]
    if (originAlreadyHandled && isUnlocked) {
      return
    }
    this.openPopup && this.openPopup()
  }

  /**
   * 当用户批准访问完整的以太坊提供商API时调用
   * Called when a user approves access to a full Ethereum provider API
   *
   * @param {string} origin - origin of the domain that had provider access approved
   */
  approveProviderRequestByOrigin (origin) {
    if (this.closePopup) {
      this.closePopup()
    }

    const { approvedOrigins } = this.store.getState()
    const { providerRequests } = this.memStore.getState()
    const providerRequest = providerRequests.find((request) => request.origin === origin)
    const remainingProviderRequests = providerRequests.filter(request => request.origin !== origin)
    this.store.updateState({
      approvedOrigins: {
        ...approvedOrigins,
        [origin]: {
          siteTitle: providerRequest ? providerRequest.siteTitle : null,
          siteImage: providerRequest ? providerRequest.siteImage : null,
          hostname: providerRequest ? providerRequest.hostname : null,
        },
      },
    })
    this.memStore.updateState({ providerRequests: remainingProviderRequests })
    this.emit(`resolvedRequest:${origin}`, { approved: true })
  }

  /**
   * 当标签拒绝访问完整的以太坊提供商API时调用
   * Called when a tab rejects access to a full Ethereum provider API
   *
   * @param {string} origin - origin of the domain that had provider access approved
   */
  rejectProviderRequestByOrigin (origin) {
    if (this.closePopup) {
      this.closePopup()
    }

    const { approvedOrigins } = this.store.getState()
    const { providerRequests } = this.memStore.getState()
    const remainingProviderRequests = providerRequests.filter(request => request.origin !== origin)

    // We're cloning and deleting keys here because we don't want to keep unneeded keys
    const _approvedOrigins = Object.assign({}, approvedOrigins)
    delete _approvedOrigins[origin]

    this.store.putState({ approvedOrigins: _approvedOrigins })
    this.memStore.putState({ providerRequests: remainingProviderRequests })
    this.emit(`resolvedRequest:${origin}`, { approved: false })
  }

  /**
   * 清除用户批准的所有 origins
   * Clears any approvals for user-approved origins
   */
  clearApprovedOrigins () {
    this.store.updateState({
      approvedOrigins: {},
    })
  }

  /**
   * Determines if a given origin should have accounts exposed
   *
   * @param {string} origin - Domain origin to check for approval status
   * @returns {boolean} - True if the origin has been approved
   */
  shouldExposeAccounts (origin) {
    return Boolean(this.store.getState().approvedOrigins[origin])
  }

  /**
   * Returns a merged state representation
   * @return {object}
   * @private
   */
  _getMergedState () {
    return Object.assign({}, this.memStore.getState(), this.store.getState())
  }
}

module.exports = ProviderApprovalController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  


  <c:entry style="margin-top:1em;">
    <c:title id="recent-blocks"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/recent-blocks.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
负责存储，更新和管理最近的 block
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const extend = require('xtend')
const EthQuery = require('eth-query')
const log = require('loglevel')
const pify = require('pify')
const {
  ROPSTEN,
  RINKEBY,
  KOVAN,
  MAINNET,
  GOERLI,
} = require('./network/enums')
const INFURA_PROVIDER_TYPES = [ROPSTEN, RINKEBY, KOVAN, MAINNET, GOERLI]


class RecentBlocksController {

  /**
   * 负责存储，更新和管理最近的 block
   *
   * Controller responsible for storing, updating and managing the recent history of blocks. Blocks are back filled
   * upon the controller's construction and then the list is updated when the given block tracker gets a 'latest' event
   * (indicating that there is a new block to process).
   *
   * @typedef {Object} RecentBlocksController
   * @param {object} opts Contains objects necessary for tracking blocks and querying the blockchain
   * @param {BlockTracker} opts.blockTracker Contains objects necessary for tracking blocks and querying the blockchain
   * @param {BlockTracker} opts.provider The provider used to create a new EthQuery instance.
   * @property {BlockTracker} blockTracker Points to the passed BlockTracker. On RecentBlocksController construction,
   * listens for 'latest' events so that new blocks can be processed and added to storage.
   * @property {EthQuery} ethQuery Points to the EthQuery instance created with the passed provider
   * @property {number} historyLength The maximum length of blocks to track
   * @property {object} store Stores the recentBlocks
   * @property {array} store.recentBlocks Contains all recent blocks, up to a total that is equal to this.historyLength
   *
   */
  constructor (opts = {}) {
    const { blockTracker, provider, networkController } = opts
    this.blockTracker = blockTracker
    this.ethQuery = new EthQuery(provider)
    this.historyLength = opts.historyLength || 40

    const initState = extend({
      recentBlocks: [], // recentBlocks 所有最新 block，数量和 historyLength 一致
    }, opts.initState)
    this.store = new ObservableStore(initState)
    const blockListner = async (newBlockNumberHex) => {
      try {
        await this.processBlock(newBlockNumberHex)
      } catch (err) {
        log.error(err)
      }
    }
    let isListening = false
    const { type } = networkController.getProviderConfig()
    if (!INFURA_PROVIDER_TYPES.includes(type) && type !== 'loading') {
      this.blockTracker.on('latest', blockListner)
      isListening = true
    }
    networkController.on('networkDidChange', (newType) => {
      if (INFURA_PROVIDER_TYPES.includes(newType) && isListening) {
        this.blockTracker.removeListener('latest', blockListner)
      } else if (
        !INFURA_PROVIDER_TYPES.includes(type) &&
        type !== 'loading' &&
        !isListening
      ) {
        this.blockTracker.on('latest', blockListner)

      }
    })
    this.backfill()
  }

  /**
   * Sets store.recentBlocks to an empty array
   *
   */
  resetState () {
    this.store.updateState({
      recentBlocks: [],
    })
  }

  /**
   * 拿到最新区块，先处理，然后扔到 recentBlocks 里，从右填充，如果 recentBlocks 满了，把最旧的删除
   * Receives a new block and modifies it with this.mapTransactionsToPrices. Then adds that block to the recentBlocks
   * array in storage. If the recentBlocks array contains the maximum number of blocks, the oldest block is removed.
   *
   * @param {object} newBlock The new block to modify and add to the recentBlocks array
   *
   */
  async processBlock (newBlockNumberHex) {
    const newBlockNumber = Number.parseInt(newBlockNumberHex, 16)
    const newBlock = await this.getBlockByNumber(newBlockNumber, true)
    if (!newBlock) return

    const block = this.mapTransactionsToPrices(newBlock)

    const state = this.store.getState()
    state.recentBlocks.push(block)

    while (state.recentBlocks.length > this.historyLength) {
      state.recentBlocks.shift()
    }

    this.store.updateState(state)
  }

  /**
   * 如果 recentBlocks 长度不够，用 block 填充，从左填充
   * Receives a new block and modifies it with this.mapTransactionsToPrices. Adds that block to the recentBlocks
   * array in storage, but only if the recentBlocks array contains fewer than the maximum permitted.
   *
   * Unlike this.processBlock, backfillBlock adds the modified new block to the beginning of the recent block array.
   *
   * @param {object} newBlock The new block to modify and add to the beginning of the recentBlocks array
   *
   */
  backfillBlock (newBlock) {
    const block = this.mapTransactionsToPrices(newBlock)

    const state = this.store.getState()

    if (state.recentBlocks.length < this.historyLength) {
      state.recentBlocks.unshift(block)
    }

    this.store.updateState(state)
  }

  /**
   * 只关心每个 tx 的 gasPrice，其他的删掉
   * Receives a block and gets the gasPrice of each of its transactions. These gas prices are added to the block at a
   * new property, and the block's transactions are removed.
   *
   * @param {object} newBlock The block to modify. It's transaction array will be replaced by a gasPrices array.
   * @returns {object} The modified block.
   *
   */
  mapTransactionsToPrices (newBlock) {
    const block = extend(newBlock, {
      gasPrices: newBlock.transactions.map((tx) => {
        return tx.gasPrice
      }),
    })
    delete block.transactions
    return block
  }

  /**
   * 从旧到新排列
   * On this.blockTracker's first 'latest' event after this RecentBlocksController's instantiation, the store.recentBlocks
   * array is populated with this.historyLength number of blocks. The block number of the this.blockTracker's first
   * 'latest' event is used to iteratively generate all the numbers of the previous blocks, which are obtained by querying
   * the blockchain. These blocks are backfilled so that the recentBlocks array is ordered from oldest to newest.
   *
   * Each iteration over the block numbers is delayed by 100 milliseconds.
   *
   * @returns {Promise<void>} Promises undefined
   */
  async backfill () {
    this.blockTracker.once('latest', async (blockNumberHex) => {
      const currentBlockNumber = Number.parseInt(blockNumberHex, 16)
      const blocksToFetch = Math.min(currentBlockNumber, this.historyLength)
      const prevBlockNumber = currentBlockNumber - 1
      const targetBlockNumbers = Array(blocksToFetch).fill().map((_, index) => prevBlockNumber - index)
      await Promise.all(targetBlockNumbers.map(async (targetBlockNumber) => {
        try {
          const newBlock = await this.getBlockByNumber(targetBlockNumber, true)
          if (!newBlock) return

          this.backfillBlock(newBlock)
        } catch (e) {
          log.error(e)
        }
      }))
    })
  }

  /**
   * 返回指定 number 的 block
   * Uses EthQuery to get a block that has a given block number.
   *
   * @param {number} number The number of the block to get
   * @returns {Promise<object>} Promises A block with the passed number
   *
   */
  async getBlockByNumber (number) {
    const blockNumberHex = '0x' + number.toString(16)
    // pify - Promisify a callback-style function
    // https://github.com/sindresorhus/pify
    return await pify(this.ethQuery.getBlockByNumber).call(this.ethQuery, blockNumberHex, true)
  }

}

module.exports = RecentBlocksController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  


  <c:entry style="margin-top:1em;">
    <c:title id="threebox"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/threebox.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
参考 3box，以太坊上的分布式数据库基础架构。
</div>
<div style="margin-bottom:1em;">
https://www.yuque.com/jnoodle/blockchain/nauwpx <br />
https://github.com/3box/3box-js <br />
https://3box.io/
</div>
<div style="margin-bottom:1em;">
3Box是web3.0的开源数据存储解决方案，允许最终用户在分布式的网络上管理他们的公共和私人信息，数据存储在IPFS上并通过OrbitDB进行管理。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const Box = process.env.IN_TEST
  ? require('../../../development/mock-3box')
  : require('3box')
const log = require('loglevel')
const migrations = require('../migrations/')
const Migrator = require('../lib/migrator')
const JsonRpcEngine = require('json-rpc-engine')
const providerFromEngine = require('eth-json-rpc-middleware/providerFromEngine')
const createMetamaskMiddleware = require('./network/createMetamaskMiddleware')
const createOriginMiddleware = require('../lib/createOriginMiddleware')

const SYNC_TIMEOUT = 60 * 1000 // one minute

// https://github.com/3box/3box-js
// 3box Controller 设置，获取和删除与以太坊账户相关的私人和公共数据
class ThreeBoxController {
  constructor (opts = {}) {
    const {
      preferencesController,
      keyringController,
      addressBookController,
      version,
      getKeyringControllerState,
    } = opts

    this.preferencesController = preferencesController
    this.addressBookController = addressBookController
    this.keyringController = keyringController
    this.provider = this._createProvider({
      version,
      getAccounts: async ({ origin }) => {
        if (origin !== '3Box') { return [] }
        const isUnlocked = getKeyringControllerState().isUnlocked

        const accounts = await this.keyringController.getAccounts()

        if (isUnlocked && accounts[0]) {
          const appKeyAddress = await this.keyringController.getAppKeyAddress(accounts[0], 'wallet://3box.metamask.io')
          return [appKeyAddress]
        } else {
          return []
        }
      },
      processPersonalMessage: async (msgParams) => {
        const accounts = await this.keyringController.getAccounts()
        return keyringController.signPersonalMessage({ ...msgParams, from: accounts[0] }, {
          withAppKeyOrigin: 'wallet://3box.metamask.io',
        })
      },
    })

    const initState = {
      threeBoxSyncingAllowed: false,
      showRestorePrompt: true,
      threeBoxLastUpdated: 0,
      ...opts.initState,
      threeBoxAddress: null,
      threeBoxSynced: false,
      threeBoxDisabled: false,
    }
    this.store = new ObservableStore(initState)
    this.registeringUpdates = false
    this.lastMigration = migrations.sort((a, b) => a.version - b.version).slice(-1)[0]

    if (initState.threeBoxSyncingAllowed) {
      this.init()
    }
  }

  async init () {
    const accounts = await this.keyringController.getAccounts()
    this.address = accounts[0]
    if (this.address && !(this.box && this.store.getState().threeBoxSynced)) {
      await this.new3Box()
    }
  }

  async _update3Box () {
    try {
      const { threeBoxSyncingAllowed, threeBoxSynced } = this.store.getState()
      if (threeBoxSyncingAllowed && threeBoxSynced) {
        const newState = {
          preferences: this.preferencesController.store.getState(),
          addressBook: this.addressBookController.state,
          lastUpdated: Date.now(),
          lastMigration: this.lastMigration,
        }

        await this.space.private.set('metamaskBackup', JSON.stringify(newState))
        await this.setShowRestorePromptToFalse()
      }
    } catch (error) {
      console.error(error)
    }
  }

  _createProvider (providerOpts) {
    const metamaskMiddleware = createMetamaskMiddleware(providerOpts)
    const engine = new JsonRpcEngine()
    engine.push(createOriginMiddleware({ origin: '3Box' }))
    engine.push(metamaskMiddleware)
    const provider = providerFromEngine(engine)
    return provider
  }

  _waitForOnSyncDone () {
    return new Promise((resolve) => {
      this.box.onSyncDone(() => {
        log.debug('3Box box sync done')
        return resolve()
      })
    })
  }

  async new3Box () {
    const accounts = await this.keyringController.getAccounts()
    this.address = await this.keyringController.getAppKeyAddress(accounts[0], 'wallet://3box.metamask.io')
    let backupExists
    try {
      const threeBoxConfig = await Box.getConfig(this.address)
      backupExists = threeBoxConfig.spaces && threeBoxConfig.spaces.metamask
    } catch (e) {
      if (e.message.match(/^Error: Invalid response \(404\)/)) {
        backupExists = false
      } else {
        throw e
      }
    }
    if (this.getThreeBoxSyncingState() || backupExists) {
      this.store.updateState({ threeBoxSynced: false })

      let timedOut = false
      const syncTimeout = setTimeout(() => {
        log.error(`3Box sync timed out after ${SYNC_TIMEOUT} ms`)
        timedOut = true
        this.store.updateState({
          threeBoxDisabled: true,
          threeBoxSyncingAllowed: false,
        })
      }, SYNC_TIMEOUT)
      try {
        this.box = await Box.openBox(this.address, this.provider)
        await this._waitForOnSyncDone()
        this.space = await this.box.openSpace('metamask', {
          onSyncDone: async () => {
            const stateUpdate = {
              threeBoxSynced: true,
              threeBoxAddress: this.address,
            }
            if (timedOut) {
              log.info(`3Box sync completed after timeout; no longer disabled`)
              stateUpdate.threeBoxDisabled = false
            }

            clearTimeout(syncTimeout)
            this.store.updateState(stateUpdate)

            log.debug('3Box space sync done')
          },
        })
      } catch (e) {
        console.error(e)
        throw e
      }
    }
  }

  async getLastUpdated () {
    const res = await this.space.private.get('metamaskBackup')
    const parsedRes = JSON.parse(res || '{}')
    return parsedRes.lastUpdated
  }

  async migrateBackedUpState (backedUpState) {
    const migrator = new Migrator({ migrations })

    const formattedStateBackup = {
      PreferencesController: backedUpState.preferences,
      AddressBookController: backedUpState.addressBook,
    }
    const initialMigrationState = migrator.generateInitialState(formattedStateBackup)
    const migratedState = await migrator.migrateData(initialMigrationState)
    return {
      preferences: migratedState.PreferencesController,
      addressBook: migratedState.AddressBookController,
    }
  }

  async restoreFromThreeBox () {
    const backedUpState = await this.space.private.get('metamaskBackup')
    const {
      preferences,
      addressBook,
    } = await this.migrateBackedUpState(backedUpState)
    this.store.updateState({ threeBoxLastUpdated: backedUpState.lastUpdated })
    preferences && this.preferencesController.store.updateState(JSON.parse(preferences))
    addressBook && this.addressBookController.update(JSON.parse(addressBook), true)
    this.setShowRestorePromptToFalse()
  }

  turnThreeBoxSyncingOn () {
    this._registerUpdates()
  }

  turnThreeBoxSyncingOff () {
    this.box.logout()
  }

  setShowRestorePromptToFalse () {
    this.store.updateState({ showRestorePrompt: false })
  }

  setThreeBoxSyncingPermission (newThreeboxSyncingState) {
    if (this.store.getState().threeBoxDisabled) {
      return
    }
    this.store.updateState({
      threeBoxSyncingAllowed: newThreeboxSyncingState,
    })

    if (newThreeboxSyncingState && this.box) {
      this.turnThreeBoxSyncingOn()
    }

    if (!newThreeboxSyncingState && this.box) {
      this.turnThreeBoxSyncingOff()
    }
  }

  getThreeBoxSyncingState () {
    return this.store.getState().threeBoxSyncingAllowed
  }

  getThreeBoxAddress () {
    return this.store.getState().threeBoxAddress
  }

  _registerUpdates () {
    if (!this.registeringUpdates) {
      const updatePreferences = this._update3Box.bind(this)
      this.preferencesController.store.subscribe(updatePreferences)
      const updateAddressBook = this._update3Box.bind(this)
      this.addressBookController.subscribe(updateAddressBook)
      this.registeringUpdates = true
    }
  }
}

module.exports = ThreeBoxController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="threebox"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/controllers/token-rates.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
轮询获取用户 token 的汇率（每3分钟）
</div>
<div style="margin-bottom:1em;">
使用的是 https://www.coingecko.com/ 币虎的服务
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ObservableStore = require('obs-store')
const log = require('loglevel')
const normalizeAddress = require('eth-sig-util').normalize
const ethUtil = require('ethereumjs-util')


// By default, poll every 3 minutes
const DEFAULT_INTERVAL = 180 * 1000

/**
 * 轮询获取用户 token 的汇率
 * A controller that polls for token exchange
 * rates based on a user's current token list
 */
class TokenRatesController {
  /**
   * Creates a TokenRatesController
   *
   * @param {Object} [config] - Options to configure controller
   */
  constructor ({ interval = DEFAULT_INTERVAL, currency, preferences } = {}) {
    this.store = new ObservableStore()
    this.currency = currency
    this.preferences = preferences
    this.interval = interval
  }

  /**
   * Updates exchange rates for all tokens
   * https://www.coingecko.com/
   */
  async updateExchangeRates () {
    if (!this.isActive) { return }
    const contractExchangeRates = {}
    const nativeCurrency = this.currency ? this.currency.state.nativeCurrency.toLowerCase() : 'eth'
    const pairs = this._tokens.map(token => token.address).join(',')
    const query = `contract_addresses=${pairs}&vs_currencies=${nativeCurrency}`
    if (this._tokens.length > 0) {
      try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/token_price/ethereum?${query}`)
        const prices = await response.json()
        this._tokens.forEach(token => {
          const price = prices[token.address.toLowerCase()] || prices[ethUtil.toChecksumAddress(token.address)]
          contractExchangeRates[normalizeAddress(token.address)] = price ? price[nativeCurrency] : 0
        })
      } catch (error) {
        log.warn(`MetaMask - TokenRatesController exchange rate fetch failed.`, error)
      }
    }
    this.store.putState({ contractExchangeRates })
  }

  /**
   * @type {Number}
   */
  set interval (interval) {
    this._handle && clearInterval(this._handle)
    if (!interval) { return }
    this._handle = setInterval(() => { this.updateExchangeRates() }, interval)
  }

  /**
   * @type {Object}
   */
  set preferences (preferences) {
    this._preferences && this._preferences.unsubscribe()
    if (!preferences) { return }
    this._preferences = preferences
    this.tokens = preferences.getState().tokens
    preferences.subscribe(({ tokens = [] }) => { this.tokens = tokens })
  }

  /**
   * @type {Array}
   */
  set tokens (tokens) {
    this._tokens = tokens
    this.updateExchangeRates()
  }
}

module.exports = TokenRatesController
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="ens-ipfs-resolver"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/ens-ipfs/resolver.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
先要了解 EIP1577 标准
</div>

<div style="margin-bottom:1em;">
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1577.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1577.md</a> <br />
<a href="https://medium.com/the-ethereum-name-service/ethdns-9d56298fa38a">https://medium.com/the-ethereum-name-service/ethdns-9d56298fa38a</a>
</div>

<div style="margin-bottom:1em;">
ENS to IPFS contentId
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const namehash = require('eth-ens-namehash')
const Eth = require('ethjs-query')
const EthContract = require('ethjs-contract')
const registryAbi = require('./contracts/registry')
const resolverAbi = require('./contracts/resolver')
// simple tool to encode/decode content hash for EIP 1577 compliant ENS Resolvers
const contentHash = require('content-hash')

module.exports = resolveEnsToIpfsContentId

// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1577.md
// https://medium.com/the-ethereum-name-service/ethdns-9d56298fa38a
// 先要了解 EIP1577 标准

// ENS to IPFS contentId
async function resolveEnsToIpfsContentId ({ provider, name }) {
  const eth = new Eth(provider)
  const hash = namehash.hash(name)
  const contract = new EthContract(eth)
  // lookup registry
  const chainId = Number.parseInt(await eth.net_version(), 10)
  const registryAddress = getRegistryForChainId(chainId)
  if (!registryAddress) {
    throw new Error(`EnsIpfsResolver - no known ens-ipfs registry for chainId "${chainId}"`)
  }
  const Registry = contract(registryAbi).at(registryAddress)
  // lookup resolver
  const resolverLookupResult = await Registry.resolver(hash)
  const resolverAddress = resolverLookupResult[0]
  if (hexValueIsEmpty(resolverAddress)) {
    throw new Error(`EnsIpfsResolver - no resolver found for name "${name}"`)
  }
  const Resolver = contract(resolverAbi).at(resolverAddress)

  const isEIP1577Compliant = await Resolver.supportsInterface('0xbc1c58d1')
  const isLegacyResolver = await Resolver.supportsInterface('0xd8389dc5')
  if (isEIP1577Compliant[0]) {
    const contentLookupResult = await Resolver.contenthash(hash)
    const rawContentHash = contentLookupResult[0]
    const decodedContentHash = contentHash.decode(rawContentHash)
    const type = contentHash.getCodec(rawContentHash)
    return {type: type, hash: decodedContentHash}
  }
  if (isLegacyResolver[0]) {
    // lookup content id
    const contentLookupResult = await Resolver.content(hash)
    const content = contentLookupResult[0]
    if (hexValueIsEmpty(content)) {
      throw new Error(`EnsIpfsResolver - no content ID found for name "${name}"`)
    }
    return {type: 'swarm-ns', hash: content.slice(2)}
  }
  throw new Error(`EnsIpfsResolver - the resolver for name "${name}" is not standard, it should either supports contenthash() or content()`)
}

function hexValueIsEmpty (value) {
  return [undefined, null, '0x', '0x0', '0x0000000000000000000000000000000000000000000000000000000000000000'].includes(value)
}

// The Ethereum Name Service registry address
function getRegistryForChainId (chainId) {
  switch (chainId) {
    // mainnet
    case 1:
      return '0x314159265dd8dbb310642f98f50c066173c1259b'
    // ropsten
    case 3:
      return '0x112234455c3a32fd11230c42e7bccd4a84e02010'
    // rinkeby
    case 4:
      return '0xe7410170f87102df0055eb195163a03b7f2bff4a'
    // goerli
    case 5:
      return '0x112234455c3a32fd11230c42e7bccd4a84e02010'
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="ens-ipfs-setup"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/ens-ipfs/setup.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
https://developer.chrome.com/extensions/webRequest
</div>
<div style="margin-bottom:1em;">
extension webRequest 流程
</div>
<div style="margin-bottom:1em;">
  <img style="width:auto;" src="/images/ether/1578145243824-6483fe5e-17c2-4a3b-8053-e040e2b4b9d2.png" />
</div>
<div style="margin-bottom:1em;">
设置 ens ipfs 解析器
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const urlUtil = require('url')
const extension = require('extensionizer')
const resolveEnsToIpfsContentId = require('./resolver.js')

const supportedTopLevelDomains = ['eth']

module.exports = setupEnsIpfsResolver

// 设置 ens ipfs 解析器
function setupEnsIpfsResolver ({ provider }) {

  // install listener
  const urlPatterns = supportedTopLevelDomains.map(tld => `*://*.${tld}/*`)
  extension.webRequest.onErrorOccurred.addListener(webRequestDidFail, { urls: urlPatterns })

  // return api object
  return {
    // uninstall listener
    remove () {
      extension.webRequest.onErrorOccurred.removeListener(webRequestDidFail)
    },
  }

  // 请求出错处理
  async function webRequestDidFail (details) {
    const { tabId, url } = details
    // ignore requests that are not associated with tabs
    if (tabId === -1) return
    // parse ens name
    const urlData = urlUtil.parse(url)
    const { hostname: name, path, search } = urlData
    const domainParts = name.split('.')
    const topLevelDomain = domainParts[domainParts.length - 1]
    // if unsupported TLD, abort
    if (!supportedTopLevelDomains.includes(topLevelDomain)) return
    // otherwise attempt resolve
    attemptResolve({ tabId, name, path, search })
  }

  // 尝试转换并请求
  async function attemptResolve ({ tabId, name, path, search }) {
    extension.tabs.update(tabId, { url: `loading.html` })
    let url = `https://manager.ens.domains/name/${name}`
    try {
      const {type, hash} = await resolveEnsToIpfsContentId({ provider, name })
      if (type === 'ipfs-ns') {
        const resolvedUrl = `https://gateway.ipfs.io/ipfs/${hash}${path}${search || ''}`
        try {
          // check if ipfs gateway has result
          const response = await fetch(resolvedUrl, { method: 'HEAD' })
          if (response.status === 200) url = resolvedUrl
        } catch (err) {
          console.warn(err)
        }
      } else if (type === 'swarm-ns') {
        url = `https://swarm-gateways.net/bzz:/${hash}${path}${search || ''}`
      } else if (type === 'onion' || type === 'onion3') {
        url = `http://${hash}.onion${path}${search || ''}`
      }
    } catch (err) {
      console.warn(err)
    } finally {
      extension.tabs.update(tabId, { url })
    }
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="migrator-index"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/migrator/index.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
处理 MetaMask 迁移
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EventEmitter = require('events')

/**
 * @typedef {object} Migration
 * @property {number} version - The migration version
 * @property {Function} migrate - Returns a promise of the migrated data
 */

/**
 * 处理 MetaMask 迁移
 * @typedef {object} MigratorOptions
 * @property {Array<Migration>} [migrations] - The list of migrations to apply
 * @property {number} [defaultVersion] - The version to use in the initial state
 */

class Migrator extends EventEmitter {

  /**
   * @constructor
   * @param {MigratorOptions} opts
   */
  constructor (opts = {}) {
    super()
    const migrations = opts.migrations || []
    // sort migrations by version 按版本顺序从小到大排列
    this.migrations = migrations.sort((a, b) => a.version - b.version)
    // grab migration with highest version 获取最新版本
    const lastMigration = this.migrations.slice(-1)[0]
    // use specified defaultVersion or highest migration version
    this.defaultVersion = opts.defaultVersion || (lastMigration && lastMigration.version) || 0
  }

  // run all pending migrations on meta in place
  async migrateData (versionedData = this.generateInitialState()) {
    // 获取所有尚未运行的迁移
    // get all migrations that have not yet been run
    const pendingMigrations = this.migrations.filter(migrationIsPending)

    // 挨个执行
    // perform each migration
    for (const index in pendingMigrations) {
      const migration = pendingMigrations[index]
      try {
        // attempt migration and validate
        const migratedData = await migration.migrate(versionedData)
        if (!migratedData.data) throw new Error('Migrator - migration returned empty data')
        if (migratedData.version !== undefined && migratedData.meta.version !== migration.version) throw new Error('Migrator - Migration did not update version number correctly')
        // accept the migration as good
        versionedData = migratedData
      } catch (err) {
        // rewrite error message to add context without clobbering stack
        const originalErrorMessage = err.message
        err.message = `MetaMask Migration Error #${migration.version}: ${originalErrorMessage}`
        console.warn(err.stack)
        // emit error instead of throw so as to not break the run (gracefully fail)
        this.emit('error', err)
        // stop migrating and use state as is
        return versionedData
      }
    }

    return versionedData

    /**
     * Returns whether or not the migration is pending
     *
     * A migration is considered "pending" if it has a higher
     * version number than the current version.
     * @param {Migration} migration
     * @returns {boolean}
     */
    function migrationIsPending (migration) {
      return migration.version > versionedData.meta.version
    }
  }

  /**
   * Returns the initial state for the migrator
   * @param {object} [data] - The data for the initial state
   * @returns {{meta: {version: number}, data: any}}
   */
  generateInitialState (data) {
    return {
      meta: {
        version: this.defaultVersion,
      },
      data,
    }
  }

}

module.exports = Migrator
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="account-tracker"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/account-tracker.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
负责跟踪任意数量的帐户并缓存其当前余额和交易数
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
/* Account Tracker
 *
 * 负责跟踪任意数量的帐户并缓存其当前余额和交易数
 *
 * This module is responsible for tracking any number of accounts
 * and caching their current balances & transaction counts.
 *
 * It also tracks transaction hashes, and checks their inclusion status
 * on each new block.
 */

const EthQuery = require('eth-query')
const ObservableStore = require('obs-store')
const log = require('loglevel')
const pify = require('pify')
const Web3 = require('web3')
const SINGLE_CALL_BALANCES_ABI = require('single-call-balance-checker-abi')

const { bnToHex } = require('./util')
const { MAINNET_CODE, RINKEBY_CODE, ROPSTEN_CODE, KOVAN_CODE } = require('../controllers/network/enums')
const { SINGLE_CALL_BALANCES_ADDRESS, SINGLE_CALL_BALANCES_ADDRESS_RINKEBY, SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN, SINGLE_CALL_BALANCES_ADDRESS_KOVAN } = require('../controllers/network/contract-addresses')


class AccountTracker {

  /**
   * This module is responsible for tracking any number of accounts and caching their current balances & transaction
   * counts.
   *
   * It also tracks transaction hashes, and checks their inclusion status on each new block.
   *
   * @typedef {Object} AccountTracker
   * @param {Object} opts Initialize various properties of the class.
   * @property {Object} store The stored object containing all accounts to track, as well as the current block's gas limit.
   * @property {Object} store.accounts The accounts currently stored in this AccountTracker
   * @property {string} store.currentBlockGasLimit A hex string indicating the gas limit of the current block
   * @property {Object} _provider A provider needed to create the EthQuery instance used within this AccountTracker.
   * @property {EthQuery} _query An EthQuery instance used to access account information from the blockchain
   * @property {BlockTracker} _blockTracker A BlockTracker instance. Needed to ensure that accounts and their info updates
   * when a new block is created.
   * @property {Object} _currentBlockNumber Reference to a property on the _blockTracker: the number (i.e. an id) of the the current block
   *
   */
  constructor (opts = {}) {
    const initState = {
      accounts: {},
      currentBlockGasLimit: '',
    }
    this.store = new ObservableStore(initState)

    this._provider = opts.provider
    this._query = pify(new EthQuery(this._provider))
    this._blockTracker = opts.blockTracker
    // blockTracker.currentBlock may be null
    this._currentBlockNumber = this._blockTracker.getCurrentBlock()
    this._blockTracker.once('latest', blockNumber => {
      this._currentBlockNumber = blockNumber
    })
    // bind function for easier listener syntax
    this._updateForBlock = this._updateForBlock.bind(this)
    this.network = opts.network

    this.web3 = new Web3(this._provider)
  }

  start () {
    // remove first to avoid double add
    this._blockTracker.removeListener('latest', this._updateForBlock)
    // add listener
    this._blockTracker.addListener('latest', this._updateForBlock)
    // fetch account balances
    this._updateAccounts()
  }

  stop () {
    // remove listener
    this._blockTracker.removeListener('latest', this._updateForBlock)
  }

  /**
   * Ensures that the locally stored accounts are in sync with a set of accounts stored externally to this
   * AccountTracker.
   *
   * Once this AccountTracker's accounts are up to date with those referenced by the passed addresses, each
   * of these accounts are given an updated balance via EthQuery.
   *
   * @param {array} address The array of hex addresses for accounts with which this AccountTracker's accounts should be
   * in sync
   *
   */
  syncWithAddresses (addresses) {
    const accounts = this.store.getState().accounts
    const locals = Object.keys(accounts)

    const accountsToAdd = []
    addresses.forEach((upstream) => {
      if (!locals.includes(upstream)) {
        accountsToAdd.push(upstream)
      }
    })

    const accountsToRemove = []
    locals.forEach((local) => {
      if (!addresses.includes(local)) {
        accountsToRemove.push(local)
      }
    })

    this.addAccounts(accountsToAdd)
    this.removeAccount(accountsToRemove)
  }

  /**
   * Adds new addresses to track the balances of
   * given a balance as long this._currentBlockNumber is defined.
   *
   * @param {array} addresses An array of hex addresses of new accounts to track
   *
   */
  addAccounts (addresses) {
    const accounts = this.store.getState().accounts
    // add initial state for addresses
    addresses.forEach(address => {
      accounts[address] = {}
    })
    // save accounts state
    this.store.updateState({ accounts })
    // fetch balances for the accounts if there is block number ready
    if (!this._currentBlockNumber) return
    this._updateAccounts()
  }

  /**
   * Removes accounts from being tracked
   *
   * @param {array} an array of hex addresses to stop tracking
   *
   */
  removeAccount (addresses) {
    const accounts = this.store.getState().accounts
    // remove each state object
    addresses.forEach(address => {
      delete accounts[address]
    })
    // save accounts state
    this.store.updateState({ accounts })
  }

  /**
   * Given a block, updates this AccountTracker's currentBlockGasLimit, and then updates each local account's balance
   * via EthQuery
   *
   * @private
   * @param {number} blockNumber the block number to update to.
   * @fires 'block' The updated state, if all account updates are successful
   *
   */
  async _updateForBlock (blockNumber) {
    this._currentBlockNumber = blockNumber

    // block gasLimit polling shouldn't be in account-tracker shouldn't be here...
    const currentBlock = await this._query.getBlockByNumber(blockNumber, false)
    if (!currentBlock) return
    const currentBlockGasLimit = currentBlock.gasLimit
    this.store.updateState({ currentBlockGasLimit })

    try {
      await this._updateAccounts()
    } catch (err) {
      log.error(err)
    }
  }

  /**
   * balanceChecker is deployed on main eth (test)nets and requires a single call
   * for all other networks, calls this._updateAccount for each account in this.store
   *
   * @returns {Promise} after all account balances updated
   *
   */
  async _updateAccounts () {
    const accounts = this.store.getState().accounts
    const addresses = Object.keys(accounts)
    const currentNetwork = parseInt(this.network.getNetworkState())

    switch (currentNetwork) {
      case MAINNET_CODE:
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESS)
        break

      case RINKEBY_CODE:
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESS_RINKEBY)
        break

      case ROPSTEN_CODE:
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESS_ROPSTEN)
        break

      case KOVAN_CODE:
        await this._updateAccountsViaBalanceChecker(addresses, SINGLE_CALL_BALANCES_ADDRESS_KOVAN)
        break

      default:
        await Promise.all(addresses.map(this._updateAccount.bind(this)))
    }
  }

  /**
   * Updates the current balance of an account.
   *
   * @private
   * @param {string} address A hex address of a the account to be updated
   * @returns {Promise} after the account balance is updated
   *
   */
  async _updateAccount (address) {
    // query balance
    const balance = await this._query.getBalance(address)
    const result = { address, balance }
    // update accounts state
    const { accounts } = this.store.getState()
    // only populate if the entry is still present
    if (!accounts[address]) return
    accounts[address] = result
    this.store.updateState({ accounts })
  }

  /**
   * Updates current address balances from balanceChecker deployed contract instance
   * @param {*} addresses
   * @param {*} deployedContractAddress
   */
  async _updateAccountsViaBalanceChecker (addresses, deployedContractAddress) {
    const accounts = this.store.getState().accounts
    this.web3.setProvider(this._provider)
    const ethContract = this.web3.eth.contract(SINGLE_CALL_BALANCES_ABI).at(deployedContractAddress)
    const ethBalance = ['0x0']

    ethContract.balances(addresses, ethBalance, (error, result) => {
      if (error) {
        log.warn(`MetaMask - Account Tracker single call balance fetch failed`, error)
        return Promise.all(addresses.map(this._updateAccount.bind(this)))
      }
      addresses.forEach((address, index) => {
        const balance = bnToHex(result[index])
        accounts[address] = { address, balance }
      })
      this.store.updateState({ accounts })
    })
  }

}

module.exports = AccountTracker
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="diagnostics-reporter"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/diagnostics-reporter.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
诊断报告
</div>
<div style="margin-bottom:1em;">
通过 https://diagnostics.metamask.io/v1/orphanedAccounts 来获取
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
// 诊断报告
class DiagnosticsReporter {

  constructor ({ firstTimeInfo, version }) {
    this.firstTimeInfo = firstTimeInfo
    this.version = version
  }

  // 孤块
  async reportOrphans (orphans) {
    try {
      return await this.submit({
        accounts: Object.keys(orphans),
        metadata: {
          type: 'orphans',
        },
      })
    } catch (err) {
      console.error('DiagnosticsReporter - "reportOrphans" encountered an error:')
      console.error(err)
    }
  }

  // 多个Keyrings
  async reportMultipleKeyrings (rawKeyrings) {
    try {
      const keyrings = await Promise.all(rawKeyrings.map(async (keyring, index) => {
        return {
          index,
          type: keyring.type,
          accounts: await keyring.getAccounts(),
        }
      }))
      return await this.submit({
        accounts: [],
        metadata: {
          type: 'keyrings',
          keyrings,
        },
      })
    } catch (err) {
      console.error('DiagnosticsReporter - "reportMultipleKeyrings" encountered an error:')
      console.error(err)
    }
  }

  async submit (message) {
    try {
      // add metadata
      message.metadata.version = this.version
      message.metadata.firstTimeInfo = this.firstTimeInfo
      return await postData(message)
    } catch (err) {
      console.error('DiagnosticsReporter - "submit" encountered an error:')
      throw err
    }
  }

}

function postData (data) {
  const uri = 'https://diagnostics.metamask.io/v1/orphanedAccounts'
  return fetch(uri, {
    body: JSON.stringify(data), // must match 'Content-Type' header
    credentials: 'same-origin', // include, same-origin, *omit
    headers: {
      'content-type': 'application/json',
    },
    method: 'POST', // *GET, POST, PUT, DELETE, etc.
    mode: 'cors', // no-cors, cors, *same-origin
  })
}

module.exports = DiagnosticsReporter
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="message-manager"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/message-manager.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
</div>

<div style="margin-bottom:1em;">
eth_sign 接口数据制备<br />
负责管理-存储，添加，删除，更新-消息
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EventEmitter = require('events')
const ObservableStore = require('obs-store')
const ethUtil = require('ethereumjs-util')
const { errors: rpcErrors } = require('eth-json-rpc-errors')
const createId = require('./random-id')

/**
 * Represents, and contains data about, an 'eth_sign' type signature request. These are created when a signature for
 * an eth_sign call is requested.
 *
 * @see {@link https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign}
 *
 * @typedef {Object} Message
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the eth_sign method once the signature request is approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' with
 * always have a 'eth_sign' type.
 *
 */

// eth_sign 接口数据制备
module.exports = class MessageManager extends EventEmitter {

  /**
   * Controller in charge of managing - storing, adding, removing, updating - Messages.
   *
   * @typedef {Object} MessageManager
   * @param {Object} opts @deprecated
   * @property {Object} memStore The observable store where Messages are saved.
   * @property {Object} memStore.unapprovedMsgs A collection of all Messages in the 'unapproved' state
   * @property {number} memStore.unapprovedMsgCount The count of all Messages in this.memStore.unapprobedMsgs
   * @property {array} messages Holds all messages that have been created by this MessageManager
   *
   */
  constructor () {
    super()
    this.memStore = new ObservableStore({
      unapprovedMsgs: {},
      unapprovedMsgCount: 0,
    })
    this.messages = []
  }

  /**
   * A getter for the number of 'unapproved' Messages in this.messages
   *
   * @returns {number} The number of 'unapproved' Messages in this.messages
   *
   */
  get unapprovedMsgCount () {
    return Object.keys(this.getUnapprovedMsgs()).length
  }

  /**
   * A getter for the 'unapproved' Messages in this.messages
   *
   * @returns {Object} An index of Message ids to Messages, for all 'unapproved' Messages in this.messages
   *
   */
  getUnapprovedMsgs () {
    return this.messages.filter(msg => msg.status === 'unapproved')
      .reduce((result, msg) => { result[msg.id] = msg; return result }, {})
  }

  /**
   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the
   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.
   *
   * @param {Object} msgParams The params for the eth_sign call to be made after the message is approved.
   * @param {Object} req (optional) The original request object possibly containing the origin
   * @returns {promise} after signature has been
   *
   */
  addUnapprovedMessageAsync (msgParams, req) {
    return new Promise((resolve, reject) => {
      const msgId = this.addUnapprovedMessage(msgParams, req)
      // await finished
      this.once(`${msgId}:finished`, (data) => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig)
          case 'rejected':
            return reject(rpcErrors.eth.userRejectedRequest('MetaMask Message Signature: User denied message signature.'))
          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`))
        }
      })
    })
  }

  /**
   * Creates a new Message with an 'unapproved' status using the passed msgParams. this.addMsg is called to add the
   * new Message to this.messages, and to save the unapproved Messages from that list to this.memStore.
   *
   * @param {Object} msgParams The params for the eth_sign call to be made after the message is approved.
   * @param {Object} req (optional) The original request object where the origin may be specificied
   * @returns {number} The id of the newly created message.
   *
   */
  addUnapprovedMessage (msgParams, req) {
    // add origin from request
    if (req) msgParams.origin = req.origin
    msgParams.data = normalizeMsgData(msgParams.data)
    // create txData obj with parameters and meta data
    var time = (new Date()).getTime()
    var msgId = createId()
    var msgData = {
      id: msgId,
      msgParams: msgParams,
      time: time,
      status: 'unapproved',
      type: 'eth_sign',
    }
    this.addMsg(msgData)

    // signal update
    this.emit('update')
    return msgId
  }

  /**
   * Adds a passed Message to this.messages, and calls this._saveMsgList() to save the unapproved Messages from that
   * list to this.memStore.
   *
   * @param {Message} msg The Message to add to this.messages
   *
   */
  addMsg (msg) {
    this.messages.push(msg)
    this._saveMsgList()
  }

  /**
   * Returns a specified Message.
   *
   * @param {number} msgId The id of the Message to get
   * @returns {Message|undefined} The Message with the id that matches the passed msgId, or undefined if no Message has that id.
   *
   */
  getMsg (msgId) {
    return this.messages.find(msg => msg.id === msgId)
  }

  /**
   * Approves a Message. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise with
   * any the message params modified for proper signing.
   *
   * @param {Object} msgParams The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */
  approveMessage (msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId)
    return this.prepMsgForSigning(msgParams)
  }

  /**
   * Sets a Message status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the Message to approve.
   *
   */
  setMsgStatusApproved (msgId) {
    this._setMsgStatus(msgId, 'approved')
  }

  /**
   * Sets a Message status to 'signed' via a call to this._setMsgStatus and updates that Message in this.messages by
   * adding the raw signature data of the signature request to the Message
   *
   * @param {number} msgId The id of the Message to sign.
   * @param {buffer} rawSig The raw data of the signature request
   *
   */
  setMsgStatusSigned (msgId, rawSig) {
    const msg = this.getMsg(msgId)
    msg.rawSig = rawSig
    this._updateMsg(msg)
    this._setMsgStatus(msgId, 'signed')
  }

  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */
  prepMsgForSigning (msgParams) {
    delete msgParams.metamaskId
    return Promise.resolve(msgParams)
  }

  /**
   * Sets a Message status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the Message to reject.
   *
   */
  rejectMsg (msgId) {
    this._setMsgStatus(msgId, 'rejected')
  }

  /**
   * Updates the status of a Message in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId The id of the Message to update.
   * @param {string} status The new status of the Message.
   * @throws A 'MessageManager - Message not found for id: "${msgId}".' if there is no Message in this.messages with an
   * id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The Message is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along with the message
   *
   */
  _setMsgStatus (msgId, status) {
    const msg = this.getMsg(msgId)
    if (!msg) throw new Error('MessageManager - Message not found for id: "${msgId}".')
    msg.status = status
    this._updateMsg(msg)
    this.emit(`${msgId}:${status}`, msg)
    if (status === 'rejected' || status === 'signed') {
      this.emit(`${msgId}:finished`, msg)
    }
  }

  /**
   * Sets a Message in this.messages to the passed Message if the ids are equal. Then saves the unapprovedMsg list to
   * storage via this._saveMsgList
   *
   * @private
   * @param {msg} Message A Message that will replace an existing Message (with the same id) in this.messages
   *
   */
  _updateMsg (msg) {
    const index = this.messages.findIndex((message) => message.id === msg.id)
    if (index !== -1) {
      this.messages[index] = msg
    }
    this._saveMsgList()
  }

  /**
   * Saves the unapproved messages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */
  _saveMsgList () {
    const unapprovedMsgs = this.getUnapprovedMsgs()
    const unapprovedMsgCount = Object.keys(unapprovedMsgs).length
    this.memStore.updateState({ unapprovedMsgs, unapprovedMsgCount })
    this.emit('updateBadge')
  }

}

/**
 * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
 *
 * @param {any} data The buffer data to convert to a hex
 * @returns {string} A hex string conversion of the buffer data
 *
 */
function normalizeMsgData (data) {
  if (data.slice(0, 2) === '0x') {
    // data is already hex
    return data
  } else {
    // data is unicode, convert to hex
    return ethUtil.bufferToHex(Buffer.from(data, 'utf8'))
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="pending-balance-calculator"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/pending-balance-calculator.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
用于计算用户的待处理余额（当前余额 - 处理中的花费）
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const BN = require('ethereumjs-util').BN
const normalize = require('eth-sig-util').normalize

class PendingBalanceCalculator {

  /**
   * 用于计算用户的待处理余额（当前余额 - 处理中的花费）
   * Used for calculating a users "pending balance": their current balance minus the total possible cost of all their
   * pending transactions.
   *
   * @typedef {Object} PendingBalanceCalculator
   * @param {Function} getBalance Returns a promise of a BN of the current balance in Wei
   * @param {Function} getPendingTransactions Returns an array of TxMeta Objects, which have txParams properties,
   * which include value, gasPrice, and gas, all in a base=16 hex format.
   *
   */
  constructor ({ getBalance, getPendingTransactions }) {
    this.getPendingTransactions = getPendingTransactions
    this.getNetworkBalance = getBalance
  }

  /**
   * Returns the users "pending balance": their current balance minus the total possible cost of all their
   * pending transactions.
   *
   * @returns {Promise<string>} Promises a base 16 hex string that contains the user's "pending balance"
   *
   */
  async getBalance () {
    const results = await Promise.all([
      this.getNetworkBalance(),
      this.getPendingTransactions(),
    ])

    const [ balance, pending ] = results
    if (!balance) return undefined

    const pendingValue = pending.reduce((total, tx) => {
      return total.add(this.calculateMaxCost(tx))
    }, new BN(0))

    return `0x${balance.sub(pendingValue).toString(16)}`
  }

  /**
   * 计算交易的最大花费
   * Calculates the maximum possible cost of a single transaction, based on the value, gas price and gas limit.
   *
   * @param {object} tx Contains all that data about a transaction.
   * @property {object} tx.txParams Contains data needed to calculate the maximum cost of the transaction: gas,
   * gasLimit and value.
   *
   * @returns {string} Returns a base 16 hex string that contains the maximum possible cost of the transaction.
   */
  calculateMaxCost (tx) {
    const txValue = tx.txParams.value
    const value = this.hexToBn(txValue)
    const gasPrice = this.hexToBn(tx.txParams.gasPrice)

    const gas = tx.txParams.gas
    const gasLimit = tx.txParams.gasLimit
    const gasLimitBn = this.hexToBn(gas || gasLimit)

    const gasCost = gasPrice.mul(gasLimitBn)
    return value.add(gasCost)
  }

  /**
   * Converts a hex string to a BN object
   *
   * @param {string} hex A number represented as a hex string
   * @returns {Object} A BN object
   *
   */
  hexToBn (hex) {
    return new BN(normalize(hex).substring(2), 16)
  }

}

module.exports = PendingBalanceCalculator
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;">
    <c:title id="personal-message-manager"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/personal-message-manager.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
https://web3js.readthedocs.io/en/1.0/web3-eth-personal.html#sign
</div>
<div style="margin-bottom:1em;">
personal_sign 接口数据制备
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EventEmitter = require('events')
const ObservableStore = require('obs-store')
const ethUtil = require('ethereumjs-util')
const { errors: rpcErrors } = require('eth-json-rpc-errors')
const createId = require('./random-id')
const hexRe = /^[0-9A-Fa-f]+$/g
const log = require('loglevel')

/**
 * Represents, and contains data about, an 'personal_sign' type signature request. These are created when a
 * signature for an personal_sign call is requested.
 *
 * @see {@link https://web3js.readthedocs.io/en/1.0/web3-eth-personal.html#sign}
 *
 * @typedef {Object} PersonalMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the personal_sign method once the signature request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed' or 'rejected'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will
 * always have a 'personal_sign' type.
 *
 */

// personal_sign 接口数据制备
module.exports = class PersonalMessageManager extends EventEmitter {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - PersonalMessage.
   *
   * @typedef {Object} PersonalMessageManager
   * @param {Object} opts @deprecated
   * @property {Object} memStore The observable store where PersonalMessage are saved with persistance.
   * @property {Object} memStore.unapprovedPersonalMsgs A collection of all PersonalMessages in the 'unapproved' state
   * @property {number} memStore.unapprovedPersonalMsgCount The count of all PersonalMessages in this.memStore.unapprobedMsgs
   * @property {array} messages Holds all messages that have been created by this PersonalMessageManager
   *
   */
  constructor () {
    super()
    this.memStore = new ObservableStore({
      unapprovedPersonalMsgs: {},
      unapprovedPersonalMsgCount: 0,
    })
    this.messages = []
  }

  /**
   * A getter for the number of 'unapproved' PersonalMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' PersonalMessages in this.messages
   *
   */
  get unapprovedPersonalMsgCount () {
    return Object.keys(this.getUnapprovedMsgs()).length
  }

  /**
   * A getter for the 'unapproved' PersonalMessages in this.messages
   *
   * @returns {Object} An index of PersonalMessage ids to PersonalMessages, for all 'unapproved' PersonalMessages in
   * this.messages
   *
   */
  getUnapprovedMsgs () {
    return this.messages.filter(msg => msg.status === 'unapproved')
      .reduce((result, msg) => { result[msg.id] = msg; return result }, {})
  }

  /**
   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams The params for the eth_sign call to be made after the message is approved.
   * @param {Object} req (optional) The original request object possibly containing the origin
   * @returns {promise} When the message has been signed or rejected
   *
   */
  addUnapprovedMessageAsync (msgParams, req) {
    return new Promise((resolve, reject) => {
      if (!msgParams.from) {
        reject(new Error('MetaMask Message Signature: from field is required.'))
      }
      const msgId = this.addUnapprovedMessage(msgParams, req)
      this.once(`${msgId}:finished`, (data) => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig)
          case 'rejected':
            return reject(rpcErrors.eth.userRejectedRequest('MetaMask Message Signature: User denied message signature.'))
          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`))
        }
      })
    })
  }

  /**
   * Creates a new PersonalMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new PersonalMessage to this.messages, and to save the unapproved PersonalMessages from that list to
   * this.memStore.
   *
   * @param {Object} msgParams The params for the eth_sign call to be made after the message is approved.
   * @param {Object} req (optional) The original request object possibly containing the origin
   * @returns {number} The id of the newly created PersonalMessage.
   *
   */
  addUnapprovedMessage (msgParams, req) {
    log.debug(`PersonalMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`)
    // add origin from request
    if (req) msgParams.origin = req.origin
    msgParams.data = this.normalizeMsgData(msgParams.data)
    // create txData obj with parameters and meta data
    var time = (new Date()).getTime()
    var msgId = createId()
    var msgData = {
      id: msgId,
      msgParams: msgParams,
      time: time,
      status: 'unapproved',
      type: 'personal_sign',
    }
    this.addMsg(msgData)

    // signal update
    this.emit('update')
    return msgId
  }

  /**
   * Adds a passed PersonalMessage to this.messages, and calls this._saveMsgList() to save the unapproved PersonalMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg The PersonalMessage to add to this.messages
   *
   */
  addMsg (msg) {
    this.messages.push(msg)
    this._saveMsgList()
  }

  /**
   * Returns a specified PersonalMessage.
   *
   * @param {number} msgId The id of the PersonalMessage to get
   * @returns {PersonalMessage|undefined} The PersonalMessage with the id that matches the passed msgId, or undefined
   * if no PersonalMessage has that id.
   *
   */
  getMsg (msgId) {
    return this.messages.find(msg => msg.id === msgId)
  }

  /**
   * Approves a PersonalMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper signing.
   *
   * @param {Object} msgParams The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */
  approveMessage (msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId)
    return this.prepMsgForSigning(msgParams)
  }

  /**
   * Sets a PersonalMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the PersonalMessage to approve.
   *
   */
  setMsgStatusApproved (msgId) {
    this._setMsgStatus(msgId, 'approved')
  }

  /**
   * Sets a PersonalMessage status to 'signed' via a call to this._setMsgStatus and updates that PersonalMessage in
   * this.messages by adding the raw signature data of the signature request to the PersonalMessage
   *
   * @param {number} msgId The id of the PersonalMessage to sign.
   * @param {buffer} rawSig The raw data of the signature request
   *
   */
  setMsgStatusSigned (msgId, rawSig) {
    const msg = this.getMsg(msgId)
    msg.rawSig = rawSig
    this._updateMsg(msg)
    this._setMsgStatus(msgId, 'signed')
  }

  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */
  prepMsgForSigning (msgParams) {
    delete msgParams.metamaskId
    return Promise.resolve(msgParams)
  }

  /**
   * Sets a PersonalMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the PersonalMessage to reject.
   *
   */
  rejectMsg (msgId) {
    this._setMsgStatus(msgId, 'rejected')
  }

  /**
   * Updates the status of a PersonalMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId The id of the PersonalMessage to update.
   * @param {string} status The new status of the PersonalMessage.
   * @throws A 'PersonalMessageManager - PersonalMessage not found for id: "${msgId}".' if there is no PersonalMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The PersonalMessage is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along
   * with the PersonalMessage
   *
   */
  _setMsgStatus (msgId, status) {
    const msg = this.getMsg(msgId)
    if (!msg) throw new Error(`PersonalMessageManager - Message not found for id: "${msgId}".`)
    msg.status = status
    this._updateMsg(msg)
    this.emit(`${msgId}:${status}`, msg)
    if (status === 'rejected' || status === 'signed') {
      this.emit(`${msgId}:finished`, msg)
    }
  }

  /**
   * Sets a PersonalMessage in this.messages to the passed PersonalMessage if the ids are equal. Then saves the
   * unapprovedPersonalMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {msg} PersonalMessage A PersonalMessage that will replace an existing PersonalMessage (with the same
   * id) in this.messages
   *
   */
  _updateMsg (msg) {
    const index = this.messages.findIndex((message) => message.id === msg.id)
    if (index !== -1) {
      this.messages[index] = msg
    }
    this._saveMsgList()
  }

  /**
   * Saves the unapproved PersonalMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */
  _saveMsgList () {
    const unapprovedPersonalMsgs = this.getUnapprovedMsgs()
    const unapprovedPersonalMsgCount = Object.keys(unapprovedPersonalMsgs).length
    this.memStore.updateState({ unapprovedPersonalMsgs, unapprovedPersonalMsgCount })
    this.emit('updateBadge')
  }

  /**
   * A helper function that converts raw buffer data to a hex, or just returns the data if it is already formatted as a hex.
   *
   * @param {any} data The buffer data to convert to a hex
   * @returns {string} A hex string conversion of the buffer data
   *
   */
  normalizeMsgData (data) {
    try {
      const stripped = ethUtil.stripHexPrefix(data)
      if (stripped.match(hexRe)) {
        return ethUtil.addHexPrefix(stripped)
      }
    } catch (e) {
      log.debug(`Message was not hex encoded, interpreting as utf8.`)
    }

    return ethUtil.bufferToHex(Buffer.from(data, 'utf8'))
  }

}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="stream-utils"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/stream-utils.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
先要了解三个包的使用：
</div>

<h3><b>through2</b></h3>
<div style="margin-bottom:1em;">
<a href="https://github.com/rvagg/through2">https://github.com/rvagg/through2</a>
</div>

<div style="margin-bottom:1em;">
A tiny wrapper around Node.js streams.Transform (Streams2/3) to avoid explicit subclassing noise
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
var all = []

fs.createReadStream('data.csv')
  .pipe(csv2())
  .pipe(through2.obj(function (chunk, enc, callback) {
    var data = {
        name    : chunk[0]
      , address : chunk[3]
      , phone   : chunk[10]
    }
    this.push(data)

    callback()
  }))
  .on('data', (data) => {
    all.push(data)
  })
  .on('end', () => {
    doSomethingSpecial(all)
  })
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
<div style="margin-top:1em;">
through2 经常被用于处理 node 的 stream，本质上就是对于 node 原生的 transform 流进行的封装，更易于使用。
</div>
<h3><b>obj-multiplex</b></h3>
<div style="margin-bottom:1em;">
https://github.com/kumavis/obj-multiplex
</div>
<div style="margin-bottom:1em;">
就是一个多路复用流能够使用 name 来区分各个子流，以达到一个 parent 流下其实有多个子流在运行，可以通过多个子流来读入写出数据，效率更高。而且parent流结束了，则所有子流也会被销毁。
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
// create multiplexer
const mux = new ObjMultiplex()

// setup substreams
const streamA = mux.createStream('hello')
const streamB = mux.createStream('world')

// pipe over transport (and back)
mux.pipe(transport).pipe(mux)

// send values over the substreams
streamA.write({ thisIsAn: 'object' })
streamA.write(123)

// or pipe together normally
streamB.pipe(evilAiBrain).pipe(streamB)
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
<h3><b>pump</b></h3>
<div style="margin-bottom:1em;">
<a href="https://github.com/mafintosh/pump">https://github.com/mafintosh/pump</a>
</div>
<div style="margin-bottom:1em;">
将流连接在一起并关闭所有流（如果其中一个关闭）
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
var pump = require('pump')
var fs = require('fs')

var source = fs.createReadStream('/dev/random')
var dest = fs.createWriteStream('/dev/null')

pump(source, dest, function(err) {
  console.log('pipe finished', err)
})

setTimeout(function() {
  dest.destroy() // when dest is closed pump will destroy source
}, 1000)
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
var transform = someTransformStream()

pump(source, transform, anotherTransform, dest, function(err) {
  console.log('pipe finished', err)
})
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
return pump(s1, s2) // returns s2
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="代码" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const Through = require('through2')
const ObjectMultiplex = require('obj-multiplex')
const pump = require('pump')

// https://github.com/rvagg/through2
// https://github.com/kumavis/obj-multiplex
// https://github.com/mafintosh/pump

module.exports = {
  jsonParseStream: jsonParseStream,
  jsonStringifyStream: jsonStringifyStream,
  setupMultiplex: setupMultiplex,
}

/**
 * 返回 JSON.parse 后的 stream
 * Returns a stream transform that parses JSON strings passing through
 * @return {stream.Transform}
 */
function jsonParseStream () {
  return Through.obj(function (serialized, _, cb) {
    this.push(JSON.parse(serialized))
    cb()
  })
}

/**
 * 返回 JSON.stringify 后的 stream
 * Returns a stream transform that calls {@code JSON.stringify}
 * on objects passing through
 * @return {stream.Transform} the stream transform
 */
function jsonStringifyStream () {
  return Through.obj(function (obj, _, cb) {
    this.push(JSON.stringify(obj))
    cb()
  })
}

/**
 * 把 stream 转换成多路复用 stream
 * Sets up stream multiplexing for the given stream
 * @param {any} connectionStream - the stream to mux
 * @return {stream.Stream} the multiplexed stream
 */
function setupMultiplex (connectionStream) {
  const mux = new ObjectMultiplex()
  pump(
    connectionStream,
    mux,
    connectionStream,
    (err) => {
      if (err) console.error(err)
    }
  )
  return mux
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="typed-message-manager"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/typed-message-manager.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
先要了解 ETH 的签名方法：
</div>
<div style="margin-bottom:1em;">
https://www.yuque.com/jnoodle/blockchain/wsk66p#NJ9Xh
</div>
<div style="margin-bottom:1em;">
eth_signTypedData 接口数据制备
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const EventEmitter = require('events')
const ObservableStore = require('obs-store')
const createId = require('./random-id')
const assert = require('assert')
const { errors: rpcErrors } = require('eth-json-rpc-errors')
const sigUtil = require('eth-sig-util')
const log = require('loglevel')
const jsonschema = require('jsonschema')

/**
 * Represents, and contains data about, an 'eth_signTypedData' type signature request. These are created when a
 * signature for an eth_signTypedData call is requested.
 *
 * @typedef {Object} TypedMessage
 * @property {number} id An id to track and identify the message object
 * @property {Object} msgParams The parameters to pass to the eth_signTypedData method once the signature request is
 * approved.
 * @property {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
 * @property {Object} msgParams.from The address that is making the signature request.
 * @property {string} msgParams.data A hex string conversion of the raw buffer data of the signature request
 * @property {number} time The epoch time at which the this message was created
 * @property {string} status Indicates whether the signature request is 'unapproved', 'approved', 'signed', 'rejected', or 'errored'
 * @property {string} type The json-prc signing method for which a signature request has been made. A 'Message' will
 * always have a 'eth_signTypedData' type.
 *
 */

// eth_signTypedData 接口数据制备
module.exports = class TypedMessageManager extends EventEmitter {
  /**
   * Controller in charge of managing - storing, adding, removing, updating - TypedMessage.
   */
  constructor ({ networkController }) {
    super()
    this.networkController = networkController
    this.memStore = new ObservableStore({
      unapprovedTypedMessages: {},
      unapprovedTypedMessagesCount: 0,
    })
    this.messages = []
  }

  /**
   * A getter for the number of 'unapproved' TypedMessages in this.messages
   *
   * @returns {number} The number of 'unapproved' TypedMessages in this.messages
   *
   */
  get unapprovedTypedMessagesCount () {
    return Object.keys(this.getUnapprovedMsgs()).length
  }

  /**
   * A getter for the 'unapproved' TypedMessages in this.messages
   *
   * @returns {Object} An index of TypedMessage ids to TypedMessages, for all 'unapproved' TypedMessages in
   * this.messages
   *
   */
  getUnapprovedMsgs () {
    return this.messages.filter(msg => msg.status === 'unapproved')
      .reduce((result, msg) => { result[msg.id] = msg; return result }, {})
  }

  /**
   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to
   * this.memStore. Before any of this is done, msgParams are validated
   *
   * @param {Object} msgParams The params for the eth_sign call to be made after the message is approved.
   * @param {Object} req (optional) The original request object possibly containing the origin
   * @returns {promise} When the message has been signed or rejected
   *
   */
  addUnapprovedMessageAsync (msgParams, req, version) {
    return new Promise((resolve, reject) => {
      const msgId = this.addUnapprovedMessage(msgParams, req, version)
      this.once(`${msgId}:finished`, (data) => {
        switch (data.status) {
          case 'signed':
            return resolve(data.rawSig)
          case 'rejected':
            return reject(rpcErrors.eth.userRejectedRequest('MetaMask Message Signature: User denied message signature.'))
          case 'errored':
            return reject(new Error(`MetaMask Message Signature: ${data.error}`))
          default:
            return reject(new Error(`MetaMask Message Signature: Unknown problem: ${JSON.stringify(msgParams)}`))
        }
      })
    })
  }

  /**
   * Creates a new TypedMessage with an 'unapproved' status using the passed msgParams. this.addMsg is called to add
   * the new TypedMessage to this.messages, and to save the unapproved TypedMessages from that list to
   * this.memStore. Before any of this is done, msgParams are validated
   *
   * @param {Object} msgParams The params for the eth_sign call to be made after the message is approved.
   * @param {Object} req (optional) The original request object possibly containing the origin
   * @returns {number} The id of the newly created TypedMessage.
   *
   */
  addUnapprovedMessage (msgParams, req, version) {
    msgParams.version = version
    this.validateParams(msgParams)
    // add origin from request
    if (req) msgParams.origin = req.origin

    log.debug(`TypedMessageManager addUnapprovedMessage: ${JSON.stringify(msgParams)}`)
    // create txData obj with parameters and meta data
    var time = (new Date()).getTime()
    var msgId = createId()
    var msgData = {
      id: msgId,
      msgParams: msgParams,
      time: time,
      status: 'unapproved',
      type: 'eth_signTypedData',
    }
    this.addMsg(msgData)

    // signal update
    this.emit('update')
    return msgId
  }

  /**
   * 根据调用方法版本不同使用不同的验证
   * Helper method for this.addUnapprovedMessage. Validates that the passed params have the required properties.
   *
   * @param {Object} params The params to validate
   *
   */
  validateParams (params) {
    switch (params.version) {
      case 'V1':
        assert.equal(typeof params, 'object', 'Params should ben an object.')
        assert.ok('data' in params, 'Params must include a data field.')
        assert.ok('from' in params, 'Params must include a from field.')
        assert.ok(Array.isArray(params.data), 'Data should be an array.')
        assert.equal(typeof params.from, 'string', 'From field must be a string.')
        assert.doesNotThrow(() => {
          sigUtil.typedSignatureHash(params.data)
        }, 'Expected EIP712 typed data')
        break
      case 'V3':
      case 'V4':
        let data
        assert.equal(typeof params, 'object', 'Params should be an object.')
        assert.ok('data' in params, 'Params must include a data field.')
        assert.ok('from' in params, 'Params must include a from field.')
        assert.equal(typeof params.from, 'string', 'From field must be a string.')
        assert.equal(typeof params.data, 'string', 'Data must be passed as a valid JSON string.')
        assert.doesNotThrow(() => { data = JSON.parse(params.data) }, 'Data must be passed as a valid JSON string.')
        const validation = jsonschema.validate(data, sigUtil.TYPED_MESSAGE_SCHEMA)
        assert.ok(data.primaryType in data.types, `Primary type of "${data.primaryType}" has no type definition.`)
        assert.equal(validation.errors.length, 0, 'Data must conform to EIP-712 schema. See https://git.io/fNtcx.')
        const chainId = data.domain.chainId
        const activeChainId = parseInt(this.networkController.getNetworkState())
        chainId && assert.equal(chainId, activeChainId, `Provided chainId (${chainId}) must match the active chainId (${activeChainId})`)
        break
    }
  }

  /**
   * Adds a passed TypedMessage to this.messages, and calls this._saveMsgList() to save the unapproved TypedMessages from that
   * list to this.memStore.
   *
   * @param {Message} msg The TypedMessage to add to this.messages
   *
   */
  addMsg (msg) {
    this.messages.push(msg)
    this._saveMsgList()
  }

  /**
   * Returns a specified TypedMessage.
   *
   * @param {number} msgId The id of the TypedMessage to get
   * @returns {TypedMessage|undefined} The TypedMessage with the id that matches the passed msgId, or undefined
   * if no TypedMessage has that id.
   *
   */
  getMsg (msgId) {
    return this.messages.find(msg => msg.id === msgId)
  }

  /**
   * Approves a TypedMessage. Sets the message status via a call to this.setMsgStatusApproved, and returns a promise
   * with any the message params modified for proper signing.
   *
   * @param {Object} msgParams The msgParams to be used when eth_sign is called, plus data added by MetaMask.
   * @param {Object} msgParams.metamaskId Added to msgParams for tracking and identification within MetaMask.
   * @returns {Promise<object>} Promises the msgParams object with metamaskId removed.
   *
   */
  approveMessage (msgParams) {
    this.setMsgStatusApproved(msgParams.metamaskId)
    return this.prepMsgForSigning(msgParams)
  }

  /**
   * Sets a TypedMessage status to 'approved' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the TypedMessage to approve.
   *
   */
  setMsgStatusApproved (msgId) {
    this._setMsgStatus(msgId, 'approved')
  }

  /**
   * Sets a TypedMessage status to 'signed' via a call to this._setMsgStatus and updates that TypedMessage in
   * this.messages by adding the raw signature data of the signature request to the TypedMessage
   *
   * @param {number} msgId The id of the TypedMessage to sign.
   * @param {buffer} rawSig The raw data of the signature request
   *
   */
  setMsgStatusSigned (msgId, rawSig) {
    const msg = this.getMsg(msgId)
    msg.rawSig = rawSig
    this._updateMsg(msg)
    this._setMsgStatus(msgId, 'signed')
  }

  /**
   * Removes the metamaskId property from passed msgParams and returns a promise which resolves the updated msgParams
   *
   * @param {Object} msgParams The msgParams to modify
   * @returns {Promise<object>} Promises the msgParams with the metamaskId property removed
   *
   */
  prepMsgForSigning (msgParams) {
    delete msgParams.metamaskId
    delete msgParams.version
    return Promise.resolve(msgParams)
  }

  /**
   * Sets a TypedMessage status to 'rejected' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the TypedMessage to reject.
   *
   */
  rejectMsg (msgId) {
    this._setMsgStatus(msgId, 'rejected')
  }

  /**
   * Sets a TypedMessage status to 'errored' via a call to this._setMsgStatus.
   *
   * @param {number} msgId The id of the TypedMessage to error
   *
   */
  errorMessage (msgId, error) {
    const msg = this.getMsg(msgId)
    msg.error = error
    this._updateMsg(msg)
    this._setMsgStatus(msgId, 'errored')
  }

  //
  // PRIVATE METHODS
  //

  /**
   * Updates the status of a TypedMessage in this.messages via a call to this._updateMsg
   *
   * @private
   * @param {number} msgId The id of the TypedMessage to update.
   * @param {string} status The new status of the TypedMessage.
   * @throws A 'TypedMessageManager - TypedMessage not found for id: "${msgId}".' if there is no TypedMessage
   * in this.messages with an id equal to the passed msgId
   * @fires An event with a name equal to `${msgId}:${status}`. The TypedMessage is also fired.
   * @fires If status is 'rejected' or 'signed', an event with a name equal to `${msgId}:finished` is fired along
   * with the TypedMessage
   *
   */
  _setMsgStatus (msgId, status) {
    const msg = this.getMsg(msgId)
    if (!msg) throw new Error('TypedMessageManager - Message not found for id: "${msgId}".')
    msg.status = status
    this._updateMsg(msg)
    this.emit(`${msgId}:${status}`, msg)
    if (status === 'rejected' || status === 'signed' || status === 'errored') {
      this.emit(`${msgId}:finished`, msg)
    }
  }

  /**
   * Sets a TypedMessage in this.messages to the passed TypedMessage if the ids are equal. Then saves the
   * unapprovedTypedMsgs index to storage via this._saveMsgList
   *
   * @private
   * @param {msg} TypedMessage A TypedMessage that will replace an existing TypedMessage (with the same
   * id) in this.messages
   *
   */
  _updateMsg (msg) {
    const index = this.messages.findIndex((message) => message.id === msg.id)
    if (index !== -1) {
      this.messages[index] = msg
    }
    this._saveMsgList()
  }

  /**
   * Saves the unapproved TypedMessages, and their count, to this.memStore
   *
   * @private
   * @fires 'updateBadge'
   *
   */
  _saveMsgList () {
    const unapprovedTypedMessages = this.getUnapprovedMsgs()
    const unapprovedTypedMessagesCount = Object.keys(unapprovedTypedMessages).length
    this.memStore.updateState({ unapprovedTypedMessages, unapprovedTypedMessagesCount })
    this.emit('updateBadge')
  }

}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="lib-util"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/lib/util.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
一些常用工具方法
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const ethUtil = require('ethereumjs-util')
const assert = require('assert')
const BN = require('bn.js')
const {
  ENVIRONMENT_TYPE_POPUP,
  ENVIRONMENT_TYPE_NOTIFICATION,
  ENVIRONMENT_TYPE_FULLSCREEN,
  ENVIRONMENT_TYPE_BACKGROUND,
  PLATFORM_FIREFOX,
  PLATFORM_OPERA,
  PLATFORM_CHROME,
  PLATFORM_EDGE,
  PLATFORM_BRAVE,
} = require('./enums')

// 一些常用工具方法

/**
 * 生成堆栈跟踪示例
 * Generates an example stack trace
 *
 * @returns {string} A stack trace
 *
 */
function getStack () {
  const stack = new Error('Stack trace generator - not an error').stack
  return stack
}

/**
 * 检测窗口类型（根据访问的页面）
 * Used to determine the window type through which the app is being viewed.
 *  - 'popup' refers to the extension opened through the browser app icon (in top right corner in chrome and firefox)
 *  - 'responsive' refers to the main browser window
 *  - 'notification' refers to the popup that appears in its own window when taking action outside of metamask
 *  - 'background' refers to the background page
 *
 * @returns {string} A single word label that represents the type of window through which the app is being viewed
 *
 */
const getEnvironmentType = (url = window.location.href) => {
  const parsedUrl = new URL(url)
  if (parsedUrl.pathname === '/popup.html') {
    return ENVIRONMENT_TYPE_POPUP
  } else if (['/home.html', '/phishing.html'].includes(parsedUrl.pathname)) {
    return ENVIRONMENT_TYPE_FULLSCREEN
  } else if (parsedUrl.pathname === '/notification.html') {
    return ENVIRONMENT_TYPE_NOTIFICATION
  } else {
    return ENVIRONMENT_TYPE_BACKGROUND
  }
}

/**
 * 返回运行扩展程序的平台（浏览器）
 * Returns the platform (browser) where the extension is running.
 *
 * @returns {string} the platform ENUM
 *
 */
const getPlatform = _ => {
  const ua = navigator.userAgent
  if (ua.search('Firefox') !== -1) {
    return PLATFORM_FIREFOX
  } else {
    if (window && window.chrome && window.chrome.ipcRenderer) {
      return PLATFORM_BRAVE
    } else if (ua.search('Edge') !== -1) {
      return PLATFORM_EDGE
    } else if (ua.search('OPR') !== -1) {
      return PLATFORM_OPERA
    } else {
      return PLATFORM_CHROME
    }
  }
}

/**
 * 检查给定的以十六进制字符串表示的ETH余额是否足以支付 gas fee
 * Checks whether a given balance of ETH, represented as a hex string, is sufficient to pay a value plus a gas fee
 *
 * @param {object} txParams Contains data about a transaction
 * @param {string} txParams.gas The gas for a transaction
 * @param {string} txParams.gasPrice The price per gas for the transaction
 * @param {string} txParams.value The value of ETH to send
 * @param {string} hexBalance A balance of ETH represented as a hex string
 * @returns {boolean} Whether the balance is greater than or equal to the value plus the value of gas times gasPrice
 *
 */
function sufficientBalance (txParams, hexBalance) {
  // validate hexBalance is a hex string
  assert.equal(typeof hexBalance, 'string', 'sufficientBalance - hexBalance is not a hex string')
  assert.equal(hexBalance.slice(0, 2), '0x', 'sufficientBalance - hexBalance is not a hex string')

  const balance = hexToBn(hexBalance)
  const value = hexToBn(txParams.value)
  const gasLimit = hexToBn(txParams.gas)
  const gasPrice = hexToBn(txParams.gasPrice)

  const maxCost = value.add(gasLimit.mul(gasPrice))
  return balance.gte(maxCost)
}

/**
 * 将 BN 对象转换为前缀为“0x”的十六进制字符串
 * Converts a BN object to a hex string with a '0x' prefix
 *
 * @param {BN} inputBn The BN to convert to a hex string
 * @returns {string} A '0x' prefixed hex string
 *
 */
function bnToHex (inputBn) {
  return ethUtil.addHexPrefix(inputBn.toString(16))
}

/**
 * 将十六进制字符串转换为BN对象
 * Converts a hex string to a BN object
 *
 * @param {string} inputHex A number represented as a hex string
 * @returns {Object} A BN object
 *
 */
function hexToBn (inputHex) {
  return new BN(ethUtil.stripHexPrefix(inputHex), 16)
}

/**
 * 用于将BN乘以分数
 * Used to multiply a BN by a fraction
 *
 * @param {BN} targetBN The number to multiply by a fraction
 * @param {number|string} numerator The numerator of the fraction multiplier
 * @param {number|string} denominator The denominator of the fraction multiplier
 * @returns {BN} The product of the multiplication
 *
 */
function BnMultiplyByFraction (targetBN, numerator, denominator) {
  const numBN = new BN(numerator)
  const denomBN = new BN(denominator)
  return targetBN.mul(numBN).div(denomBN)
}

// 增加 listener
function applyListeners (listeners, emitter) {
  Object.keys(listeners).forEach((key) => {
    emitter.on(key, listeners[key])
  })
}

// 移除 listener
function removeListeners (listeners, emitter) {
  Object.keys(listeners).forEach((key) => {
    emitter.removeListener(key, listeners[key])
  })
}

// 数组中随机取一个元素
function getRandomArrayItem (array) {
  return array[Math.floor((Math.random() * array.length))]
}

module.exports = {
  removeListeners,
  applyListeners,
  getPlatform,
  getStack,
  getEnvironmentType,
  sufficientBalance,
  hexToBn,
  bnToHex,
  BnMultiplyByFraction,
  getRandomArrayItem,
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="scripts-background"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/background.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
  <img style="width:450px;" src="/images/ether/1578196111993-4d6eee87-5d95-4a34-9640-54aa4dd9a70d.png" />
</div>
<div style="margin-bottom:1em;line-height:1.825em">
从架构图可以了解浏览器后台进行操作的地方，它就是页面和区块链进行交互的中间部分。
参考：https://www.yuque.com/jnoodle/blockchain/vuiigi#dmOM4
</div>
<div style="margin-bottom:1em;line-height:1.825em;">
background.js 完成的事情：
</div>
<ul style="margin-top:.325em;list-style: disc;margin-left: 1.5em;line-height:1.825em;">
  <li>Defining how to open the UI for new messages, transactions, and even requests to unlock (reveal to the site) their account. 定义如何为新消息、事务、甚至为解锁(向站点显示)其帐户的请求打开UI</li>
  <li>Provide the instance's initial state, leaving MetaMask persistence to the platform. 提供实例的初始状态，将MetaMask持久化保留到平台
  <li>Providing a platform object. This is becoming our catch-all adapter for platforms to define a few other platform-variant features we require, like opening a web link. (Soon we will be moving encryption out here too, since our browser-encryption isn't portable enough!) </li>提供平台对象。这将成为平台的通用适配器，用于定义我们需要的其他一些平台变体特性，比如打开web链接。(不久我们也将把加密技术移到这里，因为我们的浏览器加密还不够便携!)</li>
</ul>
<div style="margin-bottom:1em;line-height:1.825em">
注意 background.js 里面的很多方法要结合 metamask-controller.js 一起看，才能更清楚理解。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
/**
 * Web扩展单例过程的入口点
 * @file The entry point for the web extension singleton process.
 */


// these need to run before anything else
require('./lib/freezeGlobals')
require('./lib/setupFetchDebugging')()

// polyfills
import 'abortcontroller-polyfill/dist/polyfill-patch-fetch'

const endOfStream = require('end-of-stream')
const pump = require('pump')
const debounce = require('debounce-stream')
const log = require('loglevel')
const extension = require('extensionizer')
const LocalStore = require('./lib/local-store')
const storeTransform = require('obs-store/lib/transform')
const asStream = require('obs-store/lib/asStream')
const ExtensionPlatform = require('./platforms/extension')
const Migrator = require('./lib/migrator/')
const migrations = require('./migrations/')
const PortStream = require('extension-port-stream')
const createStreamSink = require('./lib/createStreamSink')
const NotificationManager = require('./lib/notification-manager.js')
const MetamaskController = require('./metamask-controller')
const rawFirstTimeState = require('./first-time-state')
const setupSentry = require('./lib/setupSentry')
const reportFailedTxToSentry = require('./lib/reportFailedTxToSentry')
const setupMetamaskMeshMetrics = require('./lib/setupMetamaskMeshMetrics')
const EdgeEncryptor = require('./edge-encryptor')
const getFirstPreferredLangCode = require('./lib/get-first-preferred-lang-code')
const getObjStructure = require('./lib/getObjStructure')
const setupEnsIpfsResolver = require('./lib/ens-ipfs/setup')

const {
  ENVIRONMENT_TYPE_POPUP,
  ENVIRONMENT_TYPE_NOTIFICATION,
  ENVIRONMENT_TYPE_FULLSCREEN,
} = require('./lib/enums')

// 用于 e2e 测试
// METAMASK_TEST_CONFIG is used in e2e tests to set the default network to localhost
const firstTimeState = Object.assign({}, rawFirstTimeState, global.METAMASK_TEST_CONFIG)

const METAMASK_DEBUG = process.env.METAMASK_DEBUG

log.setDefaultLevel(process.env.METAMASK_DEBUG ? 'debug' : 'warn')

const platform = new ExtensionPlatform()
const notificationManager = new NotificationManager()
global.METAMASK_NOTIFIER = notificationManager

// setup sentry error reporting
const release = platform.getVersion()
const sentry = setupSentry({ release })

// browser check if it is Edge - https://stackoverflow.com/questions/9847580/how-to-detect-safari-chrome-ie-firefox-and-opera-browser
// Internet Explorer 6-11
const isIE = !!document.documentMode
// Edge 20+
const isEdge = !isIE && !!window.StyleMedia

let popupIsOpen = false
let notificationIsOpen = false
const openMetamaskTabsIDs = {}

// state persistence
const localStore = new LocalStore()
let versionedData

// initialization flow
initialize().catch(log.error)

// setup metamask mesh testing container
const { submitMeshMetricsEntry } = setupMetamaskMeshMetrics()


/**
 * TransactionMeta 代表一个交易
 *
 * An object representing a transaction, in whatever state it is in.
 * @typedef TransactionMeta
 *
 * @property {number} id - An internally unique tx identifier.
 * @property {number} time - Time the tx was first suggested, in unix epoch time (ms).
 * @property {string} status - The current transaction status (unapproved, signed, submitted, dropped, failed, rejected), as defined in `tx-state-manager.js`.
 * @property {string} metamaskNetworkId - The transaction's network ID, used for EIP-155 compliance.
 * @property {boolean} loadingDefaults - TODO: Document
 * @property {Object} txParams - The tx params as passed to the network provider.
 * @property {Object[]} history - A history of mutations to this TransactionMeta object.
 * @property {boolean} gasPriceSpecified - True if the suggesting dapp specified a gas price, prevents auto-estimation.
 * @property {boolean} gasLimitSpecified - True if the suggesting dapp specified a gas limit, prevents auto-estimation.
 * @property {string} estimatedGas - A hex string represented the estimated gas limit required to complete the transaction.
 * @property {string} origin - A string representing the interface that suggested the transaction.
 * @property {Object} nonceDetails - A metadata object containing information used to derive the suggested nonce, useful for debugging nonce issues.
 * @property {string} rawTx - A hex string of the final signed transaction, ready to submit to the network.
 * @property {string} hash - A hex string of the transaction hash, used to identify the transaction on the network.
 * @property {number} submittedTime - The time the transaction was submitted to the network, in Unix epoch time (ms).
 */

/**
 * MetaMaskState 从MetaMaskController.store EventEmitter发出的数据，
 * 也用于初始化MetaMaskController。在UI上的React状态中可以作为 state.metamask 使用
 *
 * The data emitted from the MetaMaskController.store EventEmitter, also used to initialize the MetaMaskController. Available in UI on React state as state.metamask.
 * @typedef MetaMaskState
 * @property {boolean} isInitialized - Whether the first vault has been created.
 * @property {boolean} isUnlocked - Whether the vault is currently decrypted and accounts are available for selection.
 * @property {boolean} isAccountMenuOpen - Represents whether the main account selection UI is currently displayed.
 * @property {boolean} isPopup - Returns true if the current view is an externally-triggered notification.
 * @property {string} rpcTarget - DEPRECATED - The URL of the current RPC provider.
 * @property {Object} identities - An object matching lower-case hex addresses to Identity objects with "address" and "name" (nickname) keys.
 * @property {Object} unapprovedTxs - An object mapping transaction hashes to unapproved transactions.
 * @property {Array} frequentRpcList - A list of frequently used RPCs, including custom user-provided ones.
 * @property {Array} addressBook - A list of previously sent to addresses.
 * @property {address} selectedTokenAddress - Used to indicate if a token is globally selected. Should be deprecated in favor of UI-centric token selection.
 * @property {Object} tokenExchangeRates - Info about current token prices.
 * @property {Array} tokens - Tokens held by the current user, including their balances.
 * @property {Object} send - TODO: Document
 * @property {Object} coinOptions - TODO: Document
 * @property {boolean} useBlockie - Indicates preferred user identicon format. True for blockie, false for Jazzicon.
 * @property {Object} featureFlags - An object for optional feature flags.
 * @property {string} networkEndpointType - TODO: Document
 * @property {boolean} welcomeScreen - True if welcome screen should be shown.
 * @property {string} currentLocale - A locale string matching the user's preferred display language.
 * @property {Object} provider - The current selected network provider.
 * @property {string} provider.rpcTarget - The address for the RPC API, if using an RPC API.
 * @property {string} provider.type - An identifier for the type of network selected, allows MetaMask to use custom provider strategies for known networks.
 * @property {string} network - A stringified number of the current network ID.
 * @property {Object} accounts - An object mapping lower-case hex addresses to objects with "balance" and "address" keys, both storing hex string values.
 * @property {hex} currentBlockGasLimit - The most recently seen block gas limit, in a lower case hex prefixed string.
 * @property {TransactionMeta[]} selectedAddressTxList - An array of transactions associated with the currently selected account.
 * @property {Object} unapprovedMsgs - An object of messages associated with the currently selected account, mapping a unique ID to the options.
 * @property {number} unapprovedMsgCount - The number of messages in unapprovedMsgs.
 * @property {Object} unapprovedPersonalMsgs - An object of messages associated with the currently selected account, mapping a unique ID to the options.
 * @property {number} unapprovedPersonalMsgCount - The number of messages in unapprovedPersonalMsgs.
 * @property {Object} unapprovedTypedMsgs - An object of messages associated with the currently selected account, mapping a unique ID to the options.
 * @property {number} unapprovedTypedMsgCount - The number of messages in unapprovedTypedMsgs.
 * @property {string[]} keyringTypes - An array of unique keyring identifying strings, representing available strategies for creating accounts.
 * @property {Keyring[]} keyrings - An array of keyring descriptions, summarizing the accounts that are available for use, and what keyrings they belong to.
 * @property {string} currentAccountTab - A view identifying string for displaying the current displayed view, allows user to have a preferred tab in the old UI (between tokens and history).
 * @property {string} selectedAddress - A lower case hex string of the currently selected address.
 * @property {string} currentCurrency - A string identifying the user's preferred display currency, for use in showing conversion rates.
 * @property {number} conversionRate - A number representing the current exchange rate from the user's preferred currency to Ether.
 * @property {number} conversionDate - A unix epoch date (ms) for the time the current conversion rate was last retrieved.
 * @property {Object} infuraNetworkStatus - An object of infura network status checks.
 * @property {Block[]} recentBlocks - An array of recent blocks, used to calculate an effective but cheap gas price.
 * @property {Array} shapeShiftTxList - An array of objects describing shapeshift exchange attempts.
 * @property {boolean} forgottenPassword - Returns true if the user has initiated the password recovery screen, is recovering from seed phrase.
 */

/**
 * VersionedData 版本信息
 * @typedef VersionedData
 * @property {MetaMaskState} data - The data emitted from MetaMask controller, or used to initialize it.
 * @property {Number} version - The latest migration version that has been run.
 */

/**
 * 初始化MetaMask控制器，并设置所有平台配置。

 * Initializes the MetaMask controller, and sets up all platform configuration.
 * @returns {Promise} Setup complete.
 */
async function initialize () {
  const initState = await loadStateFromPersistence()
  const initLangCode = await getFirstPreferredLangCode()
  await setupController(initState, initLangCode)
  log.debug('MetaMask initialization complete.')
}

//
// State and Persistence
//

/**
 * 加载存储的数据
 * Loads any stored data, prioritizing the latest storage strategy.
 * Migrates that data schema in case it was last loaded on an older version.
 * @returns {Promise<MetaMaskState>} Last data emitted from previous instance of MetaMask.
 */
async function loadStateFromPersistence () {
  // migrations
  const migrator = new Migrator({ migrations })

  // 先从本地读取，没有则初始化生成
  // read from disk
  // first from preferred, async API:
  versionedData = (await localStore.get()) ||
                  migrator.generateInitialState(firstTimeState)

  // check if somehow state is empty
  // this should never happen but new error reporting suggests that it has
  // for a small number of users
  // https://github.com/metamask/metamask-extension/issues/3919
  if (versionedData && !versionedData.data) {
    // unable to recover, clear state
    versionedData = migrator.generateInitialState(firstTimeState)
    sentry.captureMessage('MetaMask - Empty vault found - unable to recover')
  }

  // report migration errors to sentry
  migrator.on('error', (err) => {
    // get vault structure without secrets
    const vaultStructure = getObjStructure(versionedData)
    sentry.captureException(err, {
      // "extra" key is required by Sentry
      extra: { vaultStructure },
    })
  })

  // migrate data
  versionedData = await migrator.migrateData(versionedData)
  if (!versionedData) {
    throw new Error('MetaMask - migrator returned undefined')
  }

  // write to disk
  if (localStore.isSupported) {
    localStore.set(versionedData)
  } else {
    // throw in setTimeout so as to not block boot
    setTimeout(() => {
      throw new Error('MetaMask - Localstore not supported')
    })
  }

  // return just the data
  return versionedData.data
}

/**
 * 使用初始状态和默认语言来初始化 MetaMask Controller
 * Initializes the MetaMask Controller with any initial state and default language.
 * Configures platform-specific error reporting strategy.
 * Streams emitted state updates to platform-specific storage strategy.
 * Creates platform listeners for new Dapps/Contexts, and sets up their data connections to the controller.
 *
 * @param {Object} initState - The initial state to start the controller with, matches the state that is emitted from the controller.
 * @param {String} initLangCode - The region code for the language preferred by the current user.
 * @returns {Promise} After setup is complete.
 */
function setupController (initState, initLangCode) {
  //
  // MetaMask Controller
  //

  const controller = new MetamaskController({
    // User confirmation callbacks:
    showUnconfirmedMessage: triggerUi,
    showUnapprovedTx: triggerUi,
    openPopup: openPopup,
    closePopup: notificationManager.closePopup.bind(notificationManager),
    // initial state
    initState,
    // initial locale code
    initLangCode,
    // platform specific api
    platform,
    encryptor: isEdge ? new EdgeEncryptor() : undefined,
  })

  const provider = controller.provider
  setupEnsIpfsResolver({ provider })

  // submit rpc requests to mesh-metrics
  controller.networkController.on('rpc-req', (data) => {
    submitMeshMetricsEntry({ type: 'rpc', data })
  })

  // report failed transactions to Sentry
  controller.txController.on(`tx:status-update`, (txId, status) => {
    if (status !== 'failed') return
    const txMeta = controller.txController.txStateManager.getTx(txId)
    try {
      reportFailedTxToSentry({ sentry, txMeta })
    } catch (e) {
      console.error(e)
    }
  })

  // setup state persistence
  pump(
    asStream(controller.store),
    debounce(1000),
    storeTransform(versionifyData),
    createStreamSink(persistData),
    (error) => {
      log.error('MetaMask - Persistence pipeline failed', error)
    }
  )

  /**
   * 将给定状态分配给版本对象
   * Assigns the given state to the versioned object (with metadata), and returns that.
   * @param {Object} state - The state object as emitted by the MetaMaskController.
   * @returns {VersionedData} The state object wrapped in an object that includes a metadata key.
   */
  function versionifyData (state) {
    versionedData.data = state
    return versionedData
  }

  // 持久化 state 到 localStore
  async function persistData (state) {
    if (!state) {
      throw new Error('MetaMask - updated state is missing', state)
    }
    if (!state.data) {
      throw new Error('MetaMask - updated state does not have data', state)
    }
    if (localStore.isSupported) {
      try {
        await localStore.set(state)
      } catch (err) {
        // log error so we dont break the pipeline
        log.error('error setting state in local store:', err)
      }
    }
  }

  //
  // connect to other contexts
  //
  extension.runtime.onConnect.addListener(connectRemote)
  extension.runtime.onConnectExternal.addListener(connectExternal)

  const metamaskInternalProcessHash = {
    [ENVIRONMENT_TYPE_POPUP]: true,
    [ENVIRONMENT_TYPE_NOTIFICATION]: true,
    [ENVIRONMENT_TYPE_FULLSCREEN]: true,
  }

  const metamaskBlacklistedPorts = [
    'trezor-connect',
  ]

  // 客户端是否开启
  const isClientOpenStatus = () => {
    return popupIsOpen || Boolean(Object.keys(openMetamaskTabsIDs).length) || notificationIsOpen
  }

  /**
   * runtime.Port extension 长连接通信
   * A runtime.Port object, as provided by the browser:
   * @see https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/runtime/Port
   * @typedef Port
   * @type Object
   */

  /**
   * Connects a Port to the MetaMask controller via a multiplexed duplex stream.
   * This method identifies trusted (MetaMask) interfaces, and connects them differently from untrusted (web pages).
   * @param {Port} remotePort - The port provided by a new context.
   */
  function connectRemote (remotePort) {
    const processName = remotePort.name
    const isMetaMaskInternalProcess = metamaskInternalProcessHash[processName]

    if (metamaskBlacklistedPorts.includes(remotePort.name)) {
      return false
    }

    // 如果是内部进程，设置授信的通信
    if (isMetaMaskInternalProcess) {
      const portStream = new PortStream(remotePort)
      // communication with popup
      controller.isClientOpen = true
      // construct fake URL for identifying internal messages
      const metamaskUrl = new URL(window.location)
      metamaskUrl.hostname = 'metamask'
      controller.setupTrustedCommunication(portStream, metamaskUrl)

      if (processName === ENVIRONMENT_TYPE_POPUP) {
        popupIsOpen = true

        endOfStream(portStream, () => {
          popupIsOpen = false
          controller.isClientOpen = isClientOpenStatus()
        })
      }

      if (processName === ENVIRONMENT_TYPE_NOTIFICATION) {
        notificationIsOpen = true

        endOfStream(portStream, () => {
          notificationIsOpen = false
          controller.isClientOpen = isClientOpenStatus()
        })
      }

      if (processName === ENVIRONMENT_TYPE_FULLSCREEN) {
        const tabId = remotePort.sender.tab.id
        openMetamaskTabsIDs[tabId] = true

        endOfStream(portStream, () => {
          delete openMetamaskTabsIDs[tabId]
          controller.isClientOpen = isClientOpenStatus()
        })
      }
    } else {
      connectExternal(remotePort)
    }
  }

  // 与页面或其他扩展程序通信
  // communication with page or other extension
  function connectExternal (remotePort) {
    const senderUrl = new URL(remotePort.sender.url)
    let extensionId
    if (remotePort.sender.id !== extension.runtime.id) {
      extensionId = remotePort.sender.id
    }
    const portStream = new PortStream(remotePort)
    controller.setupUntrustedCommunication(portStream, senderUrl, extensionId)
  }

  //
  // User Interface setup
  //

  updateBadge()
  controller.txController.on('update:badge', updateBadge)
  controller.messageManager.on('updateBadge', updateBadge)
  controller.personalMessageManager.on('updateBadge', updateBadge)
  controller.typedMessageManager.on('updateBadge', updateBadge)
  controller.providerApprovalController.memStore.on('update', updateBadge)

  /**
   * 更新工具栏中的扩展图标的 badge
   * 该数字表示需要用户批准的当前待处理交易或消息签名的数量
   * Updates the Web Extension's "badge" number, on the little fox in the toolbar.
   * The number reflects the current number of pending transactions or message signatures needing user approval.
   */
  function updateBadge () {
    let label = ''
    const unapprovedTxCount = controller.txController.getUnapprovedTxCount()
    const unapprovedMsgCount = controller.messageManager.unapprovedMsgCount
    const unapprovedPersonalMsgs = controller.personalMessageManager.unapprovedPersonalMsgCount
    const unapprovedTypedMsgs = controller.typedMessageManager.unapprovedTypedMessagesCount
    const pendingProviderRequests = controller.providerApprovalController.memStore.getState().providerRequests.length
    const count = unapprovedTxCount + unapprovedMsgCount + unapprovedPersonalMsgs + unapprovedTypedMsgs + pendingProviderRequests
    if (count) {
      label = String(count)
    }
    extension.browserAction.setBadgeText({ text: label })
    extension.browserAction.setBadgeBackgroundColor({ color: '#506F8B' })
  }

  return Promise.resolve()
}

//
// Etc...
//

/**
 * 打开浏览器弹出窗口以供用户确认
 * Opens the browser popup for user confirmation
 */
function triggerUi () {
  extension.tabs.query({ active: true }, tabs => {
    const currentlyActiveMetamaskTab = Boolean(tabs.find(tab => openMetamaskTabsIDs[tab.id]))
    if (!popupIsOpen && !currentlyActiveMetamaskTab && !notificationIsOpen) {
      notificationManager.showPopup()
      notificationIsOpen = true
    }
  })
}

/**
 * 打开浏览器弹出窗口以供用户确认，等待用户交互
 * Opens the browser popup for user confirmation of watchAsset
 * then it waits until user interact with the UI
 */
function openPopup () {
  triggerUi()
  return new Promise(
    (resolve) => {
      const interval = setInterval(() => {
        if (!notificationIsOpen) {
          clearInterval(interval)
          resolve()
        }
      }, 1000)
    }
  )
}

// 首次安装，打开一个标签页
// On first install, open a new tab with MetaMask
extension.runtime.onInstalled.addListener(({reason}) => {
  if ((reason === 'install') && (!METAMASK_DEBUG)) {
    platform.openExtensionInBrowser()
  }
})
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="pending-balance-calculator"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/chromereload.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
http://livereload.com/
</div>
<div style="margin-bottom:1em;">
代码出自 https://github.com/livereload/livereload-js/blob/v2.2.0/dist/livereload.js
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
// 'use strict';

// 重新加载Chrome应用和扩展程序的客户端。
// 与livereload兼容：
// LiveReload监视文件系统中的更改。保存文件后，将根据需要对其进行预处理，然后刷新浏览器。
// 更酷的是，当更改CSS文件或图像时，浏览器会立即更新，而无需重新加载页面。
// https://github.com/livereload/livereload-js/blob/v2.2.0/dist/livereload.js

// // Reload client for Chrome Apps & Extensions.
// // The reload client has a compatibility with livereload.
// // WARNING: only supports reload command.

// var LIVERELOAD_HOST = 'localhost:';
// var LIVERELOAD_PORT = 35729;
// var connection = new WebSocket('ws://' + LIVERELOAD_HOST + LIVERELOAD_PORT + '/livereload');

// connection.onopen = function(event) {
//   var hello = {
//     command: 'hello',
//     protocols: ['http://livereload.com/protocols/official-7']
//   };

//   connection.send(JSON.stringify(hello));
// };

// connection.onerror = function (error) {
//   console.log('reload connection got error:', error);
// };

// connection.onmessage = function (e) {
//   if (e.data) {
//     var data = JSON.parse(e.data);
//     if (data && data.command === 'reload') {
//       extension.runtime.reload();
//     }
//   }
// };

window.LiveReloadOptions = { host: 'localhost' };

(function e (t, n, r) { function s (o, u) { if (!n[o]) { if (!t[o]) { var a = typeof require === 'function' && require; if (!u && a) return a(o, !0); if (i) return i(o, !0); var f = new Error("Cannot find module '" + o + "'"); throw f.code = 'MODULE_NOT_FOUND', f } var l = n[o] = {exports: {}}; t[o][0].call(l.exports, function (e) { var n = t[o][1][e]; return s(n ? n : e) }, l, l.exports, e, t, n, r) } return n[o].exports } var i = typeof require === 'function' && require; for (var o = 0; o < r.length; o++)s(r[o]); return s })({1: [function (require, module, exports) {
  (function () {
    var Connector, PROTOCOL_6, PROTOCOL_7, Parser, Version, _ref

    _ref = require('./protocol'), Parser = _ref.Parser, PROTOCOL_6 = _ref.PROTOCOL_6, PROTOCOL_7 = _ref.PROTOCOL_7

    Version = '2.2.2'

    exports.Connector = Connector = (function () {
      function Connector (options, WebSocket, Timer, handlers) {
        this.options = options
        this.WebSocket = WebSocket
        this.Timer = Timer
        this.handlers = handlers
        this._uri = 'ws' + (this.options.https ? 's' : '') + '://' + this.options.host + ':' + this.options.port + '/livereload'
        this._nextDelay = this.options.mindelay
        this._connectionDesired = false
        this.protocol = 0
        this.protocolParser = new Parser({
          connected: (function (_this) {
            return function (protocol) {
              _this.protocol = protocol
              _this._handshakeTimeout.stop()
              _this._nextDelay = _this.options.mindelay
              _this._disconnectionReason = 'broken'
              return _this.handlers.connected(protocol)
            }
          })(this),
          error: (function (_this) {
            return function (e) {
              _this.handlers.error(e)
              return _this._closeOnError()
            }
          })(this),
          message: (function (_this) {
            return function (message) {
              return _this.handlers.message(message)
            }
          })(this),
        })
        this._handshakeTimeout = new Timer((function (_this) {
          return function () {
            if (!_this._isSocketConnected()) {
              return
            }
            _this._disconnectionReason = 'handshake-timeout'
            return _this.socket.close()
          }
        })(this))
        this._reconnectTimer = new Timer((function (_this) {
          return function () {
            if (!_this._connectionDesired) {
              return
            }
            return _this.connect()
          }
        })(this))
        this.connect()
      }

      Connector.prototype._isSocketConnected = function () {
        return this.socket && this.socket.readyState === this.WebSocket.OPEN
      }

      Connector.prototype.connect = function () {
        this._connectionDesired = true
        if (this._isSocketConnected()) {
          return
        }
        this._reconnectTimer.stop()
        this._disconnectionReason = 'cannot-connect'
        this.protocolParser.reset()
        this.handlers.connecting()
        this.socket = new this.WebSocket(this._uri)
        this.socket.onopen = (function (_this) {
          return function (e) {
            return _this._onopen(e)
          }
        })(this)
        this.socket.onclose = (function (_this) {
          return function (e) {
            return _this._onclose(e)
          }
        })(this)
        this.socket.onmessage = (function (_this) {
          return function (e) {
            return _this._onmessage(e)
          }
        })(this)
        return this.socket.onerror = (function (_this) {
          return function (e) {
            return _this._onerror(e)
          }
        })(this)
      }

      Connector.prototype.disconnect = function () {
        this._connectionDesired = false
        this._reconnectTimer.stop()
        if (!this._isSocketConnected()) {
          return
        }
        this._disconnectionReason = 'manual'
        return this.socket.close()
      }

      Connector.prototype._scheduleReconnection = function () {
        if (!this._connectionDesired) {
          return
        }
        if (!this._reconnectTimer.running) {
          this._reconnectTimer.start(this._nextDelay)
          return this._nextDelay = Math.min(this.options.maxdelay, this._nextDelay * 2)
        }
      }

      Connector.prototype.sendCommand = function (command) {
        if (this.protocol == null) {
          return
        }
        return this._sendCommand(command)
      }

      Connector.prototype._sendCommand = function (command) {
        return this.socket.send(JSON.stringify(command))
      }

      Connector.prototype._closeOnError = function () {
        this._handshakeTimeout.stop()
        this._disconnectionReason = 'error'
        return this.socket.close()
      }

      Connector.prototype._onopen = function (e) {
        var hello
        this.handlers.socketConnected()
        this._disconnectionReason = 'handshake-failed'
        hello = {
          command: 'hello',
          protocols: [PROTOCOL_6, PROTOCOL_7],
        }
        hello.ver = Version
        if (this.options.ext) {
          hello.ext = this.options.ext
        }
        if (this.options.extver) {
          hello.extver = this.options.extver
        }
        if (this.options.snipver) {
          hello.snipver = this.options.snipver
        }
        this._sendCommand(hello)
        return this._handshakeTimeout.start(this.options.handshake_timeout)
      }

      Connector.prototype._onclose = function (e) {
        this.protocol = 0
        this.handlers.disconnected(this._disconnectionReason, this._nextDelay)
        return this._scheduleReconnection()
      }

      Connector.prototype._onerror = function (e) {}

      Connector.prototype._onmessage = function (e) {
        return this.protocolParser.process(e.data)
      }

      return Connector
    })()
  }).call(this)
}, {'./protocol': 6}], 2: [function (require, module, exports) {
  (function () {
    var CustomEvents

    CustomEvents = {
      bind: function (element, eventName, handler) {
        if (element.addEventListener) {
          return element.addEventListener(eventName, handler, false)
        } else if (element.attachEvent) {
          element[eventName] = 1
          return element.attachEvent('onpropertychange', function (event) {
            if (event.propertyName === eventName) {
              return handler()
            }
          })
        } else {
          throw new Error('Attempt to attach custom event ' + eventName + " to something which isn't a DOMElement")
        }
      },
      fire: function (element, eventName) {
        var event
        if (element.addEventListener) {
          event = document.createEvent('HTMLEvents')
          event.initEvent(eventName, true, true)
          return document.dispatchEvent(event)
        } else if (element.attachEvent) {
          if (element[eventName]) {
            return element[eventName]++
          }
        } else {
          throw new Error('Attempt to fire custom event ' + eventName + " on something which isn't a DOMElement")
        }
      },
    }

    exports.bind = CustomEvents.bind

    exports.fire = CustomEvents.fire
  }).call(this)
}, {}], 3: [function (require, module, exports) {
  (function () {
    var LessPlugin

    module.exports = LessPlugin = (function () {
      LessPlugin.identifier = 'less'

      LessPlugin.version = '1.0'

      function LessPlugin (window, host) {
        this.window = window
        this.host = host
      }

      LessPlugin.prototype.reload = function (path, options) {
        if (this.window.less && this.window.less.refresh) {
          if (path.match(/\.less$/i)) {
            return this.reloadLess(path)
          }
          if (options.originalPath.match(/\.less$/i)) {
            return this.reloadLess(options.originalPath)
          }
        }
        return false
      }

      LessPlugin.prototype.reloadLess = function (path) {
        var link, links, _i, _len
        links = (function () {
          var _i, _len, _ref, _results
          _ref = document.getElementsByTagName('link')
          _results = []
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            link = _ref[_i]
            if (link.href && link.rel.match(/^stylesheet\/less$/i) || (link.rel.match(/stylesheet/i) && link.type.match(/^text\/(x-)?less$/i))) {
              _results.push(link)
            }
          }
          return _results
        })()
        if (links.length === 0) {
          return false
        }
        for (_i = 0, _len = links.length; _i < _len; _i++) {
          link = links[_i]
          link.href = this.host.generateCacheBustUrl(link.href)
        }
        this.host.console.log('LiveReload is asking LESS to recompile all stylesheets')
        this.window.less.refresh(true)
        return true
      }

      LessPlugin.prototype.analyze = function () {
        return {
          disable: !!(this.window.less && this.window.less.refresh),
        }
      }

      return LessPlugin
    })()
  }).call(this)
}, {}], 4: [function (require, module, exports) {
  (function () {
    var Connector, LiveReload, Options, Reloader, Timer,
      __hasProp = {}.hasOwnProperty

    Connector = require('./connector').Connector

    Timer = require('./timer').Timer

    Options = require('./options').Options

    Reloader = require('./reloader').Reloader

    exports.LiveReload = LiveReload = (function () {
      function LiveReload (window) {
        var k, v, _ref
        this.window = window
        this.listeners = {}
        this.plugins = []
        this.pluginIdentifiers = {}
        this.console = this.window.console && this.window.console.log && this.window.console.error ? this.window.location.href.match(/LR-verbose/) ? this.window.console : {
          log: function () {},
          error: console.error,
        } : {
          log: function () {},
          error: function () {},
        }
        if (!(this.WebSocket = this.window.WebSocket || this.window.MozWebSocket)) {
          console.error('LiveReload disabled because the browser does not seem to support web sockets')
          return
        }
        if ('LiveReloadOptions' in window) {
          this.options = new Options()
          _ref = window['LiveReloadOptions']
          for (k in _ref) {
            if (!__hasProp.call(_ref, k)) continue
            v = _ref[k]
            this.options.set(k, v)
          }
        } else {
          this.options = Options.extract(this.window.document)
          if (!this.options) {
            console.error('LiveReload disabled because it could not find its own <SCRIPT> tag')
            return
          }
        }
        this.reloader = new Reloader(this.window, this.console, Timer)
        this.connector = new Connector(this.options, this.WebSocket, Timer, {
          connecting: (function (_this) {
            return function () {}
          })(this),
          socketConnected: (function (_this) {
            return function () {}
          })(this),
          connected: (function (_this) {
            return function (protocol) {
              var _base
              if (typeof (_base = _this.listeners).connect === 'function') {
                _base.connect()
              }
              _this.log('LiveReload is connected to ' + _this.options.host + ':' + _this.options.port + ' (protocol v' + protocol + ').')
              return _this.analyze()
            }
          })(this),
          error: (function (_this) {
            return function (e) {
              if (e instanceof ProtocolError) {
                if (typeof console !== 'undefined' && console !== null) {
                  return console.log('' + e.message + '.')
                }
              } else {
                if (typeof console !== 'undefined' && console !== null) {
                  return console.log('LiveReload internal error: ' + e.message)
                }
              }
            }
          })(this),
          disconnected: (function (_this) {
            return function (reason, nextDelay) {
              var _base
              if (typeof (_base = _this.listeners).disconnect === 'function') {
                _base.disconnect()
              }
              switch (reason) {
                case 'cannot-connect':
                  return _this.log('LiveReload cannot connect to ' + _this.options.host + ':' + _this.options.port + ', will retry in ' + nextDelay + ' sec.')
                case 'broken':
                  return _this.log('LiveReload disconnected from ' + _this.options.host + ':' + _this.options.port + ', reconnecting in ' + nextDelay + ' sec.')
                case 'handshake-timeout':
                  return _this.log('LiveReload cannot connect to ' + _this.options.host + ':' + _this.options.port + ' (handshake timeout), will retry in ' + nextDelay + ' sec.')
                case 'handshake-failed':
                  return _this.log('LiveReload cannot connect to ' + _this.options.host + ':' + _this.options.port + ' (handshake failed), will retry in ' + nextDelay + ' sec.')
                case 'manual':
                  break
                case 'error':
                  break
                default:
                  return _this.log('LiveReload disconnected from ' + _this.options.host + ':' + _this.options.port + ' (' + reason + '), reconnecting in ' + nextDelay + ' sec.')
              }
            }
          })(this),
          message: (function (_this) {
            return function (message) {
              switch (message.command) {
                case 'reload':
                  return _this.performReload(message)
                case 'alert':
                  return _this.performAlert(message)
              }
            }
          })(this),
        })
        this.initialized = true
      }

      LiveReload.prototype.on = function (eventName, handler) {
        return this.listeners[eventName] = handler
      }

      LiveReload.prototype.log = function (message) {
        return this.console.log('' + message)
      }

      LiveReload.prototype.performReload = function (message) {
        var _ref, _ref1
        this.log('LiveReload received reload request: ' + (JSON.stringify(message, null, 2)))
        return this.reloader.reload(message.path, {
          liveCSS: (_ref = message.liveCSS) != null ? _ref : true,
          liveImg: (_ref1 = message.liveImg) != null ? _ref1 : true,
          originalPath: message.originalPath || '',
          overrideURL: message.overrideURL || '',
          serverURL: 'http://' + this.options.host + ':' + this.options.port,
        })
      }

      LiveReload.prototype.performAlert = function (message) {
        return alert(message.message)
      }

      LiveReload.prototype.shutDown = function () {
        var _base
        if (!this.initialized) {
          return
        }
        this.connector.disconnect()
        this.log('LiveReload disconnected.')
        return typeof (_base = this.listeners).shutdown === 'function' ? _base.shutdown() : void 0
      }

      LiveReload.prototype.hasPlugin = function (identifier) {
        return !!this.pluginIdentifiers[identifier]
      }

      LiveReload.prototype.addPlugin = function (pluginClass) {
        var plugin
        if (!this.initialized) {
          return
        }
        if (this.hasPlugin(pluginClass.identifier)) {
          return
        }
        this.pluginIdentifiers[pluginClass.identifier] = true
        plugin = new pluginClass(this.window, {
          _livereload: this,
          _reloader: this.reloader,
          _connector: this.connector,
          console: this.console,
          Timer: Timer,
          generateCacheBustUrl: (function (_this) {
            return function (url) {
              return _this.reloader.generateCacheBustUrl(url)
            }
          })(this),
        })
        this.plugins.push(plugin)
        this.reloader.addPlugin(plugin)
      }

      LiveReload.prototype.analyze = function () {
        var plugin, pluginData, pluginsData, _i, _len, _ref
        if (!this.initialized) {
          return
        }
        if (!(this.connector.protocol >= 7)) {
          return
        }
        pluginsData = {}
        _ref = this.plugins
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          plugin = _ref[_i]
          pluginsData[plugin.constructor.identifier] = pluginData = (typeof plugin.analyze === 'function' ? plugin.analyze() : void 0) || {}
          pluginData.version = plugin.constructor.version
        }
        this.connector.sendCommand({
          command: 'info',
          plugins: pluginsData,
          url: this.window.location.href,
        })
      }

      return LiveReload
    })()
  }).call(this)
}, {'./connector': 1, './options': 5, './reloader': 7, './timer': 9}], 5: [function (require, module, exports) {
  (function () {
    var Options

    exports.Options = Options = (function () {
      function Options () {
        this.https = false
        this.host = null
        this.port = 35729
        this.snipver = null
        this.ext = null
        this.extver = null
        this.mindelay = 1000
        this.maxdelay = 60000
        this.handshake_timeout = 5000
      }

      Options.prototype.set = function (name, value) {
        if (typeof value === 'undefined') {
          return
        }
        if (!isNaN(+value)) {
          value = +value
        }
        return this[name] = value
      }

      return Options
    })()

    Options.extract = function (document) {
      var element, keyAndValue, m, mm, options, pair, src, _i, _j, _len, _len1, _ref, _ref1
      _ref = document.getElementsByTagName('script')
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        element = _ref[_i]
        if ((src = element.src) && (m = src.match(/^[^:]+:\/\/(.*)\/z?livereload\.js(?:\?(.*))?$/))) {
          options = new Options()
          options.https = src.indexOf('https') === 0
          if (mm = m[1].match(/^([^\/:]+)(?::(\d+))?$/)) {
            options.host = mm[1]
            if (mm[2]) {
              options.port = parseInt(mm[2], 10)
            }
          }
          if (m[2]) {
            _ref1 = m[2].split('&')
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              pair = _ref1[_j]
              if ((keyAndValue = pair.split('=')).length > 1) {
                options.set(keyAndValue[0].replace(/-/g, '_'), keyAndValue.slice(1).join('='))
              }
            }
          }
          return options
        }
      }
      return null
    }
  }).call(this)
}, {}], 6: [function (require, module, exports) {
  (function () {
    var PROTOCOL_6, PROTOCOL_7, Parser, ProtocolError,
      __indexOf = [].indexOf || function (item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i } return -1 }

    exports.PROTOCOL_6 = PROTOCOL_6 = 'http://livereload.com/protocols/official-6'

    exports.PROTOCOL_7 = PROTOCOL_7 = 'http://livereload.com/protocols/official-7'

    exports.ProtocolError = ProtocolError = (function () {
      function ProtocolError (reason, data) {
        this.message = 'LiveReload protocol error (' + reason + ') after receiving data: "' + data + '".'
      }

      return ProtocolError
    })()

    exports.Parser = Parser = (function () {
      function Parser (handlers) {
        this.handlers = handlers
        this.reset()
      }

      Parser.prototype.reset = function () {
        return this.protocol = null
      }

      Parser.prototype.process = function (data) {
        var command, e, message, options, _ref
        try {
          if (this.protocol == null) {
            if (data.match(/^!!ver:([\d.]+)$/)) {
              this.protocol = 6
            } else if (message = this._parseMessage(data, ['hello'])) {
              if (!message.protocols.length) {
                throw new ProtocolError('no protocols specified in handshake message')
              } else if (__indexOf.call(message.protocols, PROTOCOL_7) >= 0) {
                this.protocol = 7
              } else if (__indexOf.call(message.protocols, PROTOCOL_6) >= 0) {
                this.protocol = 6
              } else {
                throw new ProtocolError('no supported protocols found')
              }
            }
            return this.handlers.connected(this.protocol)
          } else if (this.protocol === 6) {
            message = JSON.parse(data)
            if (!message.length) {
              throw new ProtocolError('protocol 6 messages must be arrays')
            }
            command = message[0], options = message[1]
            if (command !== 'refresh') {
              throw new ProtocolError('unknown protocol 6 command')
            }
            return this.handlers.message({
              command: 'reload',
              path: options.path,
              liveCSS: (_ref = options.apply_css_live) != null ? _ref : true,
            })
          } else {
            message = this._parseMessage(data, ['reload', 'alert'])
            return this.handlers.message(message)
          }
        } catch (_error) {
          e = _error
          if (e instanceof ProtocolError) {
            return this.handlers.error(e)
          } else {
            throw e
          }
        }
      }

      Parser.prototype._parseMessage = function (data, validCommands) {
        var e, message, _ref
        try {
          message = JSON.parse(data)
        } catch (_error) {
          e = _error
          throw new ProtocolError('unparsable JSON', data)
        }
        if (!message.command) {
          throw new ProtocolError('missing "command" key', data)
        }
        if (_ref = message.command, __indexOf.call(validCommands, _ref) < 0) {
          throw new ProtocolError("invalid command '" + message.command + "', only valid commands are: " + (validCommands.join(', ')) + ')', data)
        }
        return message
      }

      return Parser
    })()
  }).call(this)
}, {}], 7: [function (require, module, exports) {
  (function () {
    var IMAGE_STYLES, Reloader, numberOfMatchingSegments, pathFromUrl, pathsMatch, pickBestMatch, splitUrl

    splitUrl = function (url) {
      var hash, index, params
      if ((index = url.indexOf('#')) >= 0) {
        hash = url.slice(index)
        url = url.slice(0, index)
      } else {
        hash = ''
      }
      if ((index = url.indexOf('?')) >= 0) {
        params = url.slice(index)
        url = url.slice(0, index)
      } else {
        params = ''
      }
      return {
        url: url,
        params: params,
        hash: hash,
      }
    }

    pathFromUrl = function (url) {
      var path
      url = splitUrl(url).url
      if (url.indexOf('file://') === 0) {
        path = url.replace(/^file:\/\/(localhost)?/, '')
      } else {
        path = url.replace(/^([^:]+:)?\/\/([^:\/]+)(:\d*)?\//, '/')
      }
      return decodeURIComponent(path)
    }

    pickBestMatch = function (path, objects, pathFunc) {
      var bestMatch, object, score, _i, _len
      bestMatch = {
        score: 0,
      }
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        object = objects[_i]
        score = numberOfMatchingSegments(path, pathFunc(object))
        if (score > bestMatch.score) {
          bestMatch = {
            object: object,
            score: score,
          }
        }
      }
      if (bestMatch.score > 0) {
        return bestMatch
      } else {
        return null
      }
    }

    numberOfMatchingSegments = function (path1, path2) {
      var comps1, comps2, eqCount, len
      path1 = path1.replace(/^\/+/, '').toLowerCase()
      path2 = path2.replace(/^\/+/, '').toLowerCase()
      if (path1 === path2) {
        return 10000
      }
      comps1 = path1.split('/').reverse()
      comps2 = path2.split('/').reverse()
      len = Math.min(comps1.length, comps2.length)
      eqCount = 0
      while (eqCount < len && comps1[eqCount] === comps2[eqCount]) {
        ++eqCount
      }
      return eqCount
    }

    pathsMatch = function (path1, path2) {
      return numberOfMatchingSegments(path1, path2) > 0
    }

    IMAGE_STYLES = [
      {
        selector: 'background',
        styleNames: ['backgroundImage'],
      }, {
        selector: 'border',
        styleNames: ['borderImage', 'webkitBorderImage', 'MozBorderImage'],
      },
    ]

    exports.Reloader = Reloader = (function () {
      function Reloader (window, console, Timer) {
        this.window = window
        this.console = console
        this.Timer = Timer
        this.document = this.window.document
        this.importCacheWaitPeriod = 200
        this.plugins = []
      }

      Reloader.prototype.addPlugin = function (plugin) {
        return this.plugins.push(plugin)
      }

      Reloader.prototype.analyze = function (callback) {
        return results
      }

      Reloader.prototype.reload = function (path, options) {
        var plugin, _base, _i, _len, _ref
        this.options = options
        if ((_base = this.options).stylesheetReloadTimeout == null) {
          _base.stylesheetReloadTimeout = 15000
        }
        _ref = this.plugins
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          plugin = _ref[_i]
          if (plugin.reload && plugin.reload(path, options)) {
            return
          }
        }
        if (options.liveCSS) {
          if (path.match(/\.css$/i)) {
            if (this.reloadStylesheet(path)) {
              return
            }
          }
        }
        if (options.liveImg) {
          if (path.match(/\.(jpe?g|png|gif)$/i)) {
            this.reloadImages(path)
            return
          }
        }
        return this.reloadPage()
      }

      Reloader.prototype.reloadPage = function () {
        return this.window.document.location.reload()
      }

      Reloader.prototype.reloadImages = function (path) {
        var expando, img, selector, styleNames, styleSheet, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _results
        expando = this.generateUniqueString()
        _ref = this.document.images
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          img = _ref[_i]
          if (pathsMatch(path, pathFromUrl(img.src))) {
            img.src = this.generateCacheBustUrl(img.src, expando)
          }
        }
        if (this.document.querySelectorAll) {
          for (_j = 0, _len1 = IMAGE_STYLES.length; _j < _len1; _j++) {
            _ref1 = IMAGE_STYLES[_j], selector = _ref1.selector, styleNames = _ref1.styleNames
            _ref2 = this.document.querySelectorAll('[style*=' + selector + ']')
            for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
              img = _ref2[_k]
              this.reloadStyleImages(img.style, styleNames, path, expando)
            }
          }
        }
        if (this.document.styleSheets) {
          _ref3 = this.document.styleSheets
          _results = []
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            styleSheet = _ref3[_l]
            _results.push(this.reloadStylesheetImages(styleSheet, path, expando))
          }
          return _results
        }
      }

      Reloader.prototype.reloadStylesheetImages = function (styleSheet, path, expando) {
        var e, rule, rules, styleNames, _i, _j, _len, _len1
        try {
          rules = styleSheet != null ? styleSheet.cssRules : void 0
        } catch (_error) {
          e = _error
        }
        if (!rules) {
          return
        }
        for (_i = 0, _len = rules.length; _i < _len; _i++) {
          rule = rules[_i]
          switch (rule.type) {
            case CSSRule.IMPORT_RULE:
              this.reloadStylesheetImages(rule.styleSheet, path, expando)
              break
            case CSSRule.STYLE_RULE:
              for (_j = 0, _len1 = IMAGE_STYLES.length; _j < _len1; _j++) {
                styleNames = IMAGE_STYLES[_j].styleNames
                this.reloadStyleImages(rule.style, styleNames, path, expando)
              }
              break
            case CSSRule.MEDIA_RULE:
              this.reloadStylesheetImages(rule, path, expando)
          }
        }
      }

      Reloader.prototype.reloadStyleImages = function (style, styleNames, path, expando) {
        var newValue, styleName, value, _i, _len
        for (_i = 0, _len = styleNames.length; _i < _len; _i++) {
          styleName = styleNames[_i]
          value = style[styleName]
          if (typeof value === 'string') {
            newValue = value.replace(/\burl\s*\(([^)]*)\)/, (function (_this) {
              return function (match, src) {
                if (pathsMatch(path, pathFromUrl(src))) {
                  return 'url(' + (_this.generateCacheBustUrl(src, expando)) + ')'
                } else {
                  return match
                }
              }
            })(this))
            if (newValue !== value) {
              style[styleName] = newValue
            }
          }
        }
      }

      Reloader.prototype.reloadStylesheet = function (path) {
        var imported, link, links, match, style, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1
        links = (function () {
          var _i, _len, _ref, _results
          _ref = this.document.getElementsByTagName('link')
          _results = []
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            link = _ref[_i]
            if (link.rel.match(/^stylesheet$/i) && !link.__LiveReload_pendingRemoval) {
              _results.push(link)
            }
          }
          return _results
        }).call(this)
        imported = []
        _ref = this.document.getElementsByTagName('style')
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          style = _ref[_i]
          if (style.sheet) {
            this.collectImportedStylesheets(style, style.sheet, imported)
          }
        }
        for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
          link = links[_j]
          this.collectImportedStylesheets(link, link.sheet, imported)
        }
        if (this.window.StyleFix && this.document.querySelectorAll) {
          _ref1 = this.document.querySelectorAll('style[data-href]')
          for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
            style = _ref1[_k]
            links.push(style)
          }
        }
        this.console.log('LiveReload found ' + links.length + ' LINKed stylesheets, ' + imported.length + ' @imported stylesheets')
        match = pickBestMatch(path, links.concat(imported), (function (_this) {
          return function (l) {
            return pathFromUrl(_this.linkHref(l))
          }
        })(this))
        if (match) {
          if (match.object.rule) {
            this.console.log('LiveReload is reloading imported stylesheet: ' + match.object.href)
            this.reattachImportedRule(match.object)
          } else {
            this.console.log('LiveReload is reloading stylesheet: ' + (this.linkHref(match.object)))
            this.reattachStylesheetLink(match.object)
          }
        } else {
          this.console.log("LiveReload will reload all stylesheets because path '" + path + "' did not match any specific one")
          for (_l = 0, _len3 = links.length; _l < _len3; _l++) {
            link = links[_l]
            this.reattachStylesheetLink(link)
          }
        }
        return true
      }

      Reloader.prototype.collectImportedStylesheets = function (link, styleSheet, result) {
        var e, index, rule, rules, _i, _len
        try {
          rules = styleSheet != null ? styleSheet.cssRules : void 0
        } catch (_error) {
          e = _error
        }
        if (rules && rules.length) {
          for (index = _i = 0, _len = rules.length; _i < _len; index = ++_i) {
            rule = rules[index]
            switch (rule.type) {
              case CSSRule.CHARSET_RULE:
                continue
              case CSSRule.IMPORT_RULE:
                result.push({
                  link: link,
                  rule: rule,
                  index: index,
                  href: rule.href,
                })
                this.collectImportedStylesheets(link, rule.styleSheet, result)
                break
              default:
                break
            }
          }
        }
      }

      Reloader.prototype.waitUntilCssLoads = function (clone, func) {
        var callbackExecuted, executeCallback, poll
        callbackExecuted = false
        executeCallback = (function (_this) {
          return function () {
            if (callbackExecuted) {
              return
            }
            callbackExecuted = true
            return func()
          }
        })(this)
        clone.onload = (function (_this) {
          return function () {
            _this.console.log('LiveReload: the new stylesheet has finished loading')
            _this.knownToSupportCssOnLoad = true
            return executeCallback()
          }
        })(this)
        if (!this.knownToSupportCssOnLoad) {
          (poll = (function (_this) {
            return function () {
              if (clone.sheet) {
                _this.console.log('LiveReload is polling until the new CSS finishes loading...')
                return executeCallback()
              } else {
                return _this.Timer.start(50, poll)
              }
            }
          })(this))()
        }
        return this.Timer.start(this.options.stylesheetReloadTimeout, executeCallback)
      }

      Reloader.prototype.linkHref = function (link) {
        return link.href || link.getAttribute('data-href')
      }

      Reloader.prototype.reattachStylesheetLink = function (link) {
        var clone, parent
        if (link.__LiveReload_pendingRemoval) {
          return
        }
        link.__LiveReload_pendingRemoval = true
        if (link.tagName === 'STYLE') {
          clone = this.document.createElement('link')
          clone.rel = 'stylesheet'
          clone.media = link.media
          clone.disabled = link.disabled
        } else {
          clone = link.cloneNode(false)
        }
        clone.href = this.generateCacheBustUrl(this.linkHref(link))
        parent = link.parentNode
        if (parent.lastChild === link) {
          parent.appendChild(clone)
        } else {
          parent.insertBefore(clone, link.nextSibling)
        }
        return this.waitUntilCssLoads(clone, (function (_this) {
          return function () {
            var additionalWaitingTime
            if (/AppleWebKit/.test(navigator.userAgent)) {
              additionalWaitingTime = 5
            } else {
              additionalWaitingTime = 200
            }
            return _this.Timer.start(additionalWaitingTime, function () {
              var _ref
              if (!link.parentNode) {
                return
              }
              link.parentNode.removeChild(link)
              clone.onreadystatechange = null
              return (_ref = _this.window.StyleFix) != null ? _ref.link(clone) : void 0
            })
          }
        })(this))
      }

      Reloader.prototype.reattachImportedRule = function (_arg) {
        var href, index, link, media, newRule, parent, rule, tempLink
        rule = _arg.rule, index = _arg.index, link = _arg.link
        parent = rule.parentStyleSheet
        href = this.generateCacheBustUrl(rule.href)
        media = rule.media.length ? [].join.call(rule.media, ', ') : ''
        newRule = '@import url("' + href + '") ' + media + ';'
        rule.__LiveReload_newHref = href
        tempLink = this.document.createElement('link')
        tempLink.rel = 'stylesheet'
        tempLink.href = href
        tempLink.__LiveReload_pendingRemoval = true
        if (link.parentNode) {
          link.parentNode.insertBefore(tempLink, link)
        }
        return this.Timer.start(this.importCacheWaitPeriod, (function (_this) {
          return function () {
            if (tempLink.parentNode) {
              tempLink.parentNode.removeChild(tempLink)
            }
            if (rule.__LiveReload_newHref !== href) {
              return
            }
            parent.insertRule(newRule, index)
            parent.deleteRule(index + 1)
            rule = parent.cssRules[index]
            rule.__LiveReload_newHref = href
            return _this.Timer.start(_this.importCacheWaitPeriod, function () {
              if (rule.__LiveReload_newHref !== href) {
                return
              }
              parent.insertRule(newRule, index)
              return parent.deleteRule(index + 1)
            })
          }
        })(this))
      }

      Reloader.prototype.generateUniqueString = function () {
        return 'livereload=' + Date.now()
      }

      Reloader.prototype.generateCacheBustUrl = function (url, expando) {
        var hash, oldParams, originalUrl, params, _ref
        if (expando == null) {
          expando = this.generateUniqueString()
        }
        _ref = splitUrl(url), url = _ref.url, hash = _ref.hash, oldParams = _ref.params
        if (this.options.overrideURL) {
          if (url.indexOf(this.options.serverURL) < 0) {
            originalUrl = url
            url = this.options.serverURL + this.options.overrideURL + '?url=' + encodeURIComponent(url)
            this.console.log('LiveReload is overriding source URL ' + originalUrl + ' with ' + url)
          }
        }
        params = oldParams.replace(/(\?|&)livereload=(\d+)/, function (match, sep) {
          return '' + sep + expando
        })
        if (params === oldParams) {
          if (oldParams.length === 0) {
            params = '?' + expando
          } else {
            params = '' + oldParams + '&' + expando
          }
        }
        return url + params + hash
      }

      return Reloader
    })()
  }).call(this)
}, {}], 8: [function (require, module, exports) {
  (function () {
    var CustomEvents, LiveReload, k

    CustomEvents = require('./customevents')

    LiveReload = window.LiveReload = new (require('./livereload').LiveReload)(window)

    for (k in window) {
      if (k.match(/^LiveReloadPlugin/)) {
        LiveReload.addPlugin(window[k])
      }
    }

    LiveReload.addPlugin(require('./less'))

    LiveReload.on('shutdown', function () {
      return delete window.LiveReload
    })

    LiveReload.on('connect', function () {
      return CustomEvents.fire(document, 'LiveReloadConnect')
    })

    LiveReload.on('disconnect', function () {
      return CustomEvents.fire(document, 'LiveReloadDisconnect')
    })

    CustomEvents.bind(document, 'LiveReloadShutDown', function () {
      return LiveReload.shutDown()
    })
  }).call(this)
}, {'./customevents': 2, './less': 3, './livereload': 4}], 9: [function (require, module, exports) {
  (function () {
    var Timer

    exports.Timer = Timer = (function () {
      function Timer (func) {
        this.func = func
        this.running = false
        this.id = null
        this._handler = (function (_this) {
          return function () {
            _this.running = false
            _this.id = null
            return _this.func()
          }
        })(this)
      }

      Timer.prototype.start = function (timeout) {
        if (this.running) {
          clearTimeout(this.id)
        }
        this.id = setTimeout(this._handler, timeout)
        return this.running = true
      }

      Timer.prototype.stop = function () {
        if (this.running) {
          clearTimeout(this.id)
          this.running = false
          return this.id = null
        }
      }

      return Timer
    })()

    Timer.start = function (timeout, func) {
      return setTimeout(func, timeout)
    }
  }).call(this)
}, {}]}, {}, [8])
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="scripts-contentscript"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/contentscript.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
  <img style="width:550px;" src="/images/ether/1578207153424-3d8d8c29-92c9-4d00-9f4b-89e435d92fac.png" />
</div>
<div style="margin-bottom:1em;">
  参考架构图，当访问一个新站点时，WebExtension 会在该页面的上下文中创建一个新的 ContentScript，这个脚本表示每个页面的设置过程，它创建每个页面的 web3 api，通过端口 API(封装在流抽象中) 将其连接到后台脚本，并在加载之前注入DOM。
</div>
<div style="margin-bottom:1em;">
其实就是在页面与 metamask 之间进行交互前先通过 contentscript 来对页面的内容进行查看并判断是否提供 web3 给页面。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const fs = require('fs')
const path = require('path')
const pump = require('pump')
const log = require('loglevel')
const Dnode = require('dnode')
const querystring = require('querystring')
const LocalMessageDuplexStream = require('post-message-stream')
const ObjectMultiplex = require('obj-multiplex')
const extension = require('extensionizer')
const PortStream = require('extension-port-stream')

const inpageContent = fs.readFileSync(path.join(__dirname, '..', '..', 'dist', 'chrome', 'inpage.js')).toString()
const inpageSuffix = '//# sourceURL=' + extension.runtime.getURL('inpage.js') + '\n'
const inpageBundle = inpageContent + inpageSuffix

// Eventually this streaming injection could be replaced with:
// https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Language_Bindings/Components.utils.exportFunction
//
// But for now that is only Firefox
// If we create a FireFox-only code path using that API,
// MetaMask will be much faster loading and performant on Firefox.

if (shouldInjectWeb3()) {
  injectScript(inpageBundle)
  start()
}

/**
 * 把 inpage.js 注入到页面中，使浏览器能够调用这个脚本处理 json rpc
 * Injects a script tag into the current document
 *
 * @param {string} content - Code to be executed in the current document
 */
function injectScript (content) {
  try {
    const container = document.head || document.documentElement
    const scriptTag = document.createElement('script')
    scriptTag.setAttribute('async', false)
    scriptTag.textContent = content
    container.insertBefore(scriptTag, container.children[0])
    container.removeChild(scriptTag)
  } catch (e) {
    console.error('MetaMask script injection failed', e)
  }
}

/**
 * Sets up the stream communication and submits site metadata
 *
 */
async function start () {
  await setupStreams()
  await domIsReady()
}

/**
 * 在浏览器扩展和本地浏览页面上下文之间建立双向通讯流
 * Sets up two-way communication streams between the
 * browser extension and local per-page browser context.
 *
 */
async function setupStreams () {
  // the transport-specific streams for communication between inpage and background
  const pageStream = new LocalMessageDuplexStream({
    name: 'contentscript',
    target: 'inpage',
  })
  const extensionPort = extension.runtime.connect({ name: 'contentscript' })
  const extensionStream = new PortStream(extensionPort)

  // create and connect channel muxers
  // so we can handle the channels individually
  const pageMux = new ObjectMultiplex()
  pageMux.setMaxListeners(25)
  const extensionMux = new ObjectMultiplex()
  extensionMux.setMaxListeners(25)

  pump(
    pageMux,
    pageStream,
    pageMux,
    (err) => logStreamDisconnectWarning('MetaMask Inpage Multiplex', err)
  )
  pump(
    extensionMux,
    extensionStream,
    extensionMux,
    (err) => logStreamDisconnectWarning('MetaMask Background Multiplex', err)
  )

  // forward communication across inpage-background for these channels only
  forwardTrafficBetweenMuxers('provider', pageMux, extensionMux)
  forwardTrafficBetweenMuxers('publicConfig', pageMux, extensionMux)

  // connect "phishing" channel to warning system
  const phishingStream = extensionMux.createStream('phishing')
  phishingStream.once('data', redirectToPhishingWarning)

  // connect "publicApi" channel to submit page metadata
  const publicApiStream = extensionMux.createStream('publicApi')
  const background = await setupPublicApi(publicApiStream)

  return { background }
}

function forwardTrafficBetweenMuxers (channelName, muxA, muxB) {
  const channelA = muxA.createStream(channelName)
  const channelB = muxB.createStream(channelName)
  pump(
    channelA,
    channelB,
    channelA,
    (err) => logStreamDisconnectWarning(`MetaMask muxed traffic for channel "${channelName}" failed.`, err)
  )
}

async function setupPublicApi (outStream) {
  const api = {
    getSiteMetadata: (cb) => cb(null, getSiteMetadata()),
  }
  const dnode = Dnode(api)
  pump(
    outStream,
    dnode,
    outStream,
    (err) => {
      // report any error
      if (err) log.error(err)
    }
  )
  const background = await new Promise(resolve => dnode.once('remote', resolve))
  return background
}

/**
 * Gets site metadata and returns it
 *
 */
function getSiteMetadata () {
  // get metadata
  const metadata = {
    name: getSiteName(window),
    icon: getSiteIcon(window),
  }
  return metadata
}

/**
 * Error handler for page to extension stream disconnections
 *
 * @param {string} remoteLabel Remote stream name
 * @param {Error} err Stream connection error
 */
function logStreamDisconnectWarning (remoteLabel, err) {
  let warningMsg = `MetamaskContentscript - lost connection to ${remoteLabel}`
  if (err) warningMsg += '\n' + err.stack
  console.warn(warningMsg)
}

/**
 * 是否应注入Web3（html页面，非 xml，pdf，且不在黑名单）
 * Determines if Web3 should be injected
 *
 * @returns {boolean} {@code true} if Web3 should be injected
 */
function shouldInjectWeb3 () {
  return doctypeCheck() && suffixCheck() &&
    documentElementCheck() && !blacklistedDomainCheck()
}

/**
 * Checks the doctype of the current document if it exists
 *
 * @returns {boolean} {@code true} if the doctype is html or if none exists
 */
function doctypeCheck () {
  const doctype = window.document.doctype
  if (doctype) {
    return doctype.name === 'html'
  } else {
    return true
  }
}

/**
 * Returns whether or not the extension (suffix) of the current document is prohibited
 *
 * This checks {@code window.location.pathname} against a set of file extensions
 * that should not have web3 injected into them. This check is indifferent of query parameters
 * in the location.
 *
 * @returns {boolean} whether or not the extension of the current document is prohibited
 */
function suffixCheck () {
  const prohibitedTypes = [
    /\.xml$/,
    /\.pdf$/,
  ]
  const currentUrl = window.location.pathname
  for (let i = 0; i < prohibitedTypes.length; i++) {
    if (prohibitedTypes[i].test(currentUrl)) {
      return false
    }
  }
  return true
}

/**
 * Checks the documentElement of the current document
 *
 * @returns {boolean} {@code true} if the documentElement is an html node or if none exists
 */
function documentElementCheck () {
  const documentElement = document.documentElement.nodeName
  if (documentElement) {
    return documentElement.toLowerCase() === 'html'
  }
  return true
}

/**
 * Checks if the current domain is blacklisted
 *
 * @returns {boolean} {@code true} if the current domain is blacklisted
 */
function blacklistedDomainCheck () {
  const blacklistedDomains = [
    'uscourts.gov',
    'dropbox.com',
    'webbyawards.com',
    'cdn.shopify.com/s/javascripts/tricorder/xtld-read-only-frame.html',
    'adyen.com',
    'gravityforms.com',
    'harbourair.com',
    'ani.gamer.com.tw',
    'blueskybooking.com',
    'sharefile.com',
  ]
  const currentUrl = window.location.href
  let currentRegex
  for (let i = 0; i < blacklistedDomains.length; i++) {
    const blacklistedDomain = blacklistedDomains[i].replace('.', '\\.')
    currentRegex = new RegExp(`(?:https?:\\/\\/)(?:(?!${blacklistedDomain}).)*$`)
    if (!currentRegex.test(currentUrl)) {
      return true
    }
  }
  return false
}

/**
 * 钓鱼网站警告
 * Redirects the current page to a phishing information page
 */
function redirectToPhishingWarning () {
  console.log('MetaMask - routing to Phishing Warning component')
  const extensionURL = extension.runtime.getURL('phishing.html')
  window.location.href = `${extensionURL}#${querystring.stringify({
    hostname: window.location.hostname,
    href: window.location.href,
  })}`
}


/**
 * Extracts a name for the site from the DOM
 */
function getSiteName (window) {
  const document = window.document
  const siteName = document.querySelector('head > meta[property="og:site_name"]')
  if (siteName) {
    return siteName.content
  }

  const metaTitle = document.querySelector('head > meta[name="title"]')
  if (metaTitle) {
    return metaTitle.content
  }

  return document.title
}

/**
 * Extracts an icon for the site from the DOM
 */
function getSiteIcon (window) {
  const document = window.document

  // Use the site's favicon if it exists
  const shortcutIcon = document.querySelector('head > link[rel="shortcut icon"]')
  if (shortcutIcon) {
    return shortcutIcon.href
  }

  // Search through available icons in no particular order
  const icon = Array.from(document.querySelectorAll('head > link[rel="icon"]')).find((icon) => Boolean(icon.href))
  if (icon) {
    return icon.href
  }

  return null
}

/**
 * Returns a promise that resolves when the DOM is loaded (does not wait for images to load)
 */
async function domIsReady () {
  // already loaded
  if (['interactive', 'complete'].includes(document.readyState)) return
  // wait for load
  await new Promise(resolve => window.addEventListener('DOMContentLoaded', resolve, { once: true }))
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="createStandardProvider"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/createStandardProvider.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
先要了解 EIP-1193
</div>
<div style="margin-bottom:1em;">
<a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md">https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md</a>
</div>
<div style="margin-bottom:1em;">
该EIP规范了以太坊提供者JavaScript API，以实现客户端和应用程序之间的一致性。该提供程序的目的是最小化，并且可以在window.ethereum上使用，以实现跨环境兼容性。提供这些事件是为了方便启用响应式dapp UI。
</div>
<div style="margin-bottom:1em;">
将传统 provider 转换为符合 EIP-1193 的 provider
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
class StandardProvider {
  _isConnected
  _provider

  constructor (provider) {
    this._provider = provider
    this._subscribe()
    // indicate that we've connected, mostly just for standard compliance
    setTimeout(() => {
      this._onConnect()
    })
  }

  _onClose () {
    if (this._isConnected === undefined || this._isConnected) {
      this._provider.emit('close', {
        code: 1011,
        reason: 'Network connection error',
      })
    }
    this._isConnected = false
  }

  _onConnect () {
    !this._isConnected && this._provider.emit('connect')
    this._isConnected = true
  }

  _subscribe () {
    this._provider.on('data', (error, { method, params }) => {
      if (!error && method === 'eth_subscription') {
        this._provider.emit('notification', params.result)
      }
    })
  }

  /**
   * sendAsync 转换成标准的 send
   * Initiate an RPC method call
   *
   * @param {string} method - RPC method name to call
   * @param {string[]} params - Array of RPC method parameters
   * @returns {Promise<*>} Promise resolving to the result if successful
   */
  send (method, params = []) {
    return new Promise((resolve, reject) => {
      try {
        this._provider.sendAsync({ id: 1, jsonrpc: '2.0', method, params }, (error, response) => {
          error = error || response.error
          error ? reject(error) : resolve(response)
        })
      } catch (error) {
        reject(error)
      }
    })
  }
}

/**
 * 将传统 provider 转换为符合 EIP-1193 的 provider
 * Converts a legacy provider into an EIP-1193-compliant standard provider
 * @param {Object} provider - Legacy provider to convert
 * @returns {Object} Standard provider
 */
export default function createStandardProvider (provider) {
  const standardProvider = new StandardProvider(provider)
  const sendLegacy = provider.send
  provider.send = (methodOrPayload, callbackOrArgs) => {
    if (typeof methodOrPayload === 'string' && !callbackOrArgs || Array.isArray(callbackOrArgs)) {
      return standardProvider.send(methodOrPayload, callbackOrArgs)
    }
    return sendLegacy.call(provider, methodOrPayload, callbackOrArgs)
  }
  return provider
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="edge-encryptor"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/edge-encryptor.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
微软 Edge 浏览器特定的加解密 API
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
const asmcrypto = require('asmcrypto.js')
const Unibabel = require('browserify-unibabel')

/**
 * 微软 Edge 浏览器特定的加解密 API
 * A Microsoft Edge-specific encryption class that exposes
 * the interface expected by eth-keykeyring-controller
 */
class EdgeEncryptor {
  /**
   * 将任意对象加密为密文
   * Encrypts an arbitrary object to ciphertext
   *
   * @param {string} password Used to generate a key to encrypt the data
   * @param {Object} dataObject Data to encrypt
   * @returns {Promise<string>} Promise resolving to an object with ciphertext
   */
  encrypt (password, dataObject) {
    var salt = this._generateSalt()
    return this._keyFromPassword(password, salt)
      .then(function (key) {
        var data = JSON.stringify(dataObject)
        var dataBuffer = Unibabel.utf8ToBuffer(data)
        var vector = global.crypto.getRandomValues(new Uint8Array(16))
        var resultbuffer = asmcrypto.AES_GCM.encrypt(dataBuffer, key, vector)

        var buffer = new Uint8Array(resultbuffer)
        var vectorStr = Unibabel.bufferToBase64(vector)
        var vaultStr = Unibabel.bufferToBase64(buffer)
        return JSON.stringify({
          data: vaultStr,
          iv: vectorStr,
          salt: salt,
        })
      })
  }

  /**
   * 从密文解密任意对象
   * Decrypts an arbitrary object from ciphertext
   *
   * @param {string} password Used to generate a key to decrypt the data
   * @param {string} text Ciphertext of an encrypted object
   * @returns {Promise<Object>} Promise resolving to copy of decrypted object
   */
  decrypt (password, text) {
    const payload = JSON.parse(text)
    const salt = payload.salt
    return this._keyFromPassword(password, salt)
      .then(function (key) {
        const encryptedData = Unibabel.base64ToBuffer(payload.data)
        const vector = Unibabel.base64ToBuffer(payload.iv)
        return new Promise((resolve, reject) => {
          var result
          try {
            result = asmcrypto.AES_GCM.decrypt(encryptedData, key, vector)
          } catch (err) {
            return reject(new Error('Incorrect password'))
          }
          const decryptedData = new Uint8Array(result)
          const decryptedStr = Unibabel.bufferToUtf8(decryptedData)
          const decryptedObj = JSON.parse(decryptedStr)
          resolve(decryptedObj)
        })
      })
  }

  /**
   * 使用密码检索加密密钥
   * Retrieves a cryptographic key using a password
   *
   * @private
   * @param {string} password Password used to unlock a cryptographic key
   * @param {string} salt Random base64 data
   * @returns {Promise<Object>} Promise resolving to a derived key
   */
  _keyFromPassword (password, salt) {

    var passBuffer = Unibabel.utf8ToBuffer(password)
    var saltBuffer = Unibabel.base64ToBuffer(salt)
    const iterations = 10000
    const length = 32 // SHA256 hash size
    return new Promise((resolve) => {
      var key = asmcrypto.Pbkdf2HmacSha256(passBuffer, saltBuffer, iterations, length)
      resolve(key)
    })
  }

  /**
   * 生成随机的base64编码数据
   * Generates random base64 encoded data
   *
   * @private
   * @returns {string} Randomized base64 encoded data
   */
  _generateSalt (byteCount = 32) {
    var view = new Uint8Array(byteCount)
    global.crypto.getRandomValues(view)
    var b64encoded = btoa(String.fromCharCode.apply(null, view))
    return b64encoded
  }
}

module.exports = EdgeEncryptor
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="scripts-inpage"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/inpage.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
  <img style="width:550px;" src="/images/ether/1578209103323-fe38b997-4bd1-4dc5-9a53-0f6a44fe0b87.png" />
</div>
<div style="margin-bottom:1em;">
在 inpage.js 你可以看到我们创建了一个我们用来将 WebExtension 端口包装成流的 PortMessage Stream，因此我们可以在 WebExtension 的更加不规则的 API 表面上重用我们喜欢的流抽象。在新的平台中，您可能需要以不同的方式构造这个流。关键是您需要构建一个从站点上下文到后台的流。一旦你设置好了，它就会像魔术一样运作!
</div>
<div style="margin-bottom:1em;">
注入全局 Web3
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
/*global Web3*/

// 注入全局 Web3

// 缓存 global.define，防止冲突
// need to make sure we aren't affected by overlapping namespaces
// and that we dont affect the app with our namespace
// mostly a fix for web3's BigNumber if AMD's "define" is defined...
let __define

/**
 * Caches reference to global define object and deletes it to
 * avoid conflicts with other global define objects, such as
 * AMD's define function
 */
const cleanContextForImports = () => {
  __define = global.define
  try {
    global.define = undefined
  } catch (_) {
    console.warn('MetaMask - global.define could not be deleted.')
  }
}

/**
 * Restores global define object from cached reference
 */
const restoreContextAfterImports = () => {
  try {
    global.define = __define
  } catch (_) {
    console.warn('MetaMask - global.define could not be overwritten.')
  }
}

cleanContextForImports()
require('web3/dist/web3.min.js')
const log = require('loglevel')
const LocalMessageDuplexStream = require('post-message-stream')
const setupDappAutoReload = require('./lib/auto-reload.js')
const MetamaskInpageProvider = require('metamask-inpage-provider')
const createStandardProvider = require('./createStandardProvider').default

let warned = false

restoreContextAfterImports()

log.setDefaultLevel(process.env.METAMASK_DEBUG ? 'debug' : 'warn')

//
// setup plugin communication
//

// /为页面inpage与contentscript建立双向流连接
// setup background connection
const metamaskStream = new LocalMessageDuplexStream({
  name: 'inpage',
  target: 'contentscript',
})

// 组成inpageProvider
// compose the inpage provider
const inpageProvider = new MetamaskInpageProvider(metamaskStream)

// set a high max listener count to avoid unnecesary warnings
inpageProvider.setMaxListeners(100)

let warnedOfAutoRefreshDeprecation = false
// augment the provider with its enable method
inpageProvider.enable = function ({ force } = {}) {
  if (
    !warnedOfAutoRefreshDeprecation &&
    inpageProvider.autoRefreshOnNetworkChange
  ) {
    console.warn(`MetaMask: MetaMask will soon stop reloading pages on network change.
If you rely upon this behavior, add a 'networkChanged' event handler to trigger the reload manually: https://metamask.github.io/metamask-docs/API_Reference/Ethereum_Provider#ethereum.on(eventname%2C-callback)
Set 'ethereum.autoRefreshOnNetworkChange' to 'false' to silence this warning: https://metamask.github.io/metamask-docs/API_Reference/Ethereum_Provider#ethereum.autorefreshonnetworkchange'
`)
    warnedOfAutoRefreshDeprecation = true
  }
  return new Promise((resolve, reject) => {
    inpageProvider.sendAsync({ method: 'eth_requestAccounts', params: [force] }, (error, response) => {
      if (error || response.error) {
        reject(error || response.error)
      } else {
        resolve(response.result)
      }
    })
  })
}

// give the dapps control of a refresh they can toggle this off on the window.ethereum
// this will be default true so it does not break any old apps.
inpageProvider.autoRefreshOnNetworkChange = true


// publicConfig isn't populated until we get a message from background.
// Using this getter will ensure the state is available
const getPublicConfigWhenReady = async () => {
  const store = inpageProvider.publicConfigStore
  let state = store.getState()
  // if state is missing, wait for first update
  if (!state.networkVersion) {
    state = await new Promise(resolve => store.once('update', resolve))
    console.log('new state', state)
  }
  return state
}

// 增加 _metamask 和一些方法
// add metamask-specific convenience methods
inpageProvider._metamask = new Proxy({
  /**
   * Synchronously determines if this domain is currently enabled, with a potential false negative if called to soon
   *
   * @returns {boolean} - returns true if this domain is currently enabled
   */
  isEnabled: function () {
    const { isEnabled } = inpageProvider.publicConfigStore.getState()
    return Boolean(isEnabled)
  },

  /**
   * Asynchronously determines if this domain is currently enabled
   *
   * @returns {Promise<boolean>} - Promise resolving to true if this domain is currently enabled
   */
  isApproved: async function () {
    const { isEnabled } = await getPublicConfigWhenReady()
    return Boolean(isEnabled)
  },

  /**
   * Determines if MetaMask is unlocked by the user
   *
   * @returns {Promise<boolean>} - Promise resolving to true if MetaMask is currently unlocked
   */
  isUnlocked: async function () {
    const { isUnlocked } = await getPublicConfigWhenReady()
    return Boolean(isUnlocked)
  },
}, {
  get: function (obj, prop) {
    !warned && console.warn('Heads up! ethereum._metamask exposes methods that have ' +
    'not been standardized yet. This means that these methods may not be implemented ' +
    'in other dapp browsers and may be removed from MetaMask in the future.')
    warned = true
    return obj[prop]
  },
})

// Work around for web3@1.0 deleting the bound `sendAsync` but not the unbound
// `sendAsync` method on the prototype, causing `this` reference issues
const proxiedInpageProvider = new Proxy(inpageProvider, {
  // straight up lie that we deleted the property so that it doesnt
  // throw an error in strict mode
  deleteProperty: () => true,
})

window.ethereum = createStandardProvider(proxiedInpageProvider)

//
// setup web3
//

if (typeof window.web3 !== 'undefined') {
  throw new Error(`MetaMask detected another web3.
     MetaMask will not work reliably with another web3 extension.
     This usually happens if you have two MetaMasks installed,
     or MetaMask and another web3 extension. Please remove one
     and try again.`)
}

const web3 = new Web3(proxiedInpageProvider)
web3.setProvider = function () {
  log.debug('MetaMask - overrode web3.setProvider')
}
log.debug('MetaMask - injected web3')

setupDappAutoReload(web3, inpageProvider.publicConfigStore)

// set web3 defaultAccount
inpageProvider.publicConfigStore.subscribe(function (state) {
  web3.eth.defaultAccount = state.selectedAddress
})

inpageProvider.publicConfigStore.subscribe(function (state) {
  if (state.onboardingcomplete) {
    window.postMessage('onboardingcomplete', '*')
  }
})
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;">
    <c:title id="metamask-controller"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/metamask-controller.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
先了解下面的库
</div>
<div style="margin-bottom:1em;">
gaba
</div>
<div style="margin-bottom:1em;">
https://github.com/MetaMask/gaba
</div>
<div style="margin-bottom:1em;">
平台无关模块的集合，用于为加密货币钱包创建安全的数据模型
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
import {
  ComposableController,
  NetworkStatusController,
  TokenRatesController
} from 'gaba';

const datamodel = new ComposableController([
  new NetworkStatusController(),
  new TokenRatesController()
]);

datamodel.subscribe((state) => {/* data model has changed */});
   ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="代码" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[

<div style="margin-bottom:1em;">
MetaMask 的核心功能都存在于 MetaMask Controller 里，这个文件的目标是让它最终成为能够被导入到任何兼容于js的上下文中的属于自己的 javascript 模块，从而完全管理应用程序与以太坊之间的关系。
</div>
<div style="margin-bottom:1em;">
建议一个一个方法跟进去看。
</div>
<div style="margin-bottom:1em;">
不知道 account、wallet、vault 的含义，可以看 https://wiki.parity.io/Accounts%2C-Wallets%2C-Vaults
</div>
   ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:green;font-size:1em;background-color:white;font-size:1.2em;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
/**
 * MetaMask Controller 聚合其他控制器并导出api
 * @file      The central metamask controller. Aggregates other controllers and exports an api.
 * @copyright Copyright (c) 2018 MetaMask
 * @license   MIT
 */

const EventEmitter = require('events')
const pump = require('pump')
const Dnode = require('dnode')
const pify = require('pify')
const ObservableStore = require('obs-store')
const ComposableObservableStore = require('./lib/ComposableObservableStore')
const createDnodeRemoteGetter = require('./lib/createDnodeRemoteGetter')
const asStream = require('obs-store/lib/asStream')
const AccountTracker = require('./lib/account-tracker')
const RpcEngine = require('json-rpc-engine')
const debounce = require('debounce')
const createEngineStream = require('json-rpc-middleware-stream/engineStream')
const createFilterMiddleware = require('eth-json-rpc-filters')
const createSubscriptionManager = require('eth-json-rpc-filters/subscriptionManager')
const createOriginMiddleware = require('./lib/createOriginMiddleware')
const createLoggerMiddleware = require('./lib/createLoggerMiddleware')
const providerAsMiddleware = require('eth-json-rpc-middleware/providerAsMiddleware')
const {setupMultiplex} = require('./lib/stream-utils.js')
const KeyringController = require('eth-keyring-controller')
const NetworkController = require('./controllers/network')
const PreferencesController = require('./controllers/preferences')
const AppStateController = require('./controllers/app-state')
const InfuraController = require('./controllers/infura')
const CachedBalancesController = require('./controllers/cached-balances')
const OnboardingController = require('./controllers/onboarding')
const ThreeBoxController = require('./controllers/threebox')
const RecentBlocksController = require('./controllers/recent-blocks')
const IncomingTransactionsController = require('./controllers/incoming-transactions')
const MessageManager = require('./lib/message-manager')
const PersonalMessageManager = require('./lib/personal-message-manager')
const TypedMessageManager = require('./lib/typed-message-manager')
const TransactionController = require('./controllers/transactions')
const TokenRatesController = require('./controllers/token-rates')
const DetectTokensController = require('./controllers/detect-tokens')
const ProviderApprovalController = require('./controllers/provider-approval')
const ABTestController = require('./controllers/ab-test')
const nodeify = require('./lib/nodeify')
const accountImporter = require('./account-import-strategies')
const getBuyEthUrl = require('./lib/buy-eth-url')
const selectChainId = require('./lib/select-chain-id')
const {Mutex} = require('await-semaphore')
const {version} = require('../manifest.json')
const {BN} = require('ethereumjs-util')
const GWEI_BN = new BN('1000000000')
const percentile = require('percentile')
const seedPhraseVerifier = require('./lib/seed-phrase-verifier')
const log = require('loglevel')
const TrezorKeyring = require('eth-trezor-keyring')
const LedgerBridgeKeyring = require('eth-ledger-bridge-keyring')
const EthQuery = require('eth-query')
const ethUtil = require('ethereumjs-util')
const contractMap = require('eth-contract-metadata')
// https://github.com/MetaMask/gaba
// 平台无关模块的集合，用于为加密货币钱包创建安全的数据模型
const {
  AddressBookController,
  CurrencyRateController,
  ShapeShiftController,
  PhishingController,
} = require('gaba')
const backEndMetaMetricsEvent = require('./lib/backend-metametrics')

module.exports = class MetamaskController extends EventEmitter {

  /**
   * @constructor
   * @param {Object} opts
   */
  constructor (opts) {
    super()

    this.defaultMaxListeners = 20

    this.sendUpdate = debounce(this.privateSendUpdate.bind(this), 200)
    this.opts = opts
    const initState = opts.initState || {}
    this.recordFirstTimeInfo(initState)

    // this keeps track of how many "controllerStream" connections are open
    // the only thing that uses controller connections are open metamask UI instances
    this.activeControllerConnections = 0

    // platform-specific api
    this.platform = opts.platform

    // observable state store
    this.store = new ComposableObservableStore(initState)

    // lock to ensure only one vault created at once
    // 保证一次只有一个 vault 创建
    this.createVaultMutex = new Mutex()

    // network store
    this.networkController = new NetworkController(initState.NetworkController)

    // preferences controller
    this.preferencesController = new PreferencesController({
      initState: initState.PreferencesController,
      initLangCode: opts.initLangCode,
      openPopup: opts.openPopup,
      network: this.networkController,
    })

    // app-state controller
    this.appStateController = new AppStateController({
      preferencesStore: this.preferencesController.store,
      onInactiveTimeout: () => this.setLocked(),
    })

    // currency controller
    this.currencyRateController = new CurrencyRateController(undefined, initState.CurrencyController)

    // infura controller
    this.infuraController = new InfuraController({
      initState: initState.InfuraController,
    })
    this.infuraController.scheduleInfuraNetworkCheck()

    this.phishingController = new PhishingController()

    // rpc provider
    this.initializeProvider()
    this.provider = this.networkController.getProviderAndBlockTracker().provider
    this.blockTracker = this.networkController.getProviderAndBlockTracker().blockTracker

    // token exchange rate tracker
    this.tokenRatesController = new TokenRatesController({
      currency: this.currencyRateController,
      preferences: this.preferencesController.store,
    })

    this.recentBlocksController = new RecentBlocksController({
      blockTracker: this.blockTracker,
      provider: this.provider,
      networkController: this.networkController,
    })

    this.incomingTransactionsController = new IncomingTransactionsController({
      blockTracker: this.blockTracker,
      networkController: this.networkController,
      preferencesController: this.preferencesController,
      initState: initState.IncomingTransactionsController,
    })

    // account tracker watches balances, nonces, and any code at their address.
    this.accountTracker = new AccountTracker({
      provider: this.provider,
      blockTracker: this.blockTracker,
      network: this.networkController,
    })

    // activeControllerConnections > 0 开始查余额，否则停止
    // start and stop polling for balances based on activeControllerConnections
    this.on('controllerConnectionChanged', (activeControllerConnections) => {
      if (activeControllerConnections > 0) {
        this.accountTracker.start()
        this.incomingTransactionsController.start()
      } else {
        this.accountTracker.stop()
        this.incomingTransactionsController.stop()
      }
    })

    this.cachedBalancesController = new CachedBalancesController({
      accountTracker: this.accountTracker,
      getNetwork: this.networkController.getNetworkState.bind(this.networkController),
      initState: initState.CachedBalancesController,
    })

    this.onboardingController = new OnboardingController({
      initState: initState.OnboardingController,
    })

    // ensure accountTracker updates balances after network change
    this.networkController.on('networkDidChange', () => {
      this.accountTracker._updateAccounts()
    })

    // key mgmt
    const additionalKeyrings = [TrezorKeyring, LedgerBridgeKeyring]
    this.keyringController = new KeyringController({
      keyringTypes: additionalKeyrings,
      initState: initState.KeyringController,
      getNetwork: this.networkController.getNetworkState.bind(this.networkController),
      encryptor: opts.encryptor || undefined,
    })

    this.keyringController.memStore.subscribe((s) => this._onKeyringControllerUpdate(s))

    // detect tokens controller
    this.detectTokensController = new DetectTokensController({
      preferences: this.preferencesController,
      network: this.networkController,
      keyringMemStore: this.keyringController.memStore,
    })

    this.addressBookController = new AddressBookController(undefined, initState.AddressBookController)

    this.threeBoxController = new ThreeBoxController({
      preferencesController: this.preferencesController,
      addressBookController: this.addressBookController,
      keyringController: this.keyringController,
      initState: initState.ThreeBoxController,
      getKeyringControllerState: this.keyringController.memStore.getState.bind(this.keyringController.memStore),
      version,
    })

    // tx mgmt
    this.txController = new TransactionController({
      initState: initState.TransactionController || initState.TransactionManager,
      networkStore: this.networkController.networkStore,
      preferencesStore: this.preferencesController.store,
      txHistoryLimit: 40,
      getNetwork: this.networkController.getNetworkState.bind(this),
      signTransaction: this.keyringController.signTransaction.bind(this.keyringController),
      provider: this.provider,
      blockTracker: this.blockTracker,
      getGasPrice: this.getGasPrice.bind(this),
    })
    this.txController.on('newUnapprovedTx', () => opts.showUnapprovedTx())

    this.txController.on(`tx:status-update`, async (txId, status) => {
      if (status === 'confirmed' || status === 'failed') {
        const txMeta = this.txController.txStateManager.getTx(txId)
        this.platform.showTransactionNotification(txMeta)

        const { txReceipt } = txMeta
        const participateInMetaMetrics = this.preferencesController.getParticipateInMetaMetrics()
        if (txReceipt && txReceipt.status === '0x0' && participateInMetaMetrics) {
          const metamaskState = await this.getState()
          backEndMetaMetricsEvent(metamaskState, {
            customVariables: {
              errorMessage: txMeta.simulationFails.reason,
            },
            eventOpts: {
              category: 'backend',
              action: 'Transactions',
              name: 'On Chain Failure',
            },
          })
        }
      }
    })

    this.networkController.on('networkDidChange', () => {
      this.setCurrentCurrency(this.currencyRateController.state.currentCurrency, function () {})
    })

    this.shapeshiftController = new ShapeShiftController(undefined, initState.ShapeShiftController)

    this.networkController.lookupNetwork()
    this.messageManager = new MessageManager()
    this.personalMessageManager = new PersonalMessageManager()
    this.typedMessageManager = new TypedMessageManager({ networkController: this.networkController })

    // ensure isClientOpenAndUnlocked is updated when memState updates
    this.on('update', (memState) => {
      this.isClientOpenAndUnlocked = memState.isUnlocked && this._isClientOpen
    })

    this.providerApprovalController = new ProviderApprovalController({
      closePopup: opts.closePopup,
      initState: initState.ProviderApprovalController,
      keyringController: this.keyringController,
      openPopup: opts.openPopup,
      preferencesController: this.preferencesController,
    })

    this.abTestController = new ABTestController({
      initState: initState.ABTestController,
    })

    this.store.updateStructure({
      AppStateController: this.appStateController.store,
      TransactionController: this.txController.store,
      KeyringController: this.keyringController.store,
      PreferencesController: this.preferencesController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      ShapeShiftController: this.shapeshiftController,
      NetworkController: this.networkController.store,
      InfuraController: this.infuraController.store,
      CachedBalancesController: this.cachedBalancesController.store,
      OnboardingController: this.onboardingController.store,
      ProviderApprovalController: this.providerApprovalController.store,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      ThreeBoxController: this.threeBoxController.store,
      ABTestController: this.abTestController.store,
    })

    this.memStore = new ComposableObservableStore(null, {
      AppStateController: this.appStateController.store,
      NetworkController: this.networkController.store,
      AccountTracker: this.accountTracker.store,
      TxController: this.txController.memStore,
      CachedBalancesController: this.cachedBalancesController.store,
      TokenRatesController: this.tokenRatesController.store,
      MessageManager: this.messageManager.memStore,
      PersonalMessageManager: this.personalMessageManager.memStore,
      TypesMessageManager: this.typedMessageManager.memStore,
      KeyringController: this.keyringController.memStore,
      PreferencesController: this.preferencesController.store,
      RecentBlocksController: this.recentBlocksController.store,
      AddressBookController: this.addressBookController,
      CurrencyController: this.currencyRateController,
      ShapeshiftController: this.shapeshiftController,
      InfuraController: this.infuraController.store,
      OnboardingController: this.onboardingController.store,
      // ProviderApprovalController
      ProviderApprovalController: this.providerApprovalController.store,
      ProviderApprovalControllerMemStore: this.providerApprovalController.memStore,
      IncomingTransactionsController: this.incomingTransactionsController.store,
      // ThreeBoxController
      ThreeBoxController: this.threeBoxController.store,
      ABTestController: this.abTestController.store,
    })
    this.memStore.subscribe(this.sendUpdate.bind(this))
  }

  /**
   * Constructor helper: initialize a provider.
   */
  initializeProvider () {
    const providerOpts = {
      static: {
        eth_syncing: false,
        web3_clientVersion: `MetaMask/v${version}`,
      },
      version,
      // account mgmt
      // 解锁时才显示账户
      getAccounts: async ({ origin }) => {
        // Expose no accounts if this origin has not been approved, preventing
        // account-requring RPC methods from completing successfully
        const exposeAccounts = this.providerApprovalController.shouldExposeAccounts(origin)
        if (origin !== 'metamask' && !exposeAccounts) { return [] }
        const isUnlocked = this.keyringController.memStore.getState().isUnlocked
        const selectedAddress = this.preferencesController.getSelectedAddress()
        // only show address if account is unlocked
        if (isUnlocked && selectedAddress) {
          return [selectedAddress]
        } else {
          return []
        }
      },
      // tx signing
      processTransaction: this.newUnapprovedTransaction.bind(this),
      // msg signing
      processEthSignMessage: this.newUnsignedMessage.bind(this),
      processTypedMessage: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV3: this.newUnsignedTypedMessage.bind(this),
      processTypedMessageV4: this.newUnsignedTypedMessage.bind(this),
      processPersonalMessage: this.newUnsignedPersonalMessage.bind(this),
      getPendingNonce: this.getPendingNonce.bind(this),
    }
    const providerProxy = this.networkController.initializeProvider(providerOpts)
    return providerProxy
  }

  /**
   * 把一些公共配置同步给 dapp，如 isUnlocked, selectedAddress, network, completedOnboarding, provider
   * Constructor helper: initialize a public config store.
   * This store is used to make some config info available to Dapps synchronously.
   */
  createPublicConfigStore ({ checkIsEnabled }) {
    // subset of state for metamask inpage provider
    const publicConfigStore = new ObservableStore()

    // setup memStore subscription hooks
    this.on('update', updatePublicConfigStore)
    updatePublicConfigStore(this.getState())

    publicConfigStore.destroy = () => {
      this.removeEventListener && this.removeEventListener('update', updatePublicConfigStore)
    }

    function updatePublicConfigStore (memState) {
      const publicState = selectPublicState(memState)
      publicConfigStore.putState(publicState)
    }

    function selectPublicState ({ isUnlocked, selectedAddress, network, completedOnboarding, provider }) {
      const isEnabled = checkIsEnabled()
      const isReady = isUnlocked && isEnabled
      const result = {
        isUnlocked,
        isEnabled,
        selectedAddress: isReady ? selectedAddress : null,
        networkVersion: network,
        onboardingcomplete: completedOnboarding,
        chainId: selectChainId({ network, provider }),
      }
      return result
    }

    return publicConfigStore
  }

  //=============================================================================
  // EXPOSED TO THE UI SUBSYSTEM
  //=============================================================================

  /**
   * UI 可以使用的 state
   * The metamask-state of the various controllers, made available to the UI
   *
   * @returns {Object} status
   */
  getState () {
    const vault = this.keyringController.store.getState().vault
    const isInitialized = !!vault

    return {
      ...{ isInitialized },
      ...this.memStore.getFlatState(),
    }
  }

  /**
   * UI 可以调用的 API
   * Returns an Object containing API Callback Functions.
   * These functions are the interface for the UI.
   * The API object can be transmitted over a stream with dnode.
   *
   * @returns {Object} Object containing API functions.
   */
  getApi () {
    const keyringController = this.keyringController
    const preferencesController = this.preferencesController
    const txController = this.txController
    const networkController = this.networkController
    const providerApprovalController = this.providerApprovalController
    const onboardingController = this.onboardingController
    const threeBoxController = this.threeBoxController
    const abTestController = this.abTestController

    return {
      // etc
      getState: (cb) => cb(null, this.getState()),
      setCurrentCurrency: this.setCurrentCurrency.bind(this),
      setUseBlockie: this.setUseBlockie.bind(this),
      setUseNonceField: this.setUseNonceField.bind(this),
      setParticipateInMetaMetrics: this.setParticipateInMetaMetrics.bind(this),
      setMetaMetricsSendCount: this.setMetaMetricsSendCount.bind(this),
      setFirstTimeFlowType: this.setFirstTimeFlowType.bind(this),
      setCurrentLocale: this.setCurrentLocale.bind(this),
      markAccountsFound: this.markAccountsFound.bind(this),
      markPasswordForgotten: this.markPasswordForgotten.bind(this),
      unMarkPasswordForgotten: this.unMarkPasswordForgotten.bind(this),
      getGasPrice: (cb) => cb(null, this.getGasPrice()),

      // coinbase
      buyEth: this.buyEth.bind(this),
      // shapeshift
      createShapeShiftTx: this.createShapeShiftTx.bind(this),

      // primary HD keyring management
      addNewAccount: nodeify(this.addNewAccount, this),
      verifySeedPhrase: nodeify(this.verifySeedPhrase, this),
      resetAccount: nodeify(this.resetAccount, this),
      removeAccount: nodeify(this.removeAccount, this),
      importAccountWithStrategy: nodeify(this.importAccountWithStrategy, this),

      // hardware wallets
      connectHardware: nodeify(this.connectHardware, this),
      forgetDevice: nodeify(this.forgetDevice, this),
      checkHardwareStatus: nodeify(this.checkHardwareStatus, this),
      unlockHardwareWalletAccount: nodeify(this.unlockHardwareWalletAccount, this),

      // mobile
      fetchInfoToSync: nodeify(this.fetchInfoToSync, this),

      // vault management
      submitPassword: nodeify(this.submitPassword, this),

      // network management
      setProviderType: nodeify(networkController.setProviderType, networkController),
      setCustomRpc: nodeify(this.setCustomRpc, this),
      updateAndSetCustomRpc: nodeify(this.updateAndSetCustomRpc, this),
      delCustomRpc: nodeify(this.delCustomRpc, this),

      // PreferencesController 相关方法
      setSelectedAddress: nodeify(preferencesController.setSelectedAddress, preferencesController),
      addToken: nodeify(preferencesController.addToken, preferencesController),
      removeToken: nodeify(preferencesController.removeToken, preferencesController),
      removeSuggestedTokens: nodeify(preferencesController.removeSuggestedTokens, preferencesController),
      setCurrentAccountTab: nodeify(preferencesController.setCurrentAccountTab, preferencesController),
      setAccountLabel: nodeify(preferencesController.setAccountLabel, preferencesController),
      setFeatureFlag: nodeify(preferencesController.setFeatureFlag, preferencesController),
      setPreference: nodeify(preferencesController.setPreference, preferencesController),
      completeOnboarding: nodeify(preferencesController.completeOnboarding, preferencesController),
      addKnownMethodData: nodeify(preferencesController.addKnownMethodData, preferencesController),
      unsetMigratedPrivacyMode: nodeify(preferencesController.unsetMigratedPrivacyMode, preferencesController),

      // BlacklistController
      whitelistPhishingDomain: this.whitelistPhishingDomain.bind(this),

      // AddressController
      // https://github.com/MetaMask/gaba#addressbookcontroller
      setAddressBook: nodeify(this.addressBookController.set, this.addressBookController),
      removeFromAddressBook: this.addressBookController.delete.bind(this.addressBookController),

      // AppStateController
      // 将上次激活时间设置为当前时间
      setLastActiveTime: nodeify(this.appStateController.setLastActiveTime, this.appStateController),

      // KeyringController
      // https://github.com/tsirysndr/eth-keyring-controller
      setLocked: nodeify(this.setLocked, this),
      createNewVaultAndKeychain: nodeify(this.createNewVaultAndKeychain, this),
      createNewVaultAndRestore: nodeify(this.createNewVaultAndRestore, this),
      addNewKeyring: nodeify(keyringController.addNewKeyring, keyringController),
      exportAccount: nodeify(keyringController.exportAccount, keyringController),

      // txController
      cancelTransaction: nodeify(txController.cancelTransaction, txController),
      updateTransaction: nodeify(txController.updateTransaction, txController),
      updateAndApproveTransaction: nodeify(txController.updateAndApproveTransaction, txController),
      retryTransaction: nodeify(this.retryTransaction, this),
      createCancelTransaction: nodeify(this.createCancelTransaction, this),
      createSpeedUpTransaction: nodeify(this.createSpeedUpTransaction, this),
      getFilteredTxList: nodeify(txController.getFilteredTxList, txController),
      isNonceTaken: nodeify(txController.isNonceTaken, txController),
      estimateGas: nodeify(this.estimateGas, this),
      getPendingNonce: nodeify(this.getPendingNonce, this),
      getNextNonce: nodeify(this.getNextNonce, this),

      // messageManager
      signMessage: nodeify(this.signMessage, this),
      cancelMessage: this.cancelMessage.bind(this),

      // personalMessageManager
      signPersonalMessage: nodeify(this.signPersonalMessage, this),
      cancelPersonalMessage: this.cancelPersonalMessage.bind(this),

      // personalMessageManager
      signTypedMessage: nodeify(this.signTypedMessage, this),
      cancelTypedMessage: this.cancelTypedMessage.bind(this),

      // provider approval
      approveProviderRequestByOrigin: providerApprovalController.approveProviderRequestByOrigin.bind(providerApprovalController),
      rejectProviderRequestByOrigin: providerApprovalController.rejectProviderRequestByOrigin.bind(providerApprovalController),
      clearApprovedOrigins: providerApprovalController.clearApprovedOrigins.bind(providerApprovalController),

      // onboarding controller
      setSeedPhraseBackedUp: nodeify(onboardingController.setSeedPhraseBackedUp, onboardingController),

      // 3Box https://github.com/3box/3box-js
      setThreeBoxSyncingPermission: nodeify(threeBoxController.setThreeBoxSyncingPermission, threeBoxController),
      restoreFromThreeBox: nodeify(threeBoxController.restoreFromThreeBox, threeBoxController),
      setShowRestorePromptToFalse: nodeify(threeBoxController.setShowRestorePromptToFalse, threeBoxController),
      getThreeBoxLastUpdated: nodeify(threeBoxController.getLastUpdated, threeBoxController),
      turnThreeBoxSyncingOn: nodeify(threeBoxController.turnThreeBoxSyncingOn, threeBoxController),
      initializeThreeBox: nodeify(this.initializeThreeBox, this),

      // a/b test controller
      getAssignedABTestGroupName: nodeify(abTestController.getAssignedABTestGroupName, abTestController),
    }
  }


  //=============================================================================
  // VAULT / KEYRING RELATED METHODS
  //=============================================================================

  /**
   * 创建一个新的 vault 并创建一个新的钥匙串
   * Creates a new Vault and create a new keychain.
   *
   * A vault, or KeyringController, is a controller that contains
   * many different account strategies, currently called Keyrings.
   * Creating it new means wiping all previous keyrings.
   *
   * A keychain, or keyring, controls many accounts with a single backup and signing strategy.
   * For example, a mnemonic phrase can generate many accounts, and is a keyring.
   *
   * @param  {string} password
   *
   * @returns {Object} vault
   */
  async createNewVaultAndKeychain (password) {
    const releaseLock = await this.createVaultMutex.acquire()
    try {
      let vault
      const accounts = await this.keyringController.getAccounts()
      if (accounts.length > 0) {
        vault = await this.keyringController.fullUpdate()
      } else {
        vault = await this.keyringController.createNewVaultAndKeychain(password)
        const accounts = await this.keyringController.getAccounts()
        this.preferencesController.setAddresses(accounts)
        this.selectFirstIdentity()
      }
      releaseLock()
      return vault
    } catch (err) {
      releaseLock()
      throw err
    }
  }

  /**
   * 创建一个新的 vault 并还原现有的 keyring
   * Create a new Vault and restore an existent keyring.
   * @param  {} password
   * @param  {} seed
   */
  async createNewVaultAndRestore (password, seed) {
    const releaseLock = await this.createVaultMutex.acquire()
    try {
      let accounts, lastBalance

      const keyringController = this.keyringController

      // clear known identities
      this.preferencesController.setAddresses([])
      // create new vault
      const vault = await keyringController.createNewVaultAndRestore(password, seed)

      const ethQuery = new EthQuery(this.provider)
      accounts = await keyringController.getAccounts()
      lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery)

      const primaryKeyring = keyringController.getKeyringsByType('HD Key Tree')[0]
      if (!primaryKeyring) {
        throw new Error('MetamaskController - No HD Key Tree found')
      }

      // seek out the first zero balance
      while (lastBalance !== '0x0') {
        await keyringController.addNewAccount(primaryKeyring)
        accounts = await keyringController.getAccounts()
        lastBalance = await this.getBalance(accounts[accounts.length - 1], ethQuery)
      }

      // set new identities
      this.preferencesController.setAddresses(accounts)
      this.selectFirstIdentity()
      releaseLock()
      return vault
    } catch (err) {
      releaseLock()
      throw err
    }
  }

  /**
   * 从 AccountTracker 获取帐户余额，或直接从网络请求
   * Get an account balance from the AccountTracker or request it directly from the network.
   * @param {string} address - The account address
   * @param {EthQuery} ethQuery - The EthQuery instance to use when asking the network
   */
  getBalance (address, ethQuery) {
    return new Promise((resolve, reject) => {
      const cached = this.accountTracker.store.getState().accounts[address]

      if (cached && cached.balance) {
        resolve(cached.balance)
      } else {
        ethQuery.getBalance(address, (error, balance) => {
          if (error) {
            reject(error)
            log.error(error)
          } else {
            resolve(balance || '0x0')
          }
        })
      }
    })
  }

  /**
   * 收集我们要与移动客户端共享的所有信息用于同步
   * accounts、preferences、transactions、network
   *
   * Collects all the information that we want to share
   * with the mobile client for syncing purposes
   * @returns Promise<Object> Parts of the state that we want to syncx
   */
  async fetchInfoToSync () {
    // Preferences
    const {
      accountTokens,
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress,
      tokens,
    } = this.preferencesController.store.getState()

    // Filter ERC20 tokens
    const filteredAccountTokens = {}
    Object.keys(accountTokens).forEach(address => {
      const checksummedAddress = ethUtil.toChecksumAddress(address)
      filteredAccountTokens[checksummedAddress] = {}
      Object.keys(accountTokens[address]).forEach(
        networkType => (filteredAccountTokens[checksummedAddress][networkType] = networkType !== 'mainnet' ?
          accountTokens[address][networkType] :
          accountTokens[address][networkType].filter(({ address }) => {
            const tokenAddress = ethUtil.toChecksumAddress(address)
            return contractMap[tokenAddress] ? contractMap[tokenAddress].erc20 : true
          })
        )
      )
    })

    const preferences = {
      accountTokens: filteredAccountTokens,
      currentLocale,
      frequentRpcList,
      identities,
      selectedAddress,
      tokens,
    }

    // Accounts
    const hdKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0]
    const hdAccounts = await hdKeyring.getAccounts()
    const accounts = {
      hd: hdAccounts.filter((item, pos) => (hdAccounts.indexOf(item) === pos)).map(address => ethUtil.toChecksumAddress(address)),
      simpleKeyPair: [],
      ledger: [],
      trezor: [],
    }

    // transactions

    let transactions = this.txController.store.getState().transactions
    // delete tx for other accounts that we're not importing
    transactions = transactions.filter(tx => {
      const checksummedTxFrom = ethUtil.toChecksumAddress(tx.txParams.from)
      return (
        accounts.hd.includes(checksummedTxFrom)
      )
    })

    return {
      accounts,
      preferences,
      transactions,
      network: this.networkController.store.getState(),
    }
  }

  /**
   * 提交用户密码并尝试解锁 vault
   * Submits the user's password and attempts to unlock the vault.
   * Also synchronizes the preferencesController, to ensure its schema
   * is up to date with known accounts once the vault is decrypted.
   *
   * @param {string} password - The user's password
   * @returns {Promise<object>} - The keyringController update.
   */
  async submitPassword (password) {
    await this.keyringController.submitPassword(password)
    const accounts = await this.keyringController.getAccounts()

    // verify keyrings
    const nonSimpleKeyrings = this.keyringController.keyrings.filter(keyring => keyring.type !== 'Simple Key Pair')
    if (nonSimpleKeyrings.length > 1 && this.diagnostics) {
      await this.diagnostics.reportMultipleKeyrings(nonSimpleKeyrings)
    }

    await this.preferencesController.syncAddresses(accounts)
    await this.txController.pendingTxTracker.updatePendingTxs()

    try {
      const threeBoxSyncingAllowed = this.threeBoxController.getThreeBoxSyncingState()
      if (threeBoxSyncingAllowed && !this.threeBoxController.box) {
        // 'await' intentionally omitted to avoid waiting for initialization
        this.threeBoxController.init()
        this.threeBoxController.turnThreeBoxSyncingOn()
      } else if (threeBoxSyncingAllowed && this.threeBoxController.box) {
        this.threeBoxController.turnThreeBoxSyncingOn()
      }
    } catch (error) {
      log.error(error)
    }

    return this.keyringController.fullUpdate()
  }

  /**
   * 用户身份
   * @type Identity
   * @property {string} name - The account nickname.
   * @property {string} address - The account's ethereum address, in lower case.
   * @property {boolean} mayBeFauceting - Whether this account is currently
   * receiving funds from our automatic Ropsten faucet.
   */

  /**
   * 将 state 中的第一个地址设置为所选地址
   * Sets the first address in the state to the selected address
   */
  selectFirstIdentity () {
    const { identities } = this.preferencesController.store.getState()
    const address = Object.keys(identities)[0]
    this.preferencesController.setSelectedAddress(address)
  }

  // 获取硬件钱包 keyring
  // https://github.com/MetaMask/eth-simple-keyring#the-keyring-class-protocol
  // Hardware
  //

  async getKeyringForDevice (deviceName, hdPath = null) {
    let keyringName = null
    switch (deviceName) {
      case 'trezor':
        keyringName = TrezorKeyring.type
        break
      case 'ledger':
        keyringName = LedgerBridgeKeyring.type
        break
      default:
        throw new Error('MetamaskController:getKeyringForDevice - Unknown device')
    }
    let keyring = await this.keyringController.getKeyringsByType(keyringName)[0]
    if (!keyring) {
      keyring = await this.keyringController.addNewKeyring(keyringName)
    }
    if (hdPath && keyring.setHdPath) {
      keyring.setHdPath(hdPath)
    }

    keyring.network = this.networkController.getProviderConfig().type

    return keyring

  }

  /**
   * 从 trezor 设备获取帐户列表
   * Fetch account list from a trezor device.
   *
   * @returns [] accounts
   */
  async connectHardware (deviceName, page, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath)
    let accounts = []
    switch (page) {
      case -1:
        accounts = await keyring.getPreviousPage()
        break
      case 1:
        accounts = await keyring.getNextPage()
        break
      default:
        accounts = await keyring.getFirstPage()
    }

    // Merge with existing accounts
    // and make sure addresses are not repeated
    const oldAccounts = await this.keyringController.getAccounts()
    const accountsToTrack = [...new Set(oldAccounts.concat(accounts.map(a => a.address.toLowerCase())))]
    this.accountTracker.syncWithAddresses(accountsToTrack)
    return accounts
  }

  /**
   * 检查设备是否已解锁
   * Check if the device is unlocked
   *
   * @returns {Promise<boolean>}
   */
  async checkHardwareStatus (deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath)
    return keyring.isUnlocked()
  }

  /**
   * 从内存中删除所有设备信息
   * 因此与keyring的下一次交互将提示用户连接TREZOR设备并导出帐户信息
   * Clear
   *
   * @returns {Promise<boolean>}
   */
  async forgetDevice (deviceName) {

    const keyring = await this.getKeyringForDevice(deviceName)
    keyring.forgetDevice()
    return true
  }

  /**
   * 从 trezor 设备导入帐户
   * Imports an account from a trezor device.
   *
   * @returns {} keyState
   */
  async unlockHardwareWalletAccount (index, deviceName, hdPath) {
    const keyring = await this.getKeyringForDevice(deviceName, hdPath)

    keyring.setAccountToUnlock(index)
    const oldAccounts = await this.keyringController.getAccounts()
    const keyState = await this.keyringController.addNewAccount(keyring)
    const newAccounts = await this.keyringController.getAccounts()
    this.preferencesController.setAddresses(newAccounts)
    newAccounts.forEach(address => {
      if (!oldAccounts.includes(address)) {
        // Set the account label to Trezor 1 /  Ledger 1, etc
        this.preferencesController.setAccountLabel(address, `${deviceName[0].toUpperCase()}${deviceName.slice(1)} ${parseInt(index, 10) + 1}`)
        // Select the account
        this.preferencesController.setSelectedAddress(address)
      }
    })

    const { identities } = this.preferencesController.store.getState()
    return { ...keyState, identities }
  }


  //
  // Account Management
  //

  /**
   * 将新帐户添加到默认（第一个）HD 助记词
   * Adds a new account to the default (first) HD seed phrase Keyring.
   *
   * @returns {} keyState
   */
  async addNewAccount () {
    const primaryKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0]
    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found')
    }
    const keyringController = this.keyringController
    const oldAccounts = await keyringController.getAccounts()
    const keyState = await keyringController.addNewAccount(primaryKeyring)
    const newAccounts = await keyringController.getAccounts()

    await this.verifySeedPhrase()

    this.preferencesController.setAddresses(newAccounts)
    newAccounts.forEach((address) => {
      if (!oldAccounts.includes(address)) {
        this.preferencesController.setSelectedAddress(address)
      }
    })

    const {identities} = this.preferencesController.store.getState()
    return {...keyState, identities}
  }

  /**
   * 验证助记词的有效性
   * Verifies the validity of the current vault's seed phrase.
   *
   * Validity: seed phrase restores the accounts belonging to the current vault.
   *
   * Called when the first account is created and on unlocking the vault.
   *
   * @returns {Promise<string>} Seed phrase to be confirmed by the user.
   */
  async verifySeedPhrase () {

    const primaryKeyring = this.keyringController.getKeyringsByType('HD Key Tree')[0]
    if (!primaryKeyring) {
      throw new Error('MetamaskController - No HD Key Tree found')
    }

    const serialized = await primaryKeyring.serialize()
    const seedWords = serialized.mnemonic

    const accounts = await primaryKeyring.getAccounts()
    if (accounts.length < 1) {
      throw new Error('MetamaskController - No accounts found')
    }

    try {
      await seedPhraseVerifier.verifyAccounts(accounts, seedWords)
      return seedWords
    } catch (err) {
      log.error(err.message)
      throw err
    }
  }

  /**
   * 清除交易历史记录，以允许用户强制重置其随机数
   * 通常用在开发环境中
   * Clears the transaction history, to allow users to force-reset their nonces.
   * Mostly used in development environments, when networks are restarted with
   * the same network ID.
   *
   * @returns Promise<string> The current selected address.
   */
  async resetAccount () {
    const selectedAddress = this.preferencesController.getSelectedAddress()
    this.txController.wipeTransactions(selectedAddress)
    this.networkController.resetConnection()

    return selectedAddress
  }

  /**
   * 从状态/存储中删除帐户
   * Removes an account from state / storage.
   *
   * @param {string[]} address A hex address
   *
   */
  async removeAccount (address) {
    // Remove account from the preferences controller
    this.preferencesController.removeAddress(address)
    // Remove account from the account tracker controller
    this.accountTracker.removeAccount([address])

    // Remove account from the keyring
    await this.keyringController.removeAccount(address)
    return address
  }


  /**
   * 导入具有指定导入策略的帐户
   * 比如：Private Key、JSON File
   * 每种策略都代表一种不同的序列化以太坊密钥对的方式
   * Imports an account with the specified import strategy.
   * These are defined in app/scripts/account-import-strategies
   * Each strategy represents a different way of serializing an Ethereum key pair.
   *
   * @param  {string} strategy - A unique identifier for an account import strategy.
   * @param  {any} args - The data required by that strategy to import an account.
   * @param  {Function} cb - A callback function called with a state update on success.
   */
  async importAccountWithStrategy (strategy, args) {
    const privateKey = await accountImporter.importAccount(strategy, args)
    const keyring = await this.keyringController.addNewKeyring('Simple Key Pair', [ privateKey ])
    const accounts = await keyring.getAccounts()
    // update accounts in preferences controller
    const allAccounts = await this.keyringController.getAccounts()
    this.preferencesController.setAddresses(allAccounts)
    // set new account as selected
    await this.preferencesController.setSelectedAddress(accounts[0])
  }

  // ---------------------------------------------------------------------------
  // Identity Management (signature operations)
  // 身份管理（签名操作）

  /**
   * 当 Dapp 建议签署新的 TX 时调用
   * Called when a Dapp suggests a new tx to be signed.
   * this wrapper needs to exist so we can provide a reference to
   *  "newUnapprovedTransaction" before "txController" is instantiated
   *
   * @param {Object} msgParams - The params passed to eth_sign.
   * @param {Object} req - (optional) the original request, containing the origin
   */
  async newUnapprovedTransaction (txParams, req) {
    return await this.txController.newUnapprovedTransaction(txParams, req)
  }

  // eth_sign methods:

  /**
   * 当 Dapp 使用 eth_sign 方法来请求用户批准时调用
   * eth_sign 已过时
   * Called when a Dapp uses the eth_sign method, to request user approval.
   * eth_sign is a pure signature of arbitrary data. It is on a deprecation
   * path, since this data can be a transaction, or can leak private key
   * information.
   *
   * @param {Object} msgParams - The params passed to eth_sign.
   * @param {Function} cb = The callback function called with the signature.
   */
  newUnsignedMessage (msgParams, req) {
    const promise = this.messageManager.addUnapprovedMessageAsync(msgParams, req)
    this.sendUpdate()
    this.opts.showUnconfirmedMessage()
    return promise
  }

  /**
   * 表示用户打算完成 eth_sign 方法
   * Signifies user intent to complete an eth_sign method.
   *
   * @param  {Object} msgParams The params passed to eth_call.
   * @returns {Promise<Object>} Full state update.
   */
  signMessage (msgParams) {
    log.info('MetaMaskController - signMessage')
    const msgId = msgParams.metamaskId

    // sets the status op the message to 'approved'
    // and removes the metamaskId for signing
    return this.messageManager.approveMessage(msgParams)
      .then((cleanMsgParams) => {
      // signs the message
        return this.keyringController.signMessage(cleanMsgParams)
      })
      .then((rawSig) => {
      // tells the listener that the message has been signed
      // and can be returned to the dapp
        this.messageManager.setMsgStatusSigned(msgId, rawSig)
        return this.getState()
      })
  }

  /**
   * 用于取消通过 eth_sign 提交的消息
   * Used to cancel a message submitted via eth_sign.
   *
   * @param {string} msgId - The id of the message to cancel.
   */
  cancelMessage (msgId, cb) {
    const messageManager = this.messageManager
    messageManager.rejectMsg(msgId)
    if (cb && typeof cb === 'function') {
      cb(null, this.getState())
    }
  }

  // personal_sign methods:

  /**
   * 当 dapp 使用 personal_sign 方法时调用
   * Called when a dapp uses the personal_sign method.
   * This is identical to the Geth eth_sign method, and may eventually replace
   * eth_sign.
   *
   * We currently define our eth_sign and personal_sign mostly for legacy Dapps.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @param {Function} cb - The callback function called with the signature.
   * Passed back to the requesting Dapp.
   */
  async newUnsignedPersonalMessage (msgParams, req) {
    const promise = this.personalMessageManager.addUnapprovedMessageAsync(msgParams, req)
    this.sendUpdate()
    this.opts.showUnconfirmedMessage()
    return promise
  }

  /**
   * 表示用户同意在队列中签名 personal_sign 消息
   * Signifies a user's approval to sign a personal_sign message in queue.
   * Triggers signing, and the callback function from newUnsignedPersonalMessage.
   *
   * @param {Object} msgParams - The params of the message to sign & return to the Dapp.
   * @returns {Promise<Object>} - A full state update.
   */
  signPersonalMessage (msgParams) {
    log.info('MetaMaskController - signPersonalMessage')
    const msgId = msgParams.metamaskId
    // sets the status op the message to 'approved'
    // and removes the metamaskId for signing
    return this.personalMessageManager.approveMessage(msgParams)
      .then((cleanMsgParams) => {
      // signs the message
        return this.keyringController.signPersonalMessage(cleanMsgParams)
      })
      .then((rawSig) => {
      // tells the listener that the message has been signed
      // and can be returned to the dapp
        this.personalMessageManager.setMsgStatusSigned(msgId, rawSig)
        return this.getState()
      })
  }

  /**
   * 用于取消 personal_sign 类型的消息
   * Used to cancel a personal_sign type message.
   * @param {string} msgId - The ID of the message to cancel.
   * @param {Function} cb - The callback function called with a full state update.
   */
  cancelPersonalMessage (msgId, cb) {
    const messageManager = this.personalMessageManager
    messageManager.rejectMsg(msgId)
    if (cb && typeof cb === 'function') {
      cb(null, this.getState())
    }
  }

  // eth_signTypedData methods

  /**
   * 根据EIP 712，在 dapp 使用 eth_signTypedData 方法时调用
   * Called when a dapp uses the eth_signTypedData method, per EIP 712.
   *
   * @param {Object} msgParams - The params passed to eth_signTypedData.
   * @param {Function} cb - The callback function, called with the signature.
   */
  newUnsignedTypedMessage (msgParams, req, version) {
    const promise = this.typedMessageManager.addUnapprovedMessageAsync(msgParams, req, version)
    this.sendUpdate()
    this.opts.showUnconfirmedMessage()
    return promise
  }

  /**
   * 用户根据EIP 712批准对 eth_signTypedData 的调用的方法
   * The method for a user approving a call to eth_signTypedData, per EIP 712.
   * Triggers the callback in newUnsignedTypedMessage.
   *
   * @param  {Object} msgParams - The params passed to eth_signTypedData.
   * @returns {Object} Full state update.
   */
  async signTypedMessage (msgParams) {
    log.info('MetaMaskController - eth_signTypedData')
    const msgId = msgParams.metamaskId
    const version = msgParams.version
    try {
      const cleanMsgParams = await this.typedMessageManager.approveMessage(msgParams)

      // For some reason every version after V1 used stringified params.
      if (version !== 'V1') {
        // But we don't have to require that. We can stop suggesting it now:
        if (typeof cleanMsgParams.data === 'string') {
          cleanMsgParams.data = JSON.parse(cleanMsgParams.data)
        }
      }

      const signature = await this.keyringController.signTypedMessage(cleanMsgParams, { version })
      this.typedMessageManager.setMsgStatusSigned(msgId, signature)
      return this.getState()
    } catch (error) {
      log.info('MetaMaskController - eth_signTypedData failed.', error)
      this.typedMessageManager.errorMessage(msgId, error)
    }
  }

  /**
   * 用于取消 eth_signTypedData 类型的消息
   * Used to cancel a eth_signTypedData type message.
   * @param {string} msgId - The ID of the message to cancel.
   * @param {Function} cb - The callback function called with a full state update.
   */
  cancelTypedMessage (msgId, cb) {
    const messageManager = this.typedMessageManager
    messageManager.rejectMsg(msgId)
    if (cb && typeof cb === 'function') {
      cb(null, this.getState())
    }
  }

  // ---------------------------------------------------------------------------
  // MetaMask Version 3 Migration Account Restauration Methods

  /**
   * A legacy method (probably dead code) that was used when we swapped out our
   * key management library that we depended on.
   *
   * Described in:
   * https://medium.com/metamask/metamask-3-migration-guide-914b79533cdd
   *
   * @deprecated
   * @param  {} migratorOutput
   */
  restoreOldVaultAccounts (migratorOutput) {
    const { serialized } = migratorOutput
    return this.keyringController.restoreKeyring(serialized)
      .then(() => migratorOutput)
  }

  /**
   * A legacy method used to record user confirmation that they understand
   * that some of their accounts have been recovered but should be backed up.
   * This function no longer does anything and will be removed.
   *
   * @deprecated
   * @param {Function} cb - A callback function called with a full state update.
   */
  markAccountsFound (cb) {
    // TODO Remove me
    cb(null, this.getState())
  }

  /**
   * An account object
   * @typedef Account
   * @property string privateKey - The private key of the account.
   */

  //=============================================================================
  // END (VAULT / KEYRING RELATED METHODS)
  //=============================================================================

  /**
   * 允许用户通过使用更高的gas重试来加快交易速度
   * Allows a user to try to speed up a transaction by retrying it
   * with higher gas.
   *
   * @param {string} txId - The ID of the transaction to speed up.
   */
  async retryTransaction (txId, gasPrice) {
    await this.txController.retryTransaction(txId, gasPrice)
    const state = await this.getState()
    return state
  }

  /**
   * 允许用户尝试通过创建新交易来取消先前提交的交易
   * Allows a user to attempt to cancel a previously submitted transaction by creating a new
   * transaction.
   * @param {number} originalTxId - the id of the txMeta that you want to attempt to cancel
   * @param {string=} customGasPrice - the hex value to use for the cancel transaction
   * @returns {object} MetaMask state
   */
  async createCancelTransaction (originalTxId, customGasPrice) {
    try {
      await this.txController.createCancelTransaction(originalTxId, customGasPrice)
      const state = await this.getState()
      return state
    } catch (error) {
      throw error
    }
  }

  // 使用大 gasPrice 加快交易
  async createSpeedUpTransaction (originalTxId, customGasPrice) {
    await this.txController.createSpeedUpTransaction(originalTxId, customGasPrice)
    const state = await this.getState()
    return state
  }

  // 估算 gas 通过 eth_estimateGas 接口
  estimateGas (estimateGasParams) {
    return new Promise((resolve, reject) => {
      return this.txController.txGasUtil.query.estimateGas(estimateGasParams, (err, res) => {
        if (err) {
          return reject(err)
        }

        return resolve(res)
      })
    })
  }

  //=============================================================================
  // PASSWORD MANAGEMENT
  //=============================================================================

  /**
   * 允许用户开始用助记词恢复钱包
   * Allows a user to begin the seed phrase recovery process.
   * @param {Function} cb - A callback function called when complete.
   */
  markPasswordForgotten (cb) {
    this.preferencesController.setPasswordForgotten(true)
    this.sendUpdate()
    cb()
  }

  /**
   * 允许用户结束助记词恢复过程
   * Allows a user to end the seed phrase recovery process.
   * @param {Function} cb - A callback function called when complete.
   */
  unMarkPasswordForgotten (cb) {
    this.preferencesController.setPasswordForgotten(false)
    this.sendUpdate()
    cb()
  }

  //=============================================================================
  // SETUP
  //=============================================================================

  /**
   * 用于创建复用流以连接到不受信任的上下文，比如 Dapp 或其他扩展程序
   * Used to create a multiplexed stream for connecting to an untrusted context
   * like a Dapp or other extension.
   * @param {*} connectionStream - The Duplex stream to connect to.
   * @param {URL} senderUrl - The URL of the resource requesting the stream,
   * which may trigger a blacklist reload.
   * @param {string} extensionId - The extension id of the sender, if the sender
   * is an extension
   */
  setupUntrustedCommunication (connectionStream, senderUrl, extensionId) {
    // Check if new connection is blacklisted
    if (this.phishingController.test(senderUrl.hostname)) {
      log.debug('MetaMask - sending phishing warning for', senderUrl.hostname)
      this.sendPhishingWarning(connectionStream, senderUrl.hostname)
      return
    }

    // setup multiplexing
    const mux = setupMultiplex(connectionStream)
    // connect features
    const publicApi = this.setupPublicApi(mux.createStream('publicApi'))
    this.setupProviderConnection(mux.createStream('provider'), senderUrl, extensionId, publicApi)
    this.setupPublicConfig(mux.createStream('publicConfig'), senderUrl)
  }

  /**
   * 用于创建用于连接到可信上下文的多路复用流
   * Used to create a multiplexed stream for connecting to a trusted context,
   * like our own user interfaces, which have the provider APIs, but also
   * receive the exported API from this controller, which includes trusted
   * functions, like the ability to approve transactions or sign messages.
   *
   * @param {*} connectionStream - The duplex stream to connect to.
   * @param {URL} senderUrl - The URL requesting the connection,
   * used in logging and error reporting.
   */
  setupTrustedCommunication (connectionStream, senderUrl) {
    // setup multiplexing
    const mux = setupMultiplex(connectionStream)
    // connect features
    this.setupControllerConnection(mux.createStream('controller'))
    this.setupProviderConnection(mux.createStream('provider'), senderUrl)
  }

  /**
   * 当检测到可疑域时调用。请求浏览器重定向，转到反网络钓鱼页面。
   * Called when we detect a suspicious domain. Requests the browser redirects
   * to our anti-phishing page.
   *
   * @private
   * @param {*} connectionStream - The duplex stream to the per-page script,
   * for sending the reload attempt to.
   * @param {string} hostname - The URL that triggered the suspicion.
   */
  sendPhishingWarning (connectionStream, hostname) {
    const mux = setupMultiplex(connectionStream)
    const phishingStream = mux.createStream('phishing')
    phishingStream.write({ hostname })
  }

  /**
   * 使用 Dnode 通过流提供我们的API
   * A method for providing our API over a stream using Dnode.
   * @param {*} outStream - The stream to provide our API over.
   */
  setupControllerConnection (outStream) {
    const api = this.getApi()
    // 用 dnode 包装
    const dnode = Dnode(api)
    // report new active controller connection
    this.activeControllerConnections++
    this.emit('controllerConnectionChanged', this.activeControllerConnections)
    // connect dnode api to remote connection
    pump(
      outStream,
      dnode,
      outStream,
      (err) => {
        // report new active controller connection
        this.activeControllerConnections--
        this.emit('controllerConnectionChanged', this.activeControllerConnections)
        // report any error
        if (err) log.error(err)
      }
    )
    dnode.on('remote', (remote) => {
      // push updates to popup
      const sendUpdate = (update) => remote.sendUpdate(update)
      this.on('update', sendUpdate)
      // remove update listener once the connection ends
      dnode.on('end', () => this.removeListener('update', sendUpdate))
    })
  }

  /**
   * 通过给定流为我们的以太坊 provider 提供服务
   * A method for serving our ethereum provider over a given stream.
   * @param {*} outStream - The stream to provide over.
   * @param {URL} senderUrl - The URI of the requesting resource.
   * @param {string} extensionId - The id of the extension, if the requesting
   * resource is an extension.
   * @param {object} publicApi - The public API
   */
  setupProviderConnection (outStream, senderUrl, extensionId, publicApi) {
    const getSiteMetadata = publicApi && publicApi.getSiteMetadata
    const engine = this.setupProviderEngine(senderUrl, extensionId, getSiteMetadata)

    // setup connection
    const providerStream = createEngineStream({ engine })

    pump(
      outStream,
      providerStream,
      outStream,
      (err) => {
        // handle any middleware cleanup
        engine._middleware.forEach((mid) => {
          if (mid.destroy && typeof mid.destroy === 'function') {
            mid.destroy()
          }
        })
        if (err) log.error(err)
      }
    )
  }

  /**
   * 创建 provider，该 provider 在请求域中受到安全限制
   * A method for creating a provider that is safely restricted for the requesting domain.
   **/
  setupProviderEngine (senderUrl, extensionId, getSiteMetadata) {
    const origin = senderUrl.hostname
    // setup json rpc engine stack
    const engine = new RpcEngine()
    const provider = this.provider
    const blockTracker = this.blockTracker

    // create filter polyfill middleware
    const filterMiddleware = createFilterMiddleware({ provider, blockTracker })

    // create subscription polyfill middleware
    const subscriptionManager = createSubscriptionManager({ provider, blockTracker })
    subscriptionManager.events.on('notification', (message) => engine.emit('notification', message))

    // metadata
    engine.push(createOriginMiddleware({ origin }))
    engine.push(createLoggerMiddleware({ origin }))
    // filter and subscription polyfills
    engine.push(filterMiddleware)
    engine.push(subscriptionManager.middleware)
    // watch asset
    engine.push(this.preferencesController.requestWatchAsset.bind(this.preferencesController))
    // requestAccounts
    engine.push(this.providerApprovalController.createMiddleware({
      senderUrl,
      extensionId,
      getSiteMetadata,
    }))
    // forward to metamask primary provider
    engine.push(providerAsMiddleware(provider))
    return engine
  }

  /**
   * 通过流提供我们的公共配置信息
   * A method for providing our public config info over a stream.
   * This includes info we like to be synchronous if possible, like
   * the current selected account, and network ID.
   *
   * Since synchronous methods have been deprecated in web3,
   * this is a good candidate for deprecation.
   *
   * @param {*} outStream - The stream to provide public config over.
   * @param {URL} senderUrl - The URL of requesting resource
   */
  setupPublicConfig (outStream, senderUrl) {
    const configStore = this.createPublicConfigStore({
      // check the providerApprovalController's approvedOrigins
      checkIsEnabled: () => this.providerApprovalController.shouldExposeAccounts(senderUrl.hostname),
    })
    const configStream = asStream(configStore)

    pump(
      configStream,
      outStream,
      (err) => {
        configStore.destroy()
        configStream.destroy()
        if (err) log.error(err)
      }
    )
  }

  /**
   * 通过流提供我们的公共api
   * A method for providing our public api over a stream.
   * This includes a method for setting site metadata like title and image
   *
   * @param {*} outStream - The stream to provide the api over.
   */
  setupPublicApi (outStream) {
    const dnode = Dnode()
    // connect dnode api to remote connection
    pump(
      outStream,
      dnode,
      outStream,
      (err) => {
        // report any error
        if (err) log.error(err)
      }
    )

    const getRemote = createDnodeRemoteGetter(dnode)

    const publicApi = {
      // wrap with an await remote
      getSiteMetadata: async () => {
        const remote = await getRemote()
        return await pify(remote.getSiteMetadata)()
      },
    }

    return publicApi
  }

  /**
   * 处理 KeyringController 更新
   * Handle a KeyringController update
   * @param {object} state the KC state
   * @return {Promise<void>}
   * @private
   */
  async _onKeyringControllerUpdate (state) {
    const {isUnlocked, keyrings} = state
    const addresses = keyrings.reduce((acc, {accounts}) => acc.concat(accounts), [])

    if (!addresses.length) {
      return
    }

    // Ensure preferences + identities controller know about all addresses
    this.preferencesController.addAddresses(addresses)
    this.accountTracker.syncWithAddresses(addresses)

    const wasLocked = !isUnlocked
    if (wasLocked) {
      const oldSelectedAddress = this.preferencesController.getSelectedAddress()
      if (!addresses.includes(oldSelectedAddress)) {
        const address = addresses[0]
        await this.preferencesController.setSelectedAddress(address)
      }
    }
  }

  /**
   * 向所有注册的侦听器发出完整的 MetaMask 状态
   * A method for emitting the full MetaMask state to all registered listeners.
   * @private
   */
  privateSendUpdate () {
    this.emit('update', this.getState())
  }

  /**
   * 以最近的 gas price 估算合适的 gas price
   * A method for estimating a good gas price at recent prices.
   * Returns the lowest price that would have been included in
   * 50% of recent blocks.
   *
   * @returns {string} A hex representation of the suggested wei gas price.
   */
  getGasPrice () {
    const { recentBlocksController } = this
    const { recentBlocks } = recentBlocksController.store.getState()

    // Return 1 gwei if no blocks have been observed:
    if (recentBlocks.length === 0) {
      return '0x' + GWEI_BN.toString(16)
    }

    const lowestPrices = recentBlocks.map((block) => {
      if (!block.gasPrices || block.gasPrices.length < 1) {
        return GWEI_BN
      }
      return block.gasPrices
        .map(hexPrefix => hexPrefix.substr(2))
        .map(hex => new BN(hex, 16))
        .sort((a, b) => {
          return a.gt(b) ? 1 : -1
        })[0]
    })
      .map(number => number.div(GWEI_BN).toNumber())

    const percentileNum = percentile(65, lowestPrices)
    const percentileNumBn = new BN(percentileNum)
    return '0x' + percentileNumBn.mul(GWEI_BN).toString(16)
  }

  /**
   * 返回批准后的交易关联的 nonce
   * Returns the nonce that will be associated with a transaction once approved
   * @param address {string} - The hex string address for the transaction
   * @returns Promise<number>
   */
  async getPendingNonce (address) {
    const { nonceDetails, releaseLock } = await this.txController.nonceTracker.getNonceLock(address)
    const pendingNonce = nonceDetails.params.highestSuggested

    releaseLock()
    return pendingNonce
  }

  /**
   * 根据随机数跟踪器返回下一个随机数
   * Returns the next nonce according to the nonce-tracker
   * @param address {string} - The hex string address for the transaction
   * @returns Promise<number>
   */
  async getNextNonce (address) {
    let nonceLock
    try {
      nonceLock = await this.txController.nonceTracker.getNonceLock(address)
    } finally {
      nonceLock.releaseLock()
    }
    return nonceLock.nextNonce
  }

  //=============================================================================
  // CONFIG
  //=============================================================================

  // Log blocks

  /**
   * 设置用户首选显示货币
   * A method for setting the user's preferred display currency.
   * @param {string} currencyCode - The code of the preferred currency.
   * @param {Function} cb - A callback function returning currency info.
   */
  setCurrentCurrency (currencyCode, cb) {
    const { ticker } = this.networkController.getNetworkConfig()
    try {
      const currencyState = {
        nativeCurrency: ticker,
        currentCurrency: currencyCode,
      }
      this.currencyRateController.update(currencyState)
      this.currencyRateController.configure(currencyState)
      cb(null, this.currencyRateController.state)
    } catch (err) {
      cb(err)
    }
  }

  /**
   * 将用户引导到获取以太币的地址
   * A method for forwarding the user to the easiest way to obtain ether,
   * or the network "gas" currency, for the current selected network.
   *
   * @param {string} address - The address to fund.
   * @param {string} amount - The amount of ether desired, as a base 10 string.
   */
  buyEth (address, amount) {
    if (!amount) amount = '5'
    const network = this.networkController.getNetworkState()
    const url = getBuyEthUrl({ network, address, amount })
    if (url) this.platform.openWindow({ url })
  }

  /**
   * 触发货币转换 https://shapeshift.io/
   * A method for triggering a shapeshift currency transfer.
   * @param {string} depositAddress - The address to deposit to.
   * @property {string} depositType - An abbreviation of the type of crypto currency to be deposited.
   */
  createShapeShiftTx (depositAddress, depositType) {
    this.shapeshiftController.createTransaction(depositAddress, depositType)
  }

  // network
  /**
   * 选择以太坊RPC提供程序的自定义URL并更新它
   * A method for selecting a custom URL for an ethereum RPC provider and updating it
   * @param {string} rpcUrl - A URL for a valid Ethereum RPC API.
   * @param {number} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} nickname - Optional nickname of the selected network.
   * @returns {Promise<String>} - The RPC Target URL confirmed.
   */

  async updateAndSetCustomRpc (rpcUrl, chainId, ticker = 'ETH', nickname, rpcPrefs) {
    await this.preferencesController.updateRpc({ rpcUrl, chainId, ticker, nickname, rpcPrefs })
    this.networkController.setRpcTarget(rpcUrl, chainId, ticker, nickname, rpcPrefs)
    return rpcUrl
  }


  /**
   * 为以太坊RPC提供程序选择自定义URL
   * A method for selecting a custom URL for an ethereum RPC provider.
   * @param {string} rpcTarget - A URL for a valid Ethereum RPC API.
   * @param {number} chainId - The chainId of the selected network.
   * @param {string} ticker - The ticker symbol of the selected network.
   * @param {string} nickname - Optional nickname of the selected network.
   * @returns {Promise<String>} - The RPC Target URL confirmed.
   */
  async setCustomRpc (rpcTarget, chainId, ticker = 'ETH', nickname = '', rpcPrefs = {}) {
    const frequentRpcListDetail = this.preferencesController.getFrequentRpcListDetail()
    const rpcSettings = frequentRpcListDetail.find((rpc) => rpcTarget === rpc.rpcUrl)

    if (rpcSettings) {
      this.networkController.setRpcTarget(rpcSettings.rpcUrl, rpcSettings.chainId, rpcSettings.ticker, rpcSettings.nickname, rpcPrefs)
    } else {
      this.networkController.setRpcTarget(rpcTarget, chainId, ticker, nickname, rpcPrefs)
      await this.preferencesController.addToFrequentRpcList(rpcTarget, chainId, ticker, nickname, rpcPrefs)
    }
    return rpcTarget
  }

  /**
   * 删除所选的自定义网址
   * A method for deleting a selected custom URL.
   * @param {string} rpcTarget - A RPC URL to delete.
   */
  async delCustomRpc (rpcTarget) {
    await this.preferencesController.removeFromFrequentRpcList(rpcTarget)
  }

  // 初始化 3box Controller
  async initializeThreeBox () {
    await this.threeBoxController.init()
  }

  /**
   * 设置是否使用块状标识图标格式
   * Sets whether or not to use the blockie identicon format.
   * @param {boolean} val - True for bockie, false for jazzicon.
   * @param {Function} cb - A callback function called when complete.
   */
  setUseBlockie (val, cb) {
    try {
      this.preferencesController.setUseBlockie(val)
      cb(null)
    } catch (err) {
      cb(err)
    }
  }

  /**
   * 设置是否使用 nonce 字段
   * Sets whether or not to use the nonce field.
   * @param {boolean} val - True for nonce field, false for not nonce field.
   * @param {Function} cb - A callback function called when complete.
   */
  setUseNonceField (val, cb) {
    try {
      this.preferencesController.setUseNonceField(val)
      cb(null)
    } catch (err) {
      cb(err)
    }
  }

  /**
   * 设置用户是否使用 MetaMetrics 跟踪使用情况数据
   * Sets whether or not the user will have usage data tracked with MetaMetrics
   * @param {boolean} bool - True for users that wish to opt-in, false for users that wish to remain out.
   * @param {Function} cb - A callback function called when complete.
   */
  setParticipateInMetaMetrics (bool, cb) {
    try {
      const metaMetricsId = this.preferencesController.setParticipateInMetaMetrics(bool)
      cb(null, metaMetricsId)
    } catch (err) {
      cb(err)
    }
  }

  // 设置 metaMetricsSendCount
  setMetaMetricsSendCount (val, cb) {
    try {
      this.preferencesController.setMetaMetricsSendCount(val)
      cb(null)
    } catch (err) {
      cb(err)
    }
  }

  /**
   * 设置用户希望遵循的第一次流程的类型：创建或导入
   * Sets the type of first time flow the user wishes to follow: create or import
   * @param {String} type - Indicates the type of first time flow the user wishes to follow
   * @param {Function} cb - A callback function called when complete.
   */
  setFirstTimeFlowType (type, cb) {
    try {
      this.preferencesController.setFirstTimeFlowType(type)
      cb(null)
    } catch (err) {
      cb(err)
    }
  }


  /**
   * 设置用户当前语言
   * A method for setting a user's current locale, affecting the language rendered.
   * @param {string} key - Locale identifier.
   * @param {Function} cb - A callback function called when complete.
   */
  setCurrentLocale (key, cb) {
    try {
      const direction = this.preferencesController.setCurrentLocale(key)
      cb(null, direction)
    } catch (err) {
      cb(err)
    }
  }

  /**
   * 首次初始化存储
   * A method for initializing storage the first time.
   * @param {Object} initState - The default state to initialize with.
   * @private
   */
  recordFirstTimeInfo (initState) {
    if (!('firstTimeInfo' in initState)) {
      initState.firstTimeInfo = {
        version,
        date: Date.now(),
      }
    }
  }

  // TODO: Replace isClientOpen methods with `controllerConnectionChanged` events.
  /**
   * 记录 MetaMask 用户界面是否打开
   * A method for recording whether the MetaMask user interface is open or not.
   * @private
   * @param {boolean} open
   */
  set isClientOpen (open) {
    this._isClientOpen = open
    this.isClientOpenAndUnlocked = this.getState().isUnlocked && open
    this.detectTokensController.isOpen = open
  }

  /**
   * 激活 token 价格检索
   * A method for activating the retrieval of price data,
   * which should only be fetched when the UI is visible.
   * @private
   * @param {boolean} active - True if price data should be getting fetched.
   */
  set isClientOpenAndUnlocked (active) {
    this.tokenRatesController.isActive = active
  }

  /**
  * Creates RPC engine middleware for processing eth_signTypedData requests
  *
  * @param {Object} req - request object
  * @param {Object} res - response object
  * @param {Function} - next
  * @param {Function} - end
  */

  /**
   * 将域添加到PhishingController白名单
   * Adds a domain to the PhishingController whitelist
   * @param {string} hostname the domain to whitelist
   */
  whitelistPhishingDomain (hostname) {
    return this.phishingController.bypass(hostname)
  }

  /**
   * 锁定 MetaMask
   * Locks MetaMask
   */
  setLocked () {
    return this.keyringController.setLocked()
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;">
    <c:title id="scripts-ui"><![CDATA[<div style="color:blue;font-size:1.425em;">app/scripts/ui.js</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
UI 相关方法
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[

// this must run before anything else
require('./lib/freezeGlobals')

// polyfills
import 'abortcontroller-polyfill/dist/polyfill-patch-fetch'

const PortStream = require('extension-port-stream')
const { getEnvironmentType } = require('./lib/util')
const { ENVIRONMENT_TYPE_NOTIFICATION, ENVIRONMENT_TYPE_FULLSCREEN, ENVIRONMENT_TYPE_POPUP } = require('./lib/enums')
const extension = require('extensionizer')
const ExtensionPlatform = require('./platforms/extension')
const NotificationManager = require('./lib/notification-manager')
const notificationManager = new NotificationManager()
const setupSentry = require('./lib/setupSentry')
const {EventEmitter} = require('events')
const Dnode = require('dnode')
const Eth = require('ethjs')
const EthQuery = require('eth-query')
const urlUtil = require('url')
const launchMetaMaskUi = require('../../ui')
const StreamProvider = require('web3-stream-provider')
const {setupMultiplex} = require('./lib/stream-utils.js')
const log = require('loglevel')

// UI 相关方法

start().catch(log.error)

async function start () {

  // create platform global
  global.platform = new ExtensionPlatform()

  // setup sentry error reporting
  const release = global.platform.getVersion()
  setupSentry({ release, getState })
  // provide app state to append to error logs
  function getState () {
    // get app state
    const state = window.getCleanAppState()
    // remove unnecessary data
    delete state.localeMessages
    delete state.metamask.recentBlocks
    // return state to be added to request
    return state
  }

  // 识别窗口类型（弹出窗口，通知）
  // identify window type (popup, notification)
  const windowType = getEnvironmentType(window.location.href)
  global.METAMASK_UI_TYPE = windowType
  closePopupIfOpen(windowType)

  // setup stream to background
  const extensionPort = extension.runtime.connect({ name: windowType })
  const connectionStream = new PortStream(extensionPort)

  const activeTab = await queryCurrentActiveTab(windowType)
  initializeUiWithTab(activeTab)

  // 如果 popop 开着，则关掉
  function closePopupIfOpen (windowType) {
    if (windowType !== ENVIRONMENT_TYPE_NOTIFICATION) {
      // should close only chrome popup
      notificationManager.closePopup()
    }
  }

  // 初始化 UI 出错，则提示：MetaMask应用无法加载：请重新打开并关闭MetaMask以重新启动
  function displayCriticalError (container, err) {
    container.innerHTML = '<div class="critical-error">The MetaMask app failed to load: please open and close MetaMask again to restart.</div>'
    container.style.height = '80px'
    log.error(err.stack)
    throw err
  }

  // 初始化 UI
  function initializeUiWithTab (tab) {
    const container = document.getElementById('app-content')
    initializeUi(tab, container, connectionStream, (err, store) => {
      if (err) {
        return displayCriticalError(container, err)
      }

      const state = store.getState()
      const { metamask: { completedOnboarding } = {} } = state

      if (!completedOnboarding && windowType !== ENVIRONMENT_TYPE_FULLSCREEN) {
        global.platform.openExtensionInBrowser()
      }
    })
  }
}

// 查询当前激活的 tab
async function queryCurrentActiveTab (windowType) {
  return new Promise((resolve) => {
    // At the time of writing we only have the `activeTab` permission which means
    // that this query will only succeed in the popup context (i.e. after a "browserAction")
    if (windowType !== ENVIRONMENT_TYPE_POPUP) {
      resolve({})
      return
    }

    extension.tabs.query({active: true, currentWindow: true}, (tabs) => {
      const [activeTab] = tabs
      const {title, url} = activeTab
      const { hostname: origin, protocol } = url ? urlUtil.parse(url) : {}
      resolve({
        title, origin, protocol, url,
      })
    })
  })
}

//
function initializeUi (activeTab, container, connectionStream, cb) {
  connectToAccountManager(connectionStream, (err, backgroundConnection) => {
    if (err) {
      return cb(err)
    }

    launchMetaMaskUi({
      activeTab,
      container,
      backgroundConnection,
    }, cb)
  })
}

/**
 * 建立与后台和 Web3 provider 的连接
 * Establishes a connection to the background and a Web3 provider
 *
 * @param {PortDuplexStream} connectionStream PortStream instance establishing a background connection
 * @param {Function} cb Called when controller connection is established
 */
function connectToAccountManager (connectionStream, cb) {
  const mx = setupMultiplex(connectionStream)
  setupControllerConnection(mx.createStream('controller'), cb)
  setupWeb3Connection(mx.createStream('provider'))
}

/**
 * 建立与 Web3 provider 提供程序的流连接
 * Establishes a streamed connection to a Web3 provider
 *
 * @param {PortDuplexStream} connectionStream PortStream instance establishing a background connection
 */
function setupWeb3Connection (connectionStream) {
  const providerStream = new StreamProvider()
  providerStream.pipe(connectionStream).pipe(providerStream)
  connectionStream.on('error', console.error.bind(console))
  providerStream.on('error', console.error.bind(console))
  global.ethereumProvider = providerStream
  global.ethQuery = new EthQuery(providerStream)
  global.eth = new Eth(providerStream)
}

/**
 * 建立与后台账户管理的流式连接
 * Establishes a streamed connection to the background account manager
 *
 * @param {PortDuplexStream} connectionStream PortStream instance establishing a background connection
 * @param {Function} cb Called when the remote account manager connection is established
 */
function setupControllerConnection (connectionStream, cb) {
  const eventEmitter = new EventEmitter()
  const backgroundDnode = Dnode({
    sendUpdate: function (state) {
      eventEmitter.emit('update', state)
    },
  })
  connectionStream.pipe(backgroundDnode).pipe(connectionStream)
  backgroundDnode.once('remote', function (backgroundConnection) {
    backgroundConnection.on = eventEmitter.on.bind(eventEmitter)
    cb(null, backgroundConnection)
  })
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;">
    <c:title id="scripts-ui"><![CDATA[<div style="color:blue;font-size:1.425em;">app/manifest.json</div>]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="margin-bottom:1em;">
插件配置文件
</div>
<div style="margin-bottom:1em;">
https://developer.chrome.com/extensions/manifest
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;margin-top:0;padding-top:0;">
      <![CDATA[
{
  // 插件的名称
  "name": "__MSG_appName__",
  "short_name": "__MSG_appName__",
  // 插件的版本
  "version": "7.4.0",
  // 清单文件的版本，这个必须写，而且必须是2
  "manifest_version": 2,
  "author": "https://metamask.io",
  // 插件描述
  "description": "__MSG_appDescription__",
  "commands": {
    "_execute_browser_action": {
      "suggested_key": {
        "windows": "Alt+Shift+M",
        "mac": "Alt+Shift+M",
        "chromeos": "Alt+Shift+M",
        "linux": "Alt+Shift+M"
      }
    }
  },
  // 插件图标
  "icons": {
    "16": "images/icon-16.png",
    "128": "images/icon-128.png"
  },
  "applications": {
    "gecko": {
      "id": "webextension@metamask.io",
      "strict_min_version": "56.0"
    }
  },
  // 默认语言
  "default_locale": "en",
  // 会一直常驻的后台JS或后台页面
  "background": {
    "scripts": [
      "chromereload.js",
      "bg-libs.js",
      "background.js"
    ],
    "persistent": true
  },
  // 浏览器右上角图标设置，browser_action、page_action、app 必须三选一
  "browser_action": {
    "default_icon": {
      "19": "images/icon-19.png",
      "38": "images/icon-38.png"
    },
    "default_title": "MetaMask",
    "default_popup": "popup.html"
  },
  // 需要直接注入页面的JS
  "content_scripts": [
    {
      //"matches": ["http://*/*", "https://*/*"],
      // "<all_urls>" 表示匹配所有地址
      "matches": [
        "file://*/*",
        "http://*/*",
        "https://*/*"
      ],
      // 多个JS按顺序注入
      "js": [
        "contentscript.js"
      ],
      // 代码注入的时间，可选值： "document_start", 
      // "document_end", or "document_idle"，最后一个表示页面空闲时，默认 document_idle
      "run_at": "document_start",
      "all_frames": true
    },
    // content-script 可以配置多个规则
    {
      "matches": [
        "*://connect.trezor.io/*/popup.html"
      ],
      "js": [
        "vendor/trezor/content-script.js"
      ]
    }
  ],
  // 权限申请 https://developer.chrome.com/extensions/declare_permissions
  "permissions": [
    "storage", // 插件本地存储
    "unlimitedStorage", // 无限存储，没有这个属性，只有 5m
    "clipboardWrite", // 剪贴板权限
    "http://localhost:8545/", // 网站白名单
    "https://*.infura.io/", // 网站白名单
    "activeTab",
    "webRequest", // web请求
    "*://*.eth/", // 可以通过executeScript或者insertCSS访问的网站
    "notifications" // 通知
  ],
  // 普通页面能够直接访问的插件资源列表，如果不设置是无法直接访问的
  "web_accessible_resources": [
    "inpage.js",
    "phishing.html"
  ],
  // 网站可以向插件发消息
  "externally_connectable": {
    "matches": [
      "https://metamask.io/*"
    ],
    "ids": [
      "*"
    ]
  }
}
   ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

</c:component>
