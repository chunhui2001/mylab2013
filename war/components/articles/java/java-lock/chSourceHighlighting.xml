<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
本文简单介绍: 可重入锁、不可重入锁、安全锁、非安全锁
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[synchronized &mdash; 可重入锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
在调用含有锁的函数时，若相邻的调用都在同一个线程中，就不会阻塞，若相邻的调用不再同一个线程中，就会使其中一个线程执行阻塞等待操作。<br />
如果锁具备可重入性，则称作为可重入锁。像 synchronized 和 ReentrantLock 都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个 synchronized 方法时，比如说 method1，而在 method1 中会调用另外一个 synchronized 方法 method2，此时线程不必重新去申请锁，而是可以直接执行方法 method2。
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="" title="简单示例" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[

/** 
 * 以下代码中的两个方法 method1 和 method2 都用 synchronized 修饰了，
 * 假如某一时刻，线程A执行到了 method1，此时线程A获取了这个对象的锁，而由于 method2 也是 synchronized 方法，
 * 假如 synchronized 不具备可重入性，此时线程A需要重新申请锁。
 * 但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。
 * 而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。
 */
class MyClass {

    public synchronized void method1() {
        method2();
    }
     
    public synchronized void method2() {
         
    }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="复杂示例" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class Lock {
 
    boolean isLocked = false;
    Thread  lockedBy = null;
    int lockedCount = 0;
 
    public synchronized void lock()
            throws InterruptedException{
 
        Thread thread = Thread.currentThread();

        while (isLocked && lockedBy != thread) {
            wait();
        }
 
        isLocked = true;
        lockedCount++;
        lockedBy = thread;
 
    }
 
    public synchronized void unlock() {
 
        if (Thread.currentThread() == this.lockedBy) {
 
            lockedCount--;
 
            if (lockedCount == 0) {
                isLocked = false;
                notify();
            }
        }
    }

}


public class Count {
 
    Lock lock = new Lock();
 
    public void print() {
        lock.lock();
        doAdd();
        lock.unlock();
    }
 
    public void doAdd() {
        lock.lock();

        // do something
        lock.unlock();
    }
 
}

]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[因为 synchronized 锁是可重入锁所以, 上边的 Count 类中 print() 与 doAdd() 函数都会被成功执行。]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[不可重入锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
每次调用含有锁的函数时，若锁已被占用且未释放，其他线程就阻塞等待。
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
public class Lock {
 
    private boolean isLocked = false;
 
    public synchronized void lock () throws InterruptedException{
 
        while (isLocked) {    
            wait();
        }
 
        isLocked = true;
 
    }
 
    public synchronized void unlock () {
        isLocked = false;
        notify();
    }
 
}
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
print() 函数会被执行，doAdd() 进入死锁状态，一直阻塞等待锁的释放。
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[可中断锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
顾名思义，就是可以相应中断的锁。在Java中，synchronized 就不是可中断锁，而 Lock 是可中断锁。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
<br />
在下文提到的 lockInterruptibly() 用法时可体现 Lock 的可中断性。
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[公平锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。
<br />
非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。
<br />
在Java中，synchronized 就是非公平锁，它无法保证等待的线程获取锁的顺序。
<br />
而对于 ReentrantLock 和 ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[读写锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
<br />
正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。
<br />
ReadWriteLock 就是读写锁，它是一个接口，ReentrantReadWriteLock 实现了这个接口。
<br />
可以通过 readLock()获取读锁，通过 writeLock() 获取写锁。
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[synchronized 的缺陷]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
synchronized 是 java 中的一个关键字，也就是说是 Java 语言内置的特性。那么为什么会出现 Lock 呢？<br />
如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。<br />
因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过 Lock 就可以办到。<br />
另外，通过 Lock 可以知道线程有没有成功获取到锁。这个是 synchronized 无法办到的。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
Lock 提供了比 synchronized 更多的功能。但是要注意以下几点: <br />
1）synchronized 是不可中断锁，而 Lock 是可中断锁。
1）Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；<br />
2）Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。因此使用 Lock 时需要在 finally 块中释放锁； <br />
3) Lock 可以提高多个线程进行读操作的效率。而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Lock 接口定义]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
                     <div>
如果采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try{} catch{} 块中进行，并且将释放锁的操作放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。<br />通常使用 Lock 来进行同步的话，是以下面这种形式去使用的：
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="lock()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
Lock lock = ...;

try {
    lock.lock();
    //处理任务
} catch(Exception ex) {
     
} finally {
    lock.unlock();   //释放锁
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="tryLock()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>
tryLock() 方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。
</div>
<div style="margin-top:1em;">
tryLock(long time, TimeUnit unit) 方法和 tryLock() 方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
</div>
<div style="margin-top:1em;">
一般情况下通过 tryLock() 来获取锁时是这样使用的：
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
Lock lock = ...;

if (lock.tryLock()) {
    try {
       // 处理任务
    } catch(Exception ex){
       
    } finally{
       lock.unlock();   // 释放锁
    } 
} else {
    // 如果不能获取锁，则直接做其他事情

}

]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[ReentrantLock(false) &mdash; 非安全锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
与 synchronize 效果一样，在锁被释放后，线程们相互竞争来获取锁。
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[安全锁（ReentrantLock(true)）]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
在锁释放后，可以按照线程队列或者自定义的条件，唤醒指定的线程或者分组的线程们。ReentrantLock 是唯一实现了 Lock 接口的类.
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="lock() 的错误使用方法" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 以下代码的问题在于，在 insert() 方法中的 lock 变量是局部变量，每个线程执行该方法时都会保存一个副本，
// 那么理所当然每个线程执行到 lock.lock() 处获取的是不同的锁，所以就不会发生冲突。
public class Test {
    
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();

    public static void main(String[] args)  {
    
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();

    }  
     
    public void insert(Thread thread) {
    
        Lock lock = new ReentrantLock();    //注意这个地方
        lock.lock();
    
        try {
            System.out.println(thread.getName()+"得到了锁");
            for(int i=0;i<5;i++) {
                arrayList.add(i);
            }
        } catch (Exception e) {
            // TODO: handle exception
        } finally {
            System.out.println(thread.getName()+"释放了锁");
            lock.unlock();
        }
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="lock() 的正确使用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 将lock声明为类的属性
public class Test {
    
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    private Lock lock = new ReentrantLock();    //注意这个地方

    public static void main(String[] args)  {
        
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();

    }  
     
    public void insert(Thread thread) {
        
        lock.lock();

        try {
            System.out.println(thread.getName()+"得到了锁");
            for(int i=0;i<5;i++) {
                arrayList.add(i);
            }
        } catch (Exception e) {
            // TODO: handle exception
        }finally {
            System.out.println(thread.getName()+"释放了锁");
            lock.unlock();
        }
    
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="tryLock() 的使用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class Test {
    
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    private Lock lock = new ReentrantLock();    //注意这个地方

    public static void main(String[] args)  {
    
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
    }  
     
    public void insert(Thread thread) {
    
        if (lock.tryLock()) {
            try {
                System.out.println(thread.getName()+"得到了锁");
                for(int i=0;i<5;i++) {
                    arrayList.add(i);
                }
            } catch (Exception e) {
                // TODO: handle exception
            }finally {
                System.out.println(thread.getName()+"释放了锁");
                lock.unlock();
            }
        } else {
            System.out.println(thread.getName()+"获取锁失败");
        }
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="lockInterruptibly() 响应中断的使用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class Test {

    private Lock lock = new ReentrantLock();   

    public static void main(String[] args)  {

        Test test = new Test();
        MyThread thread1 = new MyThread(test);
        MyThread thread2 = new MyThread(test);
    
        thread1.start();
        thread2.start();
         
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    
        thread2.interrupt();
    }  
     
    public void insert(Thread thread) throws InterruptedException{
        
        lock.lockInterruptibly();   

        // 注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将 InterruptedException 抛出
        try {  
            System.out.println(thread.getName()+"得到了锁");
            long startTime = System.currentTimeMillis();
            for(    ;     ;) {
                if(System.currentTimeMillis() - startTime >= Integer.MAX_VALUE)
                    break;
                //插入数据
            }
        }
        finally {
            System.out.println(Thread.currentThread().getName()+"执行finally");
            lock.unlock();
            System.out.println(thread.getName()+"释放了锁");
        }  
    }
}
 
class MyThread extends Thread {

    private Test test = null;

    public MyThread(Test test) {
        this.test = test;
    }

    @Override
    public void run() {
        try {
            test.insert(Thread.currentThread());
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName()+"被中断");
        }
    }

}
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[ReadWriteLock 接口定义]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public interface ReadWriteLock {
    /**
     * Returns the lock used for reading.
     * @return the lock used for reading.
     */
    Lock readLock();
 
    /**
     * Returns the lock used for writing.
     * @return the lock used for writing.
     */
    Lock writeLock();
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="synchronized 版读写锁" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。
public class Test {
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
     
    public static void main(String[] args)  {
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
    }  
     
    public synchronized void get(Thread thread) {
        long start = System.currentTimeMillis();
        while(System.currentTimeMillis() - start <= 1) {
            System.out.println(thread.getName()+"正在进行读操作");
        }
        System.out.println(thread.getName()+"读操作完毕");
    }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="ReentrantReadWriteLock" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
/**
 * thread1 和 thread2 在同时进行读操作。
 * 这样就大大提升了读操作的效率。
 * 不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
 * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。
 * 关于 ReentrantReadWriteLock 类中的其他方法感兴趣的朋友可以自行查阅API文档。
 */
public class Test {

    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
     
    public static void main(String[] args)  {
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
    }  
     
    public void get(Thread thread) {
        rwl.readLock().lock();
        try {
            long start = System.currentTimeMillis();
             
            while(System.currentTimeMillis() - start <= 1) {
                System.out.println(thread.getName()+"正在进行读操作");
            }
            System.out.println(thread.getName()+"读操作完毕");
        } finally {
            rwl.readLock().unlock();
        }
    }
}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>







</c:component>
