<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
锁-是为了解决并发操作引起的脏读、数据不一致的问题。<br />
本文简单介绍: 可重入锁、不可重入锁、安全锁、非安全锁 <br />
<br />
当我们说线程安全时，到底在说什么<br />
http://www.jasongj.com/java/thread_safe/
]]>
  </c:abstract>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[寄存器]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<h3>https://baijiahao.baidu.com/s?id=1590302037132894549</h3>
<div style="line-height: 1.625em;">
寄存器在汇编语言重占有很重要的的地位，首先必须了解两个知识点：寄存器和内存模型。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
先来看寄存器。CPU 本身只负责运算，不负责储存数据。数据一般都储存在内存之中，CPU 要用的时候就去内存读写数据。但是，CPU 的运算速度远高于内存的读写速度，为了避免被拖慢，CPU 都自带一级缓存和二级缓存。基本上，CPU 缓存可以看作是读写速度较快的内存。
</div>

<div style="line-height: 1.625em;margin-top:.5em;">
但是，CPU 缓存还是不够快，另外数据在缓存里面的地址是不固定的，CPU 每次读写都要寻址也会拖慢速度。因此，除了缓存之外，CPU 还自带了寄存器（register），用来储存最常用的数据。也就是说，那些最频繁读写的数据（比如循环变量），都会放在寄存器里面，CPU 优先读写寄存器，再由寄存器跟内存交换数据。
</div>

<div style="line-height: 1.625em;margin-top:.5em;">
寄存器不依靠地址区分数据，而依靠名称。每一个寄存器都有自己的名称，我们告诉 CPU 去具体的哪一个寄存器拿数据，这样的速度是最快的。有人比喻寄存器是 CPU 的零级缓存。
</div>

<div style="line-height: 1.625em;margin-top:.5em;">
我们常常看到 32位 CPU、64位 CPU 这样的名称，其实指的就是寄存器的大小。32 位 CPU 的寄存器大小就是4个字节。
</div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="寄存器的种类" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<div>
    早期的 x86 CPU 只有8个寄存器，而且每个都有不同的用途。现在的寄存器已经有100多个了，都变成通用寄存器，不特别指定用途了，但是早期寄存器的名字都被保存了下来。
</div>


<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>EAX</li>
    <li>EBX</li>
    <li>ECX</li>
    <li>EDX</li>
    <li>EDI</li>
    <li>ESI</li>
    <li>EBP</li>
    <li>ESP</li>
</ul>

<div style="margin-top:1em;">
上面这8个寄存器之中，前面七个都是通用的。ESP 寄存器有特定用途，保存当前 Stack 的地址（详见下一节）。
</div>


]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[volatile (可变的)]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
Java 编程语言允许线程访问共享变量， 为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java 语言提供了 volatile，在某些情况下比锁要更加方便。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
volatile 在多处理器开发中保证了共享变量的 “可见性”。<b style="color:red;">可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</b><b style="color:green;">当使用 volatile 修饰某个变量时，它会保证对该变量的修改会立即被更新到内存中，并且将其它缓存中对该变量的缓存设置成无效，因此其它线程需要读取该值时必须从主内存中读取，从而得到最新的值。</b>
</div>

<div>
volatile 限定编译器对这个指针的指向的存储单元不进行优化, 即<b>不用通用寄存器暂时代替这个指针的指向的存储单元</b>, 而是每次取值都直接到指针的指向的存储单元取值。volatile 主要用于变量会异步改变的情况下, 主要有三个方面:
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>cpu外设寄存器</li>
    <li>中断和主循环都会用到的全局变量</li>
    <li>操作系统中的线程间都会用到的公共变量</li>
</ul>




<div style="margin-top: .625em;">
volatile 类型是这样的，其数据确实可能在未知的情况下发生变化。比如，硬件设备的终端更改了它，现在硬件设备往往也有自己的私有内存地址，比如显存，他们一般是通过映象的方式，反映到一段特定的内存地址当中，这样，在某些条件下，程序就可以直接访问这些私有内存了。另外，比如共享的内存地址，多个程序都对它操作的时候。你的程序并不知道，这个内存何时被改变了。如果不加这个 voliatile 修饰，程序是利用 catch 当中的数据，那个可能是过时的了。 加了 voliatile，就在需要用的时候，程序重新去那个地址去提取，保证是最新的。归纳起来如下：
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>volatile 变量可变, 允许除了程序之外的比如硬件来修改他的内容  </li>
    <li>访问该数据任何时候都会直接访问该地址处内容，即通过 cache 提高访问速度的优化被取消 </li>
</ul>

<div style="margin-top:.5em;">
  <b style="color:red;">当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到CPU缓存中。</b>如果计算机有多个CPU，每个线程可能在不同的CPU上被处理，这意味着每个线程可以拷贝到不同的 CPU cache 中。 而声明变量是 volatile 的，JVM 保证了每次读变量都从内存中读，跳过 CPU cache 这一步。
</div>

<div style="line-height: 1.625em;margin-top:.5em;">
如果 volatile 变量修饰符使用恰当的话，它比 synchronized 的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。
</div>

<div style="margin-top:.5em;">
  <img width="350px" src="/images/java/volatile.jpg" />
</div>

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="当一个变量定义为 volatile 之后，将具备两种特性" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>保证此变量对所有的线程的可见性，这里的“可见性”，如本文开头所述，当一个线程修改了这个变量的值，volatile 保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。但普通变量做不到这点，普通变量的值在线程间传递均需要通过主内存（详见：Java内存模型）来完成。</li>
    <li>禁止指令重排序优化。有 volatile 修饰的变量，赋值后多执行了一个 <b style="font-size:1.5em;">“load addl $0x0, (%esp)”</b> 操作，这个操作相当于一个<b style="color:red;">内存屏障</b>(指令重排序时不能把后面的指令重排序到内存屏障之前的位置)，只有一个CPU访问内存时，并不需要内存屏障；<b style="color:blue;">（什么是指令重排序：是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理）。</b></li>
</ul>

]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="可见性" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
  <b>可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。</b>也就是一个线程修改的结果。另一个线程马上就能看到。比如：用 volatile 修饰的变量，就会具有可见性。<b>volatile 修饰的变量<em style="font-size:1.5em;color:red;">不允许线程内部缓存和重排序</em>，即直接修改内存。</b>所以对其他线程是可见的。但是这里需要注意一个问题，volatile 只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。
</div>

<h4 style="margin-top:.625em;">在 Java 中 volatile、synchronized 和 final 实现可见性。</h4>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="原子性" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
  <b>原子是世界上的最小单位，具有不可分割性。比如 a=0；</b>（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作是原子操作。再比如：<b>a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。</b>非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java 的 concurrent 包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference 等。</div>

<h4 style="margin-top:.625em;">在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。</h4>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="有序性" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
  Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。</div>

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="下面一段代码在多线程环境下, 将存在问题 (摘自: Java Concurrency in Practice)" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

// 
/**
 * @author zhengbinMac
 */
public class NoVisibility {
    private static boolean ready;
    private static int number;
    private static class ReaderThread extends Thread {
        @Override
        public void run() {
            while(!ready) {
                Thread.yield();
            }
            System.out.println(number);
        }
    }
    public static void main(String[] args) {
        new ReaderThread().start();
        number = 42;
        ready = true;
    }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
  NoVisibility可能会持续循环下去，因为读线程可能永远都看不到ready的值。甚至NoVisibility可能会输出0，因为读线程可能看到了写入ready的值，但却没有看到之后写入number的值，这种现象被称为“重排序”。只要在某个线程中无法检测到重排序情况（即使在其他线程中可以明显地看到该线程中的重排序），那么就无法确保线程中的操作将按照程序中指定的顺序来执行。当主线程首先写入number，然后在没有同步的情况下写入ready，那么读线程看到的顺序可能与写入的顺序完全相反。
</div>

<div style="margin-top: .3em;">
  在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行春旭进行判断，无法得到正确的结论。
</div>

<div style="margin-top: .3em;">
  这个看上去像是一个失败的设计，但却能使JVM充分地利用现代多核处理器的强大性能。例如，在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行重排序，并将数值缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并将数值缓存在处理器特定的缓存中。
</div>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[synchronized &mdash; 可重入锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
    synchronized 通过锁机制实现同步。在 Java 中 synchronized 实现同步的基础是 Java 中的每一个对象都可以作为锁。
    <br /> 
    当一个线程试图访问同步代码块时，它首先必须得到锁，退出或抛出异常时必须释放锁。具体表现为以下3种形式: 
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;color:red;">
    <li>对于普通同步方法，锁是当前实例对象。</li>
    <li>对于静态同步方法，锁是当前类的Class对象。</li>
    <li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>

<div style="line-height: 1.625em;margin-top:.5em;">
在调用含有锁的函数时，若相邻的调用都在同一个线程中，就不会阻塞，若相邻的调用不再同一个线程中，就会使其中一个线程执行阻塞等待操作。<br />
如果锁具备可重入性，则称作为可重入锁。像 synchronized 和 ReentrantLock 都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个 synchronized 方法时，比如说 method1，而在 method1 中会调用另外一个 synchronized 方法 method2，此时线程不必重新去申请锁，而是可以直接执行方法 method2。
</div>
<div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="synchronized 实现原理" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div style="line-height: 1.625em;">
    synchronized 是基于 Monitor 来实现同步的。Monitor 从两个方面来支持线程之间的同步：
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;color:blue;">
    <li>互斥执行</li>
    <li>协作</li>
</ul>


<ul style="margin-left: 2.2em;list-style-type: decimal;margin-top: .3em;color:green;">
    <li>Java 使用对象锁 (使用 synchronized 获得对象锁) 保证工作在共享的数据集上的线程互斥执行。</li>
    <li>使用 notify/notifyAll/wait 方法来协同不同线程之间的工作。</li>
    <li>Class 和 Object 都关联了一个 Monitor。</li>
</ul>


<div>
    <div style="display:inline-block;
            margin-top:.3em;
            border:solid 1px darkorange;
            padding:.5em 1em;border-style: dashed;">
        <img src="/images/java/monitor.jpg" />
        <h5 style="text-align:center;"><b>Monitor 的工作机理</b></h5>
    </div>
</div>


<ul style="margin-left:1.5em;list-style-type:disc;margin-top:1em;">
    <li>线程进入同步方法中。</li>
    <li>为了继续执行临界区代码，线程必须获取 Monitor 锁。如果获取锁成功，将成为该监视者对象的拥有者。任一时刻内，监视者对象只属于一个活动线程（The Owner）</li>
    <li>拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。</li>
    <li>其他线程调用 notify() / notifyAll() 接口唤醒等待集合中的线程，这些等待的线程需要重新获取监视锁后才能执行 wait() 之后的代码。</li>
    <li>同步方法执行完毕了，线程退出临界区，并释放监视锁。</li>
</ul>


]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="synchronized 具体实现" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left:1.5em;list-style-type:disc;margin-top:1em;">
    <li>同步代码块采用 monitorenter、monitorexit 指令显式的实现。</li>
    <li>同步方法则使用 ACC_SYNCHRONIZED 标记符隐式的实现。</li>
    <li>拥有监视者对象的线程可以调用 wait() 进入等待集合（Wait Set），同时释放监视锁，进入等待状态。</li>
</ul>

]]>
    </c:sourceContent>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[

public class SynchronizedTest {

   public synchronized void method1(){
       System.out.println("Hello World!");
   }

   public  void method2(){
       synchronized (this){
           System.out.println("Hello World!");
       }
   }
}


]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[

<h3>// javap 编译后的字节码如下：</h3>
<img width="450px" src="/images/java/javap-compiler.jpg" />

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="monitorenter" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[



<div style="line-height: 1.625em;">
    每一个对象都有一个 monitor，一个 monitor 只能被一个线程拥有。当一个线程执行到 monitorenter 指令时会尝试获取相应对象的 monitor，获取规则如下：
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;color:blue;">
    <li>如果 monitor 的进入数为 0，则该线程可以进入 monitor，并将 monitor 进入数设置为1，该线程即为 monitor 的拥有者。</li>
    <li>如果当前线程已经拥有该 monitor，只是重新进入，则进入 monitor 的进入数加1，所以 synchronized 关键字实现的锁是可重入的锁。</li>
    <li>如果 monitor 已被其他线程拥有，则当前线程进入阻塞状态，直到 monitor 的进入数为0，再重新尝试获取 monitor。</li>
</ul>

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="monitorexit" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<div style="line-height: 1.625em;">
    只有拥有相应对象的 monitor 的线程才能执行 monitorexit 指令。每执行一次该指令 monitor 进入数减1，当进入数为0时当前线程释放 monitor，此时其他阻塞的线程将可以尝试获取该 monitor。
</div>

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="锁存放的位置" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div style="line-height: 1.625em;color:red;">
    锁标记存放在 Java 对象头的 <b>Mark Word</b> 中。
</div>

<table style="margin: .5em 0;line-height: 1.3em;color:green;margin-top:1em;">
    <caption style="padding:.3em;padding-left:0;text-align:left;font-size: 1.5em;color:blueviolet">Java 对象头长度</caption>
    <thead>
        <tr>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">长度</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">内容</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">说明</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;font-weight: normal;">32/64位</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;"><b style="color:red;">Mark World</b></td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">存储对象的 hashCode 或锁信息</td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;font-weight: normal;">32/64位</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;">Class Metadata Address</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">存储到对象类型数据的指针</td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;font-weight: normal;">32/64位</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;">Array Length</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">数组的长度 (如果当前对象是数组)</td>
        </tr>
    </tbody>
</table>

<table style="margin: .5em 0;line-height: 1.3em;color:green;margin-top:1em;">
    <caption style="padding:.3em;padding-left:0;text-align:left;font-size: 1.5em;color:blueviolet">
        32位JVM Mark Word 结构
    </caption>
    <thead>
        <tr>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">锁状态</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">25bit</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">4bit</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">1bit 是否是偏向锁</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">2bit 锁标志位</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;padding-right:1.325em;text-align: left;font-weight: normal;">无锁状态</td>
            <td style="border: solid 1px gray;padding:.3em .5em;padding-right:1.325em;text-align: left;">对象的 hashcode</td>
            <td style="border: solid 1px gray;padding:.3em .5em;padding-right:1.325em;text-align: left;padding-right:1.325em;">对象分代年龄</td>
            <td style="border: solid 1px gray;padding:.3em .5em;padding-right:1.325em;text-align: left;padding-right:1.325em;">0</td>
            <td style="border: solid 1px gray;padding:.3em .5em;padding-right:1.325em;text-align: left;padding-right:1.325em;">01</td>
        </tr>
    </tbody>
</table>

<table style="margin: .5em 0;line-height: 1.3em;color:green;margin-top:1em;">
    <caption style="padding:.3em;padding-left:0;text-align:left;font-size: 1.5em;color:blueviolet">
        32位JVM Mark Word 状态变化
    </caption>
    <thead>
        <tr>
            <th border="1" style="border: solid 1px gray;padding:0;text-align:center;color:green;vertical-align:middle;" rowspan="2">锁状态</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;" colspan="2">25bit</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;vertical-align:middle;" rowspan="2">4bit</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;">1bit</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;">2bit</th>
        </tr>
        <tr>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;">23bit</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;">2bit</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;">是否是偏向锁</th>
            <th style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;">锁标志位</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">轻量级锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;" colspan="4">指向栈中锁记录的指针</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">00</td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">重量级锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;" colspan="4">指向互斥量(重量级锁)的指针</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">10</td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">GC标记</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;" colspan="4">空</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">11</td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">偏向锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">线程id</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">Epoch</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">对象分代年龄</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">1</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">01</td>
        </tr>
    </tbody>
</table>

<table style="margin: .5em 0;line-height: 1.3em;color:green;margin-top:1em;">
    <caption style="padding:.3em;padding-left:0;text-align:left;font-size: 1.5em;color:blueviolet">
        64位JVM Mark Word 结构
    </caption>
    <thead>
        <tr>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;vertical-align:middle;" rowspan="2">锁状态</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;vertical-align:middle;">25bit</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;vertical-align:middle;">31bit</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;text-align:center;color:green;vertical-align:middle;">1bit</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">4bit</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">1bit</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">2bit</th>
        </tr>
        <tr>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">&nbsp;</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">&nbsp;</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">cms_free</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">分代年龄</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">偏向锁</th>
            <th border="1" style="border: solid 1px gray;padding:.3em .5em;;text-align:center;color:green;vertical-align:middle;">锁标志位</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">无锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">unused</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">hashcode</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">&nbsp;</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">&nbsp;</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">0</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">01</td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">偏向锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;" colspan="2">ThreadID(54bit)/Epoch(2bit)</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">&nbsp;</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">&nbsp;</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">1</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align:center;font-weight: normal;">01</td>
        </tr>
    </tbody>
</table>

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="synchronized 的锁优化" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div style="margin-bottom:.3em;">
JavaSE1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。
</div>

<div style="margin-bottom:.3em;">
在JavaSE1.6中，<b>锁一共有4种状态，级别<span style="color:red;ext-decoration:underline;">从低到高依</span>次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态</b>，这几个状态会随着竞争情况逐渐升级。
</div>

<div style="margin-bottom:.3em;">
锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<table>
    <tbody>
        <tr>
            <td><b>偏向锁</b></td>
            <td><b>轻量级锁</b></td>
        </tr>
        <tr>
            <td>无锁竞争的情况下为了减少锁竞争的资源开销，引入偏向锁。</td>
            <td>轻量级锁所适应的场景是线程交替执行同步块的情况。</td>
        </tr>
        <tr>
            <td><img width="480px" src="/images/java/lock-level.jpg" /></td>
            <td><img width="480px" src="/images/java/lock-level2.jpg" /></td>
        </tr>
    </tbody>
</table>


<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: 1em;">
    <li><b>锁粗化(Lock Coarsening):</b> 也就是减少不必要的紧连在一起的unlock，lock操作，将多个连续的锁扩展成一个范围更大的锁。</li>
    <li><b>锁消除(Lock Elimination): </b>锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。</li>
    <li><b>适应性自旋(Adaptive Spinning):</b> 自适应意味着自旋的时间不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。另一方面，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。</li>
</ul>



<table style="margin: .5em 0;line-height: 1.3em;color:green;margin-top:1em;">
    <caption style="padding:.3em;padding-left:0;text-align:left;font-size: 1.5em;color:blueviolet">
    锁的优缺点对比
    </caption>
    <thead>
        <tr>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">锁</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">优点</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">缺点</th>
            <th style="padding:.3em .5em;border: solid 1px gray;text-align:left;color:green;">适用场景</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;font-weight: normal;">偏向锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;">
                加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在几纳秒的差距。
            </td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">
                如果线程间存在锁竞争，会带来额外的锁撤销的消耗。
            </td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">
                适用于只有一个线程访问的同步块场景。
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;font-weight: normal;">轻量级锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;">
                竞争的线程不会阻塞，提高了程序的响应速度。
            </td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">
                如果始终得不到锁竞争的线程，<b style="color:red;">使用自旋会消耗CPU</b>。
            </td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">
                追求响应时间同步块执行速度非常快。
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;">
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;font-weight: normal;">重量级锁</td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;">
                竞争的线程不使用自旋，不会消耗CPU。
            </td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">
                线程阻塞，响应时间缓慢。
            </td>
            <td style="border: solid 1px gray;padding:.3em .5em;text-align: left;padding-right:1.325em;">
                追求吞吐量，同步块执行速度缓慢。
            </td>
        </tr>
    </tbody>
</table>

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="synchronized 简单示例" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[

/** 
 * 以下代码中的两个方法 method1 和 method2 都用 synchronized 修饰了，
 * 假如某一时刻，线程A执行到了 method1，此时线程A获取了这个对象的锁，而由于 method2 也是 synchronized 方法，
 * 假如 synchronized 不具备可重入性，此时线程A需要重新申请锁。
 * 但是这就会造成一个问题，因为线程A已经持有了该对象的锁，而又在申请获取该对象的锁，这样就会线程A一直等待永远不会获取到的锁。
 * 而由于synchronized和Lock都具备可重入性，所以不会发生上述现象。
 */
class MyClass {

    public synchronized void method1() {
        method2();
    }
     
    public synchronized void method2() {
         
    }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="synchronized 复杂示例" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class Lock {
 
    boolean isLocked = false;
    Thread  lockedBy = null;
    int lockedCount = 0;
 
    public synchronized void lock()
            throws InterruptedException{
 
        Thread thread = Thread.currentThread();

        while (isLocked && lockedBy != thread) {
            wait();
        }
 
        isLocked = true;
        lockedCount++;
        lockedBy = thread;
 
    }
 
    public synchronized void unlock() {
 
        if (Thread.currentThread() == this.lockedBy) {
 
            lockedCount--;
 
            if (lockedCount == 0) {
                isLocked = false;
                notify();
            }
        }
    }

}


public class Count {
 
    Lock lock = new Lock();
 
    public void print() {
        lock.lock();
        doAdd();
        lock.unlock();
    }
 
    public void doAdd() {
        lock.lock();

        // do something
        lock.unlock();
    }
 
}

]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[因为 synchronized 锁是可重入锁所以, 上边的 Count 类中 print() 与 doAdd() 函数都会被成功执行。]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[CAS]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
CAS，在 Java 并发应用中通常指 CompareAndSwap 或 CompareAndSet，即比较并交换。
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;">
解决多线程并行情况下使用锁造成性能损耗的一种机制，CAS操作包含三个操作数——内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在CAS指令之前返回该位置的值。CAS有效地说明了“我认为位置V应该包含值A；如果包含该值，则将B放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
 
<ul style="margin-left: 1.5em;list-style-type: disc;">
    <li>CAS是一个原子操作，它比较一个内存位置的值并且只有相等时修改这个内存位置的值为新的值，保证了新的值总是基于最新的信息计算的，如果有其他线程在这期间修改了这个值则CAS失败。CAS返回是否成功或者内存位置原来的值用于判断是否CAS成功。</li>
    <li>JVM 中的 CAS 操作是<b style="color:red;">利用了处理器提供的 CMPXCHG 指令实现的</b>。</li>
</ul>

<pre style="margin-top:1em;">
优点：
竞争不大的时候系统开销小。

缺点：
1. 循环时间长开销大。
2. ABA问题。
3. 只能保证一个共享变量的原子操作。
</pre>
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[

        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>






  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Java中的锁实现]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="html" title="队列同步器（AQS）" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
    队列同步器 AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架。
</div>
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.35em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
.getState() // 获取同步状态
.setState(int newState) // 设置同步状态
.compareAndSetState(int expect, int update) // 使用 CAS 设置当前状态, 该方法能够保证状态设置的原子性
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="通过内置的FIFO双向队列来完成获取锁线程的排队工作" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[



<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>同步器包含两个节点类型的应用，一个指向头节点，一个指向尾节点，未获取到锁的线程会创建节点线程安全（compareAndSetTail）的加入队列尾部。同步队列遵循FIFO，首节点是获取同步状态成功的节点。</li>
    <li>未获取到锁的线程将创建一个节点，设置到尾节点。</li>
    <li>首节点的线程在释放锁时，将会唤醒后继节点。而后继节点将会在获取锁成功时将自己设置为首节点。</li>
</ul>
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="独占式/共享式锁获取" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<table>
    <thead>
        <tr>
            <th>独占锁</th>
            <th>共享锁</th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>有且只有一个线程能获取到锁，如：ReentrantLock。</td>
            <td rowspan="2">可以多个线程同时获取到锁，如：CountDownLatch</td>
        </tr>
        <tr>
            <td>每个节点自旋观察自己的前一节点是不是 Header 节点，如果是，就去尝试获取锁。</td>
        </tr>
        <tr>
            <td style="vertical-align: top;">
                <img width="485px" src="/images/java/get-locker.jpg" />
            </td>
            <td style="vertical-align: top;">
                <img width="450px" src="/images/java/share-locker-flow.jpg" />
                <img width="285px" src="/images/java/share-locker.jpg" />
            </td>
        </tr>
    </tbody>
</table>


]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[

        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[ConcurrentHashMap 的实现原理及使用]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        ConcurrentHashMap 使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="构造方法" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
public ConcurrentHashMap() {

}

public ConcurrentHashMap(int initialCapacity) {

    if (initialCapacity < 0)
        throw new IllegalArgumentException();

    int cap = ((initialCapacity >= (MAXIMUM_CAPACITY >>> 1)) ?
               MAXIMUM_CAPACITY :
               tableSizeFor(initialCapacity + (initialCapacity >>> 1) + 1)); //MAXIMUM_CAPACITY = 1 << 30

    this.sizeCtl = cap;//ConcurrentHashMap在构造函数中只会初始化sizeCtl值，并不会直接初始化table，而是延缓到第一次put操作。 
}

public ConcurrentHashMap(Map<? extends K, ? extends V> m) {
    this.sizeCtl = DEFAULT_CAPACITY;//DEFAULT_CAPACITY = 16
    putAll(m);
}
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[不可重入锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
每次调用含有锁的函数时，若锁已被占用且未释放，其他线程就阻塞等待。
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
public class Lock {
 
    private boolean isLocked = false;
 
    public synchronized void lock () throws InterruptedException{
 
        while (isLocked) {    
            wait();
        }
 
        isLocked = true;
 
    }
 
    public synchronized void unlock () {
        isLocked = false;
        notify();
    }
 
}
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
print() 函数会被执行，doAdd() 进入死锁状态，一直阻塞等待锁的释放。
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[可中断锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
顾名思义，就是可以相应中断的锁。在Java中，synchronized 就不是可中断锁，而 Lock 是可中断锁。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。
<br />
在下文提到的 lockInterruptibly() 用法时可体现 Lock 的可中断性。
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[公平锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
公平锁即尽量以请求锁的顺序来获取锁。比如同是有多个线程在等待一个锁，当这个锁被释放时，等待时间最久的线程（最先请求的线程）会获得该所，这种就是公平锁。
<br />
非公平锁即无法保证锁的获取是按照请求锁的顺序进行的。这样就可能导致某个或者一些线程永远获取不到锁。
<br />
在Java中，synchronized 就是非公平锁，它无法保证等待的线程获取锁的顺序。
<br />
而对于 ReentrantLock 和 ReentrantReadWriteLock，它默认情况下是非公平锁，但是可以设置为公平锁。
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[读写锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
读写锁将对一个资源（比如文件）的访问分成了2个锁，一个读锁和一个写锁。
<br />
正因为有了读写锁，才使得多个线程之间的读操作不会发生冲突。
<br />
ReadWriteLock 就是读写锁，它是一个接口，ReentrantReadWriteLock 实现了这个接口。
<br />
可以通过 readLock()获取读锁，通过 writeLock() 获取写锁。
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[synchronized 的缺陷]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
synchronized 是 java 中的一个关键字，也就是说是 Java 语言内置的特性。那么为什么会出现 Lock 呢？<br />
如果多个线程都只是进行读操作，所以当一个线程在进行读操作时，其他线程只能等待无法进行读操作。<br />
因此就需要一种机制来使得多个线程都只是进行读操作时，线程之间不会发生冲突，通过 Lock 就可以办到。<br />
另外，通过 Lock 可以知道线程有没有成功获取到锁。这个是 synchronized 无法办到的。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
Lock 提供了比 synchronized 更多的功能。但是要注意以下几点: <br />
1）synchronized 是不可中断锁，而 Lock 是可中断锁。 <br />
2）Lock 不是 Java 语言内置的，synchronized 是 Java 语言的关键字，因此是内置特性。Lock 是一个类，通过这个类可以实现同步访问；<br />
3）Lock 和 synchronized 有一点非常大的不同，采用 synchronized 不需要用户去手动释放锁，当 synchronized 方法或者 synchronized 代码块执行完之后，系统会自动让线程释放对锁的占用；而 Lock 则必须要用户去手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。因此使用 Lock 时需要在 finally 块中释放锁； <br />
4) Lock 可以提高多个线程进行读操作的效率。而当竞争资源非常激烈时（即有大量线程同时竞争），此时Lock的性能要远远优于synchronized
</div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Lock 接口定义]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public interface Lock {
    void lock();
    void lockInterruptibly() throws InterruptedException;
    boolean tryLock();
    boolean tryLock(long time, TimeUnit unit) throws InterruptedException;
    void unlock();
    Condition newCondition();
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
                     <div>
如果采用 Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁。因此一般来说，使用 Lock 必须在 try{} catch{} 块中进行，并且将释放锁的操作放在 finally 块中进行，以保证锁一定被被释放，防止死锁的发生。<br />通常使用 Lock 来进行同步的话，是以下面这种形式去使用的：
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="lock()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
Lock lock = ...;

try {
    lock.lock();
    //处理任务
} catch(Exception ex) {
     
} finally {
    lock.unlock();   //释放锁
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="tryLock()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>
tryLock() 方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。
</div>
<div style="margin-top:1em;">
tryLock(long time, TimeUnit unit) 方法和 tryLock() 方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。
</div>
<div style="margin-top:1em;">
一般情况下通过 tryLock() 来获取锁时是这样使用的：
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
Lock lock = ...;

if (lock.tryLock()) {
    try {
       // 处理任务
    } catch(Exception ex){
       
    } finally{
       lock.unlock();   // 释放锁
    } 
} else {
    // 如果不能获取锁，则直接做其他事情

}

]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[ReentrantLock(false) &mdash; 非安全锁]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
与 synchronize 效果一样，在锁被释放后，线程们相互竞争来获取锁。
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
 
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[安全锁（ReentrantLock(true)）]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
在锁释放后，可以按照线程队列或者自定义的条件，唤醒指定的线程或者分组的线程们。ReentrantLock 是唯一实现了 Lock 接口的类.
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;"></div>
      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="lock() 的错误使用方法" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 以下代码的问题在于，在 insert() 方法中的 lock 变量是局部变量，每个线程执行该方法时都会保存一个副本，
// 那么理所当然每个线程执行到 lock.lock() 处获取的是不同的锁，所以就不会发生冲突。
public class Test {
    
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();

    public static void main(String[] args)  {
    
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();

    }  
     
    public void insert(Thread thread) {
    
        Lock lock = new ReentrantLock();    //注意这个地方
        lock.lock();
    
        try {
            System.out.println(thread.getName()+"得到了锁");
            for(int i=0;i<5;i++) {
                arrayList.add(i);
            }
        } catch (Exception e) {
            // TODO: handle exception
        } finally {
            System.out.println(thread.getName()+"释放了锁");
            lock.unlock();
        }
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="lock() 的正确使用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 将lock声明为类的属性
public class Test {
    
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    private Lock lock = new ReentrantLock();    //注意这个地方

    public static void main(String[] args)  {
        
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();

    }  
     
    public void insert(Thread thread) {
        
        lock.lock();

        try {
            System.out.println(thread.getName()+"得到了锁");
            for(int i=0;i<5;i++) {
                arrayList.add(i);
            }
        } catch (Exception e) {
            // TODO: handle exception
        }finally {
            System.out.println(thread.getName()+"释放了锁");
            lock.unlock();
        }
    
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="tryLock() 的使用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class Test {
    
    private ArrayList<Integer> arrayList = new ArrayList<Integer>();
    private Lock lock = new ReentrantLock();    //注意这个地方

    public static void main(String[] args)  {
    
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.insert(Thread.currentThread());
            };
        }.start();
    }  
     
    public void insert(Thread thread) {
    
        if (lock.tryLock()) {
            try {
                System.out.println(thread.getName()+"得到了锁");
                for(int i=0;i<5;i++) {
                    arrayList.add(i);
                }
            } catch (Exception e) {
                // TODO: handle exception
            }finally {
                System.out.println(thread.getName()+"释放了锁");
                lock.unlock();
            }
        } else {
            System.out.println(thread.getName()+"获取锁失败");
        }
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="lockInterruptibly() 响应中断的使用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class Test {

    private Lock lock = new ReentrantLock();   

    public static void main(String[] args)  {

        Test test = new Test();
        MyThread thread1 = new MyThread(test);
        MyThread thread2 = new MyThread(test);
    
        thread1.start();
        thread2.start();
         
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    
        thread2.interrupt();
    }  
     
    public void insert(Thread thread) throws InterruptedException{
        
        lock.lockInterruptibly();   

        // 注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将 InterruptedException 抛出
        try {  
            System.out.println(thread.getName()+"得到了锁");
            long startTime = System.currentTimeMillis();
            for(    ;     ;) {
                if(System.currentTimeMillis() - startTime >= Integer.MAX_VALUE)
                    break;
                //插入数据
            }
        }
        finally {
            System.out.println(Thread.currentThread().getName()+"执行finally");
            lock.unlock();
            System.out.println(thread.getName()+"释放了锁");
        }  
    }
}
 
class MyThread extends Thread {

    private Test test = null;

    public MyThread(Test test) {
        this.test = test;
    }

    @Override
    public void run() {
        try {
            test.insert(Thread.currentThread());
        } catch (InterruptedException e) {
            System.out.println(Thread.currentThread().getName()+"被中断");
        }
    }

}
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[ReadWriteLock 接口定义]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public interface ReadWriteLock {
    /**
     * Returns the lock used for reading.
     * @return the lock used for reading.
     */
    Lock readLock();
 
    /**
     * Returns the lock used for writing.
     * @return the lock used for writing.
     */
    Lock writeLock();
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="synchronized 版读写锁" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 这段程序的输出结果会是，直到thread1执行完读操作之后，才会打印thread2执行读操作的信息。
public class Test {
    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
     
    public static void main(String[] args)  {
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
    }  
     
    public synchronized void get(Thread thread) {
        long start = System.currentTimeMillis();
        while(System.currentTimeMillis() - start <= 1) {
            System.out.println(thread.getName()+"正在进行读操作");
        }
        System.out.println(thread.getName()+"读操作完毕");
    }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="ReentrantReadWriteLock" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
/**
 * thread1 和 thread2 在同时进行读操作。
 * 这样就大大提升了读操作的效率。
 * 不过要注意的是，如果有一个线程已经占用了读锁，则此时其他线程如果要申请写锁，则申请写锁的线程会一直等待释放读锁。
 * 如果有一个线程已经占用了写锁，则此时其他线程如果申请写锁或者读锁，则申请的线程会一直等待释放写锁。
 * 关于 ReentrantReadWriteLock 类中的其他方法感兴趣的朋友可以自行查阅API文档。
 */
public class Test {

    private ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
     
    public static void main(String[] args)  {
        final Test test = new Test();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
        new Thread(){
            public void run() {
                test.get(Thread.currentThread());
            };
        }.start();
         
    }  
     
    public void get(Thread thread) {
        rwl.readLock().lock();
        try {
            long start = System.currentTimeMillis();
             
            while(System.currentTimeMillis() - start <= 1) {
                System.out.println(thread.getName()+"正在进行读操作");
            }
            System.out.println(thread.getName()+"读操作完毕");
        } finally {
            rwl.readLock().unlock();
        }
    }
}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Java中的偏向锁，轻量级锁， 重量级锁解析]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

原文: <a href="https://blog.csdn.net/lengxiao1993/article/details/81568130">https://blog.csdn.net/lengxiao1993/article/details/81568130</a>
<div>
synchronized 关键字通过一对字节码指令 monitorenter/monitorexit 实现， 这对指令被 JVM 规范所描述。
</div>
<div style="margin-top:.325em;">
java.util.concurrent.Lock 通过 Java 代码搭配 sun.misc.Unsafe 中的本地调用实现的
</div>

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="Java 对象头" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:blue;font-size:1.425em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>字宽（Word）: 内存大小的单位概念， 对于 32 位处理器 1 Word = 4 Bytes， 64 位处理器 1 Word = 8 Bytes</li>
    <li>每一个 Java 对象都至少占用 2 个字宽的内存(数组类型占用3个字宽)。</li>
    <li>第一个字宽也被称为对象头 Mark Word。对象头包含了多种不同的信息，其中就包含对象锁相关的信息。</li>
    <li>第二个字宽是指向定义该对象类信息（class metadata）的指针</li>
</ul>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top:1em;">
    <li>MarkWord 中包含对象 hashCode 的那种无锁状态是偏向机制被禁用时，分配出来的无锁对象 MarkWord 起始状态</li>
    <li>偏向机制被启用时，分配出来的对象状态是 ThreadId|Epoch|age|1|01, ThreadId 为空时标识对象尚未偏向于任何一个线程， ThreadId 不为空时，对象既可能处于偏向特定线程的状态，也有可能处于已经被特定线程占用完毕释放的状态，需结合 Epoch 和其他信息判断对象是否允许再偏向（rebias）。</li>
</ul>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top:1em;">
    <li>非数组类型的对象头的结构如下表</li>
</ul>

<div style="margin-top: .3em;">
    <img width="100%" src="/images/java/java-class-header.png" />
</div>

<div style="margin-top:1em;">
下面的图片来自参考论文 <a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8487&rep=rep1&type=pdf">Eliminating Synchronization-Related Atomic Operations with Biased Locking and Bulk Rebiasing</a>， 可以与上面的表格进行比对参照， 更为清晰, 可以看出来， 标志位（tag bits）可以直接确定唯一的一种锁状态
</div>


<div style="margin-top:.3em;">
    <img width="100%" src="/images/java/java-class-header-table.png" />
</div>

]]>
    </c:sourceContent>





    <c:sourceContent type="html" title=" CAS 指令" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:blue;font-size:1.425em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>CAS（Compare And Swap）指令是一个CPU层级的原子性操作指令。在 Intel 处理器中，其汇编指令为 cmpxchg。</li>
    <li>该指令概念上存在3个参数，第一个参数【目标地址】，第二个参数【值1】，第三个参数【值2】，指令会比较【目标地址存储的内容】和 【值1】 是否一致， 如果一致，则将【值 2】填写到【目标地址】，其语义可以用如下的伪代码表示。</li>
    <li>注意： 该指令是是原子性的， 也就是说 CPU 执行该指令时， 是不会被中断执行其他指令的</li>
</ul>

]]>
    </c:sourceContent>


    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:blue;font-size:1.425em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
function cas(p , old , new ) returns bool {
    // *p 表示指针p所指向的内存地址
    if *p ≠ old { 
        return false
    }
    *p ← new
    return true
}
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



</c:component>
