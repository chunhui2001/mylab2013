<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div>
hashCode 是 jdk 根据对象的地址或者字符串或者数字算出来的 int 类型的数值, 用于提高查询效率, 为不相等的对象生成不同整数结果可以提高哈希表的性能。
<br /><br />
若关键字为k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。
</div>
<pre>       
▪ 集合    ▪ 容器        
▪ 数组    ▪ 关联数组  ▪ Multimap  ▪ 集
▪ 多重集   ▪ 散列表   ▪ 树状数组  
▪ 列表    ▪ 链表    ▪ 队列    ▪ 堆栈
▪ 循环队列  ▪ 跳跃列表      
▪ 树     ▪ 二叉查找树 ▪ 堆 ▪ 线段树
▪ 红黑树   ▪ AVL树      
▪ 图     ▪ 有向无环图 ▪ 二元决策图 ▪ 无向图
</pre>
<div style="text-align: center;padding: 1em;font-size: 3em;color: crimson;padding-bottom: 0;">
散列表（Hash table，也叫哈希表）
</div>
]]>
  </c:abstract>




  <c:entry style="margin-top:2em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[著名的ELFhash算法]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
int ELFhash(char*key) {
    unsigned long h=0;
    while(*key) {
        h = (h << 4) + *key++;
        unsigned long g = h & 0xF0000000L;
        if(g)
            h ^= g >> 24;
        h &= ~g;
    }
    return h % MOD;
}
]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[
        <div>一些著名的 hash 算法: MD4、MD5、SHA-1 及其他</div>
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Hashcode 原理]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
将数据根据特定的算法映射到一个固定地址上 相当于一人一个座位(内存地址) 一人一个座位号(HashCode)的意思 一旦某个座位上有人 那么才和这个座位上的人eqauls比较 同一个人则不分配 不同则分配其他位置(散列) 如果这个座位上没人 则直接就坐
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;">
基于实现以上的需求 Java 对 eqauls() 和 hashCode() 做了以下的规定：
        </div>

        <ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;color:red;">
            <li>如果 eqauls 为 true 则两者的 hashCode 一定相同</li>
            <li>如果两者的 hashCode() 相同 eqauls 不一定为 true；hashCode() 不同 那么 eqauls() 一定不为 true</li>
        </ul>

        <div style="margin-top:1em;line-height: 1.625em;">
            这里体现了 hashCode() 对查询效率的优化：<br />
首先 hashcode() 对比的效率会高于 eqauls() 那么在上的上述的场景中 我们可以先通过 hashcode() 来对比 如果不一样就不需要 eqauls() 对比. 如果一样再通 eqauls() 对比增加可靠性, 这种方案既准确也高效.
        </div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="一致性" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[

在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 hashcode 比较时所用的信息没有被修改。
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="Hash算法在信息安全方面的应用" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[

<div style="margin-top:.625em;"><b>文件校验</b></div>
<div style="margin-top:.325em;">我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测出数据传输中的信道误码，但却不能防止对数据的恶意破坏。</div>
<div style="margin-top:.325em;">MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。</div>

<div style="margin-top:1.3em;"><b>数字签名</b></div>
<div style="margin-top:.325em;">Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。</div>

<div style="margin-top:1.3em;"><b>鉴权协议</b></div>
<div style="margin-top:.325em;">如下的鉴权协议又被称作挑战--认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</div>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[哈希表]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
散列表（Hash table，也叫哈希表），是根据关键码值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
给定表M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希 (Hash）表，函数 f(key) 为哈希(Hash) 函数。
</div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="基本概念" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<ul style="list-style-type: disc;margin-left: 1.5em;line-height: 1.425em;">
    <li style="margin-bottom: .3em;">
    若关键字为k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
    </li>
    <li style="margin-bottom: .3em;">
    对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。
    </li>
    <li style="margin-bottom: .3em;">
    若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。
    </li>
</ul>
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="生成 hashcode 常用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。<br />
实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：
</div>

<ul style="color:red;list-style-type: disc;margin-left: 1.5em;line-height: 1.3em;margin-top:.625em;">
    <li style="margin-bottom: .3em;">
    计算哈希函数所需时间
    </li>
    <li style="margin-bottom: .3em;">
    关键字的长度
    </li>
    <li style="margin-bottom: .3em;">
    哈希表的大小
    </li>
    <li style="margin-bottom: .3em;">
    关键字的分布情况
    </li>
    <li style="margin-bottom: .3em;">
    记录的查找频率
    </li>
</ul>



<ul style="list-style-type: decimal;margin-left: 2.2em;line-height: 1.625em;margin-top:1.625em;">
    <li style="margin-bottom: .3em;">
    <b>直接寻址法：</b><br />取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。
    </li>
    <li style="margin-bottom: .3em;">
    <b>数字分析法：</b><br />分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
    </li>
    <li style="margin-bottom: .3em;">
        <div>
            <b>平方取中法：</b><br />当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。<br />这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。<b>例：</b>
        </div>
        <div>
            <div style="color:brown;margin-top:.3em;">我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示: </div>
            <table style="color: cadetblue;font-size: 2em;margin: .5em 0;line-height: 1.3em;">
                <tbody>
                    <tr style="padding: 0;margin: 0;">
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;font-weight: normal;">K</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">E</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;padding-right:1.325em;">Y</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">A</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">B</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;font-weight: normal;">11</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">05</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">25</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">01</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">02</td>
                    </tr>
                </tbody>
            </table>

            <table style="color:blueviolet !important">
                <thead>
                    <tr style="padding: 0;margin: 0;">
                        <th style="padding: 0;margin: 0;padding-right:1.325em;color:blueviolet !important">关键字</th>
                        <th style="padding: 0;margin: 0;padding-right:2.325em;color:blueviolet !important">内部编码</th>
                        <th style="padding: 0;margin: 0;padding-right:2.325em;color:blueviolet !important">内部编码的平方值</th>
                        <th style="padding: 0;margin: 0;padding-right:1.325em;color:blueviolet !important">H(k)关键字的哈希地址</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="padding: 0;margin: 0;">
                        <td style="padding: 0;margin: 0;font-weight: normal;">KEYA</td>
                        <td style="padding: 0;margin: 0;">11052501</td>
                        <td style="padding: 0;margin: 0;">122157778355001</td>
                        <td style="padding: 0;margin: 0;">778</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">KYAB</td>
                        <td style="padding: 0;margin: 0;">11250102</td>
                        <td style="padding: 0;margin: 0;">126564795010404</td>
                        <td style="padding: 0;margin: 0;">795</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">AKEY</td>
                        <td style="padding: 0;margin: 0;">01110525</td>
                        <td style="padding: 0;margin: 0;">001233265775625</td>
                        <td style="padding: 0;margin: 0;">265</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">BKEY</td>
                        <td style="padding: 0;margin: 0;">02110525</td>
                        <td style="padding: 0;margin: 0;">004454315775625</td>
                        <td style="padding: 0;margin: 0;">315</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </li>
    <li style="margin-bottom: .3em;">
      <div>
        <b>分段叠加法：</b><br />将关键字分割成位数相同的几部分，最后一部分可以较短。 然后将这几部分相加, 舍弃最高进位后的结果就是该关键字的哈希地址(即:散列地址)。具体方法有<b>折叠法</b>与<b>移位法</b>。移位法是将分割后的每部分低位对齐相加，折叠法是从一端向另一端沿分割界来回折叠(奇数段为正序，偶数段为倒序)，然后将各段相加。例如：key=12360324711202065,哈希表长度为1000，则应把关键字分成3位一段，在此舍去最低的两位65，分别进行移位叠加和折叠叠加，求得哈希地址为105和907，
        <br />如图8.24所示。
      </div>
      <pre style="color:red;">

     1  2  3                   1  2   3
     6  0  3                   3  0   6
     2  4  7                   2  4   7
     1  1  2                   2  1   1
+)   0  2  0                +) 0  2   0
 ———————————               ————————————
  1  1  0  5                   9  0   7

   a）移位叠加                (b) 折叠叠加

            <b>[由叠加法求哈希地址]</b>
      </pre>
    </li>
    <li style="margin-bottom: .3em;">
     <div><b>除留余数法：</b><br />取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词
     </div>
     <pre style="color:blue;">

假设哈希表长为m，p为小于等于m的最大素数，则哈希函数为:
<b style="color:red;font-size:2em;">h（k）=k %  p</b> 其中%为模p取余运算。

例如，已知待散列元素为（18，75，60，43，54，90，46），表长m=10，p=7，则有:
   h(18)=18 % 7=4    h(75)=75 % 7=5   h(60)=60 % 7=4   
   h(43)=43 % 7=1    h(54)=54 % 7=5   h(90)=90 % 7=6   
   h(46)=46 % 7=4

此时冲突较多。为减少冲突，可取较大的m值和p值，如m=p=13，结果如下：
   h(18)=18 % 13=5    h(75)=75 % 13=10   h(60)=60 % 13=8
   h(43)=43 % 13=4    h(54)=54 % 13=2   h(90)=90 % 13=12
   h(46)=46 % 13=7
     </pre>
     <p>此时分布情况如下所示(相对均匀):</p>
     <table>
      <tbody>

        <tr>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">54</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">43</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">18</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">46</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">60</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">75</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
          <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">90</td>
        </tr>
        <tr>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">0</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">1</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">2</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">3</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">4</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">5</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">6</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">7</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">8</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">9</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">10</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">11</td>
          <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">12</td>
        </tr>
      </tbody>
     </table>
    </li>

    <li style="">
     <b>伪随机数法：</b><br />选择一随机函数，取关键字的随机值作为散列地址，即 h(key)=random(key)。通常用于关键字长度不同的场合。
    </li>
</ul>


]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="处理冲突" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<h3 style="color:gray;">
参考: http://blog.sina.com.cn/s/blog_6fd335bb0100v1ks.html
</h3>
<ul style="list-style-type: decimal;margin-left: 2.5em;line-height: 1.425em;">
    <li style="margin-bottom: .3em;">
        <div>
          <b>开放寻址法:</b> 这种方法也称<b  style="color:red;">再散列法，其基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中</b>。这种方法有一个通用的再散列函数形式：
          <br />
          <b style="color: crimson;">H<sub>i</sub>=（H（key）+d<sub>i</sub>）% m   i=1，2，…，n</b>
          <br />
          其中H（key）为哈希函数，m 为表长，di称为增量序列。增量序列的取值方式不同，相应的再散列方式也不同。主要有以下三种：
        </div>
        <div>
            <ul style="list-style-type: disc;margin: .5em 1.5em;">
                <li style="color: crimson;"><b>d<sub>i</sub>=1,2,3，…，m-1，称线性探测再散列；</b><br />
                   特点是：冲突发生时，顺序查看表中下一单元，直到找出一个空单元或查遍全表。</li>
                <li style="color: crimson;"><b>d<sub>i</sub>=1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>，⑶<sup>2</sup>，…，±（k)<sup>2</sup>,(k<=m/2）称二次探测再散列；</b><br />
                   特点是：冲突发生时，在表的左右进行跳跃式探测，比较灵活。</li>
                <li style="color: crimson;">
                  <div style="color: crimson;"><b>d<sub>i</sub>=伪随机数序列，称伪随机探测再散列。</b></div>
                  
                  <div style="color:gray;margin-top:1em;">线性探测再散列的优点是：只要哈希表不满，就一定能找到一个不冲突的哈希地址，而二次探测再散列和伪随机探测再散列则不一定。
                   线性探测再散列的缺点是：线性探测再散列容易产生“二次聚集”，即在处理同义词的冲突时又导致非同义词的冲突。
                   <br />例如，当表中i, i+1 ,i+2三个单元已满时，下一个哈希地址为i, 或i+1 ,或i+2，或i+3的元素，都将填入i+3这同一个单元，而这四个元素并非同义词。</div>

                  <div style="color: darkorchid;margin-top:1em;">
                    <p>
                      具体实现时，应建立一个伪随机数发生器，（如i=(i+p) % m），并给定一个随机数做起点。</p>
                    <p style="color:chocolate">
                      <span>例如: </span><br /> 已知哈希表长度 m=11，哈希函数为：<b style="color:blue;">H（key）= key %  11</b>，则H（47）=3，H（26）=4，H（60）=5，假设下一个关键字为69，则H（69）=3，与47冲突。
                    </p>
                  </div>
                  <div style="color:green;">
                    如果用<b style="text-decoration: underline;font-size:1.5em;">线性探测再散列</b>处理冲突，
                    <br />下一个哈希地址为 H1=（3 + 1）% 11 = 4，
                    <br />仍然冲突，再找下一个哈希地址为 H2=（3 + 2）% 11 = 5，
                    <br />还是冲突，继续找下一个哈希地址为 H3=（3 + 3）% 11 = 6，
                    <br />此时不再冲突，将69填入5号单元，参表 (A)。
                  </div>
                  
                 <table style="margin-top:.325em;">
                  <tbody>
                    <tr>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">47</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">26</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">60</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;"><b style="font-size:1.825em;font-family: fantasy;color: red;text-shadow: 0px 0px 14px #FF0000;">69</b></td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                    </tr>
                    <tr>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">0</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">1</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">2</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">3</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">4</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">5</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">6</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">7</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">8</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">9</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">10</td>
                    </tr>
                  </tbody>
                 </table>
                  <div style="margin-top:.625em;color:green;">
                    如果用<b style="text-decoration: underline;font-size:1.5em;">二次探测再散列</b>处理冲突，
                    <br />下一个哈希地址为 H1=（3 + 1<sup>2</sup>）% 11 = 4，
                    <br />仍然冲突，再找下一个哈希地址为H2=（3 - 1<sup>2</sup>）% 11 = 2，
                    <br />此时不再冲突，将69填入2号单元，参表 (B)。
                  </div>

                 <table style="margin-top:.325em;">
                  <tbody>
                    <tr>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;"><b style="font-size:1.825em;font-family: fantasy;color: red;text-shadow: 0px 0px 14px #FF0000;">69</b></td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">47</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">26</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">60</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                    </tr>
                    <tr>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">0</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">1</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">2</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">3</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">4</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">5</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">6</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">7</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">8</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">9</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">10</td>
                    </tr>
                  </tbody>
                 </table>
                  <div style="margin-top:.625em;color:green;">
                    如果用<b style="text-decoration: underline;font-size:1.5em;">伪随机探测再散列</b>处理冲突，且伪随机数序列为：2，5，9，……..，
                    <br />则下一个哈希地址为 H1=（3 + 2）% 11 = 5，
                    <br />仍然冲突，再找下一个哈希地址为 H2=（3 + 5）% 11 = 8，
                    <br />此时不再冲突，将69填入8号单元，参表 (C)。
                  </div>

                 <table style="margin-top:.325em;">
                  <tbody>
                    <tr>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;"></td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">47</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">26</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">60</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;"><b style="font-size:1.825em;font-family: fantasy;color: red;text-shadow: 0px 0px 14px #FF0000;">69</b></td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                      <td style="padding:4px 8px;text-align:center;border:solid 1px goldenrod;">&nbsp;</td>
                    </tr>
                    <tr>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">0</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">1</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">2</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">3</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">4</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">5</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">6</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">7</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">8</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">9</td>
                      <td style="padding: 5px 8px;text-align:center;color:gray;;border:solid 1px goldenrod;">10</td>
                    </tr>
                  </tbody>
                 </table>
                </li>
            </ul>
        </div>
    </li>
    <li style="margin-bottom: .3em;">
    <b>再散列法</b>, 这种方法是同时构造多个不同的哈希函数：<br />

    <b>H<sub>i</sub>=RH<sub>i</sub>(key),i=1,2，…，k </b> <br />
    当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。
    </li>
    <li style="margin-bottom: .3em;">
    <b>链地址法(拉链法)</b>, 这种方法的基本思想是<b style="color:red;">将所有哈希地址为i的元素构成一个称为同义词链的单链表</b>, 并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。
    </li>
    <li style="margin-bottom: .3em;">
    <b>建立一个公共溢出区</b>, 这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表
    </li>
</ul>
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[java 集合 HashMap、HashTable、HashSet]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<img width="650px" src="/images/java/hashmap-structrue.png" />
]]></c:desc1>
    </c:desc>


    <c:sourceContent type="html" title="HashMap 存储结构" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<ul style="margin-left: 2em;list-style-type: decimal;margin-top: .3em;">
    <li style="margin-bottom:.3em;">hashmap 底层是以数组方式进行存储。将 key-value 对作为数组中的一个元素进行存储。</li>
    <li style="margin-bottom:.3em;">key-value 都是 Map.Entry 中的属性。其中将 key 的值进行 hash 之后进行存储，即每一个 key 都是计算 hash 值，然后再存储。每一个 Hash 值对应一个数组下标，数组下标是根据 hash 值和数组长度计算得来。</li>
    <li style="margin-bottom:.3em;">由于不能的 key 有可能 hash 值相同，即该位置的数组中的元素出现两个，对于这种情况，hashmap 采用链表形式进行存储。</li>
</ul>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="HashMap 底层为什么一定用数组" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<ul style="margin-left: 2em;list-style-type: decimal;margin-top: .3em;">
    <li style="margin-bottom:.3em;"><b>数组效率高: </b> 在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li>
    <li style="margin-bottom:.3em;"><b>可自定义扩容机制: </b>采用基本数组结构，扩容机制可以自己定义，HashMap 中数组扩容刚好是2的次幂，在做取模运算的效率高。
    <br /><b style="color:red;">注1: HashMap 在扩容时，新数组的容量将是原来的2倍</b>
    <br /><b style="color:red;">注2: ArrayList 底层也是数组，但是扩容机制是1.5倍扩容</b>
  </li>
</ul>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="HashMap 执行流程" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left: 2em;list-style-type: decimal;margin-top: .3em;">
    <li style="margin-bottom:.3em;">判断当前 table 有没有初始化,没有就调用 resize() 方法初始化.(resize 方法既是扩容也是初始化)</li>
    <li style="margin-bottom:.3em;">判断算出的位置i处有没有值,没有值,创建一个新的node,插入i位置.</li>
    <li style="margin-bottom:.3em;">当前i位置有值,判断头结点的 hash 和 key 是否和传入的 key 和 hash 相等,相等则记录这个e.</li>
    <li style="margin-bottom:.3em;">与头节点的 key 和 hash 不同,判断节点是否是树节点,如果是,调用树节点的插入方法 putTreeVal() 方法.(占时不了解红黑树的底层方法实现逻辑,待续).</li>
    <li style="margin-bottom:.3em;">不是树结构,那证明是链表结构,遍历链表结构,并记录链表长度 binCount. 主要做了两步,(1)在链表里找到和传入的 key 和 hash 相等的基点,并记录,(2) 没有找到,创建一个节点,插入链表的尾部,并判断链表长度有没有大于等于8,如果是就调 treeifyBin 方法决定是否需要树化.</li>
    <li style="margin-bottom:.3em;">判断前面记录的e节点是否为空,不为空证明找到了相同的基点,那就替换 value, 返回 oldValue.</li>
    <li style="margin-bottom:.3em;">整个插入流程已经结束,接下来要判断是否需要扩容,如果(++size > threshold)满足,那么就调用扩容方法</li>
</ul>
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="HashMap put() 源码" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>put() 方法: 它调用键对象的 hashCode() 方法来计算 hashcode 值，系统根据 hashcode 值决定该元素在 <b>bucket/桶</b> 位置。如果两个对象 key 的 hashcode 返回值相同，那他们的存储位置相同，如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但 key 不会覆盖；如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加 Entry 位于 Entry 链的头部。
</div>


<div>
put() 源码如下: </div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}

/**
 * put
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) {
    Node<K,V>[] tab;
    Node<K,V> p;
    int n, i;
    if ((tab = table) == null || (n = tab.length) == 0) // table为null,table的length为0,table还没有初始化
        n = (tab = resize()).length; //调用扩容方法,初始化table
    if ((p = tab[i = (n - 1) & hash]) == null) //table{[i] 没有值,直接插入
        tab[i] = newNode(hash, key, value, null);
    else { // 有值
        Node<K,V> e; K k;
        if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k)))) // 找到了相同的key
            e = p;
        else if (p instanceof TreeNode) // 判断是否是树结构
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value); // 调用树的插入
        else {
            // 遍历链表,并记录节点的长度
            for (int binCount = 0; ; ++binCount) {
                if ((e = p.next) == null) { // 找到最后一个节点了
                    p.next = newNode(hash, key, value, null); //设置当前节点为为p的next
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st 如果节点长度大于等于了8,就调用treeifyBin方法
                        treeifyBin(tab, hash);
                    break;
                }
                if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k)))) // 找到了相同的key
                    // 此时break,返回的是e.key与传入的key相等的e,以便下面进行替换
                    break;
                p = e;
            }
        }
        // e != null 说明前面的遍历找到了相同的key,下面就行替换,返回旧值
        if (e != null) { // existing mapping for key //
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null) // onlyIfAbsent默认是false
                e.value = value; // 替换value
            afterNodeAccess(e);
            return oldValue; // 返回旧的value
        }
    }
    ++modCount;
    //  当前值大于阈值,进行扩容
    if (++size > threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="HashMap get 源码()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>get()方法: 当 HashMap 的每个 bucket 里存储的 Entry 只是单个 Entry，即没有通过指针产生 Entry 链时，此时 HashMap 具有最好的性能。当程序通过 key 取出对应 value 时，系统先计算出该 key 的 hashCode() 返回值，再根据该 hashCode() 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 值。</div>

<div>get 源码如下:</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.5em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 从代码看出，HashMap 的每个 bucket 里只有一个Entry，HashMap 可以根据索引快速取出该 bucket 里的 Entry。
// 在发生 Hash 冲突的情况下，单个 bucket 里存储的不是一个Entry，
// 而是一个 Entry 链，系统只能按顺序遍历每个 Entry，直到找到想搜索的 Entry。
public V get(Object key) {
    Node<K,V> e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
}

/**
 * 获取值
 */
final Node<K,V> getNode(int hash, Object key) {
    Node<K,V>[] tab;
    Node<K,V> first, e;
    int n;
    K k;
    if ((tab = table) != null && (n = tab.length) > 0 && // table不是null,table的长度大于0
            (first = tab[(n - 1) & hash]) != null) { // ,根据可以取得第一个node不为空
        if (first.hash == hash && // always check first node  对比第一个hash和当前值的hash是否一样
                ((k = first.key) == key || (key != null && key.equals(k))))
            return first; // 等于第一个,返回
        if ((e = first.next) != null) { // 向下遍历,next不等于空
            if (first instanceof TreeNode) // 判断是否是树结构
                return ((TreeNode<K,V>)first).getTreeNode(hash, key); // 查找
            do { // 不是树,就是链表,遍历链表
                if (e.hash == hash &&
                        ((k = e.key) == key || (key != null && key.equals(k))))
                    return e;
            } while ((e = e.next) != null);
        }
    }
    return null; //  没有找到,返回null
}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="HashMap resize() 源码()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>解释为什么在新 table 的位置没有重新计算, 而是根据 (e.hash & oldCap) == 0, 
  <br /> 等于0就是在原位置, 不等于0时, 就是 newtable[原位置+oldCap]
  <br /> 如下图:
</div>

<img width="750px" src="/images/java/hashmap-resize.png" />
<div style="margin-top:1em;">
  table 长度我们以 16 为例, hash 值我们以 484 和 30 为例, 我们发现 484&16=0, 30&16=30, 我们发现一个区别就是他们的他们的低5位一个是0、一个是1.
</div>
<div style="margin-top:1em;">
  我们让低5位是0的484, 分别&上 (16-1)和(32-1), 结论是位置没有发生变化, 所以说如果低5位是0, 那么扩容前和扩容后位置不变.
</div>
<img width="750px" src="/images/java/hashmap-resize2.jpg" />
<div style="margin-top:1em;">
  我们让低5位是1的30,分别&上(16-1)和(32-1),结论是位置发生变化,所以说如果低5位是1,那么新位置就是: 原来位置+oldCap.
</div>
<img width="750px" src="/images/java/hashmap-resize3.jpg" />
<div style="margin-top:1em;">
  其实我们发现(e.hash & oldCap) == 0 只是为了证明低5位是0还是1,这是为什么了,其实是和(16-1)和(32-1)有着密切的关系,15二进制是1111,31是11111,我们发现不管哪个数&上15或者31都是这个数低4位或者低5位本身,所以e.hash如果低5位0,那其实都是&1111,因为低5位是0&运算下还是0,如果e.hash的低5位是1,那么和0相比就是低5位会变成1,所以需要加上这个多的位置的值oldCap.
</div>

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.5em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
/**
 * 扩容
 * @return
 */
final Node<K,V>[] resize() {
    // 旧table
    Node<K,V>[] oldTab = table;
    // 旧的table长度
    int oldCap = (oldTab == null) ? 0 : oldTab.length;
    // 旧的阈值
    int oldThr = threshold;
    int newCap, newThr = 0;
    //  证明就table,已经被初始化了
    if (oldCap > 0) {
        // 如果旧的table大于做大值,阈值就设置为Internet的最大值,返回
        if (oldCap >= MAXIMUM_CAPACITY) {
            threshold = Integer.MAX_VALUE;
            return oldTab;
        }
        // 给newCap赋值 newCap = oldCap << 1 (* 2^1) < MAXIMUM_CAPACITY(1 << 30)
        // oldCap >= 16 证明已经初始化过了,现在是扩容(假如oldCap就是16)
        // 新阈值 newThr = (oldThr = threshold) = 12 << 1(12 * 2^1)
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1; // double threshold // 新的阈值
    }
    // 这种情况是table还没有初始化
    // oldThr >0 是因为在有参构造里面会把cap赋值给threshold
    else if (oldThr > 0) // initial capacity was placed in threshold
        // 容量就是oldThr
        newCap = oldThr;
    // 无参构造,容量和阈值都使用默认
    else {               // zero initial threshold signifies using defaults
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    // newThr=0证明使用的是有参构造,容量有值,阈值没有值
    // 所以初始化阈值
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                (int)ft : Integer.MAX_VALUE);
    }

    /** 上面属于table参数准备部分,分为初始化或者扩容 */

    // 新的阈值
    threshold = newThr;
    // 创建新的table
    @SuppressWarnings({"rawtypes","unchecked"})
    Node<K,V>[] newTab = (Node<K,V>[])new Node[newCap];
    table = newTab;
    if (oldTab != null) {
        // 开始遍历旧的table,进行数据迁移
        for (int j = 0; j < oldCap; ++j) {
            Node<K,V> e;
            if ((e = oldTab[j]) != null) {
                oldTab[j] = null; // 释放内存地址
                if (e.next == null) // 表示只有一个元素
                    newTab[e.hash & (newCap - 1)] = e;
                else if (e instanceof TreeNode) // 如果是树结构,调用树结构的方法
                    ((TreeNode<K,V>)e).split(this, newTab, j, oldCap);
                else { // preserve order
                    // 链表结构的数据 lo 表示位置不变 hi表示位置是原来的位置+oldCap
                    // 是通过(e.hash & oldCap) == 0 这句话来判断的
                    Node<K,V> loHead = null, loTail = null;
                    Node<K,V> hiHead = null, hiTail = null;
                    Node<K,V> next;
                    do {
                        next = e.next;
                       // 解释在上面的图片
                        if ((e.hash & oldCap) == 0) {
                            if (loTail == null) // 第一次循环 tail 为null,所以头和尾都是 e
                                loHead = e;  // 头部是当前的e
                            else             // 接下来的循环tail不为null
                                loTail.next = e; // loTail 是上一次满足if的e
                                                 // e 是这一次满足if的e
                                                 // 所以loTail.next = e的目的就是,上一次满足if的e指向下一次满足if的e
                                                 // 代码就是loTail.next = e
                            loTail = e;  // 每次循环尾部就是当前节点
                        }
                        else {
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        }
                    } while ((e = next) != null);
                    // 位置不变还是j
                    if (loTail != null) {
                        loTail.next = null; // 尾部节点的next设置为null
                        newTab[j] = loHead; // 设置头结点指向table[j] (第一次循环时,head=tail,接下来循环给tail追加节点)
                    }
                    // 位置变化,是 j+oldCap
                    if (hiTail != null) {
                        hiTail.next = null; 
                        newTab[j + oldCap] = hiHead;
                    }
                }
            }
        }
    }
    return newTab;
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Entry 结构分析" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
Entry 是 hashMap 中封装 key-value 键值对的，主要包括如下属性
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.5em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
static class Entry<K,V> implements Map.Entry<K,V> {

    final K key;      // map 中 key 值，可以为 null。
    V value;          // map 中的 value 值，可以为 null。
    Entry<K,V> next;  // 链表引用，防止 key 值不同，hash 值相同。
    int hash;         // 每个 key 的 hash 值

    // 构造函数
    Entry(int h, K k, V v, Entry<K,V> n) {
        value = v;
        next = n;
        key = k;
        hash = h;
    }

    public final K getKey() {
        return key;
    }

    public final V getValue() {
        return value;
    }
    
    // 同一个 key 时，新值替换旧值，返回旧值
    public final V setValue(V newValue) {
        V oldValue = value;
        value = newValue;
        return oldValue;
    }
    
    // key 值重写 equals 方法
    public final boolean equals(Object o) {
        if (!(o instanceof Map.Entry))
            return false;
        Map.Entry e = (Map.Entry)o;
        Object k1 = getKey();
        Object k2 = e.getKey();
        if (k1 == k2 || (k1 != null && k1.equals(k2))) {
            Object v1 = getValue();
            Object v2 = e.getValue();
            if (v1 == v2 || (v1 != null && v1.equals(v2)))
                return true;
        }
        return false;
    }
    
    // 重写 hashCode 值
    public final int hashCode() {
        return Objects.hashCode(getKey()) ^ Objects.hashCode(getValue());
    }

    public final String toString() {
        return getKey() + "=" + getValue();
    }
    
    // ......

}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="HashMap 属性分析" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
HashMap 属性分析
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.5em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public class HashMap<K,V> extends AbstractMap<K,V> implements Map<K,V>, Cloneable, Serializable
{
 
    /**
     * 默认情况下，hashmap 大小为 16.即 1<<4 就是1乘以2的4次幂 =16
     */
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16
 
    /**
     * hashMap 的最大值
     */
    static final int MAXIMUM_CAPACITY = 1 << 30;
 
    /**
     * 默认加载加载因子，即使用空间达到总空间的 0.75 时，需要扩容。
     */
    static final float DEFAULT_LOAD_FACTOR = 0.75f;
 
    /**
     * 声明 hashmap 一个空数组。
     */
    static final Entry<?,?>[] EMPTY_TABLE = {};
 
    /**
     * 最开始时，hashmap 是一个空数组。
     */
    transient Entry<K,V>[] table = (Entry<K,V>[]) EMPTY_TABLE;
 
    /**
     * map 的元素的个数
     */
    transient int size;
 
    /*
     * hashmap 的实际存储空间大小。这个空间是 "总空间*加载因子" 得出的大小。
     * 比如默认是16，加载因子是 0.74。则 threshold 就是12。
     */
    int threshold;
 
    /**
     * 加载因子，即使用空间达到总空间的0.75时，需要扩容。
     */
    final float loadFactor;
 
    /**
     *  modCount 是这个 list 被结构性修改的次数。
     *  结构性修改是指：改变list的size大小，或者，以其他方式改变他导致正在进行迭代时出现错误的结果。
     *  这个字段用于迭代器和列表迭代器的实现类中，由迭代器和列表迭代器方法返回。
     *  如果这个值被意外改变，这个迭代器将会抛出 ConcurrentModificationException的异常来响应：next,remove,previous,set,add 这些操作。
     *  在迭代过程中，他提供了fail-fast行为而不是不确定行为来处理并发修改。
     *  子类使用这个字段是可选的，如果子类希望提供fail-fast迭代器，它仅仅需要在add(int, E),remove(int)方法
     * （或者它重写的其他任何会结构性修改这个列表的方法）中添加这个字段。
     *  调用一次add(int,E)或者remove(int)方法时必须且仅仅给这个字段加1，否则迭代器会抛出伪装的ConcurrentModificationExceptions错误。
     *  如果一个实现类不希望提供fail-fast迭代器，则可以忽略这个字段。
     */
    transient int modCount;
 
    /**
     *  threshold 这个值的最大值就是 Integer.MAX_VALUE
     */
    static final int ALTERNATIVE_HASHING_THRESHOLD_DEFAULT = Integer.MAX_VALUE;
    
    // ......

}
]]>
    </c:sourceContent>




    <c:sourceContent type="html" title="HashMap 有两个参数影响其性能：" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left: 2em;list-style-type: decimal;margin-top: .3em;">
    <li style="margin-bottom:.3em;">初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。<b style="color:blue;">当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用rehash 方法将容量翻倍。</b></li>
    <li style="margin-bottom:.3em;">加载因子过高虽然减少了空间开销，但同时也增加了查询成本<b style="color:red;">（加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了）</b>。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地降低 rehash 操作次数。如果初始容量大于最大条目数除以加载因子(实际上就是最大条目数小于初始容量*加载因子)，则不会发生 rehash 操作。</li>
    <li style="margin-bottom:.3em;">HashMap 存放的元素越来越多，到达临界值 (阀值)threshold 时，就要对 Entry 数组扩容，这是 Java 集合类框架最大的魅力，<b style="color:green;">HashMap 在扩容时，新数组的容量将是原来的2倍，由于容量发生变化，原有的每个元素需要重新计算 bucketIndex，再存放到新数组中去，也就是所谓的 rehash</b>。<b>HashMap 默认初始容量16，加载因子0.75，也就是说<b style="color:blue;">最多能放16*0.75=12个元素，当put第13个时，HashMap 将发生 rehash</b>，rehash 的一系列处理比较影响性能，所以当我们需要向 HashMap 存放较多元素时，最好指定合适的初始容量和加载因子，否则 HashMap 默认只能存12个元素，将会发生多次 rehash 操作。</b></li>
</ul>

]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="HashMap 和 Hashtable 的区别" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
    HashMap 和 Hashtable 都实现了 Map 接口，主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap 几乎可以等价于 Hashtable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值(key)和值(value)，而 Hashtable 则不行)。
</div>

<div style="margin-top:.625em;">
    HashMap 是非 synchronized，而 Hashtable 是 synchronized，意味着 Hashtable 是线程安全的，多个线程可以共享一个 Hashtable；而多个线程是不能共享 HashMap的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。另一个区别是 HashMap 的迭代器(Iterator)是 <b style="color:red;">fail-fast</b> 迭代器，而 Hashtable 是 <b style="color:red;">enumerator迭代器</b>。HashMap 可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap);
</div>

]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="HashMap 和 HashSet 的区别" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
HashSet 实现了 Set 接口，它不允许集合中有重复的值，HashMap 实现了 Map 接口，Map 接口对键值对进行映射。
HashSet 扩展了 HashMap, 所以底层还是用到 map 存储，存储实现同 map 一致，HashMap 储存键值，HashSet 存储对象。
分类: java 基础
</div>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>









  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[java 中的 fail-fast(快速失败) 机制]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
在线程不安全的集合中，如使用迭代器的过程中，发现集合被修改，会抛出 ConcurrentModificationExceptions 错误，这就是 fail-fast 机制，是 java 集合(Collection) 中的一种错误检测机制。对集合进行结构性修改时，modCount都会增加，在初始化迭代器时，modCount 的值会赋给 expectedModCount，在迭代的过程中，只要 modCount 改变了，int expectedModCount = modCount 等式就不成立了，迭代器检测到这一点，就会抛出错误：currentModificationExceptions。fail-fast 机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 bug。
</div>

<div style="line-height: 1.625em;margin-top:.5em;">
在我们常见的 java 集合中就可能出现 fail-fast 机制,比如 ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。
</div>
      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="单线程环境下 ArrayList 发生 fail-fast 例子" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public static void main(String[] args) {

   List<String> list = new ArrayList<>();
   
   for (int i = 0 ; i < 10 ; i++ ) {
        list.add(i + "");
   }

   Iterator<String> iterator = list.iterator();
   int i = 0 ;

   while(iterator.hasNext()) {
        
        if (i == 3) {
            // 遍历的同时删除元素, 这个时候，就会发生 fail-fast。
            // 既: ConcurrentModificationException
            list.remove(3);
        }

        System.out.println(iterator.next());
        i ++;
   }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="单线程环境下 HashMap 发生 fail-fast 例子" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
public static void main(String[] args) {
    
    Map<String, String> map = new HashMap<>();
    
    for (int i = 0 ; i < 10 ; i ++ ) {
        map.put(i+"", i+"");
    }

    Iterator<Entry<String, String>> it = map.entrySet().iterator();
    int i = 0;
    
    while (it.hasNext()) {
    
        if (i == 3) {
            // 遍历的同时删除元素, 这个时候，就会发生 fail-fast。
            // 既: ConcurrentModificationException
            map.remove(3+"");
        }
    
        Entry<String, String> entry = it.next();
        System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
        i++;
    }

}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="fail-fast 的原理" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<b style="color:red;">fail-fast 是如何抛出 ConcurrentModificationException 异常的，又是在什么情况下才会抛出?</b>
我们知道，对于集合如 list，map 类，我们都可以通过迭代器来遍历，而 Iterator 其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现 Iterator 并实现相关方法。这里我们就以 ArrayList 类为例。在 ArrayList 中，当调用 list.iterator() 时，其源码是：
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
// 当待用 list.iterator() 它会返回一个新的 Itr 类，
// 而 Itr 类是 ArrayList 的内部类，实现了 Iterator 接口，
public Iterator<E> iterator() {
    return new Itr();
}

// 下面是 Itr 类的源码
private class Itr implements Iterator<E> {

    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i >= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size && modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    /** 
     * expectedModCount 在整个迭代过程除了一开始赋予初始值 modCount 外，并没有再发生改变，
     * 所以可能发生改变的就只有 modCount，在关于 ArrayList 扩容机制的分析中，
     * 可以知道在 ArrayList 进行 add，remove，clear 等涉及到修改集合中的元素个数的操作时，
     * modCount 就会发生改变(modCount ++),
     * 所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使 modCount 发生变化，
     * 这样在 checkForComodification 方法中就会抛出 ConcurrentModificationException 异常。
     */
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }

}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="如何避免 fail-fast" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
在单线程的遍历过程中，如果要进行 remove 操作，可以调用迭代器的 remove 方法而不是集合类的 remove 方法。<br />
看看 ArrayList 中迭代器的 remove 方法的源码：
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="方法一" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
public void remove() {

    if (lastRet < 0)
        throw new IllegalStateException();

    checkForComodification();

    try {
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException ex) {
        throw new ConcurrentModificationException();
    }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
可以看到，该 remove 方法并不会修改 modCount 的值，并且不会对后面的遍历造成影响，因为该方法 remove 不能指定元素，只能 remove 当前遍历过的那个元素，所以调用该方法并不会发生 fail-fast 现象。该方法有局限性。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
public static void main(String[] args) {
    
    List<String> list = new ArrayList<>();
    
    for (int i = 0 ; i < 10 ; i++ ) {
        list.add(i + "");
    }

    Iterator<String> iterator = list.iterator();
    int i = 0 ;
    
    while (iterator.hasNext()) {
        if (i == 3) {
             iterator.remove(); //迭代器的remove()方法
        }
        System.out.println(iterator.next());
        i ++;
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="方法二" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
使用 java 并发包(java.util.concurrent) 中的类来代替 ArrayList 和 hashMap。
比如使用 CopyOnWriterArrayList 代替 ArrayList，<b style="color:green;">CopyOnWriterArrayList</b> 在使用上跟 ArrayList 几乎一样，CopyOnWriter 是写时复制的容器(COW)，在读写时是线程安全的。<b style="color:red;">该容器在对 add 和 remove 等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList 在迭代过程并不会发生 fail-fast 现象</b>。但 CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。
</div>
<div style="margin-top:.625em;">
对于 HashMap，可以使用 ConcurrentHashMap，ConcurrentHashMap 采用了锁机制，是线程安全的。在迭代方面，<b style="color:green;">ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变</b>。即迭代不会发生 fail-fast，但不保证获取的是最新的数据。
</div>
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[JDK1.8 中的 HashMap 的红黑树]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="为什么要引入红黑数（特殊的平衡二叉树）数据结构" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>由于在 JDK1.7 之前，ＨashMap 的数据结构为：数组 + 链表。数组相当于日常中用到的数据结构 Array. 用来确定 key-value 对所存储的位置。那么为什么又有链表结构？这个要从 HashMap 散列值生成来讲起。这个具体细节可参考相关文档即可。如果按照 Ｈash 值，通过 Hash 函数来确认桶位，会存在一个问题，就是 hash 冲突的问题，也就是相同的 key 可能会产生一样的 hash 值。</div>

<div style="margin-top:.625em;">
所以引入了链表来存储 hash 值一样的 key-value. 如果按照链表的方式存储，随着节点的增加数据会越来越多，这会导致<b style="color:red;">查询节点的时间复杂度会逐渐增加，平均时间复杂度Ｏ(n)</b>。 为了提高查询效率，故在 JDK１.8 中引入<b style="color:red;">改进了的方法红黑树。此数据结构的平均查询效率为Ｏ(long n)。</b><b style="color:green;">当链表节点长度超过８时，将链表转换为二叉树。</b></div>


<img width="550px" src="/images/java/red-black-tree.jpg" />

]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="红黑树的特性" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[


        <ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
            <li><b>什么时红黑树:</b> 红黑树（Red Black Tree）是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的: <b style="color:red;">它可以在O(log n)时间内做查找，插入和删除</b>，这里的 n 是树中元素的数目。</li>
            <li><b>红黑树特点:</b>
<ul style="margin-left: 2em;list-style-type: upper-roman;color:lightseagreen;margin-top: .3em;">
<li>性质1: 节点是红色或黑色。</li>
<li>性质2: 根节点是黑色。</li>
<li>性质3: 每个叶节点（NIL节点，空节点）是黑色的。</li>
<li>性质4: 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)</li>
<li>性质5: 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。</li>
</ul>
</li>
        </ul>



]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
//数据结构
static final class TreeNode<K,V> extends LinkedHashMap.Entry<K,V> {
    TreeNode<K,V> parent;  // red-black tree links
    TreeNode<K,V> left;
    TreeNode<K,V> right;
    TreeNode<K,V> prev;    // needed to unlink next upon deletion
    boolean red;　//红黑节点标识
    TreeNode(int hash, K key, V val, Node<K,V> next) {
    super(hash, key, val, next);
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="HashMap 引入红黑树时做了哪些改造" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
// 当链表节点长度超过８时，将链表转换为二叉树。
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {

    Node<K,V>[] tab; 
    Node<K,V> p; 
    int n, i;

    if ((tab = table) == null || (n = tab.length) == 0) {
        n = (tab = resize()).length;
    }
    
    if ((p = tab[i = (n - 1) & hash]) == null) {
        tab[i] = newNode(hash, key, value, null);
    } else {
        
        Node<K,V> e; K k;

        if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k)))) {
            e = p;
        } else if (p instanceof TreeNode) {
            e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);
        } else {

            for (int binCount = 0; ; ++binCount) {
        
                if ((e = p.next) == null) {
        
                    // 先将新节点插入到　p.next
                    p.next = newNode(hash, key, value, null);
        
                    //　如果长度链表长度超过８，则转换为二叉树
                    if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st

                        /**
                         * hash 是需要转化二叉树的 hash 值
                         */
                        treeifyBin(tab, hash);
                    break;
                }

                // 存在hash和key都一样的情况，则说明已经存在。直接跳出循环
                if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))
                    break;
                
                // 继续下一次循环
                p = e;
            }
        }

        if (e != null) { 
            // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        }

    }

    ++modCount;

    if (++size > threshold)
        resize();
    
    afterNodeInsertion(evict);
    
    return null;

}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="红黑树的具体实现方式" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>在JDK1.8 HashMap中，转换为红黑树大致分为三个步骤。</div>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>第一阶段：将链表转化为二叉树</li>
    <li>第二阶段：验证是否满足红黑树的五大特征</li>
    <li>第三阶段：对二叉树进行左右旋转操作</li>
</ul>

]]>
    </c:sourceContent>



    <c:sourceContent type="" title="将链表转化为二叉树" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
final void treeifyBin(Node<K,V>[] tab, int hash) {

    int n, index; Node<K,V> e;

    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY) {
        // 重新计算 hash段位，及table的索引位，第一个节点
        resize();
    } else if ((e = tab[index = (n - 1) & hash]) != null) {

        /************　双向链表　start ***************/
        //　hd头节点, tl尾节点
        TreeNode<K,V> hd = null, tl = null;
        do {
            // 循环所有节点
            TreeNode<K,V> p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else {
                p.prev = tl;
                tl.next = p;
            }
            tl = p;
        } while ((e = e.next) != null);// 循环下一个节点
        /************　双向链表　end ***************/


        // 前面仅仅转换为双向链表，treeify 才是转换红黑树的处理方法入口　
        // 第一个节点赋值为头节点,也就是根节点
        if ((tab[index] = hd) != null)
            // 将二叉树转换为红黑树
            hd.treeify(tab);
    }

}

]]>
    </c:sourceContent>



    <c:sourceContent type="" title="验证是否满足红黑树的五大特征" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
/**
 * 调用这个方法之前　也就是一个双向链表
 * 初始进入值为　this 头节点
 * 将双向链表转换为红黑树
 * 目标：查询　root　节点
 * @param tab
 */
final void treeify(Node<K,V>[] tab) {

    TreeNode<K,V> root = null;//root节点

    for (TreeNode<K,V> x = this, next; x != null; x = next) {

        next = (TreeNode<K,V>)x.next; //next　下一个节点
        x.left = x.right = null;//设置左右节点为空

        if (root == null) {//首次循环　root　== null
            x.parent = null; // 将根节点的父节点设置位空
            x.red = false; // 将根节点设置为 black
            root = x; //将x 设置为根节点
        } else {
            // 非根节点
            K k = x.key;//　获取当前循环节点ｋｅy
            int h = x.hash;// 获取当前节点ｈａｓｈ
            Class<?> kc = null;

            // 从根节点开始验证
            for (TreeNode<K,V> p = root;;) {
                int dir, ph;
                K pk = p.key;// 每个节点的ｋｅｙ
                if ((ph = p.hash) > h) //每个节点的ｈａｓh 与　外层循环的ｘ.hash做比较
                    dir = -1;// <0 ,沿左路径查找　-１
                else if (ph < h)// >0, 沿右路径查找　１
                    dir = 1;

                // 如果存在比较对象，则根据比较对象定义的comparable进行比较
                // 比较之后返回查询节点路径（左或右）
                else if ((kc == null &&
                        (kc = comparableClassFor(k)) == null) ||
                        (dir = compareComparables(kc, k, pk)) == 0)
                    dir = tieBreakOrder(k, pk);

                // p设置位ｘ的父节点　xp
                TreeNode<K,V> xp = p;

                //　如果父节点的左节点或右节点为空时，才进行插入操作
                if ((p = (dir <= 0) ? p.left : p.right) == null) {
                    // 将px设置为ｘ的父节点
                    x.parent = xp;
                    if (dir <= 0)
                        xp.left = x;
                    else
                        xp.right = x;
                    // 将二叉树转换位红黑树－正式转换红黑树
                    root = balanceInsertion(root, x);
                    break;
                }
            }
        }
    }

    moveRootToFront(tab, root);

}
]]>
    </c:sourceContent>



    <c:sourceContent type="" title="对二叉树进行左右旋转操作" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
/**
 * 转换二叉树为红黑树
 * @param root　根节点
 * @param x　执行的节点
 * @param <K>
 * @param <V>
 * @return
 */
static <K,V> TreeNode<K,V> balanceInsertion(TreeNode<K,V> root,
                                            TreeNode<K,V> x) {
    // 默认ｘ节点为红色节点
    x.red = true;

    /**
     * xp: 　 x的父节点
     * xpp: 　x父节点的父节点
     * xppl:　x父节点的父节点左子节点
     * xppr:　x父节点的父节点右子节点
     */
    for (TreeNode<K,V> xp, xpp, xppl, xppr;;) {

        // xp = x.parent
        // 如果x存在父节点，则说明目前只有一个节点,即root.根据
        // 红黑树的五大特征，根节点只能为黑色节点
        if ((xp = x.parent) == null) {
            x.red = false;
            return x;
        }

        else if (!xp.red || (xpp = xp.parent) == null) {
            // xpp = xp.parent
            // 直接查询的是根节点
            return root;
        }

        // xppl = xpp.left
        // x的父节点时左节点时
        if (xp == (xppl = xpp.left)) {

            // 验证是否需要旋转
            // xppr = xpp.right 存在右节点　且　右节点为红色
            if ((xppr = xpp.right) != null && xppr.red) {
                xppr.red = false; // xppr　设置位ｂlack
                xp.red = false; // xp　设置位ｂlack
                xpp.red = true; // xpp　设置位red
                x = xpp;// 将x赋值为父节点的父节点
            } else {
                if (x == xp.right) {

                    // 左旋转
                    root = rotateLeft(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }
                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;

                        // 右旋转
                        root = rotateRight(root, xpp);
                    }
                }
            }
        } else {
            // x的父节点右节点时
            // 验证是否需要旋转
            if (xppl != null && xppl.red) {
                xppl.red = false;
                xp.red = false;
                xpp.red = true;
                x = xpp;
            } else {
                if (x == xp.left) {
                    // 右旋转
                    root = rotateRight(root, x = xp);
                    xpp = (xp = x.parent) == null ? null : xp.parent;
                }

                if (xp != null) {
                    xp.red = false;
                    if (xpp != null) {
                        xpp.red = true;

                        // 左旋转
                        root = rotateLeft(root, xpp);
                    }
                }
            }
        }
    }
}
]]>
    </c:sourceContent>



    <c:sourceContent type="" title="左旋转" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
/**
 * 左旋转
 * @param root
 * @param p
 * @param <K>
 * @param <V>
 * @return
 */
static <K,V> TreeNode<K,V> rotateLeft(TreeNode<K,V> root,
                                      TreeNode<K,V> p) {
    TreeNode<K,V> r, pp, rl;
    if (p != null && (r = p.right) != null) {
        if ((rl = p.right = r.left) != null)
            rl.parent = p;
        if ((pp = r.parent = p.parent) == null)
            (root = r).red = false;
        else if (pp.left == p)
            pp.left = r;
        else
            pp.right = r;
        r.left = p;
        p.parent = r;
    }
    return root;
}
]]>
    </c:sourceContent>



    <c:sourceContent type="" title="右旋转" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
/**
 * 右旋转
 * @param root
 * @param p
 * @param <K>
 * @param <V>
 * @return
 */
static <K,V> TreeNode<K,V> rotateRight(TreeNode<K,V> root,

                                       TreeNode<K,V> p) {

    // l: p的左节点 　pp:p的父节点　lr:左右节点
    TreeNode<K,V> l, pp, lr;

    // 传入参数
    // root: 默认调用此方法前指定的root节点
    // p: root的父节点
    if (p != null && (l = p.left) != null) {

        if ((lr = p.left = l.right) != null)
            lr.parent = p;

        // 判断p的父节点是否为空
        if ((pp = l.parent = p.parent) == null)
            // 调整root的值
            (root = l).red = false;


        else if (pp.right == p)
            pp.right = l;
        else
            pp.left = l;

        //　将p调整为　root 节点的右节点
        l.right = p;

        //将l调整为p的parent
        p.parent = l;
    }

    return root;
}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>






  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Java中的<< 和 >> 和 >>> 详解]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<div style="line-height: 1.625em;font-size:2em;">
<b style="color:red;"><<</b> 表示左移移，不分正负数，低位补0；　
</div>
<pre>
注：以下数据类型默认为byte-8位 

左移时不管正负，低位补0

正数：<b style="color:green;font-weight:blue;font-size:1.3em;">r = 20 << 2</b>
　　20的二进制补码: 0001 0100
　　向左移动两位后: 0101 0000
　　　　   　结果: r = 80

负数：<b style="color:green;font-weight:blue;font-size:1.3em;">r = -20 << 2</b>
 -20 的二进制原码: 1001 0100
 -20 的二进制反码: 1110 1011
 -20 的二进制补码: 1110 1100
左移两位后的补码: 1011 0000
　 　　　　　反码: 1010 1111
　     　　　原码: 1101 0000
　　　　　　　结果: r = -80
</pre>



<div style="line-height: 1.625em;font-size:2em;margin-top:1em;">
<b style="color:red;">>></b> 表示右移，如果该数为正，则高位补0，若为负数，则高位补1；
</div>
<pre>
注：以下数据类型默认为byte-8位

正数：<b style="color:green;font-weight:blue;font-size:1.3em;">r = 20 >> 2</b>
　　   20的二进制补码：0001 0100
　　   向右移动两位后：0000 0101
　　　　   　　　结果：r = 5

负数：<b style="color:green;font-weight:blue;font-size:1.3em;">r = -20 >> 2</b>
　　-20 的二进制原码 ：1001 0100
　　-20 的二进制反码 ：1110 1011
　　-20 的二进制补码 ：1110 1100
　　  右移两位后的补码：1111 1011 
　　　　　　　　  反码：1111 1010
　　　　　　　　  原码：1000 0101
　　　　　　　　  结果：r = -5
</pre>



<div style="line-height: 1.625em;font-size:2em;margin-top:1em;">
<b style="color:red;">>>></b> 表示无符号右移，也叫逻辑右移，
<br />即若该数为正，则高位补0，而若该数为负数，则右移后高位同样补0
</div>
<pre>

正数：　<b style="color:green;font-weight:blue;font-size:1.3em;">r = 20 >>> 2</b>
　　　　的结果与 r = 20 >> 2 相同；

负数：　<b style="color:green;font-weight:blue;font-size:1.3em;">r = -20 >>> 2</b>
注：以下数据类型默认为 int 32位
　　-20源码：10000000 00000000 00000000 00010100
　　　　反码：11111111 11111111 11111111 11101011
　　　　补码：11111111 11111111 11111111 11101100
　　　　右移：00111111 11111111 11111111 11111011
　　　　结果：r = 1073741819
</pre>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>








  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[大O表示法]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
大O表示法使用大写字母O，可以认为其含义为"order of"（大约是）。我们可以使用大O法来描述线性查找使用了O(N)级时间，二分查找使用了O(log N)级时间，向一个无序数组中插入使用了O(1)，或常数级时间。
      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="下面的图总结了算法的运行时间：" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<table>
  <thead>
    <tr>
      <th>算法</th>
      <th>算法复杂度</th>
      <th>效率</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>线性查找</td>
      <td>O(N)</td>
      <td>还可以</td>
    </tr>
    <tr>
      <td>二分查找</td>
      <td>O(logN)</td>
      <td>良好</td>
    </tr>
    <tr>
      <td>无序数组的插入</td>
      <td>O(1)</td>
      <td>优秀</td>
    </tr>
    <tr>
      <td>有序数组的插入</td>
      <td>O(N)</td>
      <td>还可以</td>
    </tr>
    <tr>
      <td>无序数组的删除</td>
      <td>O(N)</td>
      <td>还可以</td>
    </tr>
    <tr>
      <td>有序数组的删除</td>
      <td>O(N)</td>
      <td>还可以</td>
    </tr>
    <tr>
      <td>冒泡排序</td>
      <td>O(N^2)</td>
      <td>很差</td>
    </tr>
  </tbody>
</table>

<div style="margin-top:1em;">
  通过图我们可以比较不同的大O值，O(1)是优秀，O(logN)是良好，O(N)是还可以，O(N^2)则很差了，比如冒泡排序。
下面我们通过例子来看一下二分查找法。就是我们玩过的游戏猜数字，设定一个数组大小，一个人心里想一个数，让另外一个人来猜。每次告诉他猜大了还是小了，直到猜中为止。看花了多少步。
</div>
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="二分查找法" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
/**
* 二分查找法
* @param search 要查找的数
* @param total 数组长度
*/
public void compute(int search,int total){

  // 设定的数组
  int[] num;
  if (!(total > 0 && search <= total && search >= 0)) {
    System.out.println("请输入大于等于0的正整数且查找的数不能大于数组里最大的数");
    return;
  } 

  num = new int[total];

  for (int i = 0 ; i < total; i++) {
    num[i] = i;
  }

  // 花了多少次找到
  int sum = 0;
  // 最小值
  int min = 0 ;
  // 最大值
  int max = total;
  // 当前猜的值
  int current;
  
  while (true) {
    
    sum ++ ;
    current = (min + max) / 2;
    
    // 打印猜的每个数
    System.out.println(current);
    if(num[current] == search) {
      System.out.println("找到了,花了" + sum + "次");
      return;
    } 

    // 如果猜的数大于选定的数，则把max设为猜的数，否则把min设为猜的数
    if(num[current] > search) {
      max = num[current] ;
    } else {
      min = num[current];
    }

  }

}
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>





</c:component>
