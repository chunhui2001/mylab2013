<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div>
hashCode 是 jdk 根据对象的地址或者字符串或者数字算出来的 int 类型的数值, 用于提高查询效率, 为不相等的对象生成不同整数结果可以提高哈希表的性能。
<br /><br />
若关键字为k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。
</div>
<pre>       
▪ 集合    ▪ 容器        
▪ 数组    ▪ 关联数组  ▪ Multimap  ▪ 集
▪ 多重集   ▪ 散列表   ▪ 树状数组  
▪ 列表    ▪ 链表    ▪ 队列    ▪ 堆栈
▪ 循环队列  ▪ 跳跃列表      
▪ 树     ▪ 二叉查找树 ▪ 堆 ▪ 线段树
▪ 红黑树   ▪ AVL树      
▪ 图     ▪ 有向无环图 ▪ 二元决策图 ▪ 无向图
</pre>
<div style="text-align: center;padding: 1em;font-size: 3em;color: crimson;padding-bottom: 0;">
散列表（Hash table，也叫哈希表）
</div>
]]>
  </c:abstract>




  <c:entry style="margin-top:2em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[著名的ELFhash算法]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
int ELFhash(char*key) {
    unsigned long h=0;
    while(*key) {
        h = (h << 4) + *key++;
        unsigned long g = h & 0xF0000000L;
        if(g)
            h ^= g >> 24;
        h &= ~g;
    }
    return h % MOD;
}
]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[
        <div>一些著名的 hash 算法: MD4、MD5、SHA-1 及其他</div>
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Hashcode 原理]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
将数据根据特定的算法映射到一个固定地址上 相当于一人一个座位(内存地址) 一人一个座位号(HashCode)的意思 一旦某个座位上有人 那么才和这个座位上的人eqauls比较 同一个人则不分配 不同则分配其他位置(散列) 如果这个座位上没人 则直接就坐
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;">
基于实现以上的需求 Java对eqauls和hashCode做了以下的规定：
        </div>

        <ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;color:red;">
            <li>如果 eqauls 为 true 则两者的 hashCode 一定相同</li>
            <li>如果两者的 hashCode() 相同 eqauls 不一定为 true；hashCode() 不同 那么 eqauls() 一定不为 true</li>
        </ul>

        <div style="margin-top:1em;line-height: 1.625em;">
            这里也就体现了hashCode对查询效率的优化：<br />
首先 hashcode() 对比的效率会高于 eqauls() 那么在上的上述的场景中 我们可以先通过 hashcode() 来对比 如果不一样就不需要 eqauls() 对比. 如果一样再通 eqauls() 对比增加可靠性, 这种方案既准确也高效.
        </div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="一致性" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[

在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 hashcode 比较时所用的信息没有被修改。
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="Hash算法在信息安全方面的应用" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[

<div style="margin-top:.625em;"><b>文件校验</b></div>
<div style="margin-top:.325em;">我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测出数据传输中的信道误码，但却不能防止对数据的恶意破坏。</div>
<div style="margin-top:.325em;">MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。</div>

<div style="margin-top:1.3em;"><b>数字签名</b></div>
<div style="margin-top:.325em;">Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。</div>

<div style="margin-top:1.3em;"><b>鉴权协议</b></div>
<div style="margin-top:.325em;">如下的鉴权协议又被称作挑战--认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</div>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[哈希表]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
散列表（Hash table，也叫哈希表），是根据关键码值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
给定表M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希 (Hash）表，函数 f(key) 为哈希(Hash) 函数。
</div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="基本概念" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<ul style="list-style-type: disc;margin-left: 1.5em;line-height: 1.425em;">
    <li style="margin-bottom: .3em;">
    若关键字为k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
    </li>
    <li style="margin-bottom: .3em;">
    对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。
    </li>
    <li style="margin-bottom: .3em;">
    若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。
    </li>
</ul>
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="生成 hashcode 常用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。<br />
实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：
</div>

<ul style="color:red;list-style-type: disc;margin-left: 1.5em;line-height: 1.3em;margin-top:.625em;">
    <li style="margin-bottom: .3em;">
    计算哈希函数所需时间
    </li>
    <li style="margin-bottom: .3em;">
    关键字的长度
    </li>
    <li style="margin-bottom: .3em;">
    哈希表的大小
    </li>
    <li style="margin-bottom: .3em;">
    关键字的分布情况
    </li>
    <li style="margin-bottom: .3em;">
    记录的查找频率
    </li>
</ul>



<ul style="list-style-type: decimal;margin-left: 2.2em;line-height: 1.625em;margin-top:1.625em;">
    <li style="margin-bottom: .3em;">
    <b>直接寻址法：</b><br />取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。
    </li>
    <li style="margin-bottom: .3em;">
    <b>数字分析法：</b><br />分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
    </li>
    <li style="margin-bottom: .3em;">
        <div>
            <b>平方取中法：</b><br />当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。<br />这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。<b>例：</b>
        </div>
        <div>
            <div style="color:brown;margin-top:.3em;">我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示: </div>
            <table style="color: cadetblue;font-size: 2em;margin: .5em 0;line-height: 1.3em;">
                <tbody>
                    <tr style="padding: 0;margin: 0;">
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;font-weight: normal;">K</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">E</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;padding-right:1.325em;">Y</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">A</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">B</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;font-weight: normal;">11</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">05</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">25</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">01</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">02</td>
                    </tr>
                </tbody>
            </table>

            <table style="color:blueviolet !important">
                <thead>
                    <tr style="padding: 0;margin: 0;">
                        <th style="padding: 0;margin: 0;padding-right:1.325em;color:blueviolet !important">关键字</th>
                        <th style="padding: 0;margin: 0;padding-right:2.325em;color:blueviolet !important">内部编码</th>
                        <th style="padding: 0;margin: 0;padding-right:2.325em;color:blueviolet !important">内部编码的平方值</th>
                        <th style="padding: 0;margin: 0;padding-right:1.325em;color:blueviolet !important">H(k)关键字的哈希地址</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="padding: 0;margin: 0;">
                        <td style="padding: 0;margin: 0;font-weight: normal;">KEYA</td>
                        <td style="padding: 0;margin: 0;">11052501</td>
                        <td style="padding: 0;margin: 0;">122157778355001</td>
                        <td style="padding: 0;margin: 0;">778</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">KYAB</td>
                        <td style="padding: 0;margin: 0;">11250102</td>
                        <td style="padding: 0;margin: 0;">126564795010404</td>
                        <td style="padding: 0;margin: 0;">795</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">AKEY</td>
                        <td style="padding: 0;margin: 0;">01110525</td>
                        <td style="padding: 0;margin: 0;">001233265775625</td>
                        <td style="padding: 0;margin: 0;">265</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">BKEY</td>
                        <td style="padding: 0;margin: 0;">02110525</td>
                        <td style="padding: 0;margin: 0;">004454315775625</td>
                        <td style="padding: 0;margin: 0;">315</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </li>
    <li style="margin-bottom: .3em;">
    <b>折叠法：</b><br />将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
    </li>
    <li style="margin-bottom: .3em;">
     <b>随机数法：</b><br />选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。
    </li>
    <li style="margin-bottom: .3em;">
     <b>除留余数法：</b><br />取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词
    </li>
</ul>


]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="处理冲突" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<h3 style="color:gray;">
参考: http://blog.sina.com.cn/s/blog_6fd335bb0100v1ks.html
</h3>
<ul style="list-style-type: decimal;margin-left: 2.5em;line-height: 1.425em;">
    <li style="margin-bottom: .3em;">
        <div>
            开放寻址法：Hi=(H(key) + di) MOD m,i=1,2，…，k(k<=m-1），其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：
        </div>
        <div>
            <ul style="list-style-type: disc;margin: .5em 1.5em;color: crimson;">
                <li>di=1,2,3，…，m-1，称线性探测再散列；</li>
                <li>di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k<=m/2）称二次探测再散列；</li>
                <li>di=伪随机数序列，称伪随机探测再散列。</li>
            </ul>
        </div>
    </li>
    <li style="margin-bottom: .3em;">
    再散列法：Hi=RHi(key),i=1,2，…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
    </li>
    <li style="margin-bottom: .3em;">
    链地址法（拉链法）
    </li>
    <li style="margin-bottom: .3em;">
    建立一个公共溢出区
    </li>
</ul>
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>






</c:component>
