<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div>
hashCode 是 jdk 根据对象的地址或者字符串或者数字算出来的 int 类型的数值, 用于提高查询效率, 为不相等的对象生成不同整数结果可以提高哈希表的性能。
<br /><br />
若关键字为k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。
</div>
<pre>       
▪ 集合    ▪ 容器        
▪ 数组    ▪ 关联数组  ▪ Multimap  ▪ 集
▪ 多重集   ▪ 散列表   ▪ 树状数组  
▪ 列表    ▪ 链表    ▪ 队列    ▪ 堆栈
▪ 循环队列  ▪ 跳跃列表      
▪ 树     ▪ 二叉查找树 ▪ 堆 ▪ 线段树
▪ 红黑树   ▪ AVL树      
▪ 图     ▪ 有向无环图 ▪ 二元决策图 ▪ 无向图
</pre>
<div style="text-align: center;padding: 1em;font-size: 3em;color: crimson;padding-bottom: 0;">
散列表（Hash table，也叫哈希表）
</div>
]]>
  </c:abstract>




  <c:entry style="margin-top:2em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[著名的ELFhash算法]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
int ELFhash(char*key) {
    unsigned long h=0;
    while(*key) {
        h = (h << 4) + *key++;
        unsigned long g = h & 0xF0000000L;
        if(g)
            h ^= g >> 24;
        h &= ~g;
    }
    return h % MOD;
}
]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[
        <div>一些著名的 hash 算法: MD4、MD5、SHA-1 及其他</div>
        ]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Hashcode 原理]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        <div style="line-height: 1.625em;">
将数据根据特定的算法映射到一个固定地址上 相当于一人一个座位(内存地址) 一人一个座位号(HashCode)的意思 一旦某个座位上有人 那么才和这个座位上的人eqauls比较 同一个人则不分配 不同则分配其他位置(散列) 如果这个座位上没人 则直接就坐
     </div>
        <div style="line-height: 1.625em;margin-top:.5em;">
基于实现以上的需求 Java 对 eqauls() 和 hashCode() 做了以下的规定：
        </div>

        <ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;color:red;">
            <li>如果 eqauls 为 true 则两者的 hashCode 一定相同</li>
            <li>如果两者的 hashCode() 相同 eqauls 不一定为 true；hashCode() 不同 那么 eqauls() 一定不为 true</li>
        </ul>

        <div style="margin-top:1em;line-height: 1.625em;">
            这里体现了 hashCode() 对查询效率的优化：<br />
首先 hashcode() 对比的效率会高于 eqauls() 那么在上的上述的场景中 我们可以先通过 hashcode() 来对比 如果不一样就不需要 eqauls() 对比. 如果一样再通 eqauls() 对比增加可靠性, 这种方案既准确也高效.
        </div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="一致性" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[

在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 hashcode 比较时所用的信息没有被修改。
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="Hash算法在信息安全方面的应用" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[

<div style="margin-top:.625em;"><b>文件校验</b></div>
<div style="margin-top:.325em;">我们比较熟悉的校验算法有奇偶校验和CRC校验，这2种校验并没有抗数据篡改的能力，它们一定程度上能检测出数据传输中的信道误码，但却不能防止对数据的恶意破坏。</div>
<div style="margin-top:.325em;">MD5 Hash算法的"数字指纹"特性，使它成为目前应用最广泛的一种文件完整性校验和（Checksum）算法，不少Unix系统有提供计算md5 checksum的命令。</div>

<div style="margin-top:1.3em;"><b>数字签名</b></div>
<div style="margin-top:.325em;">Hash 算法也是现代密码体系中的一个重要组成部分。由于非对称算法的运算速度较慢，所以在数字签名协议中，单向散列函数扮演了一个重要的角色。对 Hash 值，又称"数字摘要"进行数字签名，在统计上可以认为与对文件本身进行数字签名是等效的。而且这样的协议还有其他的优点。</div>

<div style="margin-top:1.3em;"><b>鉴权协议</b></div>
<div style="margin-top:.325em;">如下的鉴权协议又被称作挑战--认证模式：在传输信道是可被侦听，但不可被篡改的情况下，这是一种简单而安全的方法。</div>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[哈希表]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
散列表（Hash table，也叫哈希表），是根据关键码值 (Key value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
给定表M，存在函数 f(key)，对任意给定的关键字值 key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希 (Hash）表，函数 f(key) 为哈希(Hash) 函数。
</div>
      ]]></c:desc1>
    </c:desc>



    <c:sourceContent type="html" title="基本概念" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<ul style="list-style-type: disc;margin-left: 1.5em;line-height: 1.425em;">
    <li style="margin-bottom: .3em;">
    若关键字为k，则其值存放在 f(k) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系f为散列函数，按这个思想建立的表为散列表。
    </li>
    <li style="margin-bottom: .3em;">
    对不同的关键字可能得到同一散列地址，即k1≠k2，而f(k1)=f(k2)，这种现象称为冲突（英语：Collision）。具有相同函数值的关键字对该散列函数来说称做同义词。综上所述，根据散列函数f(k)和处理冲突的方法将一组关键字映射到一个有限的连续的地址集（区间）上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。
    </li>
    <li style="margin-bottom: .3em;">
    若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数（Uniform Hash function），这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。
    </li>
</ul>
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="生成 hashcode 常用方法" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<div>
散列函数能使对一个数据序列的访问过程更加迅速有效，通过散列函数，数据元素将被更快地定位。<br />
实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：
</div>

<ul style="color:red;list-style-type: disc;margin-left: 1.5em;line-height: 1.3em;margin-top:.625em;">
    <li style="margin-bottom: .3em;">
    计算哈希函数所需时间
    </li>
    <li style="margin-bottom: .3em;">
    关键字的长度
    </li>
    <li style="margin-bottom: .3em;">
    哈希表的大小
    </li>
    <li style="margin-bottom: .3em;">
    关键字的分布情况
    </li>
    <li style="margin-bottom: .3em;">
    记录的查找频率
    </li>
</ul>



<ul style="list-style-type: decimal;margin-left: 2.2em;line-height: 1.625em;margin-top:1.625em;">
    <li style="margin-bottom: .3em;">
    <b>直接寻址法：</b><br />取关键字或关键字的某个线性函数值为散列地址。即H(key)=key或H(key) = a·key + b，其中a和b为常数（这种散列函数叫做自身函数）。若其中H(key）中已经有值了，就往下一个找，直到H(key）中没有值了，就放进去。
    </li>
    <li style="margin-bottom: .3em;">
    <b>数字分析法：</b><br />分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。
    </li>
    <li style="margin-bottom: .3em;">
        <div>
            <b>平方取中法：</b><br />当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。<br />这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。<b>例：</b>
        </div>
        <div>
            <div style="color:brown;margin-top:.3em;">我们把英文字母在字母表中的位置序号作为该英文字母的内部编码。例如K的内部编码为11，E的内部编码为05，Y的内部编码为25，A的内部编码为01, B的内部编码为02。由此组成关键字“KEYA”的内部代码为11052501，同理我们可以得到关键字“KYAB”、“AKEY”、“BKEY”的内部编码。之后对关键字进行平方运算后，取出第7到第9位作为该关键字哈希地址，如下图所示: </div>
            <table style="color: cadetblue;font-size: 2em;margin: .5em 0;line-height: 1.3em;">
                <tbody>
                    <tr style="padding: 0;margin: 0;">
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;font-weight: normal;">K</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">E</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;padding-right:1.325em;">Y</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">A</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">B</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;font-weight: normal;">11</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">05</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">25</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">01</td>
                        <td style="padding: 0;margin: 0;padding-right:1.325em;text-align: center;">02</td>
                    </tr>
                </tbody>
            </table>

            <table style="color:blueviolet !important">
                <thead>
                    <tr style="padding: 0;margin: 0;">
                        <th style="padding: 0;margin: 0;padding-right:1.325em;color:blueviolet !important">关键字</th>
                        <th style="padding: 0;margin: 0;padding-right:2.325em;color:blueviolet !important">内部编码</th>
                        <th style="padding: 0;margin: 0;padding-right:2.325em;color:blueviolet !important">内部编码的平方值</th>
                        <th style="padding: 0;margin: 0;padding-right:1.325em;color:blueviolet !important">H(k)关键字的哈希地址</th>
                    </tr>
                </thead>
                <tbody>
                    <tr style="padding: 0;margin: 0;">
                        <td style="padding: 0;margin: 0;font-weight: normal;">KEYA</td>
                        <td style="padding: 0;margin: 0;">11052501</td>
                        <td style="padding: 0;margin: 0;">122157778355001</td>
                        <td style="padding: 0;margin: 0;">778</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">KYAB</td>
                        <td style="padding: 0;margin: 0;">11250102</td>
                        <td style="padding: 0;margin: 0;">126564795010404</td>
                        <td style="padding: 0;margin: 0;">795</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">AKEY</td>
                        <td style="padding: 0;margin: 0;">01110525</td>
                        <td style="padding: 0;margin: 0;">001233265775625</td>
                        <td style="padding: 0;margin: 0;">265</td>
                    </tr>
                    <tr>
                        <td style="padding: 0;margin: 0;font-weight: normal;">BKEY</td>
                        <td style="padding: 0;margin: 0;">02110525</td>
                        <td style="padding: 0;margin: 0;">004454315775625</td>
                        <td style="padding: 0;margin: 0;">315</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </li>
    <li style="margin-bottom: .3em;">
    <b>折叠法：</b><br />将关键字分割成位数相同的几部分，最后一部分位数可以不同，然后取这几部分的叠加和（去除进位）作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。
    </li>
    <li style="margin-bottom: .3em;">
     <b>随机数法：</b><br />选择一随机函数，取关键字的随机值作为散列地址，通常用于关键字长度不同的场合。
    </li>
    <li style="margin-bottom: .3em;">
     <b>除留余数法：</b><br />取关键字被某个不大于散列表表长m的数p除后所得的余数为散列地址。即 H(key) = key MOD p,p<=m。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对p的选择很重要，一般取素数或m，若p选的不好，容易产生同义词
    </li>
</ul>


]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="处理冲突" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
<h3 style="color:gray;">
参考: http://blog.sina.com.cn/s/blog_6fd335bb0100v1ks.html
</h3>
<ul style="list-style-type: decimal;margin-left: 2.5em;line-height: 1.425em;">
    <li style="margin-bottom: .3em;">
        <div>
            开放寻址法：Hi=(H(key) + di) MOD m,i=1,2，…，k(k<=m-1），其中H(key）为散列函数，m为散列表长，di为增量序列，可有下列三种取法：
        </div>
        <div>
            <ul style="list-style-type: disc;margin: .5em 1.5em;color: crimson;">
                <li>di=1,2,3，…，m-1，称线性探测再散列；</li>
                <li>di=1^2,-1^2,2^2,-2^2，⑶^2，…，±（k)^2,(k<=m/2）称二次探测再散列；</li>
                <li>di=伪随机数序列，称伪随机探测再散列。</li>
            </ul>
        </div>
    </li>
    <li style="margin-bottom: .3em;">
    再散列法：Hi=RHi(key),i=1,2，…，k RHi均是不同的散列函数，即在同义词产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
    </li>
    <li style="margin-bottom: .3em;">
    链地址法（拉链法）
    </li>
    <li style="margin-bottom: .3em;">
    建立一个公共溢出区
    </li>
</ul>
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[java 集合 HashMap、HashTable、HashSet]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
HashMap 基于 hashing 原理，通过 put() 和 get() 方法储存和获取对象。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
put() 方法: 它调用键对象的 hashCode() 方法来计算 hashcode 值，系统根据 hashcode 值决定该元素在 bucket 位置。如果两个对象 key 的 hashcode 返回值相同，那他们的存储位置相同，如果这两个 Entry 的 key 通过 equals 比较返回 true，新添加 Entry 的 value 将覆盖集合中原有 Entry 的 value，但 key 不会覆盖；如果这两个 Entry 的 key 通过 equals 比较返回 false，新添加的 Entry 将与集合中原有 Entry 形成 Entry 链，而且新添加 Entry 位于 Entry 链的头部。put() 源码如下: 
</div>
      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="put() 源码" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public V put(K paramK, V paramV) {

    // 如果key为空，调用putForNullKey方法
    if (paramK == null)
        return putForNullKey(paramV);

    // 根据key的keyCode计算Hash值
    int i = hash(paramK.hashCode());

    // 搜索指定hash值的对应在table中的索引
    int j = indexFor(i, this.table.length);

    // 链地址法
    // 如果j索引处的Entry不为空，通过循环遍历localEntry元素的下一个元素
    for (Entry localEntry = this.table[j]; localEntry != null; localEntry = localEntry.next) {
        Object localObject1;
    
        // 找到指定key与放入key相等(hash值相同，通过equals比较返回true)
        if ((localEntry.hash == i)
                && ((((localObject1 = localEntry.key) == paramK) || (paramK
                        .equals(localObject1))))) {
            Object localObject2 = localEntry.value;
            localEntry.value = paramV;
            localEntry.recordAccess(this);
            return localObject2;
        }
    }

    // 如果j索引Entry为null，此处没有Entry
    this.modCount += 1;
    
    // 将key、value添加到i索引处
    addEntry(i, paramK, paramV, j);
    return null;

}

void addEntry(int paramInt1, K paramK, V paramV, int paramInt2) {
    //获取指定bucketIndex索引处Entry
    Entry localEntry = this.table[paramInt2];
    //将新创建的Entry放入bucketIndex索引处，并让新的Entry指向原来的Entry
    this.table[paramInt2] = new Entry(paramInt1, paramK, paramV, localEntry);
    //如果map中的key-value数量超过
    if (this.size++ >= this.threshold)
    //table对象的长度扩充到2倍
        resize(2 * this.table.length);
}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="get源码()" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
get()方法: 当 HashMap 的每个 bucket 里存储的 Entry 只是单个 Entry，即没有通过指针产生 Entry 链时，此时 HashMap 具有最好的性能。当程序通过 key 取出对应 value 时，系统先计算出该 key 的 hashCode() 返回值，再根据该 hashCode() 返回值找出该 key 在 table 数组中的索引，然后取出该索引处的 Entry，最后返回该 key 对应的 value 值。get 源码如下:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.5em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
// 从代码看出，HashMap 的每个 bucket 里只有一个Entry，HashMap 可以根据索引快速取出该 bucket 里的 Entry。
// 在发生 Hash 冲突的情况下，单个 bucket 里存储的不是一个Entry，
// 而是一个 Entry 链，系统只能按顺序遍历每个 Entry，直到找到想搜索的 Entry。
public V get(Object paramObject) {

    // 如果 key 为空，调用 getForNullKey() 取出对应的 value
    if (paramObject == null)
        return getForNullKey();

    // 根据 key 的 hashCode 值计算 hash 码
    int i = hash(paramObject.hashCode());
    
    // 直接取出 table 数组中指定索引处的值
    Entry localEntry = this.table[indexFor(i, this.table.length)];
    
    while (localEntry != null) {

        Object localObject;
    
        // 如果该 Entry 的 key 与被搜索 key 相同
        if ((localEntry.hash == i)
                && ((((localObject = localEntry.key) == paramObject) || (paramObject
                        .equals(localObject)))))
            return localEntry.value;
    
        // 搜索该 Entry 链的下一个
        localEntry = localEntry.next;
    
    }

    return null;

}
]]>
    </c:sourceContent>




    <c:sourceContent type="html" title="HashMap 有两个参数影响其性能：" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<ul style="margin-left: 2em;list-style-type: decimal;margin-top: .3em;">
    <li style="margin-bottom:.3em;">初始容量和加载因子。默认初始容量是16，加载因子是0.75。容量是哈希表中桶(Entry数组)的数量，初始容量只是哈希表在创建时的容量。加载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度。<b>当哈希表中的条目数超出了加载因子与当前容量的乘积时，通过调用rehash 方法将容量翻倍。</b></li>
    <li style="margin-bottom:.3em;">加载因子过高虽然减少了空间开销，但同时也增加了查询成本<b style="color:red;">（加载因子是表示Hsah表中元素的填满的程度.若:加载因子越大,填满的元素越多,好处是,空间利用率高了,但:冲突的机会加大了.反之,加载因子越小,填满的元素越少,好处是:冲突的机会减小了,但:空间浪费多了）</b>。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地降低 rehash 操作次数。如果初始容量大于最大条目数除以加载因子(实际上就是最大条目数小于初始容量*加载因子)，则不会发生 rehash 操作。</li>
    <li style="margin-bottom:.3em;">HashMap 存放的元素越来越多，到达临界值 (阀值)threshold 时，就要对 Entry 数组扩容，这是 Java 集合类框架最大的魅力，<b style="color:green;">HashMap 在扩容时，新数组的容量将是原来的2倍，由于容量发生变化，原有的每个元素需要重新计算 bucketIndex，再存放到新数组中去，也就是所谓的 rehash</b>。<b>HashMap 默认初始容量16，加载因子0.75，也就是说<b style="color:blue;">最多能放16*0.75=12个元素，当put第13个时，HashMap 将发生 rehash</b>，rehash 的一系列处理比较影响性能，所以当我们需要向 HashMap 存放较多元素时，最好指定合适的初始容量和加载因子，否则 HashMap 默认只能存12个元素，将会发生多次 rehash 操作。</b></li>
</ul>

]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="HashMap 和 Hashtable 的区别" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
    HashMap 和 Hashtable 都实现了 Map 接口，主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap 几乎可以等价于 Hashtable，除了 HashMap 是非 synchronized 的，并可以接受 null(HashMap 可以接受为 null 的键值(key)和值(value)，而 Hashtable 则不行)。
</div>

<div style="margin-top:.625em;">
    HashMap 是非 synchronized，而 Hashtable 是 synchronized，意味着 Hashtable 是线程安全的，多个线程可以共享一个 Hashtable；而多个线程是不能共享 HashMap的。Java 5 提供了 ConcurrentHashMap，它是 HashTable 的替代，比 HashTable 的扩展性更好。另一个区别是 HashMap 的迭代器(Iterator)是 <b style="color:red;">fail-fast</b> 迭代器，而 Hashtable 是 <b style="color:red;">enumerator迭代器</b>。HashMap 可以通过下面的语句进行同步：Map m = Collections.synchronizeMap(hashMap);
</div>

]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="HashMap 和 HashSet 的区别" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<div>
HashSet 实现了 Set 接口，它不允许集合中有重复的值，HashMap 实现了 Map 接口，Map 接口对键值对进行映射。
HashSet 扩展了 HashMap, 所以底层还是用到 map 存储，存储实现同 map 一致，HashMap 储存键值，HashSet 存储对象。
分类: java 基础
</div>

]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>









  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[java 中的 fail-fast(快速失败) 机制]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="line-height: 1.625em;">
fail-fast 机制，即快速失败机制，是java集合(Collection) 中的一种错误检测机制。当在迭代集合的过程中该集合在结构上发生改变的时候，就有可能会发生fail-fast，即抛出ConcurrentModificationException异常。fail-fast 机制并不保证在不同步的修改下一定会抛出异常，它只是尽最大努力去抛出，所以这种机制一般仅用于检测 bug。
</div>
<div style="line-height: 1.625em;margin-top:.5em;">
在我们常见的 java 集合中就可能出现 fail-fast 机制,比如 ArrayList，HashMap。在多线程和单线程环境下都有可能出现快速失败。
</div>
      ]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="单线程环境下 ArrayList 发生 fail-fast 例子" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
                     <![CDATA[
public static void main(String[] args) {

   List<String> list = new ArrayList<>();
   
   for (int i = 0 ; i < 10 ; i++ ) {
        list.add(i + "");
   }

   Iterator<String> iterator = list.iterator();
   int i = 0 ;

   while(iterator.hasNext()) {
        
        if (i == 3) {
            // 遍历的同时删除元素, 这个时候，就会发生 fail-fast。
            // 既: ConcurrentModificationException
            list.remove(3);
        }

        System.out.println(iterator.next());
        i ++;
   }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="单线程环境下 HashMap 发生 fail-fast 例子" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
public static void main(String[] args) {
    
    Map<String, String> map = new HashMap<>();
    
    for (int i = 0 ; i < 10 ; i ++ ) {
        map.put(i+"", i+"");
    }

    Iterator<Entry<String, String>> it = map.entrySet().iterator();
    int i = 0;
    
    while (it.hasNext()) {
    
        if (i == 3) {
            // 遍历的同时删除元素, 这个时候，就会发生 fail-fast。
            // 既: ConcurrentModificationException
            map.remove(3+"");
        }
    
        Entry<String, String> entry = it.next();
        System.out.println("key= " + entry.getKey() + " and value= " + entry.getValue());
        i++;
    }

}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="fail-fast 的原理" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
<b style="color:red;">fail-fast 是如何抛出 ConcurrentModificationException 异常的，又是在什么情况下才会抛出?</b>
我们知道，对于集合如 list，map 类，我们都可以通过迭代器来遍历，而 Iterator 其实只是一个接口，具体的实现还是要看具体的集合类中的内部类去实现 Iterator 并实现相关方法。这里我们就以 ArrayList 类为例。在 ArrayList 中，当调用 list.iterator() 时，其源码是：
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
// 当待用 list.iterator() 它会返回一个新的 Itr 类，
// 而 Itr 类是 ArrayList 的内部类，实现了 Iterator 接口，
public Iterator<E> iterator() {
    return new Itr();
}

// 下面是 Itr 类的源码
private class Itr implements Iterator<E> {

    int cursor;       // index of next element to return
    int lastRet = -1; // index of last element returned; -1 if no such
    int expectedModCount = modCount;

    public boolean hasNext() {
        return cursor != size;
    }

    @SuppressWarnings("unchecked")
    public E next() {
        checkForComodification();
        int i = cursor;
        if (i >= size)
            throw new NoSuchElementException();
        Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length)
            throw new ConcurrentModificationException();
        cursor = i + 1;
        return (E) elementData[lastRet = i];
    }

    public void remove() {
        if (lastRet < 0)
            throw new IllegalStateException();
        checkForComodification();

        try {
            ArrayList.this.remove(lastRet);
            cursor = lastRet;
            lastRet = -1;
            expectedModCount = modCount;
        } catch (IndexOutOfBoundsException ex) {
            throw new ConcurrentModificationException();
        }
    }

    @Override
    @SuppressWarnings("unchecked")
    public void forEachRemaining(Consumer<? super E> consumer) {
        Objects.requireNonNull(consumer);
        final int size = ArrayList.this.size;
        int i = cursor;
        if (i >= size) {
            return;
        }
        final Object[] elementData = ArrayList.this.elementData;
        if (i >= elementData.length) {
            throw new ConcurrentModificationException();
        }
        while (i != size && modCount == expectedModCount) {
            consumer.accept((E) elementData[i++]);
        }
        // update once at end of iteration to reduce heap write traffic
        cursor = i;
        lastRet = i - 1;
        checkForComodification();
    }

    /** 
     * expectedModCount 在整个迭代过程除了一开始赋予初始值 modCount 外，并没有再发生改变，
     * 所以可能发生改变的就只有 modCount，在关于 ArrayList 扩容机制的分析中，
     * 可以知道在 ArrayList 进行 add，remove，clear 等涉及到修改集合中的元素个数的操作时，
     * modCount 就会发生改变(modCount ++),
     * 所以当另一个线程(并发修改)或者同一个线程遍历过程中，调用相关方法使集合的个数发生改变，就会使 modCount 发生变化，
     * 这样在 checkForComodification 方法中就会抛出 ConcurrentModificationException 异常。
     */
    final void checkForComodification() {
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
    }

}
]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="如何避免 fail-fast" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
在单线程的遍历过程中，如果要进行 remove 操作，可以调用迭代器的 remove 方法而不是集合类的 remove 方法。<br />
看看 ArrayList 中迭代器的 remove 方法的源码：
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="方法一" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
public void remove() {

    if (lastRet < 0)
        throw new IllegalStateException();

    checkForComodification();

    try {
        ArrayList.this.remove(lastRet);
        cursor = lastRet;
        lastRet = -1;
        expectedModCount = modCount;
    } catch (IndexOutOfBoundsException ex) {
        throw new ConcurrentModificationException();
    }
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
可以看到，该 remove 方法并不会修改 modCount 的值，并且不会对后面的遍历造成影响，因为该方法 remove 不能指定元素，只能 remove 当前遍历过的那个元素，所以调用该方法并不会发生 fail-fast 现象。该方法有局限性。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.3em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.5em;font-family:monospace;">
                     <![CDATA[
public static void main(String[] args) {
    
    List<String> list = new ArrayList<>();
    
    for (int i = 0 ; i < 10 ; i++ ) {
        list.add(i + "");
    }

    Iterator<String> iterator = list.iterator();
    int i = 0 ;
    
    while (iterator.hasNext()) {
        if (i == 3) {
             iterator.remove(); //迭代器的remove()方法
        }
        System.out.println(iterator.next());
        i ++;
    }

}
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="方法二" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
使用 java 并发包(java.util.concurrent) 中的类来代替 ArrayList 和 hashMap。
比如使用 CopyOnWriterArrayList 代替 ArrayList，<b style="color:green;">CopyOnWriterArrayList</b> 在使用上跟 ArrayList 几乎一样，CopyOnWriter 是写时复制的容器(COW)，在读写时是线程安全的。<b style="color:red;">该容器在对 add 和 remove 等操作时，并不是在原数组上进行修改，而是将原数组拷贝一份，在新数组上进行修改，待完成后，才将指向旧数组的引用指向新数组，所以对于 CopyOnWriterArrayList 在迭代过程并不会发生 fail-fast 现象</b>。但 CopyOnWrite 容器只能保证数据的最终一致性，不能保证数据的实时一致性。
</div>
<div style="margin-top:.625em;">
对于 HashMap，可以使用 ConcurrentHashMap，ConcurrentHashMap 采用了锁机制，是线程安全的。在迭代方面，<b style="color:green;">ConcurrentHashMap 使用了一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时 new 新的数据从而不影响原有的数据 ，iterator 完成后再将头指针替换为新的数据 ，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变</b>。即迭代不会发生 fail-fast，但不保证获取的是最新的数据。
</div>
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



</c:component>
