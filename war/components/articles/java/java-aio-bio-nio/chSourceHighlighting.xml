<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[

<div>
    Java IO 体系看起来类很多，感觉很复杂，但其实是 IO 涉及的因素太多了。在设计 IO 相关的类时，编写者也不是从同一个方面考虑的，所以会给人一种很乱的感觉，并且还有设计模式的使用，更加难以使用这些 IO 类，所以特地对 Java 的 IO 做一个总结。
</div>
<div style="margin-top:.625em;">
IO 类设计出来，肯定是为了解决 IO 相关的操作的，想一想哪里会有 IO 操作？网络、磁盘。网络操作相关的类是在 java.net 包下，不在本文的总结范围内。提到磁盘，你可能会想到文件，文件操作在 IO 中是比较典型的操作。在 Java 中引入了 “流” 的概念，它表示任何有能力产生数据源或有能力接收数据源的对象。数据源可以想象成水源，海水、河水、湖水、一杯水等等。数据传输可以想象为水的运输，古代有用桶运水，用竹管运水的，现在有钢管运水，不同的运输方式对应不同的运输特性。
</div>

<div style="margin-top:.625em;">
    <img style="margin:auto;width:100%;" src="/images/java/java-io.webp" />
<div>

<div style="margin-top:.625em;">
在高性能的I/O设计中，有两个比较著名的模式Reactor和Proactor模式，其中Reactor模式用于同步I/O，而Proactor运用于异步I/O操作。
</div>

<div style="margin-top:.625em;">
在比较这两个模式之前，我们首先的搞明白几个概念，什么是<b style="color:blue;">阻塞和非阻塞</b>，什么是<b style="color:green;">同步和异步</b>, 同步和异步是针对应用程序和内核的交互而言的，<b style="color:green;">同步指的是用户进程触发IO操作并等待或者轮询的去查看IO操作是否就绪，而异步是指用户进程触发IO操作以后便开始做自己的事情，而当IO操作已经完成的时候会得到IO完成的通知</b>。而<b style="color:blue;">阻塞和非阻塞是针对于进程在访问数据的时候，根据IO操作的就绪状态来采取的不同方式</b>，说白了是一种读取或者写入操作函数的实现方式，阻塞方式下读取或者写入函数将一直等待，而非阻塞方式下，读取或者写入函数会立即返回一个状态值。
</div>


<h4 style="color:red;margin-top:1em;">一般来说I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO</h4>

<div style="margin-top:.625em;">
▪▪ <b>同步阻塞IO:</b> 在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！
</div>

<div style="margin-top:.625em;">
▪▪ <b>同步非阻塞IO:</b> 在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。
</div>

<div style="margin-top:.625em;">
▪▪ <b>异步阻塞IO:</b> 此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过 select 系统调用来完成的，而 select 函数本身的实现方式是阻塞的，而采用 select 函数有个好处就是它可以同时监听多个文件句柄，从而提高系统的并发性！
</div>

<div style="margin-top:.625em;">
▪▪ <b>异步非阻塞IO:</b> 在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。 
</div>

]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Java &mdash; IO 类]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
       
      ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[


<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>文件（file）：FileInputStream、FileOutputStream、FileReader、FileWriter</li>
    <li>字节数组（byte[]）：ByteArrayInputStream、ByteArrayOutputStream</li>
    <li>字符数组（char[]）：CharArrayReader、CharArrayWriter</li>
    <li>管道操作：PipedInputStream、PipedOutputStream、PipedReader、PipedWriter</li>
    <li>基本数据类型：DataInputStream、DataOutputStream</li>
    <li>缓冲操作：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter</li>
    <li>打印：PrintStream、PrintWriter</li>
    <li>对象序列化反序列化：ObjectInputStream、ObjectOutputStream</li>
    <li>转换：InputStreamReader、OutputStreWriter</li>
    <li style="text-decoration:line-through;">字符串（String）Java8中已废弃：StringBufferInputStream、StringBufferOutputStream、StringReader、StringWriter</li>
</ul>
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[AIO、BIO、NIO 区别]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<h4 style="color:green;">Java对BIO、NIO、AIO的支持</h4>
<div style="margin-top:.625em;">
  <b>Java BIO:</b> 同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。
</div>
<div style="margin-top:.625em;">
  <b>Java NIO:</b> 同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。
</div>
<div style="margin-top:.625em;">
  <b>Java AIO(NIO.2):</b> 异步非阻塞，服务器实现模式为一个有效请求一个线程，客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。
</div>

<h4 style="color:green;margin-top:1.5em;">BIO、NIO、AIO适用场景分析</h4>
<div style="margin-top:.625em;">
  BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。
</div>
<div style="margin-top:.625em;">
  NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。
</div>
<div style="margin-top:.625em;">
  AIO方式使用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。
</div>

      ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="bio 同步阻塞" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
ServerSocket serverSocket = new ServerSocket(10101);

while (true) {
   // 获取一个套接字(阻塞) 
   final Socket socket = serverSocket.accept();

   // 开个线程, 处理连接的 clint socket... new

   // 此时接受客户端连接的线程(请求线程), 一直处于阻塞状态, 等待客户端连接(阻塞),
   // 每个 client 连接后分配一个线程 (用户线程(进程线程))(同步) --> 同步阻塞
   // ... 
}

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div style="margin-top:.625em;">
在JDK1.4出来之前，我们建立网络连接的时候采用BIO模式，需要先在服务端启动一个ServerSocket，然后在客户端启动Socket来与服务端进行通信，默认情况下服务端需要对每个请求建立一堆线程等待请求，而客户端发送请求后，先咨询服务端是否有线程响应，如果没有则会一直等待或者遭到拒绝请求，如果有的话，客户端会线程会等待请求结束后才继续执行。
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="nio 同步非阻塞" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

SocketChannel serverChannel = SocketChannel.open();

selector = Selector.open();
serverChannel.socket().bind(new InetSocketAddress(8080));
serverChannel.configureBlocking(false);
serverChannel.register(selector, SelectionKey.OP_ACCEPT);

// selector.selectedKeys() 一直轮询着, 如果事件处理很费时间, 依旧是阻塞的
// 也需要要开线程去异步处理, 保证请求的主线程不被阻塞, 达到非阻塞目的, 
// 所以它可以被设计成阻塞的, 也可以被设计成非阻塞的, 他也是基于进程线程的读写,
// 所以属于同步 --> 综上可得到他是同步非阻塞
Set<SelectionKey> sleSet = selector.selectedKeys();

while (true) {

   int count = selector.select();
   Iterator<SelectionKey> iterator = sleSet.iterator();

   while (iterator.hasNext()) {

       SelectionKey selectionKey = iterator.next();
       Buffer buffer = ByteBuffer.allocate(1024);

       if(selectionKey.isAcceptable()) {
           ServerSocketChannel socketChannel = (ServerSocketChannel) selectionKey.channel();
           // 处理逻辑,开线程

       } else if(selectionKey.isReadable()){

       } else if (selectionKey.isWritable()){

       }

       iterator.remove();
   }
}

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
  NIO本身是基于事件驱动思想来完成的，其主要想解决的是BIO的大并发问题：在使用同步I/O的网络应用中，如果要同时处理多个客户端请求，或是在客户端要同时和多个服务器进行通讯，就必须使用多线程来处理。也就是说，将每一个客户端请求分配给一个线程来单独处理。这样做虽然可以达到我们的要求，但同时又会带来另外一个问题。由于每创建一个线程，就要为这个线程分配一定的内存空间（也叫工作存储器），而且操作系统本身也对线程的总数有一定的限制。如果客户端的请求过多，服务端程序可能会因为不堪重负而拒绝客户端的请求，甚至服务器可能会因此而瘫痪。
</div>
<div style="margin-top:.625em;">
  NIO基于Reactor，当socket有流可读或可写入socket时，操作系统会相应的通知引用程序进行处理，应用再将流读取到缓冲区或写入操作系统。也就是说，这个时候，已经<em style="font-size:1.125em;color:red;">不是一个连接就要对应一个处理线程了，而是有效的请求对应一个线程，当连接没有数据时，是没有工作线程来处理的</em>。
</div>
<div style="margin-top:.625em;">
  <em style="font-size:1.125em;color:blue;">BIO与NIO一个比较重要的不同，是我们使用BIO的时候往往会引入多线程，每个连接一个单独的线程；而NIO则是使用单线程或者只使用少量的多线程，多个连接共用一个线程。</em>
</div>
<div style="margin-top:.625em;">
  NIO的最重要的地方是当一个连接创建后，不需要对应一个线程，这个连接会被注册到多路复用器上面，所以所有的连接只需要一个线程就可以搞定，当这个线程中的多路复用器进行轮询的时候，发现连接上有请求的话，才开启一个线程进行处理，也就是一个请求一个线程模式。
</div>
<div style="margin-top:.625em;">
  在NIO的处理方式中，当一个请求来的话，开启线程进行处理，可能会等待后端应用的资源(JDBC连接等)，其实这个线程就被阻塞了，当并发上来的话，还是会有BIO一样的问题。
</div>
<div style="margin-top:.625em;">
  HTTP/1.1出现后，有了Http长连接，这样除了超时和指明特定关闭的http header外，这个链接是一直打开的状态的，这样在NIO处理中可以进一步的进化，在后端资源中可以实现资源池或者队列，<em style="font-size:1.125em;color:green;">当请求来的时候，开启的线程把请求和请求数据传送给后端资源池或者队列里面就返回，并且在全局的地方保持住这个现场(哪个连接的哪个请求等)，这样前面的线程还是可以去接受其他的请求，而后端的应用的处理只需要执行队列里面的就可以了，这样请求处理和后端应用是异步的. 当后端处理完，到全局地方得到现场并产生响应，这个就实现了异步处理</em>。
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="aio 异步非阻塞" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
// 基于事件的回调, future/callback, 大概的过程是操作系统内核线程处理完, 通知进程线程拿到结果, 
// 期间进程线程可以做其他的事情, 这样做的好处是充分利用操作系统的并发能力.

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
  与NIO不同，当进行读写操作时，只须直接调用API的read或write方法即可。这两种方法均为异步的，对于读操作而言，当有流可读取时，操作系统会将可读的流传入read方法的缓冲区，并通知应用程序；对于写操作而言，当操作系统将write方法传递的流写入完毕时，操作系统主动通知应用程序。即可以理解为，read/write方法都是异步的，完成后会主动调用回调函数。  在JDK1.7中，这部分内容被称作NIO.2，主要在java.nio.channels包下增加了下面四个异步通道：
</div>
<pre style="font-size:.625em;padding:1em;background-color:beige;color:green;margin-top:.325em;border:solid 1px cadetblue;">
  AsynchronousSocketChannel
  AsynchronousServerSocketChannel
  AsynchronousFileChannel
  AsynchronousDatagramChannel
</pre>
]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title><![CDATA[Java NIO && Netty 的 epoll实现]]></c:title>
    <c:desc>
      <c:desc1> <![CDATA[

<h4 style="color:green;">Java NIO 根据操作系统不同， 针对 nio 中的 Selector 有不同的实现</h4>
<ul style="list-style-type:disc;margin-left:1.5em;margin-top:.625em;line-height:1.425em;">
    <li style="margin-bottom:.3em;">macosx: KQueueSelectorProvider</li>
    <li style="margin-bottom:.3em;">solaris: DevPollSelectorProvider</li>
    <li style="margin-bottom:.3em;">Linux: EPollSelectorProvider (Linux kernels >= 2.6) 或 PollSelectorProvider</li>
    <li style="margin-bottom:.3em;">windows: WindowsSelectorProvider</li>
</ul>
<div style="margin-top:.625em;">
  所以毋须特别指定，Oracle jdk 会自动选择合适的 Selector。如果想设置特定的 Selector，可以属性：
</div>
<pre style="font-size:.625em;padding:1em;background-color:beige;color:green;margin-top:.625em;border:solid 1px cadetblue;">
  -Djava.nio.channels.spi.SelectorProvider=sun.nio.ch.EPollSelectorProvider
</pre>
      ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Netty" id="sourceContent1" 
                     style="background-color:white;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
  自4.0.16起, Netty为Linux通过JNI的方式提供了 native socket transport. 使用 native socket transport 很简单，只需将相应的类替换即可。
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[

<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-transport-native-epoll</artifactId>
    <version>${project.version}</version>
    <classifier>${os.detected.classifier}</classifer>
</dependency>

NioEventLoopGroup → EpollEventLoopGroup
NioEventLoop → EpollEventLoop
NioServerSocketChannel → EpollServerSocketChannel
NioSocketChannel → EpollSocketChannel

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
既然如上面所说，Oracle JDK 在 Linux 已经默认使用 epoll 方式，为什么 netty 还要提供一个基于 epoll 的实现呢？这是 stackoverflow(https://stackoverflow.com/questions/23465401/why-native-epoll-support-is-introduced-in-netty) 上的一个问题。Netty 的核心开发者 Norman Maurer 这么说的：
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" 
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
Netty 的 epoll transport 使用 epoll edge-triggered 而 java 的 nio 使用 level-triggered。另外 netty epoll transport 暴露了更多的 nio 没有的配置参数，如 TCP_CORK, SO_REUSEADDR 等等
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="高效的 epoll" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:blue;font-size:1.5em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
epoll 是 Linux 下，高效的多路复用技术，也是 Linux 下高性能网络服务器的关键技术。通过网络 socket 链接，把远程资源加载到本地内存中。如何来优化这个性能呢？
</div>
<div style="margin-top:.625em;">
poll 和 select 相对之前的AIO有很大的提高，但是由于需要监视着 “等待队列” 与及 “阻塞进程”，性能还是未完全释放。这个时候CPU又被别的进程给抢走，上下文切换的性能又被消耗。</div>
<div style="margin-top:.625em;">
select 要进行遍历，才能感知到那个socket来了数据，因此select只能一个一个遍历，来唤醒每个socketChanel。</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="epoll 原理" id="sourceContent1" 
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:blue;font-size:1.5em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
                     <![CDATA[
<div>
epoll 监视多个 socket, 改进了 select 维护等待队列和阻塞进程进一步改进。把这两步动作给拆分开来。
</div>
<div style="margin-top:.325em;">
epoll_ctl 维护等待队列</div>
<div style="margin-top:.325em;">
epoll_wait 阻塞队列</div>
<div style="margin-top:.325em;">
调用 epoll_create 方法，另外会创建一个 eventpoll 对象。</div>
<div style="margin-top:.325em;">
eventpoll 维护着就绪列表，如果有 socket 来数据，就把 socket 添加到就绪列表。</div>
<div style="margin-top:.325em;">
阻塞进程收到就绪列表的回调，既可以开始 socket 数据传输工作。</div>
<div style="margin-top:.325em;">
  <img style="float:left;margin-right:1em;" src="/images/java/nio-eventpoll.webp"></img>
  <img style="float:left;border:dashed 1px orangered;" src="/images/java/eventpoll.webp"></img>
  <div class="clear"></div>
</div>
]]>
    </c:sourceContent>





    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


</c:component>
