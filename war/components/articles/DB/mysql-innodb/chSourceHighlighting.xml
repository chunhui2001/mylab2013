<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<b>
mongorestore 	-d <em style="font-weight:bold;color: forestgreen;">db_name_here</em> &lt;path to the backup&gt; 
<br />
<br />
mongodump -h 172.27.5.71:27017 -d <em style="font-weight:bold;color: forestgreen;">db_name_here</em> -o Documents/ -u rebateprd1 -p pwd_here
</b>
]]>
  </c:abstract>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL参数配置</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="服务器参数" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
32G内存、4个CPU,每个CPU 8核。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="/etc/my.cnf" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
[mysqld]
basedir = /usr/local/mysql
datadir = /usr/local/mysql/data
server_id = 1
socket = /usr/local/mysql/mysql.sock
log-error = /usr/local/mysql/data/mysqld.err
slow_query_log = 1
slow_query_log_file=/usr/local/mysql/data/slow-query.log
long_query_time = 1
log-queries-not-using-indexes
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 

##### bin log 相关配置 #####
log-bin=/usr/local/mysql/data/mysqlbin
### 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存，提高记录bin-log的效率。
binlog_cache_size = 2M 
### 表示的是binlog能够使用的最大cache内存大小
max_binlog_cache_size = 8M
### 指定binlog日志文件的大小。不能将变量设置为大于1G或小于4096字节。默认值为1G.
### 在导入大容量的 sql 文件时，建议关闭，sql_log_bin，否则硬盘扛不住，而且建议定期做删除。
max_binlog_size = 512M
### 定义了mysql清除过期日志的时间
expire_logs_days = 7

###### 连接请求的变量 ######
### MySQL的最大连接数，如果服务器的并发连接请求量较大，建议调高此值，以增加并行连接数量，
### 当然这建立在机器能支撑的情况下，因为如果连接数越多，MySQL回味每个连接提供连接缓冲区，就会开销越多的内存，
### 所以要适当调整该值，不能盲目提高设值。
### 数值过小经常会出现ERROR 1040：Too mant connetcions错误，可以通过
### mysql> show status like ‘connections'；
### 通配符来查看当前状态的连接数量（试图连接到MySQL（不管是否连接成功）的连接数），以定夺该值的大小。
### show variadles like ‘max_connections'最大连接数
### show variables like ‘max_used_connection'相应连接数
### max_used_connection/max_connections*100%（理想值约等于85%）
max_connections = 1024
### MySQL 能够暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，他就会起作用。
### 如果MySQL的连接数据达到 max_connections时，新的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈数量即 back_log，
### 如果等待连接的数量超过back_log，将不被接受连接资源。
back_log = 128
### 指的是关闭一个交互的连接之前所需要等待的秒数。
### 如果设置太小，那么连接关闭的很快，从而使一些持久的连接不起作用
### 如果设置太大容易造成连接打开时间过长，在show processlist时，能够看到太多的sleep状态的连接，从而造成too many connections错误。
### 一般希望wait_timeuot尽可能的低
wait_timeout = 60
### 指的是MySQL再关闭一个非交互的连接之前所需要等待的秒数。
interactive_timeout = 7200

###### 缓冲区变量 ######
### key_buffer_size 只对 MAISAM 表起作用。
### 指定索引缓冲区的大小，他决定索引的处理速度，尤其是索引读的速度。
### 通过检查状态值 key_read_requests和key_reads，可以知道key_buffer_size设置是否合理。
### 比例key_reads/key_read_requests应该尽可能的低，至少是1：100，1：1000更好
### 上述状态值可以使用show status like ‘key_read%'获得
### 未命中缓存的概率：key_cache_miss_rate = key_reads/key_read_requests*100%
### 如何调整key_buffer_size的值
### 默认的配置数时8388608（8M），主机有4G内存可以调优值为268435456（256M）
key_buffer_size = 256M
### 查询缓存大小，MySQL将查询结果存放在缓冲区中，今后对同样的select语句（区分大小写），将直接从缓冲区中读取结果。
### 通过 show ststus like ‘Qcache%' 可以知道query_cache_size的设置是否合理
### Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示过大，则说明Query Cache中的内存碎片较多了。
### 当一个表被更新后，和他相关的cache block将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。
### 可以用 flush query cache 语句来清空 free blocks。
### Qcache_free_memory:Query Cache 中目前剩余的内存大小。
### 通过这个参数我们可以较为准确的观察当前系统中的Query Cache内存大小是否足够，是需要增多还是过多了。
### Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询能缓存的效果。数字越大缓存效果越理想。
### Qcache_inserts：表示多少次未命中而插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，
### 执行查询处理后把结果insert带查询缓存中。这样的情况次数越多，表示查询缓存 应用到的比较少，效果也就不理想。
### Qcache_lowmen_prunes：多少条Query因为内存不足而被清除出Query Cache，
### 通过Qcache_lowmem_prunes和Qcache_free_memory 相互结合，能够更清楚的了解到我们系统中Query Cache的内存大小是否真的足够，
### 是否非常频繁的出现因为内存不足而有Query被换出。这个数字最好是长时间来看，如果这个数字在不断增长，就表示可能碎片化非常严重，或者内存很少。
### Qcache_queries_in_cache：当前Query Cache 中cache的Query数量
### Qcache_total_blocks：当前Query Cache中block的数量
### Query Cache的限制
### a）所有子查询中的外部查询SQL 不能被Cache：
### b）在p'rocedure，function以及trigger中的Query不能被Cache
### c）包含其他很多每次执行可能得到不一样的结果的函数的Query不能被Cache
query_cache_size = 256M
### 缓存类型，决定缓存什么样子的查询
### 0：OFF 相当于禁用了
### 1：ON 将缓存所有结果，除非你的select语句使用了SQL_NO_CACHE禁用了查询缓存
### 2：DENAND  则只缓存select语句中通过SQL_CACHE指定需要缓存的查询。
query_cache_type = 1
### 超出此大小的查询将不被缓存
query_cache_limit = 50M 
### 是一个MySQL中与安全有关的计数器值，他负责阻止过多尝试失败的客户端以防止暴力破解密码的情况，当超过指定次数，
### MySQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hotos命令清空此host的相关信息。（与性能并无太大的关系）
max_connect_errors = 20
### 每个需要排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY 或 GROUP BY操作
### sort_buffer_size是一个connection级的参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。
### 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统的内存资源。
### 例如：500个连接将会消耗500*sort_buffer_size(2M)=1G
sort_buffer_size = 2M
### 根据配置文件限制server接受的数据包大小。
max_allowed_packet = 32M
### 用于表示关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。
join_buffer_size = 2M
### 服务器线程缓存，这个值表示可以重新利用保存在缓存中的线程数量，当断开连接时，那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁
### 如果线程重新被请求，那么请求将从缓存中读取，如果缓存中是空的或者是新的请求，这个线程将被重新请求，那么这个线程将被重新创建，
### 如果有很多新的线程，增加这个值可以改善系统性能，通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。
### 设置规则如下：1G内存配置为8，2G内存为16
### Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程。
### Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。
### Threads_created：代表最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，
### 说明MySQL服务器一直在创建线程，这也比较消耗资源，可以适当增加配置文件中 thread_cache_size 值
### Threads_running：代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。
thread_cache_size = 200 (200/32G内存)

##### 配置Innodb的几个变量 #####
### innodb_buffer_pool_size 的作用相当于 key_buffer_size 对于MyISAM表的作用一样。
### Innodb 使用该参数指定大小的内存来缓冲数据和索引。最大可以把该值设置成物理内存的 80%。
innodb_buffer_pool_size = 2048M
### 主要控制了 innodb 将 log buffer 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为0，1，2.
### 该值对插入数据的速度影响非常大，
### 设置为2时插入10000条记录只需要两秒，
### 设置为0时只需要一秒，
### 设置为1时，则需要229秒。
### 因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅度提高速度。
innodb_flush_log_at_trx_commit = 1
### 此参数确定日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。
innodb_log_buffer_size = 32M
### 此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能。
innodb_log_file_size = 128M
### 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3
innodb_log_files_in_group = 3
### 此参数用来设置innodb线程的并发数，默认值为0表示不被限制，
### 若要设置则与服务器的CPU核心数相同或是CPU的核心数的2倍。
### 按照上边的公式: 4个CPU,每个CPU为8核. 则: (4C*8核) * 2 =64
innodb_thread_concurrency = 0
### MySQL 的随机读（查询操作）缓冲区大小
### 当按任意顺序读取行时（例如，按照排序顺序），将分配到一个随机都缓冲区。
### 进行排序查询时，MySQL会首先扫描一遍该缓冲区，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。
### 但是MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存消耗过大。
read_rnd_buffer_size = 16M
### 批量插入数据缓存大小，可以有效的提高插入效率，默认为8M
bulk_insert_buffer_size = 64M
### MySQL 读入缓冲区大小。对表进行顺序扫描的请求将分配到一个读入缓冲区MySQL会为他分配一段内存缓冲区
read_buffer_size = 1M

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


</c:component>
