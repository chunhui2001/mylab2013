<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[

]]>
  </c:abstract>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL参数配置</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="服务器参数" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
32G内存、4个CPU,每个CPU 8核。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="/etc/my.cnf" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
[mysqld]
basedir = /usr/local/mysql
datadir = /usr/local/mysql/data
server_id = 1
socket = /usr/local/mysql/mysql.sock
log-error = /usr/local/mysql/data/mysqld.err
slow_query_log = 1
slow_query_log_file=/usr/local/mysql/data/slow-query.log
long_query_time = 1
log-queries-not-using-indexes
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 

##### bin log 相关配置 #####
log-bin=/usr/local/mysql/data/mysqlbin
### 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存，提高记录bin-log的效率。
binlog_cache_size = 2M 
### 表示的是binlog能够使用的最大cache内存大小
max_binlog_cache_size = 8M
### 指定binlog日志文件的大小。不能将变量设置为大于1G或小于4096字节。默认值为1G.
### 在导入大容量的 sql 文件时，建议关闭，sql_log_bin，否则硬盘扛不住，而且建议定期做删除。
max_binlog_size = 512M
### 定义了mysql清除过期日志的时间
expire_logs_days = 7

###### 连接请求的变量 ######
### MySQL的最大连接数，如果服务器的并发连接请求量较大，建议调高此值，以增加并行连接数量，
### 当然这建立在机器能支撑的情况下，因为如果连接数越多，MySQL回味每个连接提供连接缓冲区，就会开销越多的内存，
### 所以要适当调整该值，不能盲目提高设值。
### 数值过小经常会出现ERROR 1040：Too mant connetcions错误，可以通过
### mysql> show status like ‘connections'；
### 通配符来查看当前状态的连接数量（试图连接到MySQL（不管是否连接成功）的连接数），以定夺该值的大小。
### show variadles like ‘max_connections'最大连接数
### show variables like ‘max_used_connection'相应连接数
### max_used_connection/max_connections*100%（理想值约等于85%）
max_connections = 1024
### MySQL 能够暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，他就会起作用。
### 如果MySQL的连接数据达到 max_connections时，新的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈数量即 back_log，
### 如果等待连接的数量超过back_log，将不被接受连接资源。
back_log = 128
### 指的是关闭一个交互的连接之前所需要等待的秒数。
### 如果设置太小，那么连接关闭的很快，从而使一些持久的连接不起作用
### 如果设置太大容易造成连接打开时间过长，在show processlist时，能够看到太多的sleep状态的连接，从而造成too many connections错误。
### 一般希望wait_timeuot尽可能的低
wait_timeout = 60
### 指的是MySQL再关闭一个非交互的连接之前所需要等待的秒数。
interactive_timeout = 7200

###### 缓冲区变量 ######
### key_buffer_size 只对 MAISAM 表起作用。
### 指定索引缓冲区的大小，他决定索引的处理速度，尤其是索引读的速度。
### 通过检查状态值 key_read_requests和key_reads，可以知道key_buffer_size设置是否合理。
### 比例key_reads/key_read_requests应该尽可能的低，至少是1：100，1：1000更好
### 上述状态值可以使用show status like ‘key_read%'获得
### 未命中缓存的概率：key_cache_miss_rate = key_reads/key_read_requests*100%
### 如何调整key_buffer_size的值
### 默认的配置数时8388608（8M），主机有4G内存可以调优值为268435456（256M）
key_buffer_size = 256M
### 查询缓存大小，MySQL将查询结果存放在缓冲区中，今后对同样的select语句（区分大小写），将直接从缓冲区中读取结果。
### 通过 show ststus like ‘Qcache%' 可以知道query_cache_size的设置是否合理
### Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示过大，则说明Query Cache中的内存碎片较多了。
### 当一个表被更新后，和他相关的cache block将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。
### 可以用 flush query cache 语句来清空 free blocks。
### Qcache_free_memory:Query Cache 中目前剩余的内存大小。
### 通过这个参数我们可以较为准确的观察当前系统中的Query Cache内存大小是否足够，是需要增多还是过多了。
### Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询能缓存的效果。数字越大缓存效果越理想。
### Qcache_inserts：表示多少次未命中而插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，
### 执行查询处理后把结果insert带查询缓存中。这样的情况次数越多，表示查询缓存 应用到的比较少，效果也就不理想。
### Qcache_lowmen_prunes：多少条Query因为内存不足而被清除出Query Cache，
### 通过Qcache_lowmem_prunes和Qcache_free_memory 相互结合，能够更清楚的了解到我们系统中Query Cache的内存大小是否真的足够，
### 是否非常频繁的出现因为内存不足而有Query被换出。这个数字最好是长时间来看，如果这个数字在不断增长，就表示可能碎片化非常严重，或者内存很少。
### Qcache_queries_in_cache：当前Query Cache 中cache的Query数量
### Qcache_total_blocks：当前Query Cache中block的数量
### Query Cache的限制
### a）所有子查询中的外部查询SQL 不能被Cache：
### b）在p'rocedure，function以及trigger中的Query不能被Cache
### c）包含其他很多每次执行可能得到不一样的结果的函数的Query不能被Cache
query_cache_size = 256M
### 缓存类型，决定缓存什么样子的查询
### 0：OFF 相当于禁用了
### 1：ON 将缓存所有结果，除非你的select语句使用了SQL_NO_CACHE禁用了查询缓存
### 2：DENAND  则只缓存select语句中通过SQL_CACHE指定需要缓存的查询。
query_cache_type = 1
### 超出此大小的查询将不被缓存
query_cache_limit = 50M 
### 是一个MySQL中与安全有关的计数器值，他负责阻止过多尝试失败的客户端以防止暴力破解密码的情况，当超过指定次数，
### MySQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hotos命令清空此host的相关信息。（与性能并无太大的关系）
max_connect_errors = 20
### 每个需要排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY 或 GROUP BY操作
### sort_buffer_size是一个connection级的参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。
### 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统的内存资源。
### 例如：500个连接将会消耗500*sort_buffer_size(2M)=1G
sort_buffer_size = 2M
### 根据配置文件限制server接受的数据包大小。
max_allowed_packet = 32M
### 用于表示关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。
join_buffer_size = 2M
### 服务器线程缓存，这个值表示可以重新利用保存在缓存中的线程数量，当断开连接时，那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁
### 如果线程重新被请求，那么请求将从缓存中读取，如果缓存中是空的或者是新的请求，这个线程将被重新请求，那么这个线程将被重新创建，
### 如果有很多新的线程，增加这个值可以改善系统性能，通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。
### 设置规则如下：1G内存配置为8，2G内存为16
### Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程。
### Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。
### Threads_created：代表最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，
### 说明MySQL服务器一直在创建线程，这也比较消耗资源，可以适当增加配置文件中 thread_cache_size 值
### Threads_running：代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。
thread_cache_size = 200 (200/32G内存)

##### 配置Innodb的几个变量 #####
### innodb_buffer_pool_size 的作用相当于 key_buffer_size 对于MyISAM表的作用一样。
### Innodb 使用该参数指定大小的内存来缓冲数据和索引。最大可以把该值设置成物理内存的 80%。
innodb_buffer_pool_size = 2048M
### 主要控制了 innodb 将 log buffer 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为0，1，2.
### 该值对插入数据的速度影响非常大，
### 设置为2时插入10000条记录只需要两秒，
### 设置为0时只需要一秒，
### 设置为1时，则需要229秒。
### 因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅度提高速度。
innodb_flush_log_at_trx_commit = 1
### 此参数确定日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。
innodb_log_buffer_size = 32M
### 此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能。
innodb_log_file_size = 128M
### 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3
innodb_log_files_in_group = 3
### 此参数用来设置innodb线程的并发数，默认值为0表示不被限制，
### 若要设置则与服务器的CPU核心数相同或是CPU的核心数的2倍。
### 按照上边的公式: 4个CPU,每个CPU为8核. 则: (4C*8核) * 2 =64
innodb_thread_concurrency = 0
### MySQL 的随机读（查询操作）缓冲区大小
### 当按任意顺序读取行时（例如，按照排序顺序），将分配到一个随机都缓冲区。
### 进行排序查询时，MySQL会首先扫描一遍该缓冲区，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。
### 但是MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存消耗过大。
read_rnd_buffer_size = 16M
### 批量插入数据缓存大小，可以有效的提高插入效率，默认为8M
bulk_insert_buffer_size = 64M
### MySQL 读入缓冲区大小。对表进行顺序扫描的请求将分配到一个读入缓冲区MySQL会为他分配一段内存缓冲区
read_buffer_size = 1M

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL 的架构</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  <img width="280px" src="/images/mysql/mysql-structrue.jpg" />
</div>

<div style="margin-top:.625em;">
  最上层用于连接、线程处理的部分并不是 MySQL 『发明』的，很多服务都有类似的组成部分；
  <br /> 第二层中包含了大多数 MySQL 的核心服务，包括了对 SQL 的解析、分析、优化和缓存等功能，存储过程、触发器和视图都是在这里实现的；
  <br /> 第三层是 MySQL 中真正负责数据的存储和提取的存储引擎，例如：InnoDB、MyISAM 等，文中对存储引擎的介绍都是对 InnoDB 实现的分析。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="数据的存储" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）：
</div>

<div style="margin-top:.625em;">
  <img width="100%" src="/images/mysql/mysql-innodb-engine.png" />
</div>

<div style="margin-top:.625em;">
  同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 innodb_page_size 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同：
</div>

<div style="margin-top:.625em;">
  <img width="480px" src="/images/mysql/innodb-page.jpg" />
</div>

<div style="margin-top:.625em;">
  从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="如何存储表" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。
</div>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>.frm</c:title>
    <c:desc>
      <c:desc1> <![CDATA[无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
CREATE TABLE test_frm (
   column1 CHAR(5),
   column2 INTEGER
);
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  当我们使用上面的代码创建表时，会在磁盘上的 datadir文件夹中生成一个 test_frm.frm 的文件，这个文件中就包含了表结构相关的信息：
</div>
<div style="margin-top:.325em;">
  <img width="580px" src="/images/mysql/mysql-frm.jpg" />
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>.ibd</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。
</div>
<div style="margin-top:.625em;">
当打开 innodb_file_per_table 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。
</div>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="show table status like 't1'\G;" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 2
 Avg_row_length: 8192
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2016-01-11 05:04:28
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="如何存储记录" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，<b>每个 16KB 大小的页中可以存放 2-200 行的记录。InnoDB 存储引擎提供了 compact(5.1后的默认格式)和 redundant 两个格式来存放行记录数据。redundant 格式是为了兼容之前的版本而保留。</b>
</div>
<div style="margin-top:.625em;">
  当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：
</div>
<div style="margin-top:.325em;">
  <img width="280px" src="/images/mysql/innodb-store.jpg" />
</div>
<div style="margin-top:.625em;">
  Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。
</div>
<div style="margin-top:.625em;">
  两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-antelope.jpg" />
</div>
<div style="margin-top:.625em;">
  Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。
</div>
<div style="margin-top:.625em;">
  Compact 行记录是在 MySQL 5.0 时被引入的，其设计目标是能高效存放数据。简单来说，如果一个页中存放的行数据越多，其性能就越高。
</div>


    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="行溢出数据" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  当 InnoDB 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。
</div>
<div style="margin-top:.625em;">
  当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-blob.jpg" />
</div>
<div style="margin-top:.625em;">
  但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-store-compressed.jpg" />
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="数据页结构" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-store-page.jpg" />
</div>
<div style="margin-top:.625em;">
  每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。
</div>
<div style="margin-top:.625em;">
  在页的头部和尾部之间就是用户记录和空闲空间了，每一个数据页中都包含 Infimum 和 Supremum 这两个虚拟的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-infimum.jpg" />
</div>
<div style="margin-top:.625em;">
  User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record 这一指针控制的。
</div>
<div style="margin-top:.625em;">
  B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、 next_record 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。
</div>
<div style="margin-top:.625em;">
  InnoDB 存储引擎中对数据的存储是一个非常复杂的话题，这一节中也只是对表、行记录以及页面的存储进行一定的分析和介绍，虽然作者相信这部分知识对于大部分开发者已经足够了，但是想要真正消化这部分内容还需要很多的努力和实践。
</div>

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


</c:component>
