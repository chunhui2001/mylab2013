<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[

]]>
  </c:abstract>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL参数配置</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="服务器参数" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
32G内存、4个CPU,每个CPU 8核。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="/etc/my.cnf" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
[mysqld]
basedir = /usr/local/mysql
datadir = /usr/local/mysql/data
server_id = 1
socket = /usr/local/mysql/mysql.sock
log-error = /usr/local/mysql/data/mysqld.err
slow_query_log = 1
slow_query_log_file=/usr/local/mysql/data/slow-query.log
long_query_time = 1
log-queries-not-using-indexes
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 

##### bin log 相关配置 #####
log-bin=/usr/local/mysql/data/mysqlbin
### 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存，提高记录bin-log的效率。
binlog_cache_size = 2M 
### 表示的是binlog能够使用的最大cache内存大小
max_binlog_cache_size = 8M
### 指定binlog日志文件的大小。不能将变量设置为大于1G或小于4096字节。默认值为1G.
### 在导入大容量的 sql 文件时，建议关闭，sql_log_bin，否则硬盘扛不住，而且建议定期做删除。
max_binlog_size = 512M
### 定义了mysql清除过期日志的时间
expire_logs_days = 7

###### 连接请求的变量 ######
### MySQL的最大连接数，如果服务器的并发连接请求量较大，建议调高此值，以增加并行连接数量，
### 当然这建立在机器能支撑的情况下，因为如果连接数越多，MySQL回味每个连接提供连接缓冲区，就会开销越多的内存，
### 所以要适当调整该值，不能盲目提高设值。
### 数值过小经常会出现ERROR 1040：Too mant connetcions错误，可以通过
### mysql> show status like ‘connections'；
### 通配符来查看当前状态的连接数量（试图连接到MySQL（不管是否连接成功）的连接数），以定夺该值的大小。
### show variadles like ‘max_connections'最大连接数
### show variables like ‘max_used_connection'相应连接数
### max_used_connection/max_connections*100%（理想值约等于85%）
max_connections = 1024
### MySQL 能够暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，他就会起作用。
### 如果MySQL的连接数据达到 max_connections时，新的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈数量即 back_log，
### 如果等待连接的数量超过back_log，将不被接受连接资源。
back_log = 128
### 指的是关闭一个交互的连接之前所需要等待的秒数。
### 如果设置太小，那么连接关闭的很快，从而使一些持久的连接不起作用
### 如果设置太大容易造成连接打开时间过长，在show processlist时，能够看到太多的sleep状态的连接，从而造成too many connections错误。
### 一般希望wait_timeuot尽可能的低
wait_timeout = 60
### 指的是MySQL再关闭一个非交互的连接之前所需要等待的秒数。
interactive_timeout = 7200

###### 缓冲区变量 ######
### key_buffer_size 只对 MAISAM 表起作用。
### 指定索引缓冲区的大小，他决定索引的处理速度，尤其是索引读的速度。
### 通过检查状态值 key_read_requests和key_reads，可以知道key_buffer_size设置是否合理。
### 比例key_reads/key_read_requests应该尽可能的低，至少是1：100，1：1000更好
### 上述状态值可以使用show status like ‘key_read%'获得
### 未命中缓存的概率：key_cache_miss_rate = key_reads/key_read_requests*100%
### 如何调整key_buffer_size的值
### 默认的配置数时8388608（8M），主机有4G内存可以调优值为268435456（256M）
key_buffer_size = 256M
### 查询缓存大小，MySQL将查询结果存放在缓冲区中，今后对同样的select语句（区分大小写），将直接从缓冲区中读取结果。
### 通过 show ststus like ‘Qcache%' 可以知道query_cache_size的设置是否合理
### Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示过大，则说明Query Cache中的内存碎片较多了。
### 当一个表被更新后，和他相关的cache block将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。
### 可以用 flush query cache 语句来清空 free blocks。
### Qcache_free_memory:Query Cache 中目前剩余的内存大小。
### 通过这个参数我们可以较为准确的观察当前系统中的Query Cache内存大小是否足够，是需要增多还是过多了。
### Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询能缓存的效果。数字越大缓存效果越理想。
### Qcache_inserts：表示多少次未命中而插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，
### 执行查询处理后把结果insert带查询缓存中。这样的情况次数越多，表示查询缓存 应用到的比较少，效果也就不理想。
### Qcache_lowmen_prunes：多少条Query因为内存不足而被清除出Query Cache，
### 通过Qcache_lowmem_prunes和Qcache_free_memory 相互结合，能够更清楚的了解到我们系统中Query Cache的内存大小是否真的足够，
### 是否非常频繁的出现因为内存不足而有Query被换出。这个数字最好是长时间来看，如果这个数字在不断增长，就表示可能碎片化非常严重，或者内存很少。
### Qcache_queries_in_cache：当前Query Cache 中cache的Query数量
### Qcache_total_blocks：当前Query Cache中block的数量
### Query Cache的限制
### a）所有子查询中的外部查询SQL 不能被Cache：
### b）在p'rocedure，function以及trigger中的Query不能被Cache
### c）包含其他很多每次执行可能得到不一样的结果的函数的Query不能被Cache
query_cache_size = 256M
### 缓存类型，决定缓存什么样子的查询
### 0：OFF 相当于禁用了
### 1：ON 将缓存所有结果，除非你的select语句使用了SQL_NO_CACHE禁用了查询缓存
### 2：DENAND  则只缓存select语句中通过SQL_CACHE指定需要缓存的查询。
query_cache_type = 1
### 超出此大小的查询将不被缓存
query_cache_limit = 50M 
### 是一个MySQL中与安全有关的计数器值，他负责阻止过多尝试失败的客户端以防止暴力破解密码的情况，当超过指定次数，
### MySQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hotos命令清空此host的相关信息。（与性能并无太大的关系）
max_connect_errors = 20
### 每个需要排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY 或 GROUP BY操作
### sort_buffer_size是一个connection级的参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。
### 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统的内存资源。
### 例如：500个连接将会消耗500*sort_buffer_size(2M)=1G
sort_buffer_size = 2M
### 根据配置文件限制server接受的数据包大小。
max_allowed_packet = 32M
### 用于表示关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。
join_buffer_size = 2M
### 服务器线程缓存，这个值表示可以重新利用保存在缓存中的线程数量，当断开连接时，那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁
### 如果线程重新被请求，那么请求将从缓存中读取，如果缓存中是空的或者是新的请求，这个线程将被重新请求，那么这个线程将被重新创建，
### 如果有很多新的线程，增加这个值可以改善系统性能，通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。
### 设置规则如下：1G内存配置为8，2G内存为16
### Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程。
### Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。
### Threads_created：代表最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，
### 说明MySQL服务器一直在创建线程，这也比较消耗资源，可以适当增加配置文件中 thread_cache_size 值
### Threads_running：代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。
thread_cache_size = 200 (200/32G内存)

##### 配置Innodb的几个变量 #####
### innodb_buffer_pool_size 的作用相当于 key_buffer_size 对于MyISAM表的作用一样。
### Innodb 使用该参数指定大小的内存来缓冲数据和索引。最大可以把该值设置成物理内存的 80%。
innodb_buffer_pool_size = 2048M
### 主要控制了 innodb 将 log buffer 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为0，1，2.
### 该值对插入数据的速度影响非常大，
### 设置为2时插入10000条记录只需要两秒，
### 设置为0时只需要一秒，
### 设置为1时，则需要229秒。
### 因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅度提高速度。
innodb_flush_log_at_trx_commit = 1
### 此参数确定日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。
innodb_log_buffer_size = 32M
### 此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能。
innodb_log_file_size = 128M
### 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3
innodb_log_files_in_group = 3
### 此参数用来设置innodb线程的并发数，默认值为0表示不被限制，
### 若要设置则与服务器的CPU核心数相同或是CPU的核心数的2倍。
### 按照上边的公式: 4个CPU,每个CPU为8核. 则: (4C*8核) * 2 =64
innodb_thread_concurrency = 0
### MySQL 的随机读（查询操作）缓冲区大小
### 当按任意顺序读取行时（例如，按照排序顺序），将分配到一个随机都缓冲区。
### 进行排序查询时，MySQL会首先扫描一遍该缓冲区，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。
### 但是MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存消耗过大。
read_rnd_buffer_size = 16M
### 批量插入数据缓存大小，可以有效的提高插入效率，默认为8M
bulk_insert_buffer_size = 64M
### MySQL 读入缓冲区大小。对表进行顺序扫描的请求将分配到一个读入缓冲区MySQL会为他分配一段内存缓冲区
read_buffer_size = 1M

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL 的架构</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  <img width="280px" src="/images/mysql/mysql-structrue.jpg" />
</div>

<div style="margin-top:.625em;">
  最上层用于连接、线程处理的部分并不是 MySQL 『发明』的，很多服务都有类似的组成部分；
  <br /> 第二层中包含了大多数 MySQL 的核心服务，包括了对 SQL 的解析、分析、优化和缓存等功能，存储过程、触发器和视图都是在这里实现的；
  <br /> 第三层是 MySQL 中真正负责数据的存储和提取的存储引擎，例如：InnoDB、MyISAM 等，文中对存储引擎的介绍都是对 InnoDB 实现的分析。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="数据的存储" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）：
</div>

<div style="margin-top:.625em;">
  <img width="100%" src="/images/mysql/mysql-innodb-engine.png" />
</div>

<div style="margin-top:.625em;">
  同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 innodb_page_size 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同：
</div>

<div style="margin-top:.625em;">
  <img width="480px" src="/images/mysql/innodb-page.jpg" />
</div>

<div style="margin-top:.625em;">
  从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="如何存储表" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。
</div>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>.frm</c:title>
    <c:desc>
      <c:desc1> <![CDATA[无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
CREATE TABLE test_frm (
   column1 CHAR(5),
   column2 INTEGER
);
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  当我们使用上面的代码创建表时，会在磁盘上的 datadir文件夹中生成一个 test_frm.frm 的文件，这个文件中就包含了表结构相关的信息：
</div>
<div style="margin-top:.325em;">
  <img width="580px" src="/images/mysql/mysql-frm.jpg" />
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>.ibd</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。
</div>
<div style="margin-top:.625em;">
当打开 innodb_file_per_table 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。
</div>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="show table status like 't1'\G;" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 2
 Avg_row_length: 8192
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2016-01-11 05:04:28
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="如何存储记录" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，<b>每个 16KB 大小的页中可以存放 2-200 行的记录。InnoDB 存储引擎提供了 compact(5.1后的默认格式)和 redundant 两个格式来存放行记录数据。redundant 格式是为了兼容之前的版本而保留。</b>
</div>
<div style="margin-top:.625em;">
  当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：
</div>
<div style="margin-top:.325em;">
  <img width="280px" src="/images/mysql/innodb-store.jpg" />
</div>
<div style="margin-top:.625em;">
  Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。
</div>
<div style="margin-top:.625em;">
  两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-antelope.jpg" />
</div>
<div style="margin-top:.625em;">
  Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。
</div>
<div style="margin-top:.625em;">
  Compact 行记录是在 MySQL 5.0 时被引入的，其设计目标是能高效存放数据。简单来说，如果一个页中存放的行数据越多，其性能就越高。
</div>


    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="行溢出数据" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  当 InnoDB 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。
</div>
<div style="margin-top:.625em;">
  当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-blob.jpg" />
</div>
<div style="margin-top:.625em;">
  但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-store-compressed.jpg" />
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="数据页结构" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-store-page.jpg" />
</div>
<div style="margin-top:.625em;">
  每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。
</div>
<div style="margin-top:.625em;">
  在页的头部和尾部之间就是用户记录和空闲空间了，每一个数据页中都包含 Infimum 和 Supremum 这两个虚拟的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-infimum.jpg" />
</div>
<div style="margin-top:.625em;">
  User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record 这一指针控制的。
</div>
<div style="margin-top:.625em;">
  B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、 next_record 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。
</div>
<div style="margin-top:.625em;">
  InnoDB 存储引擎中对数据的存储是一个非常复杂的话题，这一节中也只是对表、行记录以及页面的存储进行一定的分析和介绍，虽然作者相信这部分知识对于大部分开发者已经足够了，但是想要真正消化这部分内容还需要很多的努力和实践。
</div>

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>索引</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        索引是数据库中非常非常重要的概念，它是存储引擎能够快速定位记录的秘密武器，对于提升数据库的性能、减轻数据库服务器的负担有着非常重要的作用；索引优化是对查询性能优化的最有效手段，它能够轻松地将查询的性能提高几个数量级。MySQL普遍使用B+Tree实现其索引结构。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="B-Tree(平衡多路查找树) 和 B+Tree" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:1em;">
<b style="color:red;">系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</b>
InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K.
</div>

<div style="margin-top:.625em;">
而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
</div>

<div style="margin-top:.325em;">
  目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。
</div>

<h4 style="color:green;margin-top:1em;font-size:2.2em;">BTree</h4>
<div style="margin-top:.325em;">
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。一棵m阶的B-Tree有如下特性：
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>每个节点最多有m个孩子。 </li>
    <li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 </li>
    <li>若根节点不是叶子节点，则至少有2个孩子 </li>
    <li>所有叶子节点都在同一层，且不包含其它关键字信息 </li>
    <li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） </li>
    <li>关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 </li>
    <li>ki(i=1,…n)为关键字，且关键字升序排序。 </li>
    <li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ul>

<div style="margin-top:.325em;">
B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 
</div>

<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-btree.jpg" />
</div>


<div style="margin-top:.625em;">
每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。
</div>

<h4 style="margin-top:.625em;">模拟查找关键字29的过程：</h4>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
    <li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
    <li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
    <li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
    <li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
    <li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ul>


<div style="margin-top:.625em;">
分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。
</div>


<h4 style="color:green;margin-top:1em;font-size:2.2em;">B+Tree</h4>

<div style="margin-top:.625em;">
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。
</div>
<div style="margin-top:.625em;">
从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
</div>

<h4 style="margin-top:.625em;">与B-Tree相比，B+Tree有以下不同点：</h4>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>非叶子节点只存储键值信息。</li>
    <li>所有叶子节点之间都有一个链指针。</li>
    <li>数据记录都存放在叶子节点中。</li>
</ul>
<div style="margin-top:.625em;">
将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 
</div>

<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-b+tree.png" />
</div>

<div style="margin-top:.625em;">
  通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
</div>
<div style="margin-top:.625em;">
  可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：
</div>
<div style="margin-top:.625em;">
InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说<b style="color:red;">一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录</b>。
</div>
<div style="margin-top:.625em;">
实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。<b style="color:red;">mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</b>
</div>
<div style="margin-top:.625em;">
数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，<b style="color:red;">聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据</b>。<b style="color:blue;">辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键</b>。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。
</div>

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>主存存取原理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
  <img width="380px" src="/images/mysql/primary-memary.png" />
</div>

<div style="margin-top:.625em;">
  从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
主存的存取过程如下：
</div>
<div style="margin-top:.325em;">
<b>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</b>
</div>
<div style="margin-top:.325em;">
写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。
</div>
<div style="margin-top:.325em;">
这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>磁盘存取原理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
  <img width="380px" src="/images/mysql/disk.png" />
</div>

<div style="margin-top:.625em;">
  一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
下图是磁盘结构的示意图。
</div>

<div style="margin-top:.325em;">
  <img width="380px" src="/images/mysql/disk2.png" />
</div>

<div style="margin-top:.625em;">
  盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。
</div>

<div style="margin-top:.625em;">
当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="局部性原理与磁盘预读" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：
</div>

<div style="margin-top:.625em;">
当一个数据被用到时，其附近的数据也通常会马上被使用。
</div>

<div style="margin-top:.625em;">
程序运行期间所需要的数据通常比较集中。
</div>

<div style="margin-top:.625em;">
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
</div>

<div style="margin-top:.625em;">
预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL-InnoDB Compact 行记录格式</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="yb1.ibd" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
> create table yb1(
  t1 varchar(10),
  t2 varchar(10),
  t3 char(10),
  t4 varchar(10)
) row_format=compact;

> insert into yb1 values('a','bb','bb','ccc');
> insert into yb1 values('d','ee','ee','fff');
> insert into yb1 values('d',NULL,NULL,'fff');
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="hexdump -C -v yb1.ibd  > yb1.txt" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.65em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
0000c070  73 75 70 72 65 6d 75 6d  03 0a 02 01 00 00 00 10  |supremum........|
0000c080  00 2d 00 00 01 fa dd d5  00 00 00 00 39 ea a3 00  |.-..........9...|
0000c090  00 01 e8 01 10 61 62 62  62 62 20 20 20 20 20 20  |.....abbbb      |
0000c0a0  20 20 63 63 63 03 0a 02  01 00 00 00 18 00 2b 00  |  ccc.........+.|
0000c0b0  00 01 fa dd d6 00 00 00  00 39 eb a4 00 00 01 e9  |.........9......|
0000c0c0  01 10 64 65 65 65 65 20  20 20 20 20 20 20 20 66  |..deeee        f|
0000c0d0  66 66 03 01 06 00 00 20  ff 96 00 00 01 fa dd d7  |ff..... ........|
0000c0e0  00 00 00 00 39 f0 a7 00  00 01 ea 01 10 64 66 66  |....9........dff|
0000c0f0  66 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |f...............|
0000c100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
0000c110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
0000c120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="hexdump -C -v yb1.ibd  > yb1.txt" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.65em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<pre>
第一行记录从0000c078开始：
03 0a 02 01 /* 变长字段长度列表，逆序的
               03表示t4字段的值ccc的长度，
               0a表示t3字段的长度，
               02表示t2字段的值bb的长度，
               01表示t1字段的值a的长度 */
00 /* NULL标志位，第一行没有NULL值 */
00 00 10 00 2d /* record header，固定5字节 */
00 00 01 fa dd d5 /* rowid，innodb自动创建，6个字节 */ 
00 00 00 00 39 ea /* 事务ID */
a3 00 00 01 e8 01 10 /* 回滚指针 */
61 /* 列1数据'a' */
62 62 /* 列2数据'bb' */
62 62 20 20 20 20 20 20 20 20  /* 列3数据'bb' (固定长度未完全使用时，使用0x20表示) */
63 63 63 /* 列4数据'ccc' */
</pre>
<pre style="margin-top:1em;">
第二行记录从0000c0a5开始：
03 0a 02 01 /* 变长字段长度列表，逆序的
               03表示t4字段的值fff的长度，
               0a表示t3字段的长度，
               02表示t2字段的值ee的长度，
               01表示t1字段的值d的长度 */
00 /* NULL标志位，第一行没有NULL值 */
00 00 18 00 2b /* record header，固定5字节 */
00 00 01 fa dd d6 /* rowid，innodb自动创建，6个字节 */ 
00 00 00 00 39 eb /* 事务ID */
a4 00 00 01 e9 01 10 /* 回滚指针 */
64 /* 列1数据'd' */
65 65 /* 列2数据'ee' */
65 65 20 20 20 20 20 20 20 20  /* 列3数据'ee' (固定长度未完全使用时，使用0x20表示) */
66 66 66 /* 列4数据'fff' */
</pre>
<pre style="margin-top:1em;">
第三行记录从0000c0d2开始：
03 01 /* 变长字段长度列表，逆序的
         03表示t4字段的值fff的长度，
         01表示t1字段的值d的长度 */
06 /* NULL标志位，第三行有NULL值。06换成二进制为00000110，表示第2,3列是null */
00 00 20 ff 96 /* record header，固定5字节 */
00 00 01 fa dd d7 /* rowid，innodb自动创建，6个字节 */ 
00 00 00 00 39 f0 /* 事务ID */
a7 00 00 01 ea 01 10 /* 回滚指针 */
64 /* 列1数据'd' */
64 64 64 /* 列4数据'fff' */
</pre>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Record Lock、Gap Lock 和 Next-Key Lock</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Record Lock" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  记录锁（Record Lock）是加到索引记录上的锁，假设我们存在下面的一张表 users：
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.65em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
creEATE TABLE users (
   id INT NOT NULL AUTO_INCREMENT,
   last_name VARCHAR(255) NOT NULL,
   first_name VARCHAR(255),
   age INT,
   PRIMARY KEY(id),
   KEY(last_name),
   KEY(age)
);
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
如果我们使用 id 或者 last_name 作为 SQL 中 WHERE 语句的过滤条件，那么 InnoDB 就可以通过索引建立的 B+ 树找到行记录并添加索引，但是如果使用 first_name 作为过滤条件时，由于 InnoDB 不知道待修改的记录具体存放的位置，也无法对将要修改哪条记录提前做出判断就会锁定整个表。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Gap Lock" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  记录锁是在存储引擎中最为常见的锁，除了记录锁之外，InnoDB 中还存在间隙锁（Gap Lock），间隙锁是对索引记录中的一段连续区域的锁；当使用类似 SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE; 的 SQL 语句时，就会阻止其他事务向表中插入 id=15 的记录，因为整个范围都被间隙锁锁定了。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Next-Key Lock" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  Next-Key 锁相比前两者就稍微有一些复杂，它是记录锁和记录前的间隙锁的结合，<b>Next-Key 锁定的是当前值和前面的范围</b>。假如在 users 表中有以下记录：
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
+------+-------------+--------------+-------+
|   id | last_name   | first_name   |   age |
|------+-------------+--------------+-------|
|    4 | stark       | tony         |    21 |
|    1 | tom         | hiddleston   |    30 |
|    3 | morgan      | freeman      |    40 |
|    5 | jeff        | dean         |    50 |
|    2 | donald      | trump        |    80 |
+------+-------------+--------------+-------+
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-top:.625em;">
如果使用 Next-Key 锁，那么 Next-Key 锁就可以在需要的时候锁定以下的范围：
</div>

<pre>
(-∞, 21]
(21, 30]
(30, 40]
(40, 50]
(50, 80]
(80, ∞)
</pre>

<div style="margin-top:.625em;">
当我们更新一条记录，比如 SELECT * FROM users WHERE age=30 FOR UPDATE;，InnoDB 不仅会在范围 (21,30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30,40] 加间隙锁，所以插入 (21,40]范围内的记录都会被锁定。
</div>

<div style="margin-top:.325em;font-weight:bold;">
Next-Key 锁的作用其实是为了解决幻读的问题。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="死锁的发生" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
既然 InnoDB 中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁，最终导致事务发生错误；想要在 MySQL 中制造死锁的问题其实非常容易：
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session1
begin
select * from users where id=1 for update;
select * from users where id=2 for update;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session2
begin
select * from users where id=2 for update;
select * from users where id=1 for update;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
两个会话都持有一个锁，并且尝试获取对方的锁时就会发生死锁，不过 MySQL 也能在发生死锁时及时发现问题，并保证其中的一个事务能够正常工作，这对我们来说也是一个好消息。
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>事务与隔离级别</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        事务的 ACID 四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）；
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  事务的隔离性是数据库处理数据的几大基础之一，而隔离级别其实就是提供给用户用于在性能和可靠性做出选择和权衡的配置项。ISO 和 ANIS SQL 标准制定了四种事务隔离级别，而 InnoDB 遵循了 SQL92 标准中的四种隔离级别： 
  <br />
  <b>READ UNCOMMITED、 READ COMMITED、 REPEATABLE READ和 SERIALIZABLE；</b>
</div>

<h3>每个事务的隔离级别其实都比上一级多解决了一个问题：</h3>
<ul style="margin-left: 1.5em;list-style-type: disc;">
    <li><b>RAED UNCOMMITED</b> 使用查询语句不会加锁，可能会读到未提交的行（Dirty Read/脏读）；</li>
    <li><b>READ COMMITED</b> 只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；</li>
    <li><b>REPEATABLE READ</b> 多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li>
    <li><b>SERIALIZABLE</b> InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li>
</ul>

<table style="color:darkgreen;margin:.5em 0;line-height:1.3em;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;font-weight: normal;">
            &nbsp;
            </td>
            <td style="padding: 0;margin: 0;text-align:right;">Dirty <br />Read</td>
            <td style="padding: 0;margin: 0;text-align: center;">Non-Repeatable <br />Read</td>
            <td style="padding: 0;margin: 0;text-align: center;">Phantom <br />Read</td>
            <td style="padding: 0;margin: 0;text-align: center;width:520px;">&nbsp;</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;">
            RAED UNCOMMITED
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;">&radic;</td>
            <td style="padding: 0;margin: 0;text-align: center;vertical-align: middle;font-size: 1.5em;">&radic;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;">&radic;</td>
            <td style="font-size:.85em;padding: 0;margin: 0;text-align:left;">
              事务能够看到其他事务没有提交的修改，当另一个事务又回滚了修改后的情况，又被称为脏读 dirty read
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;">
            READ COMMITED
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;">&radic;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;">&radic;</td>
            <td style="font-size:.85em;padding: 0;margin: 0;text-align:left;">
              事务能够看到其他事务提交后的修改，这时会出现一个事务内两次读取数据可能因为其他事务提交的修改导致不一致的情况，称为不可重复读
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align:right;font-weight: normal;">
            REPEATABLE READ
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;">&radic;</td>
            <td style="vertical-align: middle;font-size:.85em;padding: 0;margin: 0;text-align:left;">
              事务在两次读取时读取到的数据的状态是一致的
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;">
            SERIALIZABLE
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;">&times;</td>
            <td style="font-size:.85em;padding: 0;margin: 0;text-align:left;">
              可重复读中可能出现第二次读读到第一次没有读到的数据，也就是被其他事务插入的数据，这种情况称为幻读phantom read, 该级别中不能出现幻读
            </td>
        </tr>
    </tbody>
</table>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="脏读" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
当事务的隔离级别为 READ UNCOMMITED 时，我们在 SESSION2 中插入的未提交数据在 SESSION1 中是可以访问的。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="不可重复读" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
当事务的隔离级别为 READ COMMITED 时，虽然解决了脏读的问题，但是如果在 SESSION1 先查询了一个范围的数据，在这之后 SESSION2 中插入一条数据并且提交了修改，在这时，如果 SESSION1 中再次使用相同的查询语句，就会发现两次查询的结果不一样。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session1
> begin
> select * from users where id < 5;
> sleep(2000) # 此时另一个session2插入了一条数据
> select * from users where id < 5; # READ COMMITED 的隔离级别下, 两次可能读到不同的结果　
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session2
> begin
> insert into values (4);
> commit
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
不可重复读的原因就是，在 READ COMMITED 的隔离级别下，存储引擎不会在查询记录时添加间隙锁，锁定 id<5 这个范围。
</div>
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="幻读" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
重新开启了两个会话 SESSION1 和 SESSION2，在 SESSION1中我们查询全表的信息，没有得到任何记录；在 SESSION2中向表中插入一条数据并提交；由于 REPEATABLE READ 的原因，再次查询全表的数据时，我们获得到的仍然是空集，但是在向表中插入同样的数据却出现了错误。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session1
> begin
> select * from users;
> sleep(2000) # 此时另一个session2插入了一条数据并
> select * from users;
> insert into values (1);
> Duplicate entry '1' for 'id'
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session2
> begin
> insert into values (1);
> commit
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
这种现象在数据库中就被称作幻读，虽然我们使用查询语句得到了一个空的集合，但是插入数据时却得到了错误，好像之前的查询是幻觉一样。
在标准的事务隔离级别中，幻读是由更高的隔离级别 SERIALIZABLE 解决的，但是它也可以通过 MySQL 提供的 Next-Key 锁解决：
</div>
<div style="margin-top:.325em;">
<b>REPERATABLE READ 和 READ UNCOMMITED 其实是矛盾的，如果保证了前者就看不到已经提交的事务，如果保证了后者，就会导致两次查询的结果不同</b>，MySQL 为我们提供了一种折中的方式，能够在 REPERATABLE READ 模式下加锁访问已经提交的数据，其本身并不能解决幻读的问题，而是通过文章前面提到的 Next-Key 锁来解决。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>mysql MVCC原理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
MVCC多版本控制: 指的是一种提高并发的技术。最早的数据库系统，<b>只有读读之间可以并发，读写，写读，写写都要阻塞</b>。<b style="color:blue;">引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行</b>，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，<b style="color:red;">InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本</b>。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。
</div>

<div style="margin-top:.625em;">
MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。不仅仅是MySQL，包括Oracle，PostgreSQL等其他数据库系统也都实现了MVCC，但是各自的实现机制并不相同，因为MVCC并没有一个统一的标准。MVCC在很多情况下避免了加锁操作，因此开销更低。<b>大多数的MVCC都实现了非阻塞的读操作，写操作也只锁定必要的行。</b>
</div>

<div style="margin-top:.625em;">
MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据是一致的。根据事务开始的时间不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。不同存储引擎的MVCC实现是不同的，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。
</div>

<div style="margin-top:.625em;">
MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE会对所有读取到的行都加锁。
</div>
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

</c:component>
