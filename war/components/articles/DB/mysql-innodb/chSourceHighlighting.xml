<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[

]]>
  </c:abstract>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL参数配置</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="服务器参数" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
32G内存、4个CPU,每个CPU 8核。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="/etc/my.cnf" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1.2em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
[mysqld]
basedir = /usr/local/mysql
datadir = /usr/local/mysql/data
server_id = 1
socket = /usr/local/mysql/mysql.sock
log-error = /usr/local/mysql/data/mysqld.err
slow_query_log = 1
slow_query_log_file=/usr/local/mysql/data/slow-query.log
long_query_time = 1
log-queries-not-using-indexes
sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES 

##### bin log 相关配置 #####
log-bin=/usr/local/mysql/data/mysqlbin
### 为每个session分配的内存，在事务过程中用来存储二进制日志的缓存，提高记录bin-log的效率。
binlog_cache_size = 2M 
### 表示的是binlog能够使用的最大cache内存大小
max_binlog_cache_size = 8M
### 指定binlog日志文件的大小。不能将变量设置为大于1G或小于4096字节。默认值为1G.
### 在导入大容量的 sql 文件时，建议关闭，sql_log_bin，否则硬盘扛不住，而且建议定期做删除。
max_binlog_size = 512M
### 定义了mysql清除过期日志的时间
expire_logs_days = 7

###### 连接请求的变量 ######
### MySQL的最大连接数，如果服务器的并发连接请求量较大，建议调高此值，以增加并行连接数量，
### 当然这建立在机器能支撑的情况下，因为如果连接数越多，MySQL回味每个连接提供连接缓冲区，就会开销越多的内存，
### 所以要适当调整该值，不能盲目提高设值。
### 数值过小经常会出现ERROR 1040：Too mant connetcions错误，可以通过
### mysql> show status like ‘connections'；
### 通配符来查看当前状态的连接数量（试图连接到MySQL（不管是否连接成功）的连接数），以定夺该值的大小。
### show variadles like ‘max_connections'最大连接数
### show variables like ‘max_used_connection'相应连接数
### max_used_connection/max_connections*100%（理想值约等于85%）
max_connections = 1024
### MySQL 能够暂存的连接数量。当主要MySQL线程在一个很短时间内得到非常多的连接请求，他就会起作用。
### 如果MySQL的连接数据达到 max_connections时，新的请求将会被存在堆栈中，以等待某一连接释放资源，该堆栈数量即 back_log，
### 如果等待连接的数量超过back_log，将不被接受连接资源。
back_log = 128
### 指的是关闭一个交互的连接之前所需要等待的秒数。
### 如果设置太小，那么连接关闭的很快，从而使一些持久的连接不起作用
### 如果设置太大容易造成连接打开时间过长，在show processlist时，能够看到太多的sleep状态的连接，从而造成too many connections错误。
### 一般希望wait_timeuot尽可能的低
wait_timeout = 60
### 指的是MySQL再关闭一个非交互的连接之前所需要等待的秒数。
interactive_timeout = 7200

###### 缓冲区变量 ######
### key_buffer_size 只对 MAISAM 表起作用。
### 指定索引缓冲区的大小，他决定索引的处理速度，尤其是索引读的速度。
### 通过检查状态值 key_read_requests和key_reads，可以知道key_buffer_size设置是否合理。
### 比例key_reads/key_read_requests应该尽可能的低，至少是1：100，1：1000更好
### 上述状态值可以使用show status like ‘key_read%'获得
### 未命中缓存的概率：key_cache_miss_rate = key_reads/key_read_requests*100%
### 如何调整key_buffer_size的值
### 默认的配置数时8388608（8M），主机有4G内存可以调优值为268435456（256M）
key_buffer_size = 256M
### 查询缓存大小，MySQL将查询结果存放在缓冲区中，今后对同样的select语句（区分大小写），将直接从缓冲区中读取结果。
### 通过 show ststus like ‘Qcache%' 可以知道query_cache_size的设置是否合理
### Qcache_free_blocks：缓存中相邻内存块的个数。如果该值显示过大，则说明Query Cache中的内存碎片较多了。
### 当一个表被更新后，和他相关的cache block将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。
### 可以用 flush query cache 语句来清空 free blocks。
### Qcache_free_memory:Query Cache 中目前剩余的内存大小。
### 通过这个参数我们可以较为准确的观察当前系统中的Query Cache内存大小是否足够，是需要增多还是过多了。
### Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询能缓存的效果。数字越大缓存效果越理想。
### Qcache_inserts：表示多少次未命中而插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，
### 执行查询处理后把结果insert带查询缓存中。这样的情况次数越多，表示查询缓存 应用到的比较少，效果也就不理想。
### Qcache_lowmen_prunes：多少条Query因为内存不足而被清除出Query Cache，
### 通过Qcache_lowmem_prunes和Qcache_free_memory 相互结合，能够更清楚的了解到我们系统中Query Cache的内存大小是否真的足够，
### 是否非常频繁的出现因为内存不足而有Query被换出。这个数字最好是长时间来看，如果这个数字在不断增长，就表示可能碎片化非常严重，或者内存很少。
### Qcache_queries_in_cache：当前Query Cache 中cache的Query数量
### Qcache_total_blocks：当前Query Cache中block的数量
### Query Cache的限制
### a）所有子查询中的外部查询SQL 不能被Cache：
### b）在p'rocedure，function以及trigger中的Query不能被Cache
### c）包含其他很多每次执行可能得到不一样的结果的函数的Query不能被Cache
query_cache_size = 256M
### 缓存类型，决定缓存什么样子的查询
### 0：OFF 相当于禁用了
### 1：ON 将缓存所有结果，除非你的select语句使用了SQL_NO_CACHE禁用了查询缓存
### 2：DENAND  则只缓存select语句中通过SQL_CACHE指定需要缓存的查询。
query_cache_type = 1
### 超出此大小的查询将不被缓存
query_cache_limit = 50M 
### 是一个MySQL中与安全有关的计数器值，他负责阻止过多尝试失败的客户端以防止暴力破解密码的情况，当超过指定次数，
### MySQL服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hotos命令清空此host的相关信息。（与性能并无太大的关系）
max_connect_errors = 20
### 每个需要排序的线程分配该大小的一个缓冲区。增加这值加速ORDER BY 或 GROUP BY操作
### sort_buffer_size是一个connection级的参数，在每个connection（session）第一次需要使用这个buffer的时候，一次性分配设置的内存。
### 并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统的内存资源。
### 例如：500个连接将会消耗500*sort_buffer_size(2M)=1G
sort_buffer_size = 2M
### 根据配置文件限制server接受的数据包大小。
max_allowed_packet = 32M
### 用于表示关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。
join_buffer_size = 2M
### 服务器线程缓存，这个值表示可以重新利用保存在缓存中的线程数量，当断开连接时，那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁
### 如果线程重新被请求，那么请求将从缓存中读取，如果缓存中是空的或者是新的请求，这个线程将被重新请求，那么这个线程将被重新创建，
### 如果有很多新的线程，增加这个值可以改善系统性能，通过比较Connections和Threads_created状态的变量，可以看到这个变量的作用。
### 设置规则如下：1G内存配置为8，2G内存为16
### Threads_cached：代表当前此时此刻线程缓存中有多少空闲线程。
### Threads_connected：代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。
### Threads_created：代表最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，
### 说明MySQL服务器一直在创建线程，这也比较消耗资源，可以适当增加配置文件中 thread_cache_size 值
### Threads_running：代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。
thread_cache_size = 200 (200/32G内存)

##### 配置Innodb的几个变量 #####
### innodb_buffer_pool_size 的作用相当于 key_buffer_size 对于MyISAM表的作用一样。
### Innodb 使用该参数指定大小的内存来缓冲数据和索引。最大可以把该值设置成物理内存的 80%。
innodb_buffer_pool_size = 2048M
### 主要控制了 innodb 将 log buffer 中的数据写入日志文件并 flush 磁盘的时间点，取值分别为0，1，2.
### 该值对插入数据的速度影响非常大，
### 设置为2时插入10000条记录只需要两秒，
### 设置为0时只需要一秒，
### 设置为1时，则需要229秒。
### 因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅度提高速度。
innodb_flush_log_at_trx_commit = 1
### 此参数确定日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。
innodb_log_buffer_size = 32M
### 此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能。
innodb_log_file_size = 128M
### 为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3
innodb_log_files_in_group = 3
### 此参数用来设置innodb线程的并发数，默认值为0表示不被限制，
### 若要设置则与服务器的CPU核心数相同或是CPU的核心数的2倍。
### 按照上边的公式: 4个CPU,每个CPU为8核. 则: (4C*8核) * 2 =64
innodb_thread_concurrency = 0
### MySQL 的随机读（查询操作）缓冲区大小
### 当按任意顺序读取行时（例如，按照排序顺序），将分配到一个随机都缓冲区。
### 进行排序查询时，MySQL会首先扫描一遍该缓冲区，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。
### 但是MySQL会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存消耗过大。
read_rnd_buffer_size = 16M
### 批量插入数据缓存大小，可以有效的提高插入效率，默认为8M
bulk_insert_buffer_size = 64M
### MySQL 读入缓冲区大小。对表进行顺序扫描的请求将分配到一个读入缓冲区MySQL会为他分配一段内存缓冲区
read_buffer_size = 1M

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL 的架构</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  <img width="280px" src="/images/mysql/mysql-structrue.jpg" />
</div>

<div style="margin-top:.625em;">
  最上层用于连接、线程处理的部分并不是 MySQL 『发明』的，很多服务都有类似的组成部分；
  <br /> 第二层中包含了大多数 MySQL 的核心服务，包括了对 SQL 的解析、分析、优化和缓存等功能，存储过程、触发器和视图都是在这里实现的；
  <br /> 第三层是 MySQL 中真正负责数据的存储和提取的存储引擎，例如：InnoDB、MyISAM 等，文中对存储引擎的介绍都是对 InnoDB 实现的分析。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="数据的存储" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  在 InnoDB 存储引擎中，所有的数据都被逻辑地存放在表空间中，表空间（tablespace）是存储引擎中最高的存储逻辑单位，在表空间的下面又包括段（segment）、区（extent）、页（page）：
</div>

<div style="margin-top:.625em;">
  <img width="100%" src="/images/mysql/mysql-innodb-engine.png" />
</div>

<div style="margin-top:.625em;">
  同一个数据库实例的所有表空间都有相同的页大小；默认情况下，表空间中的页大小都为 16KB，当然也可以通过改变 innodb_page_size 选项对默认大小进行修改，需要注意的是不同的页大小最终也会导致区大小的不同：
</div>

<div style="margin-top:.625em;">
  <img width="480px" src="/images/mysql/innodb-page.jpg" />
</div>

<div style="margin-top:.625em;">
  从图中可以看出，在 InnoDB 存储引擎中，一个区的大小最小为 1MB，页的数量最少为 64 个。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="如何存储表" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div>
  MySQL 使用 InnoDB 存储表时，会将表的定义和数据索引等信息分开存储，其中前者存储在 .frm文件中，后者存储在 .ibd 文件中，这一节就会对这两种不同的文件分别进行介绍。
</div>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>.frm</c:title>
    <c:desc>
      <c:desc1> <![CDATA[无论在 MySQL 中选择了哪个存储引擎，所有的 MySQL 表都会在硬盘上创建一个 .frm 文件用来描述表的格式或者说定义； .frm 文件的格式在不同的平台上都是相同的。]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
CREATE TABLE test_frm (
   column1 CHAR(5),
   column2 INTEGER
);
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  当我们使用上面的代码创建表时，会在磁盘上的 datadir文件夹中生成一个 test_frm.frm 的文件，这个文件中就包含了表结构相关的信息：
</div>
<div style="margin-top:.325em;">
  <img width="580px" src="/images/mysql/mysql-frm.jpg" />
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>.ibd</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
InnoDB 中用于存储数据的文件总共有两个部分，一是系统表空间文件，包括 ibdata1、 ibdata2 等文件，其中存储了 InnoDB 系统信息和用户数据库表数据和索引，是所有表公用的。
</div>
<div style="margin-top:.625em;">
当打开 innodb_file_per_table 选项时， .ibd 文件就是每一个表独有的表空间，文件存储了当前表的数据和相关的索引数据。
</div>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="show table status like 't1'\G;" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

*************************** 1. row ***************************
           Name: t1
         Engine: InnoDB
        Version: 10
     Row_format: Compact
           Rows: 2
 Avg_row_length: 8192
    Data_length: 16384
Max_data_length: 0
   Index_length: 0
      Data_free: 0
 Auto_increment: NULL
    Create_time: 2016-01-11 05:04:28
    Update_time: NULL
     Check_time: NULL
      Collation: utf8_general_ci
       Checksum: NULL
 Create_options: 
        Comment: 
1 row in set (0.00 sec)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="如何存储记录" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  与现有的大多数存储引擎一样，InnoDB 使用页作为磁盘管理的最小单位；数据在 InnoDB 存储引擎中都是按行存储的，<b>每个 16KB 大小的页中可以存放 2-200 行的记录。InnoDB 存储引擎提供了 compact(5.1后的默认格式)和 redundant 两个格式来存放行记录数据。redundant 格式是为了兼容之前的版本而保留。</b>
</div>
<div style="margin-top:.625em;">
  当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：
</div>
<div style="margin-top:.325em;">
  <img width="280px" src="/images/mysql/innodb-store.jpg" />
</div>
<div style="margin-top:.625em;">
  Antelope 是 InnoDB 最开始支持的文件格式，它包含两种行格式 Compact 和 Redundant，它最开始并没有名字；Antelope 的名字是在新的文件格式 Barracuda 出现后才起的，Barracuda 的出现引入了两种新的行格式 Compressed 和 Dynamic；InnoDB 对于文件格式都会向前兼容，而官方文档中也对之后会出现的新文件格式预先定义好了名字：Cheetah、Dragon、Elk 等等。
</div>
<div style="margin-top:.625em;">
  两种行记录格式 Compact 和 Redundant 在磁盘上按照以下方式存储：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-antelope.jpg" />
</div>
<div style="margin-top:.625em;">
  Compact 和 Redundant 格式最大的不同就是记录格式的第一个部分；在 Compact 中，行记录的第一部分倒序存放了一行数据中列的长度（Length），而 Redundant 中存的是每一列的偏移量（Offset），从总体上上看，Compact 行记录格式相比 Redundant 格式能够减少 20% 的存储空间。
</div>
<div style="margin-top:.625em;">
  Compact 行记录是在 MySQL 5.0 时被引入的，其设计目标是能高效存放数据。简单来说，如果一个页中存放的行数据越多，其性能就越高。
</div>


    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="行溢出数据" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  当 InnoDB 使用 Compact 或者 Redundant 格式存储极长的 VARCHAR 或者 BLOB 这类大对象时，我们并不会直接将所有的内容都存放在数据页节点中，而是将行数据中的前 768 个字节存储在数据页中，后面会通过偏移量指向溢出页。
</div>
<div style="margin-top:.625em;">
  当 InnoDB 存储数据时，它可以使用不同的行格式进行存储；MySQL 5.7 版本支持以下格式的行存储方式：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-blob.jpg" />
</div>
<div style="margin-top:.625em;">
  但是当我们使用新的行记录格式 Compressed 或者 Dynamic 时都只会在行记录中保存 20 个字节的指针，实际的数据都会存放在溢出页面中。
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-store-compressed.jpg" />
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="数据页结构" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  页是 InnoDB 存储引擎管理数据的最小磁盘单位，而 B-Tree 节点就是实际存放表中数据的页面，我们在这里将要介绍页是如何组织和存储记录的；首先，一个 InnoDB 页有以下七个部分：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-store-page.jpg" />
</div>
<div style="margin-top:.625em;">
  每一个页中包含了两对 header/trailer：内部的 Page Header/Page Directory 关心的是页的状态信息，而 Fil Header/Fil Trailer 关心的是记录页的头信息。
</div>
<div style="margin-top:.625em;">
  在页的头部和尾部之间就是用户记录和空闲空间了，每一个数据页中都包含 Infimum 和 Supremum 这两个虚拟的记录（可以理解为占位符），Infimum 记录是比该页中任何主键值都要小的值，Supremum 是该页中的最大值：
</div>
<div style="margin-top:.325em;">
  <img width="680px" src="/images/mysql/innodb-infimum.jpg" />
</div>
<div style="margin-top:.625em;">
  User Records 就是整个页面中真正用于存放行记录的部分，而 Free Space 就是空余空间了，它是一个链表的数据结构，为了保证插入和删除的效率，整个页面并不会按照主键顺序对所有记录进行排序，它会自动从左侧向右寻找空白节点进行插入，行记录在物理存储上并不是按照顺序的，它们之间的顺序是由 next_record 这一指针控制的。
</div>
<div style="margin-top:.625em;">
  B+ 树在查找对应的记录时，并不会直接从树中找出对应的行记录，它只能获取记录所在的页，将整个页加载到内存中，再通过 Page Directory 中存储的稀疏索引和 n_owned、 next_record 属性取出对应的记录，不过因为这一操作是在内存中进行的，所以通常会忽略这部分查找的耗时。
</div>
<div style="margin-top:.625em;">
  InnoDB 存储引擎中对数据的存储是一个非常复杂的话题，这一节中也只是对表、行记录以及页面的存储进行一定的分析和介绍，虽然作者相信这部分知识对于大部分开发者已经足够了，但是想要真正消化这部分内容还需要很多的努力和实践。
</div>

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>索引</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        索引是数据库中非常非常重要的概念，它是存储引擎能够快速定位记录的秘密武器，对于提升数据库的性能、减轻数据库服务器的负担有着非常重要的作用；索引优化是对查询性能优化的最有效手段，它能够轻松地将查询的性能提高几个数量级。MySQL普遍使用B+Tree实现其索引结构。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="B-Tree(平衡多路查找树) 和 B+Tree" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:1em;">
<b style="color:red;">系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。</b>
InnoDB存储引擎中有页（Page）的概念，页是其磁盘管理的最小单位。InnoDB存储引擎中默认每个页的大小为16KB，可通过参数innodb_page_size将页的大小设置为4K、8K、16K.
</div>

<div style="margin-top:.625em;">
而系统一个磁盘块的存储空间往往没有这么大，因此InnoDB每次申请磁盘空间时都会是若干地址连续磁盘块来达到页的大小16KB。InnoDB在把磁盘数据读入到磁盘时会以页为基本单位，在查询数据时如果一个页中的每条数据都能有助于定位数据记录的位置，这将会减少磁盘I/O次数，提高查询效率。
</div>

<div style="margin-top:.325em;">
  目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。
</div>

<h4 style="color:green;margin-top:1em;font-size:2.2em;">BTree</h4>
<div style="margin-top:.325em;">
B-Tree结构的数据可以让系统高效的找到数据所在的磁盘块。为了描述B-Tree，首先定义一条记录为一个二元组[key, data] ，key为记录的键值，对应表中的主键值，data为一行记录中除主键外的数据。对于不同的记录，key值互不相同。一棵m阶的B-Tree有如下特性：
</div>

<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>每个节点最多有m个孩子。 </li>
    <li>除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 </li>
    <li>若根节点不是叶子节点，则至少有2个孩子 </li>
    <li>所有叶子节点都在同一层，且不包含其它关键字信息 </li>
    <li>每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） </li>
    <li>关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 </li>
    <li>ki(i=1,…n)为关键字，且关键字升序排序。 </li>
    <li>Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)</li>
</ul>

<div style="margin-top:.325em;">
B-Tree中的每个节点根据实际情况可以包含大量的关键字信息和分支，如下图所示为一个3阶的B-Tree： 
</div>

<div style="margin-top:.325em;">
  <img width="100%" src="/images/mysql/innodb-btree.jpg" />
</div>


<div style="margin-top:.625em;">
每个节点占用一个盘块的磁盘空间，一个节点上有两个升序排序的关键字和三个指向子树根节点的指针，指针存储的是子节点所在磁盘块的地址。两个关键词划分成的三个范围域对应三个指针指向的子树的数据的范围域。以根节点为例，关键字为17和35，P1指针指向的子树的数据范围为小于17，P2指针指向的子树的数据范围为17~35，P3指针指向的子树的数据范围为大于35。
</div>

<h4 style="margin-top:.625em;">模拟查找关键字29的过程：</h4>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>根据根节点找到磁盘块1，读入内存。【磁盘I/O操作第1次】</li>
    <li>比较关键字29在区间（17,35），找到磁盘块1的指针P2。</li>
    <li>根据P2指针找到磁盘块3，读入内存。【磁盘I/O操作第2次】</li>
    <li>比较关键字29在区间（26,30），找到磁盘块3的指针P2。</li>
    <li>根据P2指针找到磁盘块8，读入内存。【磁盘I/O操作第3次】</li>
    <li>在磁盘块8中的关键字列表中找到关键字29。</li>
</ul>


<div style="margin-top:.625em;">
分析上面过程，发现需要3次磁盘I/O操作，和3次内存查找操作。由于内存中的关键字是一个有序表结构，可以利用二分法查找提高效率。而3次磁盘I/O操作是影响整个B-Tree查找效率的决定因素。B-Tree相对于AVLTree缩减了节点个数，使每次磁盘I/O取到内存的数据都发挥了作用，从而提高了查询效率。
</div>


<h4 style="color:green;margin-top:1em;font-size:2.2em;">B+Tree</h4>

<div style="margin-top:.625em;">
B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。
</div>
<div style="margin-top:.625em;">
从上一节中的B-Tree结构图中可以看到每个节点中不仅包含数据的key值，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。在B+Tree中，所有数据记录节点都是按照键值大小顺序存放在同一层的叶子节点上，而非叶子节点上只存储key值信息，这样可以大大加大每个节点存储的key值数量，降低B+Tree的高度。
</div>

<h4 style="margin-top:.625em;">与B-Tree相比，B+Tree有以下不同点：</h4>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .3em;">
    <li>非叶子节点只存储键值信息。</li>
    <li>所有叶子节点之间都有一个链指针。</li>
    <li>数据记录都存放在叶子节点中。</li>
</ul>
<div style="margin-top:.625em;">
将上一节中的B-Tree优化，由于B+Tree的非叶子节点只存储键值信息，假设每个磁盘块能存储4个键值及指针信息，则变成B+Tree后其结构如下图所示： 
</div>

<div style="margin-top:.325em;">
  <img width="100%" src="/images/mysql/innodb-b+tree.png" />
</div>

<div style="margin-top:.625em;">
  通常在B+Tree上有两个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有叶子节点（即数据节点）之间是一种链式环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始，进行随机查找。
</div>
<div style="margin-top:.625em;">
  可能上面例子中只有22条数据记录，看不出B+Tree的优点，下面做一个推算：
</div>
<div style="margin-top:.625em;">
InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值（因为是估值，为方便计算，这里的K取值为〖10〗^3）。也就是说<b style="color:red;">一个深度为3的B+Tree索引可以维护10^3 * 10^3 * 10^3 = 10亿 条记录</b>。
</div>
<div style="margin-top:.625em;">
实际情况中每个节点可能不能填充满，因此在数据库中，B+Tree的高度一般都在2~4层。<b style="color:red;">mysql的InnoDB存储引擎在设计时是将根节点常驻内存的，也就是说查找某一键值的行记录时最多只需要1~3次磁盘I/O操作。</b>
</div>
<div style="margin-top:.625em;">
数据库中的B+Tree索引可以分为聚集索引（clustered index）和辅助索引（secondary index）。上面的B+Tree示例图在数据库中的实现即为聚集索引，<b style="color:red;">聚集索引的B+Tree中的叶子节点存放的是整张表的行记录数据</b>。<b style="color:blue;">辅助索引与聚集索引的区别在于辅助索引的叶子节点并不包含行记录的全部数据，而是存储相应行数据的聚集索引键，即主键</b>。当通过辅助索引来查询数据时，InnoDB存储引擎会遍历辅助索引找到主键，然后再通过主键在聚集索引中找到完整的行记录数据。
</div>

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>主存存取原理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
  <img width="380px" src="/images/mysql/primary-memary.png" />
</div>

<div style="margin-top:.625em;">
  从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。上图展示了一个4 x 4的主存模型。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
主存的存取过程如下：
</div>
<div style="margin-top:.325em;">
<b>当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</b>
</div>
<div style="margin-top:.325em;">
写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。
</div>
<div style="margin-top:.325em;">
这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>磁盘存取原理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
  <img width="380px" src="/images/mysql/disk.png" />
</div>

<div style="margin-top:.625em;">
  一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
下图是磁盘结构的示意图。
</div>

<div style="margin-top:.325em;">
  <img width="380px" src="/images/mysql/disk2.png" />
</div>

<div style="margin-top:.625em;">
  盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。
</div>

<div style="margin-top:.625em;">
当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="局部性原理与磁盘预读" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.325em;">
由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：
</div>

<div style="margin-top:.625em;">
当一个数据被用到时，其附近的数据也通常会马上被使用。
</div>

<div style="margin-top:.625em;">
程序运行期间所需要的数据通常比较集中。
</div>

<div style="margin-top:.625em;">
由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。
</div>

<div style="margin-top:.625em;">
预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL-InnoDB Compact 行记录格式</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="yb1.ibd" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
> create table yb1(
  t1 varchar(10),
  t2 varchar(10),
  t3 char(10),
  t4 varchar(10)
) row_format=compact;

> insert into yb1 values('a','bb','bb','ccc');
> insert into yb1 values('d','ee','ee','fff');
> insert into yb1 values('d',NULL,NULL,'fff');
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="hexdump -C -v yb1.ibd  > yb1.txt" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.65em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
0000c070  73 75 70 72 65 6d 75 6d  03 0a 02 01 00 00 00 10  |supremum........|
0000c080  00 2d 00 00 01 fa dd d5  00 00 00 00 39 ea a3 00  |.-..........9...|
0000c090  00 01 e8 01 10 61 62 62  62 62 20 20 20 20 20 20  |.....abbbb      |
0000c0a0  20 20 63 63 63 03 0a 02  01 00 00 00 18 00 2b 00  |  ccc.........+.|
0000c0b0  00 01 fa dd d6 00 00 00  00 39 eb a4 00 00 01 e9  |.........9......|
0000c0c0  01 10 64 65 65 65 65 20  20 20 20 20 20 20 20 66  |..deeee        f|
0000c0d0  66 66 03 01 06 00 00 20  ff 96 00 00 01 fa dd d7  |ff..... ........|
0000c0e0  00 00 00 00 39 f0 a7 00  00 01 ea 01 10 64 66 66  |....9........dff|
0000c0f0  66 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |f...............|
0000c100  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
0000c110  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
0000c120  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.65em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<pre>
第一行记录从0000c078开始：
03 0a 02 01 /* 变长字段长度列表，逆序的
               03表示t4字段的值ccc的长度，
               0a表示t3字段的长度，
               02表示t2字段的值bb的长度，
               01表示t1字段的值a的长度 */
00 /* NULL标志位，第一行没有NULL值 */
00 00 10 00 2d /* record header，固定5字节 */
00 00 01 fa dd d5 /* rowid，innodb自动创建，6个字节 */ 
00 00 00 00 39 ea /* 事务ID */
a3 00 00 01 e8 01 10 /* 回滚指针 */
61 /* 列1数据'a' */
62 62 /* 列2数据'bb' */
62 62 20 20 20 20 20 20 20 20  /* 列3数据'bb' (固定长度未完全使用时，使用0x20表示) */
63 63 63 /* 列4数据'ccc' */
</pre>
<pre style="margin-top:1em;">
第二行记录从0000c0a5开始：
03 0a 02 01 /* 变长字段长度列表，逆序的
               03表示t4字段的值fff的长度，
               0a表示t3字段的长度，
               02表示t2字段的值ee的长度，
               01表示t1字段的值d的长度 */
00 /* NULL标志位，第一行没有NULL值 */
00 00 18 00 2b /* record header，固定5字节 */
00 00 01 fa dd d6 /* rowid，innodb自动创建，6个字节 */ 
00 00 00 00 39 eb /* 事务ID */
a4 00 00 01 e9 01 10 /* 回滚指针 */
64 /* 列1数据'd' */
65 65 /* 列2数据'ee' */
65 65 20 20 20 20 20 20 20 20  /* 列3数据'ee' (固定长度未完全使用时，使用0x20表示) */
66 66 66 /* 列4数据'fff' */
</pre>
<pre style="margin-top:1em;">
第三行记录从0000c0d2开始：
03 01 /* 变长字段长度列表，逆序的
         03表示t4字段的值fff的长度，
         01表示t1字段的值d的长度 */
06 /* NULL标志位，第三行有NULL值。06换成二进制为00000110，表示第2,3列是null */
00 00 20 ff 96 /* record header，固定5字节 */
00 00 01 fa dd d7 /* rowid，innodb自动创建，6个字节 */ 
00 00 00 00 39 f0 /* 事务ID */
a7 00 00 01 ea 01 10 /* 回滚指针 */
64 /* 列1数据'd' */
64 64 64 /* 列4数据'fff' */
</pre>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Record Lock、Gap Lock 和 Next-Key Lock</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Record Lock" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  记录锁（Record Lock）是加到索引记录上的锁，假设我们存在下面的一张表 users：
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:.65em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
creEATE TABLE users (
   id INT NOT NULL AUTO_INCREMENT,
   last_name VARCHAR(255) NOT NULL,
   first_name VARCHAR(255),
   age INT,
   PRIMARY KEY(id),
   KEY(last_name),
   KEY(age)
);
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
如果我们使用 id 或者 last_name 作为 SQL 中 WHERE 语句的过滤条件，那么 InnoDB 就可以通过索引建立的 B+ 树找到行记录并添加索引，但是如果使用 first_name 作为过滤条件时，由于 InnoDB 不知道待修改的记录具体存放的位置，也无法对将要修改哪条记录提前做出判断就会锁定整个表。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Gap Lock" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  记录锁是在存储引擎中最为常见的锁，除了记录锁之外，InnoDB 中还存在间隙锁（Gap Lock），间隙锁是对索引记录中的一段连续区域的锁；当使用类似 SELECT * FROM users WHERE id BETWEEN 10 AND 20 FOR UPDATE; 的 SQL 语句时，就会阻止其他事务向表中插入 id=15 的记录，因为整个范围都被间隙锁锁定了。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Next-Key Lock" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  Next-Key 锁相比前两者就稍微有一些复杂，它是记录锁和记录前的间隙锁的结合，<b>Next-Key 锁定的是当前值和前面的范围</b>。假如在 users 表中有以下记录：
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
+------+-------------+--------------+-------+
|   id | last_name   | first_name   |   age |
|------+-------------+--------------+-------|
|    4 | stark       | tony         |    21 |
|    1 | tom         | hiddleston   |    30 |
|    3 | morgan      | freeman      |    40 |
|    5 | jeff        | dean         |    50 |
|    2 | donald      | trump        |    80 |
+------+-------------+--------------+-------+
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-top:.625em;">
如果使用 Next-Key 锁，那么 Next-Key 锁就可以在需要的时候锁定以下的范围：
</div>

<pre>
(-∞, 21]
(21, 30]
(30, 40]
(40, 50]
(50, 80]
(80, ∞)
</pre>

<div style="margin-top:.625em;">
当我们更新一条记录，比如 SELECT * FROM users WHERE age=30 FOR UPDATE;，InnoDB 不仅会在范围 (21,30] 上加 Next-Key 锁，还会在这条记录后面的范围 (30,40] 加间隙锁，所以插入 (21,40]范围内的记录都会被锁定。
</div>

<div style="margin-top:.325em;font-weight:bold;">
Next-Key 锁的作用其实是为了解决幻读的问题。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="死锁的发生" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
既然 InnoDB 中实现的锁是悲观的，那么不同事务之间就可能会互相等待对方释放锁造成死锁，最终导致事务发生错误；想要在 MySQL 中制造死锁的问题其实非常容易：
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session1
begin
select * from users where id=1 for update;
select * from users where id=2 for update;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session2
begin
select * from users where id=2 for update;
select * from users where id=1 for update;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:1em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
两个会话都持有一个锁，并且尝试获取对方的锁时就会发生死锁，不过 MySQL 也能在发生死锁时及时发现问题，并保证其中的一个事务能够正常工作，这对我们来说也是一个好消息。
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MySQL发生死锁有哪些原因</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<h4>MySQL有三种锁的级别: 页级、表级、行级。</h4>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top:.3em;">
    <li>表级锁: 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高, 并发度最低。</li>
    <li>行级锁: 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低, 并发度也最高。</li>
    <li>页面锁: 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间, 并发度一般。</li>
</ul>
<h4 style="margin-top:1em;">加锁算法:</h4>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top:.3em;">
    <li>next KeyLocks 锁，同时锁住记录(数据)，并且锁住记录前面的Gap。</li>
    <li>Gap 锁，不锁记录，仅仅记录前面的Gap。</li>
    <li>Recordlock 锁（锁数据，不锁Gap）。</li>
    <li>所以其实 Next-KeyLocks = Gap + Recordlock。</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="死锁产生原因和示例" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-top:.5em;">
所谓死锁: <br /> DeadLock 是指两个或两个以上的进程在执行过程中,因争夺资源而造成的一种互相等待的现象,若无外力作用，它们都将无法推进下去.此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。
</div>
<div style="margin-top:.5em;">
死锁的关键在于: <br />两个(或以上)的Session加锁的顺序不一致。
</div>
<div style="margin-top:.5em;">
那么对应的解决死锁问题的关键就是: <br />让不同的 session 加锁有次序
</div>

<h4 style="margin-top:1em;color:green;">查询当前数据库运行的所有事务</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
mysql> SELECT
  trx_mysql_thread_id,
  trx_id,
  trx_state,
  trx_started,
  trx_rows_locked,
  trx_query,
  trx_rows_locked,
  trx_isolation_level
FROM
  information_schema.innodb_trx;
</pre>

<h4 style="margin-top:1em;color:green;">Get list of IP addresses connected to MySQL DB, with their connection counts</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
mysql> SELECT
  tmp.ipAddress,
  -- Calculate how many connections are being held by this IP address.
  COUNT(*) AS numConnections,
  -- For each connection, the TIME column represent how many SECONDS it has been in
  -- its current state. Running some aggregates will give us a fuzzy picture of what
  -- the connections from this IP address is doing.
  FLOOR(AVG(tmp.time)) AS timeAVG,
  MAX(tmp.time) AS timeMAX
FROM
  -- Create an intermediary table that includes an additional column representing
  -- the client IP address without the port.
  (
    SELECT
      -- We don't actually need all of these columns but, including them here to
      -- demonstrate what fields COULD be used in the processlist system.
      pl.id,
      pl. USER,
      pl. HOST,
      pl.db,
      pl.command,
      pl.time,
      pl.state,
      pl.info,
      -- The host column is in the format of "IP:PORT". We want to strip off
      -- the port number so that we can group the results by the IP alone.
      LEFT (
        pl. HOST,
        (LOCATE(':', pl. HOST) - 1)
      ) AS ipAddress
    FROM
      INFORMATION_SCHEMA. PROCESSLIST pl
  ) AS tmp
GROUP BY
  tmp.ipAddress
ORDER BY
  numConnections DESC;
</pre>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="死锁 -- 案例一" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-top:.5em;">
需求：将投资的钱拆成几份随机分配给借款人。
</div>
<div style="margin-top:.5em;">
起初业务程序思路是这样的: 
</div>
<div style="margin-top:.5em;">
投资人投资后，将金额随机分为几份，然后随机从借款人表里面选几个，然后通过一条条 select for update 去更新借款人表里面的余额等。
</div>
<div style="margin-top:.5em;">
例如两个用户同时投资，A用户金额随机分为2份，分给借款人1，2
</div>
<div style="margin-top:.5em;">
B用户金额随机分为2份，分给借款人2，1
</div>
<div style="margin-top:.5em;">
由于加锁的顺序不一样，死锁当然很快就出现了。
</div>
<div style="margin-top:.5em;">
对于这个问题的改进很简单，直接把所有分配到的借款人直接一次锁住就行了。
</div>
<div style="margin-top:.5em;">
那么对应的解决死锁问题的关键就是: <br />让不同的 session 加锁有次序
</div>
<pre style="margin-top:.5em;padding:.625em .3em;background-color:black;color:white;font-size:.725em;">
> select * from t1 where id in (xx,xx,xx) for update
</pre>
<div style="margin-top:.5em;">
在 in 里面的列表值 mysql 是会自动从小到大排序，加锁也是一条条从小到大加的锁
</div>

<h4 style="margin-top:1em;color:green;">Session1:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
mysql> begin; select * from t3 where id in (8,9) for update;
 2.| +----+--------+------+---------------------+
 3.| | id | course | name | ctime               |
 4.| +----+--------+------+---------------------+
 5.| |  8 | WA     | f    | 2016-03-02 11:36:30 |
 6.| |  9 | JX     | f    | 2016-03-01 11:36:30 |
 7.| +----+--------+------+---------------------+
 8.| rows in set (0.04 sec)
</pre>

<h4 style="margin-top:1em;color:green;">Session2:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
mysql> begin; select * from t3 where id in (10,8,5) for update;
</pre>
<div style="margin-top:.5em;">
锁等待中 ……
</div>
<div style="margin-top:.5em;">
其实这个时候id=10这条记录没有被锁住的，但id=5的记录已经被锁住了，锁的等待在id=8的这里 不信请看
</div>

<h4 style="margin-top:1em;color:green;">Session3:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
mysql> begin; select * from t3 where id=5 for update;
</pre>
<div style="margin-top:.5em;">
锁等待中 ……
</div>

<h4 style="margin-top:1em;color:green;">Session4:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
mysql> begin; select * from t3 where id=10 for update;
 1.| +----+--------+------+---------------------+
 2.| | id | course | name | ctime               |
 3.| +----+--------+------+---------------------+
 4.| | 10 | JB     | g    | 2016-03-10 11:45:05 |
 5.| +----+--------+------+---------------------+
 6.| row in set (0.00 sec)
</pre>
<div style="margin-top:.5em;">
在其它 session中id=5 是加不了锁的，但是 id=10 是可以加上锁的。
</div>
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="死锁 -- 案例二" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:1em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div style="margin-top:.5em;">
在开发中, 经常会做这类的判断需求: 根据字段值查询（有索引）, 如果不存在, 则插入; 否则更新。
</div>
<div style="margin-top:.5em;">
以id为主键为例, 目前还没有id=22的行
</div>

<h4 style="margin-top:1em;color:green;">Session1:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
 1.| msql> begin; select * from t3 where id=22 for update;
 2.| Empty set (0.00 sec)
</pre>

<h4 style="margin-top:1em;color:green;">Session2:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
 1.| msql> begin;  select * from t3 where id=23 for update;
 2.| Empty set (0.00 sec)
</pre>

<h4 style="margin-top:1em;color:green;">Session1:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
 1.| msql> insert into t3 values(22,'ac','a',now());
</pre>
<div style="margin-top:.5em;">
锁等待中……
</div>

<h4 style="margin-top:1em;color:green;">Session2:</h4>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
 1.| msql> insert into t3 values(23,'bc','b',now());
</pre>
<div style="margin-top:.5em;">
ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
</div>
<div style="margin-top:.5em;">
当对存在的行进行锁的时候(主键)，mysql就只有行锁。
</div>
<div style="margin-top:.5em;">
当对未存在的行进行锁的时候(即使条件为主键)，mysql是会锁住一段范围（有gap锁）
</div>

<h4 style="margin-top:1em;color:green;">锁住的范围为: </h4>
<div style="margin-top:.5em;">
无穷小或小于表中锁住id的最大值，无穷大或大于表中锁住id的最小值
</div>
<div style="margin-top:.5em;">
如：如果表中目前有已有的id为 [11, 12]，那么就锁住 [12, 无穷大]
</div>
<div style="margin-top:.5em;">
如果表中目前已有的id为 [11, 30]，那么就锁住 [11, 30]
</div>
<div style="margin-top:.5em;">
对于这种死锁的解决办法是：
</div>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
 1.| msql> insert into t3(xx,xx) on duplicate key update `xx`='XX';
</pre>
<div style="margin-top:1.5em;">
用 mysql 特有的语法来解决此问题。因为 insert 语句对于主键来说，插入的行不管有没有存在，都会只有行锁。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>事务与隔离级别</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        事务的 ACID 四大特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）；
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
  事务的隔离性是数据库处理数据的几大基础之一，而隔离级别其实就是提供给用户用于在性能和可靠性做出选择和权衡的配置项。ISO 和 ANIS SQL 标准制定了四种事务隔离级别，而 InnoDB 遵循了 SQL92 标准中的四种隔离级别： 
  <br />
  <b>READ UNCOMMITED、 READ COMMITED、 REPEATABLE READ和 SERIALIZABLE；</b>
</div>

<h3>每个事务的隔离级别其实都比上一级多解决了一个问题：</h3>
<ul style="margin-left: 1.5em;list-style-type: disc;">
    <li><b>RAED UNCOMMITED</b> 使用查询语句不会加锁，可能会读到未提交的行（Dirty Read/脏读）；</li>
    <li><b>READ COMMITED</b> 只对记录加记录锁，而不会在记录之间加间隙锁，所以允许新的记录插入到被锁定记录的附近，所以再多次使用查询语句时，可能得到不同的结果（Non-Repeatable Read）；</li>
    <li><b>REPEATABLE READ</b> 多次读取同一范围的数据会返回第一次查询的快照，不会返回不同的数据行，但是可能发生幻读（Phantom Read）；</li>
    <li><b>SERIALIZABLE</b> InnoDB 隐式地将全部的查询语句加上共享锁，解决了幻读的问题；</li>
</ul>

<table style="color:darkgreen;margin:.5em 0;line-height:1.3em;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;font-weight: normal;">
            &nbsp;
            </td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">Dirty Read <br /> (脏读)</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:240px;">Non-Repeatable Read <br /> (不可重复读)</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">Phantom Read <br /> (幻读)</td>
            <td style="padding: 0;margin: 0;text-align: center;width:520px;padding:.5em 0;">&nbsp;</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;padding:.5em 0;">
            RAED UNCOMMITED
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;padding:.5em 0;">&radic;</td>
            <td style="padding: 0;margin: 0;text-align: center;vertical-align: middle;font-size: 1.5em;padding:.5em 0;">&radic;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;padding:.5em 0;">&radic;</td>
            <td style="font-size:.85em;padding: 0;margin: 0;text-align:left;padding:.5em 0;">
              事务能够看到其他事务没有提交的修改，当另一个事务又回滚了修改后的情况，又被称为脏读 dirty read
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;padding:.5em 0;">
            READ COMMITED
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;padding:.5em 0;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;padding:.5em 0;">&radic;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;padding:.5em 0;">&radic;</td>
            <td style="font-size:.85em;padding: 0;margin: 0;text-align:left;padding:.5em 0;">
              事务能够看到其他事务提交后的修改，这时会出现一个事务内两次读取数据可能因为其他事务提交的修改导致不一致的情况，称为不可重复读
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;padding:.5em 0;">
            REPEATABLE READ
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;padding:.5em 0;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;padding:.5em 0;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 1.5em;padding:.5em 0;">&radic;</td>
            <td style="vertical-align: middle;font-size:.85em;padding: 0;margin: 0;text-align:left;padding:.5em 0;">
              事务在两次读取时读取到的数据的状态是一致的, Phantom Read/幻读
            </td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align:right;font-weight: normal;padding:.5em 0;">
            SERIALIZABLE
            </td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;padding:.5em 0;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;padding:.5em 0;">&times;</td>
            <td style="vertical-align: middle;padding: 0;margin: 0;text-align: center;font-size: 2.2em;padding:.5em 0;">&times;</td>
            <td style="font-size:.85em;padding: 0;margin: 0;text-align:left;padding:.5em 0;">
              可重复读中可能出现第二次读读到第一次没有读到的数据，也就是被其他事务插入的数据，这种情况称为幻读phantom read, 该级别中不能出现幻读
            </td>
        </tr>
    </tbody>
</table>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="脏读" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
当事务的隔离级别为 READ UNCOMMITED 时，我们在 SESSION2 中插入的未提交数据在 SESSION1 中是可以访问的。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="不可重复读" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
当事务的隔离级别为 READ COMMITED 时，虽然解决了脏读的问题，但是如果在 SESSION1 先查询了一个范围的数据，在这之后 SESSION2 中插入一条数据并且提交了修改，在这时，如果 SESSION1 中再次使用相同的查询语句，就会发现两次查询的结果不一样。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session1
> begin
> select * from users where id < 5;
> sleep(2000) # 此时另一个session2插入了一条数据
> select * from users where id < 5; # READ COMMITED 的隔离级别下, 两次可能读到不同的结果　
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session2
> begin
> insert into values (4);
> commit
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
不可重复读的原因就是，在 READ COMMITED 的隔离级别下，存储引擎不会在查询记录时添加间隙锁，锁定 id<5 这个范围。
</div>
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="幻读" id="sourceContent1"
                     style="background-color:white;margin-top:.325em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
重新开启了两个会话 SESSION1 和 SESSION2，在 SESSION1中我们查询全表的信息，没有得到任何记录；在 SESSION2中向表中插入一条数据并提交；由于 REPEATABLE READ 的原因，再次查询全表的数据时，我们获得到的仍然是空集，但是在向表中插入同样的数据却出现了错误。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session1
> begin
> select * from users;
> sleep(2000) # 此时另一个session2插入了一条数据并
> select * from users;
> insert into values (1);
> Duplicate entry '1' for 'id'
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
session2
> begin
> insert into values (1);
> commit
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="" id="sourceContent1"
                     style="background-color:white;margin-top:.625em;"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
这种现象在数据库中就被称作幻读，虽然我们使用查询语句得到了一个空的集合，但是插入数据时却得到了错误，好像之前的查询是幻觉一样。
在标准的事务隔离级别中，幻读是由更高的隔离级别 SERIALIZABLE 解决的，但是它也可以通过 MySQL 提供的 Next-Key 锁解决：
</div>
<div style="margin-top:.325em;">
<b>REPERATABLE READ 和 READ UNCOMMITED 其实是矛盾的，如果保证了前者就看不到已经提交的事务，如果保证了后者，就会导致两次查询的结果不同</b>，MySQL 为我们提供了一种折中的方式，能够在 REPERATABLE READ 模式下加锁访问已经提交的数据，其本身并不能解决幻读的问题，而是通过文章前面提到的 Next-Key 锁来解决。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>mysql MVCC原理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
<div>
MVCC多版本控制: 指的是一种提高并发的技术。最早的数据库系统，<b>只有读读之间可以并发，读写，写读，写写都要阻塞</b>。<b style="color:blue;">引入多版本之后，只有写写之间相互阻塞，其他三种操作都可以并行</b>，这样大幅度提高了InnoDB的并发度。在内部实现中，与Postgres在数据行上实现多版本不同，<b style="color:red;">InnoDB是在undolog中实现的，通过undolog可以找回数据的历史版本</b>。找回的数据历史版本可以提供给用户读(按照隔离级别的定义，有些读请求只能看到比较老的数据版本)，也可以在回滚的时候覆盖数据页上的数据。在InnoDB内部中，会记录一个全局的活跃读写事务数组，其主要用来判断事务的可见性。
</div>

<div style="margin-top:.625em;">
MySQL的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。不仅仅是MySQL，包括Oracle，PostgreSQL等其他数据库系统也都实现了MVCC，但是各自的实现机制并不相同，因为MVCC并没有一个统一的标准。MVCC在很多情况下避免了加锁操作，因此开销更低。<b>大多数的MVCC都实现了非阻塞的读操作，写操作也只锁定必要的行。</b>
</div>

<div style="margin-top:.625em;">
MVCC的实现，是通过保存数据在某个时间点的快照来实现的。也就是说，不管需要执行多长时间，每个事务看到的数据是一致的。根据事务开始的时间不同，每个事物对同一张表，同一时刻看到的数据可能是不一样的。不同存储引擎的MVCC实现是不同的，典型的有乐观（optimistic）并发控制和悲观（pessimistic）并发控制。
</div>

<div style="margin-top:.625em;">
MVCC只在REPEATABLE READ和READ COMMITTED两个隔离级别下工作。其他两个隔离级别都和MVCC不兼容，因为READ UNCOMMITTED总是读取最新的数据行，而不是符合当前事务版本的数据行，而SERIALIZABLE会对所有读取到的行都加锁。
</div>
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>MyBatis 3.2.x版本在并发情况下可能出现的bug及解决办法</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
        
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="我们基于Spring的Web项目使用的MyBatis版本是3.2.3，有一天忽然发现出现了很神奇的异常，如下：" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.builder.BuilderException: Error evaluating expression 'searchParam.numbers != null and searchParam.numbers.size() > 0'. Cause: org.apache.ibatis.ognl.MethodFailedException: Method "size" failed for object [111] [java.lang.IllegalAccessException: Class org.apache.ibatis.ognl.OgnlRuntime can not access a member of class java.util.Collections$SingletonList with modifiers "public"]
        at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:75) ~[mybatis-spring-1.2.1.jar:1.2.1]
        at org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:368) ~[mybatis-spring-1.2.1.jar:1.2.1]
        at com.sun.proxy.$Proxy26.selectList(Unknown Source) ~[na:na]
        at org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:198) ~[mybatis-spring-1.2.1.jar:1.2.1]
        at org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:114) ~[mybatis-3.2.3.jar:3.2.3]
        at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:58) ~[mybatis-3.2.3.jar:3.2.3]
        at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:43) ~[mybatis-3.2.3.jar:3.2.3]
        at com.sun.proxy.$Proxy55.query(Unknown Source) ~[na:na]
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
觉得很奇怪，因为这个size方法是public的，怎么就没法调用呢？而且并不是每次都出现，推断不是写法的问题。那问题到底出现在哪里呢？发现当处理比较频繁的时候，出现问题的概率较大（但也就每天几个十几个，平时是几天一次）。
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="3.2.3版本使用的OGNL版本是2.6.9，该版本在并发时存在bug，如下面的测试程序：" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
import org.apache.ibatis.scripting.xmltags.ExpressionEvaluator;
import org.junit.Assert;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.junit.runners.JUnit4;
 
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicInteger;
 
@RunWith(JUnit4.class)
public class OgnlConcurrentTest {
 
    private ExpressionEvaluator evaluator = new ExpressionEvaluator();
 
    @Test
    public void testConcurrent() throws InterruptedException {
        final CountDownLatch start = new CountDownLatch(1);
        final CountDownLatch count = new CountDownLatch(100);
 
        final AtomicInteger errorCount = new AtomicInteger();
 
        final List<String> list = new ArrayList<>();
        list.add("one");
        list.add("two");
 
        for (int i = 0; i < 100; i++) {
            new Thread(new Runnable() {
                @Override
                public void run() {
                    try {
                        start.await();
                    } catch (Exception ignored) {
                    }
 
                    for (int j = 0; j < 100; j++) {
                        try {
                            evaluator.evaluateBoolean("size() > 0", Collections.unmodifiableList(list));
                        } catch (Exception e) {
                            e.printStackTrace();
                            errorCount.incrementAndGet();
                        }
                    }
 
                    count.countDown();
                }
            }).start();
        }
 
        start.countDown();
        count.await();
 
        Assert.assertEquals(0, errorCount.get());
    }
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="程序每次运行结果不同，但基本都会报错，输出截取部分如下：" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
org.apache.ibatis.builder.BuilderException: Error evaluating expression 'size() > 0'. Cause: org.apache.ibatis.ognl.MethodFailedException: Method "size" failed for object [one, two] [java.lang.IllegalAccessException: Class org.apache.ibatis.ognl.OgnlRuntime can not access a member of class java.util.Collections$UnmodifiableCollection with modifiers "public"]
  at org.apache.ibatis.scripting.xmltags.OgnlCache.getValue(OgnlCache.java:47)
  at org.apache.ibatis.scripting.xmltags.ExpressionEvaluator.evaluateBoolean(ExpressionEvaluator.java:29)
  at OgnlConcurrentTest$1.run(OgnlConcurrentTest.java:51)
  at java.lang.Thread.run(Thread.java:745)
Caused by: org.apache.ibatis.ognl.MethodFailedException: Method "size" failed for object [one, two] [java.lang.IllegalAccessException: Class org.apache.ibatis.ognl.OgnlRuntime can not access a member of class java.util.Collections$UnmodifiableCollection with modifiers "public"]
  at org.apache.ibatis.ognl.OgnlRuntime.callAppropriateMethod(OgnlRuntime.java:837)
  at org.apache.ibatis.ognl.ObjectMethodAccessor.callMethod(ObjectMethodAccessor.java:61)
  at org.apache.ibatis.ognl.OgnlRuntime.callMethod(OgnlRuntime.java:860)
  at org.apache.ibatis.ognl.ASTMethod.getValueBody(ASTMethod.java:73)
  at org.apache.ibatis.ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:170)
  at org.apache.ibatis.ognl.SimpleNode.getValue(SimpleNode.java:210)
  at org.apache.ibatis.ognl.ASTGreater.getValueBody(ASTGreater.java:49)
  at org.apache.ibatis.ognl.SimpleNode.evaluateGetValueBody(SimpleNode.java:170)
  at org.apache.ibatis.ognl.SimpleNode.getValue(SimpleNode.java:210)
  at org.apache.ibatis.ognl.Ognl.getValue(Ognl.java:333)
  at org.apache.ibatis.ognl.Ognl.getValue(Ognl.java:413)
  at org.apache.ibatis.ognl.Ognl.getValue(Ognl.java:395)
  at org.apache.ibatis.scripting.xmltags.OgnlCache.getValue(OgnlCache.java:45)
  ... 3 more

java.lang.AssertionError: 
Expected :0
Actual   :42
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="问题出现在OgnlRuntime.invokeMethod方法的实现上，该方法如下：" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
public static Object invokeMethod(Object target, Method method, Object[] argsArray) 
            throws InvocationTargetException, IllegalAccessException {
  boolean wasAccessible = true;
  if(securityManager != null) {
    try {
      securityManager.checkPermission(getPermission(method));
    } catch (SecurityException var6) {
      throw new IllegalAccessException("Method [" + method + "] cannot be accessed.");
    }
  }
 
  if(
    (!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) 
    && !(wasAccessible = method.isAccessible())
  ) {
    method.setAccessible(true); // 第13行
  }
 
  Object result = method.invoke(target, argsArray); // 第15行
  if(!wasAccessible) {
    method.setAccessible(false); // 第17行
  }
 
  return result;
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
上面出问题的两种 List 都是 Collections 类里面的内部类，访问修饰符都不是 public（一个是private，另一个是默认），这样 method.isAccessible() 的结果就是 false。
</div>
<div style="margin-top:.625em;">
假设有两个线程 t1 和 t2，t2 执行到第 13 行的时候，t1 正好执行了第17行，此时 t2 再执行第15行的时候，就会报错了。
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="OGNL在2.7版本修复了这个问题（MyBatis在3.3.x版本升级了OGNL），对这部分加上了同步，最新实现（ognl-3.1.8）如下：" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
public static Object invokeMethod(Object target, Method method, Object[] argsArray) throws InvocationTargetException, IllegalAccessException {
  boolean syncInvoke = false;
  boolean checkPermission = false;
  synchronized(method) {
    if(_methodAccessCache.get(method) == null || _methodAccessCache.get(method) == Boolean.TRUE) {
      syncInvoke = true;
    }
 
    if(_securityManager != null && _methodPermCache.get(method) == null || _methodPermCache.get(method) == Boolean.FALSE) {
      checkPermission = true;
    }
  }
 
  boolean wasAccessible = true;
  Object result;
  if(syncInvoke) {
    synchronized(method) {
      if(checkPermission) {
        try {
          _securityManager.checkPermission(getPermission(method));
          _methodPermCache.put(method, Boolean.TRUE);
        } catch (SecurityException var11) {
          _methodPermCache.put(method, Boolean.FALSE);
          throw new IllegalAccessException("Method [" + method + "] cannot be accessed.");
        }
      }
 
      if(Modifier.isPublic(method.getModifiers()) && Modifier.isPublic(method.getDeclaringClass().getModifiers())) {
        _methodAccessCache.put(method, Boolean.FALSE);
      } else if(!(wasAccessible = method.isAccessible())) {
        method.setAccessible(true);
        _methodAccessCache.put(method, Boolean.TRUE);
      } else {
        _methodAccessCache.put(method, Boolean.FALSE);
      }
 
      result = method.invoke(target, argsArray);
      if(!wasAccessible) {
        method.setAccessible(false);
      }
    }
  } else {
    if(checkPermission) {
      try {
        _securityManager.checkPermission(getPermission(method));
        _methodPermCache.put(method, Boolean.TRUE);
      } catch (SecurityException var10) {
        _methodPermCache.put(method, Boolean.FALSE);
        throw new IllegalAccessException("Method [" + method + "] cannot be accessed.");
      }
    }
 
    result = method.invoke(target, argsArray);
  }
 
  return result;
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.425em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
代码有些长，不过主要思想就是加上了同步，剩下的就是考虑只在需要同步的时候才同步，避免影响性能。
</div>
<div style="margin-top:.625em;">
全局有一个_methodAccessCache，保存了方法与访问权限的映射关系。当_methodAccessCache.get(method) == null时，表示是第一次遇到这个方法，此时需要同步校验；当_methodAccessCache.get(method) == Boolean.TRUE表示之前遇到过，且并不是可访问的（需要人工设置可访问，访问后再还原），此时需要同步校验；除了上面这两种情况，就不需要同步了。
</div>
<div style="margin-top:.625em;">
最终我们是通过升级MyBatis解决的这个问题，我们将MyBatis升级到最新的3.4.1版本，同时也需要将mybatis-spring升级到1.3.0版本。
</div>
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>InnoDB database deadlock problem handling</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
       <a style="font-size:1.125em;" href="https://ofstack.com/MySQL/30870/innodb-database-deadlock-problem-handling.html">https://ofstack.com/MySQL/30870/innodb-database-deadlock-problem-handling.html</a>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Scene description" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="background-color:white;padding:0;font-size:1em;line-height:1.325em;font-family:monospace;">
      <![CDATA[
The DeadlockLoserDataAccessException anomaly occurs in the update table (Deadlock found when trying to get lock; try restarting transaction...) .
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Problem analysis" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;">
      <![CDATA[
This exception does not affect user usage because the database automatically rolls back and retries when it encounters a deadlock. The user's perception is that the operation is slightly delayed. However, the monitor is always reporting exceptions, so it needs to be solved 1 time.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="The solution" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
Use ES24en-ES25en where update is in your application.
I encapsulate 1 function myself, as follows.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
/**
   * 2016-03-15
   * linxuan
   * handle deadlock while update table
   */
  private void updateWithDeadLock(TestMapper mapper, Test record) throws InterruptedException {
    boolean oops;
    int retries = 5;
    do{
      oops = false;
      try{
        mapper.updateByPrimaryKeySelective(record);
      }
      catch (DeadlockLoserDataAccessException dlEx){
        oops = true;
        Thread.sleep((long) (Math.random() * 500));
      }
      finally {
      }
    } while(oops == true && retries-- >0);
  }

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="The solution" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;">
      <![CDATA[
<div>
I'm using mybatis, so I'll just pass mapper into the function, but if I don't use mybatis, I'll have to create and close the database connection myself.
</div>
<div style="margin-top:.325em;">
Extension: Database deadlock
</div>
<div style="margin-top:.325em;">
Database deadlocks are a common problem for transactional databases such as SQL Server, MySql, etc. Unless the database deadlock problem occurs frequently and the user is unable to operate, the database deadlock problem is generally not serious. Just do ES41en-ES42en in your application. So how do data deadlocks occur?
</div>
<div style="margin-top:.325em;">
InnoDB implements row locks (row level lock), divided into shared locks (S) and mutex locks (X).
</div>
<div style="margin-top:.325em;">
&#x2460; The shared lock is used for transaction read1 rows.
</div>
<div style="margin-top:.325em;">
&#x2461; The mutex is used for transaction update or delete1 lines.
</div>
<div style="margin-top:.325em;">
When client A holds the shared lock S and requests the mutex X; At the same time, client B holds the mutex X and requests the shared lock S. In this case, a database deadlock can occur. If that's not clear enough, here's an example.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Database deadlock example" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;">
      <![CDATA[
First, client A creates a table T and inserts a piece of data into T. Client A starts an select transaction, so hold the shared lock S.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
mysql> CREATE TABLE t (i INT) ENGINE = InnoDB;
Query OK, 0 rows affected (1.07 sec)

mysql> INSERT INTO t (i) VALUES(1);
Query OK, 1 row affected (0.09 sec)

mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql> SELECT * FROM t WHERE i = 1 LOCK IN SHARE MODE;
+------+
| i  |
+------+
|  1 |
+------+

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
Client B then starts a new transaction, which is the only 11 pieces of data in delete table T.    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

mysql> START TRANSACTION;
Query OK, 0 rows affected (0.00 sec)

mysql> DELETE FROM t WHERE i = 1;

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
The delete operation requires a mutex (X), but the mutex X and the shared lock S are incompatible. So the delete transaction is placed in the lock request queue and client B blocks.
</div>
<div style="margin-top:.325em;">
Finally, customer A also wants to delete that data in table T:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[

mysql> DELETE FROM t WHERE i = 1;
ERROR 1213 (40001): Deadlock found when trying to get lock;
try restarting transaction

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
Deadlocks are created! Because client A needs to lock X to delete rows, client B holds the lock X and is waiting for client A to release the lock S. Check the status of client A and B:
</div>
<div style="margin-top:.325em;">
&#x2460; Client A: Hold the lock S and wait for client B to release the lock X.
</div>
<div style="margin-top:.325em;">
&#x2461; Client B: Holding the lock X, waiting for client A to release the lock S.
</div>
<div style="margin-top:.325em;">
When a deadlock occurs, InnoDB generates an error message for one customer and releases the lock. Information returned to the customer:
</div>
<div style="margin-top:.325em;">
ERROR 1213 (40001): Deadlock found when trying to get lock;
</div>
<div style="margin-top:.325em;">
try restarting transaction
</div>
<div style="margin-top:.325em;">
Therefore, the other customer can perform the task normally. Deadlock over.
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>隔离级别、幻读、Gap Lock、Next-Key Lock</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
       <a style="font-size:1.125em;" href="https://wjrsbu.smartapps.cn/zhihu/article?id=402591869&isShared=1&_swebfr=1&_swebFromHost=heytapbrowserstack.com/MySQL/30870/innodb-database-deadlock-problem-handling.html">https://wjrsbu.smartapps.cn/zhihu/article?id=402591869&isShared=1&_swebfr=1&_swebFromHost=heytapbrowser</a>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="锁" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
首先，对于Mysql来说实现了两种行级锁：
</div>
<div style="margin-top:.325em;">
共享锁：允许事务读一行数据，一般记为S，也称为读锁
</div>
<div style="margin-top:.325em;">
排他锁：允许事务删除或者更新一行数据，一般记为X，也称为写锁
</div>
<div style="margin-top:.325em;">
关于读写锁的互斥性，应该都很清楚，读锁只能和读锁兼容，其他场景都无法兼容。
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock.jpeg" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="隔离级别" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
继续回顾下关于Mysql的4个隔离级别：
</div>
<div style="margin-top:.325em;">
<b>读未提交 Read Uncommitted: </b>能读到其他事务还没有提交的数据，这种现象叫做脏读。
</div>
<div style="margin-top:.325em;">
<b>读已提交 Read Committed: </b> 只会读取其他事务已经提交的数据，所以不会产生RC的脏读问题。所以又带来一个问题叫做不可重复读，一个事务中两次一样的SQL查询可能查到的结果不一样。
</div>
<div style="margin-top:.325em;">
<b>可重复读 Repeatable Read: </b>RR是Mysql的默认隔离级别，一个事务中两次SQL查询总是会查到一样的结果，不存在不可重复读的问题，但是还是会有幻读的问题。
</div>
<div style="margin-top:.325em;">
<b>串行 Serializable: </b> 串行场景没有任何问题，完全串行化的操作，读加读锁，写加写锁。
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock-2.jpeg" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="幻读、Next-Key Lock、MVCC" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
简单的回顾完了基础，那么我们看看RR级别下还会存在的幻读到底是什么问题，Mysql官方文档这样描述的：
</div>
<div style="margin-top:.325em;">
The so-called phantom problem occurs within a transaction when the same query produces different sets of rows at different times. For example, if a SELECT is executed twice, but returns a row the second time that was not returned the first time, the row is a “phantom” row.
</div>
<div style="margin-top:.325em;">
翻译过来就是，幻读指的是同一事务下，不同的时间点，同样的查询，得到不同的行记录的集合。
</div>
<div style="margin-top:.325em;">
如果说一个select执行了两次，但是第二次比第一次多出来行记录，这就是幻读。
</div>
<div style="margin-top:.325em;">
所以，对于幻读来说那一定是新增插入的数据！
</div>
<div style="margin-top:.325em;">
比如说在一个事务内，先查询 select * from user where age=10 for update，得到的结果是id为[1,2,3]的记录，再次执行查询，得到了结果为[1,2,3,4]的记录，这是幻读。
</div>
<div style="margin-top:.325em;">
那怎么解决幻读的问题？以前我在文章里说解决幻读的原理是MVCC（MVCC原理看这里）很多网上的文章也有这么写的，其实不能说错，但是肯定也是不太对的，准确地来说应该是通过MVCC+Next-Key Lock的方式才解决了幻读的问题。
</div>
<div style="margin-top:.325em;">
对于 MVCC 中的读可以分为两种，分别叫做快照读和当前读(这个当前读的说法我在书里翻了半天也没有找到，但是看网上一堆资料和大佬都叫当前读，那么我们就叫当前读吧，你知道的话可以告诉我哪本书有这个称呼，Mysql 我只看见 Lock reading 或者锁定读的叫法，有的也说锁定读就是当前读，但是并没有找到当前读这种称呼的出处在哪儿)。
</div>
<div style="margin-top:.325em;">
快照读就是简单的 select 查询，查询的都是快照版本，这个场景下因为都是基于MVCC来查询快照的某个版本，所以不会存在幻读的问题，也可以认为是解决了幻读的方案之一，对于 RC 级别来说，因为每次查询都重新生成一个 read view， 也就是查询的都是最新的快照数据，所以会可能每次查询到不一样的数据，造成不可重复读，而对于RR级别来说只有第一次的时候生成 read view， 查询的是事务开始的时候的快照数据，所以就不存在不可重复读的问题，当然就更不可能有幻读的问题了。
</div>
<div style="margin-top:.325em;">
所以，现在我们说幻读，其实不是指快照读的场景，而是指的是当前读的场景。
</div>
<div style="margin-top:.325em;">
当前读指的是 lock in share mode、for update 、insert、update、delete 这些需要加锁的操作。对于MVCC来说就是解决的快照读的场景，而对于当前读那么就是 Next-Key Lock 要解决的事情。
</div>
<div style="margin-top:.325em;">
那么 Next-Key Lock 是什么？怎么解决的幻读？
</div>
<div style="margin-top:.325em;">
行锁有写锁X和读锁S两种，实际上行锁有3种实现算法，Next-Key Lock 是其中之一。
</div>
<div style="margin-top:.325em;">
第一种叫做 Record Lock，字面意思，行记录的锁，实际上指的是对索引记录的锁定。
</div>
<div style="margin-top:.325em;">
比如执行语句 select * from user where age=10 for update，将会锁住 user 表所有 age=10 的行记录，所有对 age=10 的记录的操作都会被阻塞。
</div>
<div style="margin-top:.325em;">
第二种都比较熟悉，叫做 Gap Lock，也就是间隙锁，它用于锁定的索引之间的间隙，但是不会包含记录本身。
</div>
<div style="margin-top:.325em;">
比如语句 select * from user where age>1 and age<10 for update，将会锁住 age 在(1,10)的范围区间，此时其他事务对该区间的操作都会被阻塞。
</div>
<div style="margin-top:.325em;">
间隙锁是可重复读 RR 隔离级别下特有的，另外还有几种场景也会不使用间隙锁。
</div>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .625em;">
    <li style="margin-top:.325em;">事务隔离级别设置为不可重复读RC ，这样肯定没有间隙锁了。</li>
    <li style="margin-top:.325em;">Innodb_locks_unsafe_for_binlog 设置为 1</li>
    <li style="margin-top:.325em;">另外一种情况适用于主键索引或者唯一索引的等值查询条件，比如 select * from user where id=1，id 是主键索引，这样只使用 Record Lock 就可以了，因为能唯一锁定一条记录，所以没有必要再加间隙锁了，这是锁降级的过程。</li>
</ul>
<div style="margin-top:.325em;">
而第三种 Next-Key Lock 实际上就是相当于 Record Lock+Gap Lock 的组合。比如索引有10，20，30几个值，那么被锁住的区间可能会是(-∞,10]，(10,20]，(20,30]，(30,+∞)。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="解决幻读" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
上一篇关于更新 SQL 执行过程我们已经对这个基础有了一定的了解，在这里我们去掉和这里内容无关的一些日志的细节，把给数据加锁的流程加入进去，这样通过 SQL 执行可以更好地理解 Next-Key Lock 到底是如何解决幻读的，执行过程如下：
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock-3.jpeg" />
</div>
<ul style="margin-left: 1.5em;list-style-type: disc;margin-top: .625em;">
    <li style="margin-top:.325em;">首先第一步 Server 层会来查询数据</li>
    <li style="margin-top:.325em;">存储引擎根据查询条件查到数据之后对数据进行加锁，Record Lock 或者间隙锁，然后返回数据</li>
    <li style="margin-top:.325em;">Server 层拿到数据之后调用 API 去存储引擎更新数据</li>
    <li style="margin-top:.325em;">最后存储引擎返回结果，流程结束</li>
</ul>
<div style="margin-top:.325em;">
搞一张表说明一下，user 表有 4 个字段，id 是主键索引，name 是唯一索引，age 是普通索引，city 没有索引，然后插入一些测试数据，下面区分一下几种情况来说明是怎么加 Next-Key Lock 的，然后就知道为啥会没有幻读的问题了。
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock-4.jpeg" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="没有索引" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
更新语句 update user set city='nanjing' where city='wuhan' 会发生什么？
</div>
<div style="margin-top:.325em;">
因为 city 是没有索引的，所以存储引擎只能给所有的记录都加上锁，然后把数据都返回给 Server 层，然后 Server 层把 city 改成 nanjing，再更新数据。
</div>
<div style="margin-top:.325em;">
因此，首先 Record Lock 会锁住现有的7条记录，间隙锁则会对主键索引的间隙全部加上间隙锁。
</div>
<div style="margin-top:.325em;">
所以，更新的时候没有索引是非常可怕的一件事情，相当于把整个表都给锁了，那表都给锁了当然不存在幻读了。
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock-5.jpeg" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="普通索引" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
我们再假设一个语句 select * from user where age=20 for update。
</div>
<div style="margin-top:.325em;">
因为 age 是一个普通索引，存储引擎根据条件过滤查到所有匹配age=20的记录，给他们加上写锁，间隙锁会加在(10,20)，(20,30)的区间上，因此现在无论怎样都无法插入age=20的记录了
</div>
<div style="margin-top:.325em;">
为什么要锁定这两个区间？如果不锁定这两个区间的话，那么还能插入比如id=11,age=20或者id=21,age=20的记录，这样就存在幻读了。
</div>
<div style="margin-top:.325em;">
（那实际上写锁不光是在会加在age普通索引上，还会加在主键索引上，因为数据都是在主键索引下对吧，这个肯定也要加锁的，为了看起来简单点，就不画出来了）
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock-6.jpeg" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="唯一&amp;主键索引" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
如果查询的是唯一索引又会发生什么呢？比如有查询语句 select * from user where name='b' for update。
</div>
<div style="margin-top:.325em;">
上面我们提到过，如果是唯一索引或者主键索引的话，并且是等值查询，实际上会发生锁降级，降级为 Record Lock，就不会有间隙锁了。
</div>
<div style="margin-top:.325em;">
因为主键或者唯一索引能保证值是唯一的，所以也就不需要再增加间隙锁了。
</div>
<div style="margin-top:.325em;">
很显然，是无法插入name=b的的记录的，也不存在幻读问题。
</div>
<div style="margin-top:.325em;">
如果是范围查询比如id>1 and id<11呢，实际上也是一样的锁定方式，不再赘述。
</div>
<div style="margin-top:.325em;">
相比稍微有点不同的是上面也说过，唯一索引不光锁定唯一索引，还会锁定主键索引，主键索引的话只要索引主键索引就行了。
</div>
<div style="margin-top:.325em;">
<img width="430px" src="/images/mysql/mysql-lock-7.jpeg" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="总结" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.325em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
那最后说了这么多，RR级别下不是都已经解决了幻读的问题吗，怎么还说有幻读的问题呢？
</div>
<div style="margin-top:.325em;">
关于这个问题，可以看看这个报出的 BUG https://bugs.mysql.com/bug.php?id=63870，回复说了这不是BUG，这是符合隔离规范的设计，有兴趣的自己看看吧。
</div>
<div style="margin-top:.325em;">
<img width="630px" src="/images/mysql/mysql-lock-8.jpeg" />
</div>
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>保姆级教程！2 万字 + 30 张图搞懂 MySQL 是怎么加行级锁的？</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
       <a style="font-size:1.125em;" href="https://mp.weixin.qq.com/s/QhtwEgUfxsYlZBsIfLGIgg">https://mp.weixin.qq.com/s/QhtwEgUfxsYlZBsIfLGIgg</a>
        ]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
是不是很多人都对 MySQL 加行级锁的规则搞的迷迷糊糊，对记录一会加的是 next-key 锁，一会加是间隙锁，一会又是记录锁。
</div>
<div style="margin-top:.325em;">
坦白说，确实还挺复杂的，但是好在我找点了点规律，也知道如何用命令分析加了什么类型的行级锁。
</div>
<div style="margin-top:.625em;">
为了说清楚这三件事情：
</div>

<ul style="margin-left: 2.5em;list-style-type: decimal;margin-top: .3em;">
  <li>MySQL 是怎么加行级锁的？有什么规则？</li>
  <li>为什么 MySQL 要这么加行级锁？</li>
  <li>如何用命令分析加了什么行级锁？</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="什么 SQL 语句会加行级锁？" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:1.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁，所以后面的内容都是基于 InnoDB 引擎的。
</div>
<div style="margin-top:.325em;">
所以，在说 MySQL 是怎么加行级锁的时候，其实是在说 InnoDB 引擎是怎么加行级锁的。
</div>
<div style="margin-top:.325em;">
普通的 select 语句是不会对记录加锁的，因为它属于快照读，是通过  MVCC（多版本并发控制）实现的。
</div>
<div style="margin-top:.325em;">
如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为<b>锁定读</b>。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
// 对读取的记录加共享锁(S型锁)
select ... lock in share mode;
// 对读取的记录加独占锁(X型锁)
select ... for update;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:0em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
上面这两条语句必须在一个事务中，因为当事务提交了，锁就会被释放，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。
</div>
<div style="margin-top:.325em;">
** 除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁) **。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
// 对操作的记录加独占锁(X型锁)
updaet table .... where id = 1;
// 对操作的记录加独占锁(X型锁)
delete from table where id = 1;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:0em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。
</div>

<table style="color:black;margin:.5em 0;line-height:1.3em;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;font-weight: normal;">
            &nbsp;
            </td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">X</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:240px;">S</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">X</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">不兼容</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:240px;">不兼容</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">S</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:120px;">不兼容</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;width:240px;">兼容</td>
        </tr>
    </tbody>
</table>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="行级锁有哪些种类？" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:1.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
不同隔离级别下，行级锁的种类是不同的。
</div>
<div style="margin-top:.325em;">
在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。
</div>
<div style="margin-top:.325em;">
在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：
</div>

<ul style="margin-left: 2.5em;list-style-type: decimal;margin-top: .625em;">
  <li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li>
  <li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li>
  <li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li>
</ul>

<h3 style="color:green;">Record Lock</h3>
<div style="margin-top:.325em;">
Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：
</div>

<ul style="margin-left: 2.5em;list-style-type: decimal;margin-top: .625em;">
  <li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li>
  <li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li>
</ul>

<div style="margin-top:.325em;">
举个例子，当一个事务执行了下面这条语句：
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
mysql > begin;
mysql > select * from t_test where id = 1 for update;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:0em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
事务会对表中主键 id = 1 的这条记录加上 X 型的记录锁，如果这时候其他事务对这条记录进行删除或者更新操作，那么这些操作都会被阻塞。注意，其他事务插入一条 id = 1 的新记录并不会被阻塞，而是会报主键冲突的错误，这是因为主键有唯一性的约束。
</div>

<div style="margin-top:.325em;">
当事务执行 commit 后，事务过程中生成的锁都会被释放。
</div>

<h3 style="color:green;">Gap Lock</h3>
<div>
Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
</div>

<div style="margin-top:.325em;">
假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。
</div>

<div style="margin-top:.325em;">
间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
</div>

<h3 style="color:green;">Next-Key Lock</h3>

<div style="margin-top:.325em;">
Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。
</div>

<div style="margin-top:.325em;">
假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改和删除 id = 5 这条记录。
</div>

<div style="margin-top:.325em;">
所以，next-key lock 即能保护该记录，又能阻止其他事务将新记录插入到被保护记录前面的间隙中。
</div>

<div style="margin-top:.325em;">
next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。
</div>

<div style="margin-top:.325em;">
比如，一个事务持有了范围为 (1, 10] 的 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，就会被阻塞。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="MySQL 是怎么加行级锁的？" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:1.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。
</div>

<div style="margin-top:.325em;">
加锁的对象是索引，加锁的基本单位是 next-key lock，它是由记录锁和间隙锁组合而成的，next-key lock 是前开后闭区间，而间隙锁是前开后开区间。
</div>

<div style="margin-top:.325em;">
但是，next-key lock 在一些场景下会退化成记录锁或间隙锁。
</div>

<div style="margin-top:.325em;">
那到底是什么场景呢？总结一句，在能使用记录锁或者间隙锁就能避免幻读现象的场景下，next-key lock 就会退化成退化成记录锁或间隙锁。
</div>

<div style="margin-top:.325em;">
这次会以下面这个表结构来进行实验说明：
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1"
                     titleStyle="padding-left:0;color:black;font-size:1.2em;background-color:white;padding:0;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;">
      <![CDATA[
CREATE TABLE `t_user` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL,
  `age` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `index_age` (`age`) USING BTREE
) ENGINE=InnoDB  DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

insert into `t_user` ( `id`, `name`, `age`) values ( '1', 'Jim', '19');
insert into `t_user` ( `id`, `name`, `age`) values ( '5', 'Tom', '21');
insert into `t_user` ( `id`, `name`, `age`) values ( '10', 'Jerry', '22');
insert into `t_user` ( `id`, `name`, `age`) values ( '15', 'Musk', '20');
insert into `t_user` ( `id`, `name`, `age`) values ( '20', 'Keesh', '39');
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1"
                     titleStyle="color:black;font-size:1.2em;background-color:white;padding:0;margin-top:0em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625em;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
其中，id 是主键索引（唯一索引），age 是普通索引（非唯一索引），name 是普通的列。
</div>

<div style="margin-top:.325em;">
表中的有这些行记录：
</div>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
mysql> select * from t_user;
 1. +----+--------+------+
 2. | id | name   | age  |
 3. +----+--------+------+
 4. |  1 | Jim    | 19   |
 5. +----+--------+------+
 4. |  5 | Tom    | 21   |
 5. +----+--------+------+
 4. | 10 | Jerry  | 22   |
 5. +----+--------+------+
 4. | 15 | Musk   | 20   |
 5. +----+--------+------+
 4. | 20 | Keesh  | 39   |
 5. +----+--------+------+
</pre>

<div style="margin-top:.625em;">
这次实验环境的 MySQL 版本是 8.0.26，隔离级别是「可重复读」。不同版本的加锁规则可能是不同的，但是大体上是相同的。
</div>

<h3 style="color:green;">唯一索引等值查询</h3>
<div style="margin-top:.325em;">
当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同：
</div>

<ul style="margin-left: 2.5em;list-style-type: decimal;margin-top: .625em;">
  <li>当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会退化成<b>「记录锁」</b>。</li>
  <li>当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会退化成<b>「间隙锁」</b>。</li>
</ul>

<div style="margin-top:.325em;">
接下里用两个案例来说明。
</div>

<h4 style="color:blueviolet;margin:.325em 0;">1、记录存在的情况</h4>

<div style="margin-top:.325em;">
假设事务 A 执行了这条等值查询语句，查询的记录是「存在」于表中的。
</div>
<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:black;color:white;font-size:.825em;">
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t_user where id = 1 for update;
+----+--------+-----+
| id | name   | age |
+----+--------+-----+
|  1 | Jim    |  19 |
+----+--------+-----+
1 row in set (0.02 sec)
</pre>

<div style="margin-top:.625em;">
那么，事务 A 会为 id 为 1 的这条记录就会加上 X 型的记录锁。
</div>

<div style="margin-top:.625em;">
接下来，如果有其他事务，对 id 为 1 的记录进行更新或者删除操作的话，这些操作都会被阻塞，因为更新或者删除操作也会对记录加 X 型的记录锁，而 X 锁和 X 锁之间是互斥关系。
</div>

<div style="margin-top:.625em;">
比如，下面这个例子：
</div>
<table style="color:black;margin:.5em 0;line-height:1.3em;width:100%;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;font-weight: normal;">事物A</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">事物B</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">事物C</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;background-color:chocolate;color:white;">begin</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;background-color:chocolate;color:white;">select * from user where id = 1 for update;</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;background-color:crimson;color:white;">update t_user set age = 20 where id = 1; -- 阻塞</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;">
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;">&nbsp;</td>
            <td style="padding: 0;margin: 0;text-align: center;padding:.5em 0;background-color:crimson;color:white;">delete from t_user where id = 1; -- 阻塞</td>
        </tr>
    </tbody>
</table>

<div style="margin-top:.625em;">
因为事务 A 对 id = 1 的记录加了 X 型的记录锁，所以事务 B 在修改 id=1 的记录时会被阻塞，事务 C 在删除 id=1 的记录时也会被阻塞。
</div>

<div style="margin-top:.625em;">
我们可以通过 <b>select * from performance_schema.data_locks\G;</b> 这条语句，查看事务执行 SQL 过程中加了什么锁。
</div>

<div style="margin-top:.625em;">
我们以前面的事务 A 作为例子，分析下下它加了什么锁。
</div>

<pre style="margin-top:.5em;padding:.625em 1.2em;background-color:darkslateblue;color:white;font-size:.625em;">
mysql> select * from performance_schema.data_locks\G; 
*************************** 1. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 140066614791384:1067:140066534009760
ENGINE_TRANSACTION_ID: 1876
            THREAD_ID: 59
             EVENT_ID: 110
        OBJECT_SCHEMA: mydb
          OBJECT_NAME: t_user
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: NULL
OBJECT_INSTANCE_BEGIN: 140066534009760
            LOCK_TYPE: TABLE            |  ### 表锁: X型意向锁
            LOCK_MODE: IX               |
          LOCK_STATUS: GRANTED          |
            LOCK_DATA: NULL
*************************** 2. row ***************************
               ENGINE: INNODB
       ENGINE_LOCK_ID: 140066614791384:2:4:2:140066534006848
ENGINE_TRANSACTION_ID: 1876
            THREAD_ID: 59
             EVENT_ID: 110
        OBJECT_SCHEMA: mydb
          OBJECT_NAME: t_user
       PARTITION_NAME: NULL
    SUBPARTITION_NAME: NULL
           INDEX_NAME: PRIMARY
OBJECT_INSTANCE_BEGIN: 140066534006848
            LOCK_TYPE: RECORD           |  ### 行锁: X型记录锁
            LOCK_MODE: X,REC_NOT_GAP    |
          LOCK_STATUS: GRANTED          |
            LOCK_DATA: 1
2 rows in set (0.00 sec)
</pre>

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  

</c:component>
