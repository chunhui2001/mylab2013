<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div style="margin-bottom:1em;line-height:1.625;">
  Rust是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust在语法上和C++类似，但是设计者想要在保证性能的同时提供更好的内存安全。 Rust最初是由Mozilla研究院的Graydon Hoare设计创造，然后在Dave Herman, Brendan Eich以及很多其他人的贡献下逐步完善的。Rust的设计者们通过在研发Servo网站浏览器布局引擎过程中积累的经验优化了Rust语言和Rust编译器。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  Rust编译器是在MIT License 和 Apache License 2.0双重协议声明下的免费开源软件。Rust已经连续七年（2016，2017，2018，2019，2020, 2021, 2022）在Stack Overflow开发者调查的“最受喜爱编程语言”评选项目中折取桂冠。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  Rust的灵感来自多种语言的知识，其中值得一提的是Cyclone(一种安全的C语言变体)的基于区域的内存管理技术、C++的RAII原则、Haskell的类型系统、异常处理类型和类型类。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  Rust还借鉴了C++的RAII原则用于资源初始化，这种技术的本质是将资源的生命周期和对象的生命周期绑定，而堆分配类型的解除分配是通过执行drop特征上的drop()方法实现的。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  当变量的生命周期超出作用域时，程序会自动调用此方法。它还用Result和Option类型替代了空指针的概念，这意味着Rust不允许代码中出现null/undefined的值。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  <b>你需要深入理解 rust 如何确保引用永远不会指向已经离开作用域的变量。</b>
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>日常开发常用Rust库</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Web/HTTP" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>HTTP客户端</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/seanmonstar/reqwest">reqwest</a> 一个简单又强大的 HTTP 客户端，reqwest 是目前使用最多的 HTTP 库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Web框架</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/axum">axum</a> 基于 Tokio 和 Hyper 打造，模块化设计较好，目前口碑很好，值得使用 Ergonomic and modular web framework built with Tokio, Tower, and Hyper</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/SergioBenitez/Rocket">Rocket</a> 功能强大，API 简单的 Web 框架，但是主要开发者目前因为个人原因无法进行后续开发，未来存在不确定性</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/actix/actix-web">actix-web</a> 性能极高的 Web 框架，就是团队内部有些问题，未来存在一定的不确定性</li>
      <li style="margin-top:.325em;">总体来说，上述三个 web 框架都有很深的用户基础，其实都可以选用，如果让我推荐，顺序如下: axum > Rocket > actix-web。不过如果你不需要多么完善的 web 功能，只需要一个性能极高的 http 库，那么 actix-web 是非常好的选择，它的性能非常非常非常高！</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="日志监控" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>日志 <a style="text-decoration: underline;color:teal;" href="https://crates.io/keywords/log">[crates.io]</a> [github]</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/tracing">tokio-rs/tracing</a> 强大的日志框架，同时还支持 OpenTelemetry 格式，无缝打通未来的监控</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rust-lang/log">rust-lang/log</a> 官方日志库，事实上的 API 标准, 但是三方库未必遵循</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/estk/log4rs">estk/log4rs</a> 模仿 JAVA logback 和 log4j 实现的日志库, 可配置性较强</li>
      <li style="margin-top:.325em;">在其它文章中，也许会推荐 slog，但是我们不推荐，一个是因为近半年未更新，一个是 slog 自己也推荐使用 tracing。</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>监控</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/open-telemetry/opentelemetry-rust">OpenTelemetry</a> 是现在非常火的可观测性解决方案，提供了协议、API、SDK 等核心工具，用于收集监控数据，最后将这些 metrics/logs/traces 数据写入到 prometheus, jaeger 等监控平台中。最主要是，它后台很硬，后面有各大公司作为背书，未来非常看好！</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/vectordotdev/vector">vectordotdev/vector</a> 一个性能很高的数据采集 agent，采集本地的日志、监控等数据，发送到远程的 kafka、jaeger 等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="SQL客户端" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>通用</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/launchbadge/sqlx">launchbadge/sqlx</a> 异步实现、高性能、纯 Rust 代码的 SQL 库，支持 PostgreSQL, MySQL, SQLite 和 MSSQL.</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>ORM</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rbatis/rbatis">rbatis/rbatis</a> 国内团队开发的 ORM，异步、性能高、简单易上手</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/diesel-rs/diesel">diesel-rs/diesel</a> 安全、扩展性强的 Rust ORM 库，支持 Mysql、Postgre、SqlLite</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Mysql</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/blackbeam/rust-mysql-simple">blackbeam/rust-mysql-simple</a> 纯Rust实现的 Mysql 驱动,提供连接池</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/blackbeam/mysql_async">blackbeam/mysql_async</a> 基于 Tokio 实现的异步 Mysql 驱动</li>
      <li style="margin-top:.325em;">上面两个都是一个团队出品，前者文档更全, star 更多，建议使用前者</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Postgre</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/sfackler/rust-postgres">sfackler/rust-postgres</a> 纯 Rust 实现的 Postgre 客户端</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Sqlite</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rusqlite/rusqlite">rusqlite</a> 用于 Sqlite3 的 Rust 客户端</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="NoSql客户端" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Redis</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/redis-rs/redis-rs">mitsuhiko/redis-rs</a> 虽然最近更新不太活跃，但是它依然是最好的 redis 客户端，说实话，我期待更好的，可能这也是 Rust 生态的未来可期之处吧</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Canssandra</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/krojew/cdrs-tokio">krojew/cdrs-tokio</a> [cdrs-tokio] 生产可用的 Cassandra 客户端，异步、纯 Rust 实现，就是个人项目 + star 较少，未来不确定会不会不维护</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/scylladb/scylla-rust-driver">scylla-rust-driver</a> ScyllaDB 提供的官方库，支持 cql 协议，由于背靠大山，未来非常可期</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>MongoDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/mongodb/mongo-rust-driver">mongodb/mongo-rust-driver</a> 官方 MongoDB 客户端，闭着眼睛选就对了</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="分布式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>服务发现</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/lodrem/etcd-rs">luncj/etcd-rs</a> 异步实现的 Rust etcd 客户端，优点是有一定的文档、作者较为活跃, 意味着你提问题他可能会回答，不过，如果你不放心，还是考虑使用 HTTP 的方式访问 ETCD</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="消息队列" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Kafka</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/fede1024/rust-rdkafka">fede1024/rust-rdkafka</a> Rust Kafka 客户端，基于C版本的 Kafka 库 [librdkafka] 实现，文档较全、功能较为全面</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/kafka-rust/kafka-rust">kafka-rust/kafka-rust</a> 相比上一个库，它算是纯 Rust 实现，文档还行，支持 Kafka0.8.2 及以后的版本，但是对于部分0.9版本的特性还不支持。同时有一个问题：最初的作者不维护了，转给了现在的作者，但是感觉好像也不是很活跃</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Nats</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a href="https://github.com/nats-io/nats.rs">nats-io/nats.rs</a> Nats 官方提供的客户端</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="网络、通信协议" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Websocket</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/snapview/tokio-tungstenite">snapview/tokio-tungstenite</a> 更适合 Web 应用使用的生产级 Websocket 库，它是异步非阻塞的，基于下下面的 tungstenite-rs 库和 tokio 实现</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/websockets-rs/rust-websocket">rust-websocket</a> 老牌 Websocket 库，提供了客户端和服务器端实现，但是。。。很久没更新了</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/snapview/tungstenite-rs">snapview/tungstenite-rs</a> 轻量级的 Websocket 流实现，该库更偏底层，例如，你可以用来构建其它网络库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>gRPC</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/hyperium/tonic">hyperium/tonic</a> 纯 Rust 实现的 gRPC 客户端和服务器端，支持 async/await 异步调用，文档和示例较为清晰</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tikv/grpc-rs">tikv/grpc-rs</a> 国产开源之光 Tidb 团队出品的 gRPC 框架, 基于C的代码实现, 就是最近好像不是很活跃</li>
      <li style="margin-top:.325em;">其实这两个实现都很优秀，把 tonic 放在第一位，主要是因为它是纯 Rust 实现，同时社区也更为活跃，但是并不代表它比 tikv 的更好！</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>QUIC</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/cloudflare/quiche">cloudflare/quiche</a> 大名鼎鼎 cloudflare 提供的 QUIC 实现，据说在公司内部重度使用，有了大规模生产级别的验证，非常值得信任，同时该库还实现了 HTTP/3</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quinn-rs/quinn">quinn-rs/quinn</a> 提供异步 API 调用，纯 Rust 实现，同时提供了几个有用的网络库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>MQTT</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/bytebeamio/rumqtt">bytebeamio/rumqtt</a> MQTT3.1.1/5 协议库，同时实现了客户端与服务器端 broker</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/ntex-rs/ntex-mqtt">ntex-rs/ntex-mqtt</a> 客户端与服务端框架，支持 MQTT3.1.1 与5协议</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/eclipse/paho.mqtt.rust">eclipse/paho.mqtt.rust</a> 老牌 MQTT 框架，对 MQTT 支持较全, 其它各语言的实现也有</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="异步网络编程" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/tokio">tokio-rs/tokio</a> 最火的异步网络库，除了复杂上手难度高一些外，没有其它大的问题。同时tokio团队提供了多个非常优秀的Rust库，整个生态欣欣向荣，用户认可度很高</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://async.rs/">async-std</a> 跟标准库API很像的异步网络库，相对简单易用，但是貌似开发有些停滞，还有就是功能上不够完善。但是对于普通用户来说，这个库非常值得一试，它在功能和简单易用上取得了很好的平衡</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/actix/actix">actix</a> 基于Actor模型的异步网络库，但这个库的开发貌似已经停滞，他们团队一直在专注于actix-web的开发</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/mio">mio</a> 严格来说，MIO与之前三个不是同一个用途的，MIO = Meta IO，是一个底层IO库，往往用于构建其它网络库，当然如果你对应用网络性能有非常极限的要求，可以考虑它，因为它的层次比较低，所带来的抽象负担小，所以性能损耗小</li>
  <li style="margin-top:.325em;">如果你要开发生产级别的项目，我推荐使用 tokio，稳定可靠，功能丰富，控制粒度细；自己的学习项目或者没有那么严肃的开源项目，我推荐 async-std，简单好用，值得学习；当你确切知道需要 Actor 网络模型时，就用 actix</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="搜索引擎" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>ElasticSearch客户端</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/elastic/elasticsearch-rs">elastic/elasticsearch</a> 官方es客户端，目前第三方的基本都处于停滞状态，所以不管好坏，用呗</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Rust搜索引擎</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quickwit-oss/tantivy">Tantivy</a> 是Rust实现的本地搜索库，功能对标 lucene，如果你不需要分布式，那么引入 tantivy 作为自己本地 Rust 服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Rust搜索平台</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quickwit-oss/quickwit">quickwit</a> 对标 ElasticSearch，一个通用目的的分布式搜索平台，目前还在起步阶段(0.2版本)，未来非常可期，目前还不建议使用</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a> 虽然也是一个搜索平台，但是并不是通用目的的，MeiliSearch 目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="代码Debug" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>GDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/cs01/gdbgui">gdbgui</a> 提供浏览器支持的 gdb debug工具，支持 C，C++，Rust 和 Go.</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>LLDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> — 专门为VSCode设计的LLDB Debug扩展</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="性能优化" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/bheisler/criterion.rs">bheisler/criterion.rs</a> 比官方提供的 benchmark 库更好，目前已经成为事实上标准的性能测试工具</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/koute/bytehound">Bytehound</a> Linux 下的内存分析工具，可以用来分析：内存泄漏、内存分配、调用栈追踪，甚至它还有一个浏览器UI! 懂的人都懂，性能测试工具的UI服务是多么稀缺和珍贵！</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/llogiq/flame">llogiq/flame</a> 专为Rust打造的火焰图分析工具，可以告诉你程序在哪些代码上花费的时间过多，非常适合用于代码性能瓶颈的分析。与 perf 不同，flame 库允许你自己定义想要测试的代码片段，只需要在代码前后加上相应的指令即可，非常好用</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/sharkdp/hyperfine">sharkdp/hyperfine</a> 一个命令行 benchmark 工具，支持任意 shell 命令，支持缓存清除、预热、多次运行统计分析等，尽量保证结果的准确性</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="编解码" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/serde-rs/serde">Serde</a> 一个超高性能的通用序列化/反序列化框架，可以跟多种协议的库联合使用，实现统一编解码格式</li>
  <li style="margin-top:.625em;">CSV -- <a style="text-decoration: underline;color:teal;" href="https://github.com/BurntSushi/rust-csv">BurntSushi/rust-csv</a> 高性能CSV读写库，支持Serde</li>
  <li style="margin-top:.625em;">JSON -- <a style="text-decoration: underline;color:teal;" href="https://github.com/serde-rs/json">serde-rs/json</a> 快到上天的JSON库，也是Rust事实上的标准JSON库，你也可以使用它的大哥serde，一个更通用的序列化/反序列化库</li>
  <li style="margin-top:.625em;">MsgPack -- <a style="text-decoration: underline;color:teal;" href="https://github.com/3Hren/msgpack-rust">3Hren/msgpack-rust</a> 纯Rust实现的MessagePack编解码协议</li>
  <li style="margin-top:.625em;">
    <div>ProtocolBuffers</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/prost">tokio-rs/prost</a> tokio出品，基本都属精品，此库也不例外，简单易用，文档详细</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/stepancheg/rust-protobuf">stepancheg/rust-protobuf</a> 纯 Rust 实现</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>TOML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/toml-rs/toml-rs">alexcrichton/toml-rs</a> TOML编码/解码，可以配合serde使用</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>XML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tafia/quick-xml">tafia/quick-xml</a> 高性能XML库，可以配合serde使用，文档较为详细</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>YAML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/dtolnay/serde-yaml">dtolnay/serde-yaml</a> 使用serde编解码YAML格式的数据</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Email" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/lettre/lettre">lettre/lettre</a> — Rust SMTP 库</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Install Rust Development Environment</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="安装 cargo &amp; rust-analyzer" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
### 安装完成后可以使用 cargo
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

### 安装 macOS 包管理工具 brew
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

### 安装 rust-analyzer (安装Rust官方支持的代码分析前端程序), 耗时较长
$ brew install rust-analyzer

    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="安装 sublime text 4 rust 插件" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

### 打开sublime，快捷键 command + shift + p 调出命令选项，输入 install package control 安装 sublime 包管理工具
## 1. LSP（必须）
-- Language Server Protocol，语言服务器协议，此插件为 sublime 实现了 LSP 功能（有兴趣自行查阅资料），以关联 rust-analyzer，实现代码分析

## Rust Enhanced（必须）
-- 这是Rust社区官方维护的sublime插件，提供语法高亮、快捷构建等功能。

## sublimecodeintel
-- 全功能代码智能补全

## All Autocomplete
-- 在所有打开的文件中进行关键字搜索以及补全（面对所有文本，不受编程语言以及单个文件的限制）

## rust syntax
-- 为代码提供语法高亮。

## toml
-- Rust 使用 toml 做项目的配置管理。

## Tabnine
-- 基于 AI 的自动补全，可以帮助你更快地撰写代码。一位来自加拿大的大四学霸，开发了一款”Deep TabNine“代码补全工具，实现了这一大胆的想法。它支持23种编程语言、5种编辑器，使用简单，效果惊艳。

### 设置 LSP 
## 通过 sublime 打开一个随意的 rust 文件或项目文件夹，快捷键 command + shift + p 调出命令选项，有两种命令可选：
-- LSP: Enable Language Server Globally 此命令会让 sublime 只要启动就加载所选的代码分析前端（不建议，会影响s ublime 的冷启动性能）
-- LSP: Enable Language Server In Project 此命令会让 sublime 在打开当前文件/项目时才加载所选的代码分析前端，重启后需要重新操作一遍
-- 回车后，在下拉菜单中选择 'rust-analyzer' 就完成了全部配置，一切顺利的话界面显示类似下图，左下角会显示 rust-analyzer 对代码进行索引分析，
-- 指针悬停于代码有相应提示

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/1395949-20211205193017709-311037346.png" />
</div>

<blockquote style="font-size:1em;line-height:1.6em;">
  <div style="margin-bottom:1em;">
    Rust 语言服务器（RLS）基于 LSP（Language Server Protocol），即语言服务器协议，LSP 由红帽、微软和 Codenvy 联合推出，可以让不同的程序编辑器与集成开发环境（IDE）方便地嵌入各种编程语言，允许开发人员在最喜爱的工具中使用各种语言来编写程序。
  </div> 
  <div style="margin-bottom:1em;">
    它通过用于开发工具和语言服务器间通信的 JSON-RPC 标准，能够让编程工具提供实时反馈的详细信息并以此实现多种强大功能，比如符号搜寻、语法分析、代码自动补全、移至定义、描绘轮廓与重构等。Rust 语言服务器集成了这些逻辑作为后端，并通过标准的 LSP 提供给前端工具，它被设计为与前端无关，可以被不同的编辑器和 IDE 广泛采用，但目前项目团队仅在 VS Code 中进行测试。用户可以在 VS Code 扩展商店中找到基于 RLS 实现的 Rust 官方插件。
   </div>
  <div style="margin-bottom:1em;">
    <b>rust-anlyzer（RA）</b>是除了 RSL 以外的另一个 Rust 语言服务器，由社区驱动开发。自 2019 年末发布第一个预编译 Release 以来，RA 都会在每周二稳定发布新版本并保持至今。经过快速的迭代，目前 RA 各方面的优化和提升已经超越 RSL，所以也被官方纳入 RSL 2.0 计划的一部分。 Rust 的 VS Code 官方插件也已经增加了对 RA 的支持。
   </div>
  <div style="margin-bottom:1em;">
    RA 目前已经支持 Vim、Emac、Sublime Text 3 和 VSCode 等编辑器，可通过官方文档获取详细的安装指导。
   </div>
 </blockquote>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Cargo 工作空间</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
  管理多个相互关联且需要协同开发的包
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="创建工作空间" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
$ mkdir rustlabs && cd rustlabs && touch Cargo.toml

### Cargo.toml 内容
[workspace]
members = [
  "lab1",
  "lib1"
]

### 在该工作空间下创建 lab1 二进制包
$ cargo new lab1 && cargo build

### 继续在该工作空间下创建 lib1 代码包 (--lib)
$ cargo new lib1 --lib && cargo build

### 在 lib1/src/lib.rs 文件中添加一个 add_one 函数
pub fn add_one(x: i32) -> i32 {
  x + 1
}

### 将 lib1 代码包添加到lab1二进制包中, 在 lab1 中将要使用 lib1 导出的函数
$ vi lab1/Cargo.toml
[dependencies]
lib1 = { path = "../lib1" }

### 在 lab1 中使用来自 lib1 包的 add_one 函数
$ vi lab1/src/main.rs
use lib1;

fn main() {
  let num = 10;
  println!("Hello world! {} plus one is: {}!", num, lib1::add_one(num));
}

### 构建整个工作空间
$ cargo build

### 运行指定的二进制包
$ cargo run -p lab1

### 添加外部依赖包
$ vi lib1/Cargo.toml
[dependencies]
rand = "0.3.14"

### 再次构建整个工作空间, 此时 Cargo 就会引入并编译新添加的 rand 包
$ cargo build
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="为当前工作空间增加测试" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 为 lib1::add_one 函数增加一个测试
$ vi lib1/src/lib.rs
#[cfg(test)]
mod tests {

  use super::*;

  #[test]
  fn it_works() {
    assert_eq!(3, add_one(2));
  }
}

// 运行当前工作空间下的所有测试
$ cargo test

// 运行某个特定包的测试
$ cargo test -p lib1

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用 cargo install 从 crates.io 上安装可执行程序" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 输出结果的最后一行显示了二进制文件的安装路径和名称
$ cargo install ripgrep
    Finished release [optimized + debuginfo] target(s) in 1m 06s
  Installing /Users/keesh/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用自定义命令扩展 cargo 的功能" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// cargo 允许我们添加子命令来扩展它的功能而无需修改 Cargo 自身, 只要你的 $PATH 路径中存在指定的二进制文件即可, 就好像它是 cargo 的子命令一样
$ cargo rg

// 显示当前包的依赖图
$ cargo tree OR cargo tree -p tera

// 列出 cargo 的内置子命令
$ cargo --list
Installed Commands:
    add                  Add dependencies to a Cargo.toml manifest file
    b                    alias: build
    bench                Execute all benchmarks of a local package
    build                Compile a local package and all of its dependencies
    c                    alias: check
    check                Check a local package and all of its dependencies for errors
    clean                Remove artifacts that cargo has generated in the past
    clippy               Checks a package to catch common mistakes and improve your Rust code.
    config               Inspect configuration values
    d                    alias: doc
    doc                  Build a package's documentation
    fetch                Fetch dependencies of a package from the network
    fix                  Automatically fix lint warnings reported by rustc
    fmt                  Formats all bin and lib files of the current crate using rustfmt.
    generate-lockfile    Generate the lockfile for a package
    git-checkout         This command has been removed
    help                 Displays help for a cargo subcommand
    init                 Create a new cargo package in an existing directory
    install              Install a Rust binary. Default location is $HOME/.cargo/bin
    locate-project       Print a JSON representation of a Cargo.toml file's location
    login                Save an api token from the registry locally. If token is not specified, it will be read from stdin.
    logout               Remove an API token from the registry locally
    metadata             Output the resolved dependencies of a package, the concrete used versions including overrides, in machine-readable format
    miri
    new                  Create a new cargo package at <path>
    owner                Manage the owners of a crate on the registry
    package              Assemble the local package into a distributable tarball
    pkgid                Print a fully qualified package specification
    publish              Upload a package to the registry
    r                    alias: run
    read-manifest        Print a JSON representation of a Cargo.toml manifest.
    remove               Remove dependencies from a Cargo.toml manifest file
    report               Generate and display various kinds of reports
    rm                   alias: remove
    run                  Run a binary or example of the local package
    rustc                Compile a package, and pass extra options to the compiler
    rustdoc              Build a package's documentation, using specified custom flags.
    search               Search packages in crates.io
    t                    alias: test
    test                 Execute all unit and integration tests and build examples of a local package
    tree                 Display a tree visualization of a dependency graph
    uninstall            Remove a Rust binary
    update               Update dependencies as recorded in the local lock file
    vendor               Vendor all dependencies for a project locally
    verify-project       Check correctness of crate manifest
    version              Show version information
    yank                 Remove a pushed crate from the index

    ]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>可修改引用</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn main() {
    let mut i: i32 = 19;
    change_number(&mut i);
}

// 省略写法
pub fn change_string(s: &mut String) {
    s.push_str("asdf");
}

pub fn change_number(i: &mut i32) {
    *i += 1;
}

// 等价写法
pub fn change_string<'a>(s: &'a mut String) {
    s.push_str("asdf");
}

pub fn change_number<'a>(i: &'a mut i32) {
    *i += 1;
}


    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>泛型函数</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::str::FromStr;

pub fn parse_number<T: FromStr>(s: &str) -> Option<T> {
    match T::from_str(s) {
        Ok(l) => Some(l),
        _ => None,
    }
}


#[cfg(test)]
mod tests {
    #[test]
    fn it_parse_number() {
        let i: f64 = parse_number("3").expect("error parseing u32");
        assert_eq!(3.0, i);
    }
}

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>数组、向量和切片</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 1. 数组是在编译是确定大小的常量，不能在数组中追加或删除元素
// [T; N] 表示一个N个值的数组, 每个元素的类型都是 T, 
// 数组长度是类型的一部分，在编译时就确定了，N必须是常量，无法在运行时指定N的值。
let lazy_caterer: [u32; 6] = [1,3,3,4];
let taxonomy = ["Animalia", "Arthropoda", "Insects"];

// 2. 向量是一种动态分配，可扩展的值序列，向量的元素保存在堆上，可随意缩放它
//    每当向量增长到超过其缓冲区容量时，它都会选择一个比原来大1倍的新缓冲区。
// Vec<T> 表示一个向量，每个元素的类型都是T，可动态调整大小
let v1 = vec![1, 2, 3];
let mut v2: Vec<u32> = Vec::<u32>::new();
let v22 = Vec::<u32>::new();
let vv = vec![0; 14];
let v: Vec<i32> = (0..5).collect(); // 使用collect时通常要明确写出类型

println!("{:?}", v2);

// 3. 切片是对其他值中部分元素序列的引用。切片的引用的是一个胖指针，即一个双字宽的值，保存着切片中第一个元素的指针和切片中的元素个数。
//    切片表示数组或向量的一个范围，由于切片可以是任意长度，因此不能直接保存到变量中，也不能作为函数参数传递，切片永远只能按引用传递。
// &[T] 读作"共享切片"，可以由多个线程读取，但不可以修改
// &mut [T] 读作"可修改切片"，允许读写元素，但是不能共享
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.797]; // 向量
let a: [f64; 4] =     [0.0, -0.707, -1.0, -0.797]; // 数组

let sv: &[f64] = &v; // 切片
let sa: &[f64] = &a; // 切片

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/array-vec-slice.png" style="max-width:100%;" />
</div>
<div style="text-align: center;">
  向量、数组、切片、引用 之间的内存布局逻辑图
</div>

<ul style="margin-left:1em;list-style-type:disc;margin-top:1.325em;">
  <li style="margin-top:.325em;">普通引用是对单个值的非所有型指针</li>
  <li style="margin-top:.325em;">切片引用是对多个值的非所有型指针</li>
  <li style="margin-top:.325em;">切片引用的是一个胖指针，即一个双字宽的值，保存着切片中第一个元素的指针和切片中的元素个数。</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="向量 Vec" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 显示写出类型
fn build_vector() -> Vec<i16> {
  let mut v: Vec<i16> = Vec::<i16>::new();
  v.push(10i16)
  v.push(20i16)
  v
}

// 类型推断, 提高代码可读性
fn build_vector() -> Vec<i16> {
  let mut v = Vec::new();
  v.push(10)
  v.push(20)
  v
}
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>字符串类型</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let noodles = "noodles".to_string();
let oodles = &noodles[1..];
let poodles = "中_国";

println!("{}", poodles.len()); // 字节数, > 7
println!("{}", poodles.chars().count()); // 字符长度, > 3
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/string-&str-str.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>所有权</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
在 Rust 中每个值都<b>只有一个</b>决定其生命期的所有者，当这个所有者被释放(dropped)时，其所有的值也会被清除。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="所有权与函数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制。 
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {

  let s = String::from("hello");  // 变量 s 进入作用域

  takes_ownership(s);             // s 的值被移动进了函数
                                  // 所以它从这里开始不在有效

  let x: i32 = 5;                 // 变量 x 进入作用域

  makes_copy(x);                  // 变量x同样被传递进了函数
                                  
  println!("{}", x);              // 但是由于 i32 是 Copy 的, 所以 x 仍然有效           

} // x 首先离开作用域，然后是 s

fn takes_ownership(some_string: String) {    // some_string 进入作用域
  println!("{}", some_string);
} // some_string 在这里离开作用域, drop 函数被自动调用 
  // some_string 占用的内存也随之被释放

fn makes_copy(some_integer: i32) {           // some_integer 进入作用域
  println!("{}", some_integer); 
} // some_integer 在这里离开作用域, 由于是值类型没有什么特别的事发生

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="向量 Vector" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn print_padovan() {
  let mut padovan = vec![1,1,1]; // 分配内存
  for i in 3..10 {
    let next = padovan[i - 3] + padovan[i - 2];
    padovan.push(next);
  }
  println!("P(1..10) = {:?}", padovan);
} // 清除 padovan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/vecu32.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Box" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Rust 的 Box 类型是说明所有权的一个典型例子，Box<T> 是一个指针，其指向存储在堆中的T类型的值。
// 调用 Box::new(v) 会在堆上分配相应的内存缓冲区，并将值v转移进去。最后返回
{
  let point = Box::new((0.625, 0.5); 
  let label = format!("{:?}", point);

    println!(
        "{}, {}, {}, {}",
        label,
        label.len(),
        label.chars().count(),
        label.capacity()
    ); // > (0.625, 0.5), 12, 12, 16
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/point&label-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="结构体 struct" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
struct Person { name: String, birth: i32 }

let mut composers = Vec::new();

composers.push(Person{ name: "Palestrina".to_string(), birth: 1525 });
composers.push(Person{ name: "Dowland".to_string(), birth: 1563 });
composers.push(Person{ name: "Lully".to_string(), birth: 1632 });

for c in composers {
    println!("{:?}, {}, {}", c, c.name, c.birth);
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/struct-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>转移</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
在 Rust 中给<b>变量赋值</b>、给<b>函数传参</b>、从<b>函数返回值</b>这样的操作都不会复制值，而是<b>转移(move)</b>值。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="Python" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
s = ['udon', 'ramen', 'soba']
t = s    // 赋值代价较小，引用计数相对麻烦。
u = s
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/python-string-array-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="C++" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
using namespace std;
vector<string> s = { "udon", "ramen", "soba" };
vector<string> t = s; // 产生深度复制, 即复制s到t。保证了内存所有权的清晰!
vector<string> u = s; // 产生深度复制, 即复制s到t。保证了内存所有权的清晰!
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/c++-vec-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Rust" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s; // 转移所有权
let u = s; // s的值已经被转移，编译器拒绝编译这行代码
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/rust-vec-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Copy类型 &amp;mdash; 转移的例外" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
#[derive(Copy, Clone)] // 如果自定义结构体的所有字段都是copy类型，那可以在该结构体上加该注释
struct Label { number: u32 }

fn print_label(l: Label) {
  println!("STAMP: {}", l.number);
}

let l = Label { number: 3 };

// 如果Label不是Copy类型，编译器拒绝编译这行代码
// 把非copy类型的值传给print会把值的所有权转移给print, print会在返回前将该值清除
print_label(l);

println!("My label number is: {}", l.number); 

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Rc &amp; Arc 共享所有权" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::rc::Rc;

let s: Rc<String> = Rc::new("shirataki".to_string()); // Rust 假设 Rc 指针指向的值通常是共享的

s.push_str("aa"); // 编译器拒绝编译这行代码, Rust 里不存在即共享又可以修改的值

let t: Rc<String> = s.clone();
let u: Rc<String> = s.clone();

println!("{:?}", s);
println!("{:?}", t);
println!("{:?}", u);

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/rc-string-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="共享引用 &amp; 可修改引用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

let x = 1000;
let r = &x;     // 共享引用
let f = *r;     // 对 r 解引用进而读取存储在 x 里值

println!("{}, {}", *r, f);

let mut a = 10; 
let b = &mut a; // &mut a 是 y 的可修改引用

*b += 1;        // 显示对 b 解引用进而修改 a 的值

println!("{}", b);

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="给引用赋值" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let x = 10;
let y = 20;
let mut r = &x;

if true {
  r = &y; // 给引用赋值会导致它指向新值
}

println!("{}", r);

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>悬空指针</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="悬空指针 -- 例子1" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
{
  let r;
  {
    let x = 1;
    r = &x;
  }
  println!("{}", r)
}

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
以上代码编译会报错
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
cargo build
   Compiling lab2 v0.1.0 (/Users/keesh/workspace/rs-labs/lab2)
error[E0597]: `x` does not live long enough
 --> lab2/src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |     println!("{}", r)
  |                    - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `lab2` due to previous error
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="悬空指针 -- 例子2" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn dangle() -> &String {
  let s = String::from("hello");        // s 被绑定到新的 String 上。由于 s 是在函数内部创建，所以它会在执行完毕时随之释放。
                                        // 但是以下代码依旧尝试返回一个指向 s 的引用，这个引用将指向的内存不在有效
  &s                                    // 所以 rust 编译器拒绝编译这行代码
}

    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="借用向量中的元素" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let v = vec![1, 2, 3];
let r = &v[1]; // 借用

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.6;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
  由于 v 拥有向量, 而向量拥有自己的元素, 因此 v 的生命周期必须涵盖引用类型 &v[1] 的生命期。类似的，如果把引用保存在某个数据结构中，该引用的生命期必须涵盖该数据结构的生命期。比如，对于一个引用向量而言，(作为向量元素的) 所有引用的生命周期都必须涵盖拥有这个向量的变量的生命期。
</div>
<div style="margin-top:.625em;">
  例如本例中, r 借用了 v 里的某个元素的引用, 那么 v 的生命期必须大于 r 的生命期。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>生命周期</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn f<'a>(p: &'a i32) {     // 'a 相当于任意生命周期, 如果能让他的生命周期尽可能短，即恰好包含对 f 的调用，事情就比较好办
  println!("{}", p);
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="静态生命周期 &amp;mdash; 与整个程序的运行时间一样长" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

static mut STASH: &i32 = &10;

fn f(p: &'static i32) {
  unsafe {                    // 对静态变量的读写是非线程安全的，所以将赋值动作放到 unsafe 代码块中
    STASH = p;
  }
}

static WORTH_POINTING_AT: i32 = 1000;

f(&WORTH_POINTING_AT);

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
以上代码编译会报错
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="将引用作为参数传递" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 等价于 fn g(p: &i32) 
fn g<'a> (p: &'a i32) {
  ...
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="从函数返回引用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn main() {
  let s;
  {
    let parabola = [9,234934993,3,3,12,8,0,-1];
    s = smallest(&parabola);
  }
  println!("{}", s); // rust 编译器拒绝编译这行代码, 因为 s 引用的值已经超出作用域
}

// 返回切片中最小值的元素引用
fn smallest(v: &[i32]) -> &32 {
  let mut a = &v[0];
  for r in &v[1..] {
    if *r < *a {
      a = r;
    }
  }
  a
}

// 等价于
fn smallest<'a>(v: &'a [i32]) -> &'a 32 {
  let mut a = &v[0];
  for r in &v[1..] {
    if *r < *a {
      a = r;
    }
  }
  a
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="结构体包含引用 &amp;mdash; Rust 要求包含引用的结构体不能省略生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
struct S {
  r: &i32             // 编译器拒绝编译这行代码
}

// 当引用类型出现在另一个类型的定义中时，必须写出其生命周期
struct S {
  r: &'static i32     // 把 r 标记为 &'static 时意味着, r 只能引用和程序生命周期一样长的值
}

// 在类型上定义生命周期
// 每个类型 S 的值都会有一个新的生命周期 'a, 它会限制你使用这个值的方式
// 保存在 r 中的任何引用的生命周期最好包含 'a, 而 'a 也必须比保存 S 的任何值都长寿
#[derive(Debug)]
struct S<'a> {
    r: &'a i32,
}

fn main() {
  let i = 19;
  // 创建了一个带有生命周期 'a 的新 S 的值
  // 在把 &i 保存在 r 字段时，等于把 'a 完全限定在了 i 的生命周期内
  let s = S { r: &i };   
  println!("{:?}", s);
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="不同的生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
struct S<'a> {
    x: &'a i32,
    y: &'a i32,
}

// 以下代码不会创建悬空指针，
// 1. y 的引用保存在 s 中，而 s 会先于 y 被销毁。
// 2. x 的引用最终保存在 r 中，而 r 和 x 被一同销毁
// 但是如果用早期 rust 版本编译这段代码，rust 会抱怨说 y 活的不够长
// 尽管明显足够长，为什么 rust 会担心呢？仔细分析一下，你会发现它这样担心是有道理的


                        
           
fn main() {
    let x = 10;                                       |'a
    let r;                                            |
    {                                                 |
        let y = 20;                              |'b  |
        {                                        |    |
            let s = S { x: &x, y: &y };     |'c  |    |
            r = s.x;                        |    |    |
            println!("{}, {}", s.x, s.y);   |    |    |
        }                                   |    |    |
    }                                            |    |
    println!("{}", r);                                | // 编译器拒绝编译这行代码, 对于 S 来说, 编译器并不知道 x,y 谁先被销毁，  
}                                                     | // 只能通过某种标记告诉他每个字段的生命周期    
                                                        // 通过给 x,y 定义不同的生命周期标记(<'a, 'b>)解决这个问题  
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="函数签名的生命周期" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn f<'a, 'b>(r<'a>: &i32, s<'b>: &i32) -> &<'a>i32 {
  r
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="省略生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// rust 会在生命周期参数明显合理的时候，可以省略他们
struct S<'a, 'b> {
  x: &<'a>i32,
  y: &<'b>i32
}

// 省略写法
fn sum_rxy(r: &i32, s: S) -> i32 {
  r + s.x + s.y
}

// 完整写法
fn sum_rxy<'a, 'b, 'c>(r: &'a i32, s: S<'b, 'c>) -> i32 {
  r + s.x + s.y
}

// 当函数返回引用时，也需要携带生命周期参数
// 省略写法
fn first_and_third(point: &[i32, 3]) -> (&i32, &i32) {
  (&point[0], &point[2])
}

// 完整写法
fn first_and_third(point: &'a [i32, 3]) -> (&'a i32, &'a i32) {
  (&point[0], &point[2])
}

// 如果函数参数中有多个生命周期，则 rust 无法推断哪个生命周期更适合返回值, 此时 rust 要求你明确写出返回值的生命周期属性
// ....
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="某个类型的函数参数接受引用形式的 self 参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// rust 会假设 self 的生命周期就是返回值需要的生命周期
struct StringTable {
  elements: Vec[String],
}

// 省略写法
impl StringTable {
  fn find_by_prefix(&self, prefix: &str) -> Option<&String> {
    for i in 0 .. self.elements.len() {
      if self.elements[i].starts_with(prefix) {
        return Some(&self.elements[i])
      }
    }
    None
  }
}

// 完整写法
impl StringTable {
  fn find_by_prefix<'a, 'b>(&'a self, prefix: &'b str) -> Option<&String> {
    // 此时 rust 假设你无论借用的是什么，都是从 self 中借用的
    ... 
  }
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="共享与修改" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  Rust 关于修改引用和共享引用的规则
</div>
<ul style="margin-left:0em;list-style-type:none;margin-top:.625em;line-height:1.6;">
  <li>
    <b>共享访问是只读访问</b> 共享引用借用的值是只读的。在共享引用的整个生命周期内，任何事物都不能修改其引用目标，也不能修改其引用目标的可触达的值。结构体中不存在指向任何目标的可修改引用，所有者是只读的 &mdash;&mdash; 实际上是这个值被冻结了。
  </li>
  <li style="margin-top:.625em;">
    <b>可修改访问是排他访问</b> 可修改引用借用的值只能通过该引用访问。在可修改引用的整个生命周期内，没有其他路径可触及其引用目标，或触及其引用目标可触及的值。唯一能够与可修改引用的生命周期重叠的，就是从该可修改引用自身借用的引用。
  </li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 以下代码可能引入悬空指针
let v = vec![4, 8, 19, 27, 34, 10];
let r = &v;
let aside = v;    // 给 aside 赋值会转移向量，导致 v 变成未初始化状态
r[0];             // 由于 v 变成了未初始化状态，所以 r 变成了悬空指针


// 修复以上错误
let v = vec![4, 8, 19, 27, 34, 10];
{
  let r = &v;       | 引用的生命周期在 v 转移给 aside 之前结束  
  r[0];             |   
}                   |     
let aside = v;      // v 分配的内存转移给 aside 

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/flag1.png" style="width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="extend_from_slice &amp;mdash; 由于向量重新分配内存空间导致切片变成悬空指针" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[   
fn extend_slice(vec: &mut Vec<f64>, slice: &[f64]) {
  for elt in slice {
    vec.push(*elt);
  }
}     

fn main() {

  let mut wave = Vec::new();
  let head = vec![0.0, 1.0];
  let tail = [1.2, 0.34];

  extend_slice(&mut wave, &head);     // 用另一个向量扩展 wave
  extend_slice(&mut wave, &tail);     // 用数组扩展 wave

  // 追加一个元素，将自动扩容1倍
  <!-- wave.push(1.0); -->

  // 用向量自身追加向量, 
  // 在给向量追加元素时，如果缓冲区慢了，系统会自动分配一个更大的缓冲区
  // 当缓冲区自动扩容时，slice 参数仍然指向原来的四个元素缓冲区，该内存已经被清除，此时 slice 变成了悬空指针
  // rust 编译器拒绝编译这行代码
  extend_slice(&mut wave, &wave)   

  // 当 Java 中出现此问题时会抛出 ConcurrentModificationException
  // ....   

}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/flag2.png" style="width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<ul style="margin-left:2em;list-style-type:decimal;margin-top:.625em;line-height:1.6;">
  <li>
    在调用 extend_slice 函数时传入的第一个参数 &mut wave，意味着该函数已经向 wave 借用了一个可修改引用，这意味着该可修改引用必须是可触及这个向量及其元素的唯一路径。
  </li>
  <li style="margin-top:.625em;">
    而传入的第二个参数，意味着对 slice 切片需要向 wave 再次借用一个共享引用，这违反了前面提到的第二条原则。rust 拒绝这样的操作, 即编译报错。
  </li>
  <li style="margin-top:.625em;">
    rust 也可以认为 extend_slice 函数违反了第二条原则: 在待用该函数时 slice 参数已经借用了对 wave 元素的共享引用，所以无论是元素还是 vec 本身都是只读的。此时就不能再次向一个只读的值借用可修改引用了。
  </li>
</ul>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/flag3.png" style="width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="通过一下例子解释上边这张图" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[   
// 以下代码详细阐述了共享引用的借用规则
let mut x = 10;

let r1 = &x;          // 第一次借用 x 的不可修改引用
let r2 = &x;          // 第二次借用 x 的不可修改引用。可以，允许多次借出共享引用

x += 2;               // 错误，一个值如果把他的引用借出去了，在还回来之前不可以修改。

let m = &mut x;       // 错误，因为 x 已经借出了不可修改引用, 此时不能再次借出x的可修改引用。

let mut y = 20;
let m1 = &mut y;      // m1 借用了 y 的可修改引用
let m2 = &mut y;      // 错误，不能借用2次可修改引用
let z = y;            // 错误，此时不能用 y，因为它已经借出了可修改引用


// 从共享引用借用共享引用是可以的
let mut w = (107, 109);
let r = &w;
let r0 = &r.0;        // 可以，共享引用可以在借为共享引用
let r1 = &mut r.1;    // 错误，共享引用不可以在借为可修改引用

// 可修改引用可以在借为可修改引用
let mut v = (136, 139);   
let m = &mut v;
let m0 = &mut m.0;    // 可以，可修改引用可以在借为可修改引用

*m0 = 137;            
let r1 = &m.1;        // 可以，可修改引用可以在借为共享引用

v.1                   // 错误，已经借出可修改引用，禁止通过其他路径访问

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>错误处理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
painc(诧异) 和 Result 是 Rust 的错误处理机制。
</div>
<div style="margin-top:.625em;">
普通的错误使用 Result 处理，这些错误通常由程序外部的情况导致，比如错误输入、网络中断、或者权限问题。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="painc 诧异" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {

    let r = pirate_share(500, 0);

    println!("{}", r);
    println!("{}", r / 1 as f64);
    println!("{}", r.is_infinite());

    let a = r; // 复制

    println!("{}", a);

    if r.is_infinite() {
        panic!("error"); // 诧异
    }
    
}

fn pirate_share(total: u64, crew_size: usize) -> f64 {
    let half = total as f64 / 2.0;
    half / crew_size as f64
}


]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.8;font-family:monospace;margin-top:1em;">
      <![CDATA[

<div style="margin-top:.625em;">
painc(诧异) 用于处理永远不会发生的错误。当程序发生诧异时会<b>展开栈</b>。
</div>

<div style="margin-top:.425em;">
诧异不是崩溃也不是未定义行为，它是安全的且不违反 Rust 的任何安全规则。
</div>

<div style="margin-top:.425em;">
painc(诧异) 是线程级别的，一个线程诧异时其他线程可以正常运行自己的业务。<b>父线程可以捕获子线程的诧异，并优雅地处理相应的错误。</b>
</div>

<div style="margin-top:.425em;">
还有一种方法可以<b>捕获栈展开</b>，它允许诧异线程存活并继续运行。标准库函数 std::panic::catch_unwind() 就是为此设计的。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="中止进程" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.8;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.625em;">
展开栈是默认的诧异行为，但在两种情况下 Rust 不会展开栈。
</div>

<div style="margin-top:.425em;">
如果在 Rust 展开第一个函数之后的清理期间 .drop() 方法触发了第二个诧异，那么这个诧异被认为是致命的。此时 Rust 会停止展开栈并中止整个进程。
</div>

<div style="margin-top:.425em;">
如果编译时加上 -C panic=abort，那么编译后程序中的第一个诧异就会立即终止进程。（此选项能够减小编译后代码的大小）
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Result 结果" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.8;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.625em;">
Rust 没有异常，在 Rust 中函数执行失败可以通过一个返回类型来表示。
</div>

<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li>再 rust 中要比在其他语言中花更多时间来思考和权衡错误处理。</li>
  <li>rust 要求程序员在所有可能发生错误的地方做出某种决定，并记录在代码中。</li>
  <li>rust 会检查是否使用了 Result 值，因此不可能静默传递某个错误。</li>
  <li>向外传播错误，最简单的办法是只写一个 ? 操作符，且传播路径是可见的，就算是一堆代码只需一眼就能定位错误是从哪些地方传播出来的。</li>
</ul>

<pre style="margin-top:1em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
fn get_weather(location: LatLng) -> Result&lt;WeatherReport, io::Error&gt; {
  // .....

}

// 啰嗦写法
match get_weather(hometown) {
  Ok(report) => {
    display_weather(hometown, &report);
  }
  Err(err) => {
    println!("error query the weather: {}", err);
    schedule_weather_retry();
  }
}

// 简化写法1
let report = get_weather(hometown).unwrap_or_else( |_err| vague_prediction(hometown));

// 简化写法2
let report = get_weather(hometown).unwrap(); // 仅返回成功的值，如果 result 是错误的结果会触发诧异。

// 简化写法2
let report = get_weather(hometown).expect(message_here); // 失败时返回自定义错误信息。

// 将结果转换为引用
result.as_ref() 将 Result<T, E> 转换为 Result<&T, &E>，即借用现有 result 中成功或错误值的引用

// 将结果转换为可修改引用
result.as_mut() 将 Result<T, E> 转换为 Result<&mut T, &mut E>，即借用现有 result 中成功或错误值的可修改引用

// 取得 &str 类型的错误信息
err.description();

// 返回一个 Option<&Error>，取得触发 err 的底层错误(如果有的话)
err.cause()

</pre>

<div style="margin-top:1em;">
打印错误信息不一定会打印出错误原因。可以使用这个函数打印所有可用信息。
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
use std::error::Error;
use std::io::{Write, stderr};

/// 把错误信息转存到 stderr
/// 
/// 如果在构建当前错误信息或写入 stderr 时发生另一个错误，则忽略该错误
pub fn print_error(mut err: &dyn Error) {
  
  let _ = writeln!(stderr(), "error: {}", err);

  while let Some(cause) = err.source() {
    let _ = writeln!(stderr(), "caused by: {}", cause);
    err = cause;
  }

}

</pre>

<div style="margin-top:1em;">
<b>标准库的错误类型不包含栈跟踪信息，但是使用 error_chain 包可以方便地定义自己的错误类型，以支持在创建时获取栈跟踪信息。</b>
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="传播错误" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.625em;">
在尝试可能出错的操作时，有时并不希望立即处理错误。如果在每个可能出错的地方都写上 10 行 match 语句，就显得有点啰嗦了。
</div>

<div style="margin-top:.325em;">
我们通常希望调用者来处理错误。换句话说，我们希望错误可以沿着调用栈向上传播。
</div>

<div style="margin-top:.325em;">
Rust 的 ? 操作符可以传播错误。可在任何产生 Result 的表达式后面加 ?，例如：
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
let weather = get_weather(hometome)?;
</pre>

<div style="margin-top:1.625em;">
? 操作符的行为取决于这个函数是返回一个成功结果，还是返回一个错误结果。
</div>

<ul style="margin-left:2em;list-style-type:disc;margin-top: .325em;">
  <li>如果是成功结果，那么它会打开 Result 并取出其中的值。</li>
  <li>如果是错误结果，那么它会立即从闭合函数中返回，并将错误结果沿调用链向上传播。为确保传播成功，只能对返回类型为 Result 的函数使用 ?。</li>
</ul>

<div style="margin-top:.325em;">
? 操作符并不神秘。同样的操作使用一个 match 表达式也能实现，只不过太长了：
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
let weather = match get_weather(hometown) {
  Ok(succes_value) => succes_value,
  Err(err) => return Err(err)
}
</pre>

<div style="margin-top:1em;">
出错概率极高的代码示例子
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
use std::fs;
use std::io;
use std::path::Path;

fn main() {
    let src_path = Path::new("./foo/bar.txt");
    let dst_path = Path::new("./foo/bar.txt2");

    move_all(src_path, dst_path).unwrap_or_else(|_err| println!("{}", _err.to_string()));
}

fn move_all(src: &Path, dst: &Path) -> io::Result<()> {

    // 判断文件夹是否存在
    if !fs::metadata(dst).is_ok() {
        fs::create_dir_all(dst)?; // 创建文件夹
    }

    // 判断源文件夹是否存在
    if !fs::metadata(src).is_ok() {
        panic!("src not exists: path={}", String::from(src.to_string_lossy()));
    }

    // 读取dir可能失败
    for entry_result in src.read_dir()? {
        let entry = entry_result?;                    // 读取文件可能失败
        let dst_file = dst.join(entry.file_name());   // 拼接目标路径
        println!("src_file={:?}, dist_file={}", entry.path(), dst_file.display().to_string());  // 打印日志
        fs::rename(entry.path(), dst_file).unwrap();  // 重命名可能失败
    }

    // 删除文件夹
    fs::remove_dir_all(src)?;

    Ok(()) // 成功
}

</pre>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="处理多种错误类型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[


<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
use std::io::{self, BufRead};

// 当一个函数可能产生两种不同的潜在错误类型时，rust 拒绝编译代码
// 有多种办法可以处理这种情况:
// 1. 使用 error-chain 包, 它可以帮你用几行代码就定义出灵活的错误类型
// 2. 另一个简单的方法是使用 rust 内置的特性。即：所有标准库的错误类型都可以转换为 Box&lt;std::error::Error&gt; 类型
//    -- 因此处理多种错误类型的一个简单方案就是定义如下类型别名:
//    -- type GenError = Box&lt;std::error::Error&gt;
//    -- type GenResult&lt;T&gt; = Result&lt;T, GenError&gt;
//    -- 如果调用的函数返回 GenResult，但是你只想处理一种特定的错误，而让其他所有错误传播出去，
//    -- 此时可以使用范型方法 error.downcast_ref::&lt;ErrorType&gt;()
//    -- 很多语言为完成此类操作提供了内置语法，实际上完全没必要。Rust 只是专门为此提供了一个方法。
fn read_numbers(file: &mut BufRead) -> Result&lt;Vec&lt;i63&gt;, io::Error&gt; {

  let mut numbers = vec![];

  for line_result in file.lines() {
      let line = line_result?;        // 读取行可能失败，错误类型为：Result&lt;String, std::io::Error&gt;
      numbers.push(line.parse()?);    // 解析整数有可能失败，错误类型为：Result&lt;i64, std::num::ParseIntError&gt;
  }
  
  Ok(numbers)

}

</pre>


    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="在 main() 中处理错误" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[
<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
fn main() {
  invoke_func()?; // 错误，不能把错误再向外传播了
}

fn main() {
  invoke_func().expect("err"); // 主动抛出错误
}

fn main() {
  if let Err(err) = invoke_func() {
    print_error(&err);
    std::process::exit(1);
  }
}
</pre>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="声明自定义错误类型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[
<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
#[derive(Debug, Clone)]
pub struct JsonError {
  pub message: String,
  pub line: usize;
  pub colume: usize,
}

// 创建一个这种类型的错误时，可以这样写:
return Err(JsonError{
  message: "expected ']' at end of array".to_string(),
  line: current_line,
  colume: current_colume 
});



// 让该错误类型的行为接近标准错误类型
use std;
use std::fmt;

impl fmt::Display for JsonError {
  fn fmt(&self, f: &mut fmt::Formatter) -> Result&lt;(), fmt::Error&gt; {
    write!(f, "{} ({}:{})", self.message, self.line, self.column)
  }
}

// 该错误还应该实现 std::error::Error 特型
impl std::error::Error for JsonError {
  fn description(&self) -> &str {
    &self.message
  }
}

</pre>
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>结构体</c:title>
    <c:desc>
      <c:desc1> <![CDATA[

]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="命名字段结构体 &amp;mdash; GrayscaleMap" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
结构体布局 .....
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

fn main() {

  let width = 1024;
  let height = 576;

  let _image = GrayscaleMap{
    pixels: vec![0; width * height],
    size: (width, height)
  };

  // OR 
  let _image = GrayscaleMap::new_map(width, height);

  assert_eq!(_image.size, (1024, 576));
  assert_eq!(_image.pixels.len(), 1024 * 576);

  println!("capacity: {}", _image.pixels.capacity())

}

/// 8位灰阶像素的矩形
pub struct GrayscaleMap {
  pub pixels: Vec<u8>,
  pub size: (usize, usize)
}

// 给结构体增加方法
impl GrayscaleMap {
  
  // 通过函数创建结构体实例
  pub fn new_map(width: usize, height: usize) -> GrayscaleMap {
    GrayscaleMap{
      pixels: vec![0; width * height],
      size: (width, height)
    }
  }

}


]]>
    </c:sourceContent>
    <c:sourceContent type="" title="命名字段结构体 &amp;mdash; GrayscaleMap" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn main() {

    let b = Broom {
        name: "Hokey".to_string(),
        height: 60,
        health: 100,
        position: (100.0, 2.0, 0.0),
        intent: BroomIntent::FetchWater,
    };

    let (broom1, mut broom2) = Broom::chop(b);

    broom2.intent = BroomIntent::DumpWater;

    println!("{:?}", broom1);
    println!("{:?}", broom2);

}

/// 用于表示怪物
#[derive(Debug)]
#[allow(dead_code)]
pub struct Broom {
    pub name: String,
    pub height: u32,
    pub health: u32,
    pub position: (f32, f32, f32),
    pub intent: BroomIntent,
}

/// 扫帚枚举，用于表示怪物可能干的两件事
#[derive(Copy, Clone, Debug)]
pub enum BroomIntent {
    FetchWater,
    DumpWater,
}

impl Broom {
    // 按值接收怪物，取得所有权
    pub fn chop(b: Broom) -> (Broom, Broom) {
        // 基于 b 初始化 broom1，只修改 height。因为 String 不是可复制类型
        // 所以此时broom1取得了b.name的所有权
        let mut broom1 = Broom {
            height: b.height / 2,
            ..b
        };

        // 基于 broom1 初始化 broom2，由于 (broom1.name) String 不是可复制类型，所以必须显示地克隆 broom1.name
        let mut broom2 = Broom {
            name: broom1.name.clone(),
            ..broom1
        };

        // 给两个怪物扫帚取一个不一样的名字
        broom1.name.push_str("_1");
        broom2.name.push_str("_2");

        (broom1, broom2)
    }
}


]]>
    </c:sourceContent>
    <c:sourceContent type="" title="类元组结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 创建这种类型的结构体就像创建元组一样，只不过要加上结构体的名字。
pub struct Bounds (pub usize, pub usize);

let image_bounds = Bounds(1024, 768);

// 类元组结构体体非常适合创建新类型，即只包含一个要经过严格类型检查的组件的结构体。
// 例如想只使用 ASCII 文本，可以像这样定义一个新的类型
pub struct Ascii(Vec<u8>);

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="类基元结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 这种结构体在使用特型的时候有用
// 这种类型的结构体值，不占内存，也不会生成操作他们的代码。
// 例如：表达式 .. 是对类基元结构体值 RangeFull 的简写
pub struct Onesuch;
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="通过 impl 给结构体增加方法" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug,Clone)]
pub struct Queue {
  older: Vec<char>,     // 旧元素，最老的在最后
  younger: Vec<char>,   // 新元素，最新的在后边
}

impl Queue {

  pub fn pop(&mut self) -> Option<char> {

    if self.older.is_empty() {
      
      if self.younger.is_empty() {
        return None;
      }
      
      use std::mem::swap;

      // 把 younger 中的元素转移到 older 中，并保持对外承诺的顺序
      swap(&mut self.older, &mut self.younger);

      self.older.reverse();

    }

    // 到这里 older 里肯定有元素
    self.older.pop()

  }
  
  // &mut self, &self, self 方法调用表达式可以根据函数参数推断出要借用哪种引用　

  // 接 self 的收共享可修改引用
  pub fn push(&mut self, c: char) {
    self.younger.push(c);
  }

  // 接收 self 的共享引用
  pub fn is_empty(&self) -> bool {
    self.older.is_empty() && self.younger.is_empty()
  }

  // 取得 self 的所有权
  pub fn split(self) -> (Vec<char>, Vec<char>) {
    (self.older, self.younger)
  }

}

fn main () {
  
  let mut queue = Queue{
    older: vec![],
    younger: vec![],
  };

  // 只要写 queue.push(...) 就能借用一个对 queue 的可修改引用
  // 就像 (&mut queue).push(...) 一样, 因为 push 的 self 参数就是这样要求的。
  queue.push('0');
  queue.push('1');
  queue.push('2');
  queue.push('3');
  queue.push('4');
  queue.push('5');

  let l = queue.pop();

  println!("{:?}", queue);
  println!("{}", l.unwrap());

  let _ = queue.pop();
  let l = queue.pop();

  println!("{:?}", queue);
  println!("{}", l.unwrap());


}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="泛型结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
#[derive(Debug)]
pub struct Queue<T> {
  pub older: Vec<T>,
  pub younger: Vec<T>
}

impl<T> Queue<T> {
  
  pub fn new() -> Queue<T> {
    Queue{ older: Vec::new(), younger: Vec::new() }
  }

  pub fn push(&mut self, c: T) -> &mut Queue<T> {
    self.younger.push(c);
    self
  }

}

fn main () {
  let mut q = Queue::<usize>::new();
  q.push(1).push(2).push(3).push(4);
  println!("{:?}", q);
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="带声明周期参数的结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
如果结构体字段包含引用，则必须指定这些引用的生命周期。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
pub struct Extrema<'elt> {
  pub greatest: &'elt i32,      // 最大
  pub least: &'elt i32,         // 最小
}

impl Extrema<'_> {
  
  pub fn find_extrema<'a>(slice: &'a [i32]) -> Extrema<'a> {

    let mut greatest = &slice[0];
    let mut least = &slice[0];

    for i in 1..slice.len() {
      if slice[i] < *least {
        least = &slice[i];
      }
      if slice[i] > *greatest {
        greatest = &slice[i];
      }
    }

    Extrema{
      greatest, least
    }

  }

  // 鉴于返回的类型经常使用与某个参数相同的生命期，rust 在能推断出生命周期时，允许将其省略
  // 索引 find_extrema 可以写成下边这样
  pub fn find_extrema(slice: &[i32]) -> Extrema {
    // ..
  }

}

fn main() {
  
  let a = [0,-3,0,15,48];
  let e = Extrema::find_extrema(&a);

  println!("{:?}", a);
  println!("{:?}", e);

}


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="为结构体类型派生共有特型(trait)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Debug 可打印
// Clone 克隆
// Copy 可复制
// PartialEq 相等: =, !=
// PartialOrd 比较大小: >,<,>=,<=
// 只要结构体的每个字段都实现了共有特型，那么该结构体就能自动实现他们
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct Point {
  x: f64,
  y: f64
}
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="内部修改能力" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
过渡使用内部修改能力会出问题！
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 爬虫机器人，包含设置及I/O句柄
pub struct SpiderRobot {
  pub species: String,
  pub web_enable: bool,
  pub leg_devices: [fd::FileDest; 8]
}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>枚举与模式</c:title>
    <c:desc>
      <c:desc1> <![CDATA[

]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="枚举(enum)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
Rust 枚举还可以包含数据，而且可以是不同类型的数据。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
use std::fmt;

#[derive(Debug)]
pub enum TimeUnit {
  Seconds, Minutes, Hours, Days, Months, Years
}

// rust 枚举也可以有方法
impl TimeUnit {
  
  // 返回这个时间单位的复数名词
  pub fn plural(&self) -> &'static str {

    match self {
      TimeUnit::Seconds => "seconds",
      TimeUnit::Minutes => "minutes",
      TimeUnit::Hours => "hours",
      TimeUnit::Days => "days",
      TimeUnit::Months => "months",
      TimeUnit::Years => "years",
    }

  }

  pub fn singular(&self) -> &'static str {
    self.plural().trim_end_matches('s')
  }

}

impl fmt::Display for TimeUnit {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{}", self.plural())
    }
}

fn main() {
  let s = TimeUnit::Seconds;
  println!("{}", s.plural());
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="包含数据的枚举" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
显示一个对用户更友好的近似时间。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
use std::fmt;

#[derive(Debug)]
pub enum RoughTime {
  InThePast(TimeUnit, u32),
  JustNow,
  InTheFuture(TimeUnit, u32)
}

impl fmt::Display for RoughTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            RoughTime::InThePast(a, b) => write!(f, "{}{} 以前", b, a),
            RoughTime::JustNow => write!(f, "{}", "Just now"),
            RoughTime::InTheFuture(a, b) => write!(f, "将来 {}{}", b, a),
        }
    }
}

fn main() {
  let t1 = RoughTime::InThePast(TimeUnit::Years, 20 * 4 + 7);
  let t2 = RoughTime::InThePast(TimeUnit::Hours, 3);
  let t3 = RoughTime::JustNow;
  println!("{:?}", t1);
  println!("{:?}", t2);
  println!("{:?}", t3);
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:650px" src="/images/rust/RoughTime-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="结构体变体枚举" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
与常规结构体一样包含命名字段。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

pub enum Shape {
  Sphere { center: Point3d, radius: f32 },
  Cuboid { corner1: Point3d, corner2: Point3d },
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

pub enum RelationshipStatus {

  // 基元枚举
  Single,
  InArelationship, 

  // 元组枚举
  ItsComplicated(Option<String>), 

  // 命名字段枚举
  ItsExtremelyComplicated {
    car: DifferentialEquation, 
    cdr: EarlyModernistPoem
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="使用枚举的富数据结构" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
枚举也可以用来快速实现类似树的数据结构。比如任何 Json 文档都可以用这个 Rust 类型表示:
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

pub enum Json {
  Null,                                 // 一个机器字
  Boolean(bool),                        // 一个机器字
  Number(f64),                          
  String(String),                       // 占三个机器字
  Array(Vec<Json>),                     // 占三个机器字
  Object(Box<HashMap<String, Json>>)    // HashMap 占8个机器字, 用Box封装只占1个机器字节
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:650px" src="/images/rust/json-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="泛型枚举" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
Rust 标准库中的最常用的两个枚举类型都是泛型枚举: Option&lt;T&gt;, Result&lt;T,E&gt;
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

#[derive(Debug)]
pub enum Option<T> {
  None,
  Some(T)
}

#[derive(Debug)]
pub enum Result<T, E> {
  Ok(T),
  Err(E)
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="基于 rust 泛型数据结构实现的二叉树" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/binary-tree-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:.85em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use self::BinaryTree::*;

/// T类型值的有序集合
#[derive(Debug)]
pub enum BinaryTree<T> {
  Empty, 
  NonEmpty(Box<TreeNode<T>>)    // 一个指向位于堆内存的 TreeNode 的指针
}

/// 用于表示二叉树的节点
#[derive(Debug)]
pub struct TreeNode<T> {
  pub element: T, 
  pub left: BinaryTree<T>,
  pub right: BinaryTree<T>
} 

impl<T: Ord> BinaryTree<T> {
  
  pub fn add(&mut self, value: T) {

    match *self {
      Empty => *self = NonEmpty(Box::new(TreeNode{ element: value, left: Empty, right: Empty })),
      NonEmpty(ref mut node) => {
        if value <= node.element {
          node.left.add(value);
        } else {
          node.right.add(value);
        }
      }
    }

  }

}

fn main() {
  
  let mercury_tree  = NonEmpty(Box::new(TreeNode{ element: "Mercury",  left: Empty,         right: Empty }));
  let jupiter_tree  = NonEmpty(Box::new(TreeNode{ element: "Juptiter", left: Empty,         right: Empty }));
  let mars_tree     = NonEmpty(Box::new(TreeNode{ element: "Mars",     left: jupiter_tree,  right: mercury_tree }));
  let venus_tree    = NonEmpty(Box::new(TreeNode{ element: "Venus",    left: Empty,         right: Empty }));
  let uranus_tree   = NonEmpty(Box::new(TreeNode{ element: "Uranus",   left: Empty,         right: venus_tree }));
  let saturn_tree   = NonEmpty(Box::new(TreeNode{ element: "Saturn",   left: mars_tree,     right: uranus_tree }));

  println!("{:?}", saturn_tree);

  let mut tree = BinaryTree::Empty;

  tree.add(8);
  tree.add(9);
  tree.add(6);
  tree.add(2);
  tree.add(6);
  tree.add(11);
  tree.add(1);

  println!("print2: {:?}", tree);

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="枚举模式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
pub enum RoughTime {
  InThePast(TimeUnit, u32),
  JustNow,
  InTheFuture(TimeUnit, u32)
}

impl RoughTime {
  
  pub fn to_string(&self) -> String {
    // 模式匹配
    match self {
      RoughTime::InThePast(units, count) => format!("{} {} ago", count, units.plural()),
      RoughTime::JustNow => format!("just now"),
      RoughTime::InTheFuture(units, count) => format!("{} {} ago", count, units.plural()),
    }
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="字面量模式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

match meadow.count_rabbits() {
  0 => {},
  1 => println!("A rabbit is nosing around in the clover."),
  n => println!("There are {} rabbits hopping abount in the meadow", n),
}

let calendar = match settings.get_string("calendar") {
  "gregorian"   => Calendar::Gregorian,
  "chinese"     => Calendar::Chinese,
  "ethiopian"   => Calendar::Ethiopian,
  other         => return parse_error("calendar", other),
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="通配符模式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

let caption = match photo.tagged_pet() {
  Pet::Tyrannosaur    => "RRRAAAAAHHHHHHH",
  Pet::Samoyed        => "RRRAAAAAHHHHHHH",
  Pet::Tyrannosaur    => "*dog thoughts",
  _                   => "I'm cute, love me"              // 通用标题，任何宠物都适用
} 

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

match document.selection() {
  Shape::TextSpan(start, end) => paint_text_selection(start, end),
  Shape::Rectangle(rect)      => paint_rect_selection(rect),
  _                           => panic!("unexpected selection type")
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

fn check_move(current_hex: Hex, click: Point) -> game::Result<Hex> {
  
  match point_to_hex(click) {
    None => Err("That's not a game space."),
    // Some(current_hex) 错误: 模式匹配时会引入新的变量，他会遮住函数参数 current_hex
    // Some(current_hex) => Err("You are already there! You must click somewhere else."),
    Some(hex) => 
      if hex == current_hex {
        Err("You are already there! You must click somewhere else.")
      } else {
        Ok(hex)
      }
    Some(other_hex) => Ok(other_hex)
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="元组模式匹配" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn describe_point(x: i32, y: i32) -> &'static str {
  
  use std::cmp::Ordering::*;

  match (x.cmp(&0), y.cmp(&0)) {
    (Equal, Equal) => "at the origin",
    (_, Equal) => "on the x axis",
    (Equal, _) => "on the y axis",
    (Greater, Greater) => "in the first quadrant",
    (Less, Greater) => "in the second quadrant",
    _ => "somewhere else",
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="结构体模式匹配" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

match balloon.location {
  Point{ x: 0, y: height } => println!("straiht up {} meters", height),
  Point{ x: x, y: y } => println!("at {{}m, {}m}", x, y)
}

match get_account(id) {
  Some(Account{ name, language, .. }) => language.show_custom_greeting(name),
  None => {}
}

match account {
  // 注意: 匹配不可复制的值会转移值
  // 这里 account.name, account.language 被转移到了 name, language 中，其他元素则被丢弃了
  Account{ name, language, ...} => {
    ui.greeting(&name, &language);
    ui.show_settings(&account); // 错误: 此处 account 已经被转移了
  }
}

// 使用 ref 借用匹配的值
match account {
  Account{ ref name, ref language, ...} => {
    ui.greeting(&name, &language);
    ui.show_settings(&account); // 没问题
  }
}

// 匹配可修改引用
match line_result {
  Err(ref err) => log_error(err),   // 此处 err 是 &Error (共享引用)
  Ok(ref mut line) => {             // line 是可修改引用 (&mut String)
    trim_comments(line);            // 原地修改
    handle(line);
  }
}

// & 模式匹配
match chars.peek() {
  Some(&c) => println!("coming up: {:?}", c),
  None => println!("end of chars")
}

match sphere.center() {
  &Point3d{ x, y, z } => ...
}

// 匹配不可复制值
match friend.borrow_car() {
  // Some(&Car{ engine, ... }) => ...     // 如果 engine 是不可复制则会触发错误
  Some(&Car{ ref engine, ... } )          // 正确: 对不可复制值用 ref 取得值的引用
  None => {}
}

// 匹配多种可能性
let at_end = match chars.peek() {
  Some(&'\r') | Some(&'\n') | None => true,
  _ => false
}

// ... 匹配某个范围的值
// 0 ... 9 (全纳: 包含0和9)
// 0 .. 9 (半开放: 包含0但不包含9)
match next_char {
  '0' ... '9' => self.read_number(),
  'a' ... 'z' | 'A' ... 'Z' => self.read_word(),
  ' ' | '\t' | '\n' => self.skip_whitespace(),
  _ => self.handle_punctuation()
}

// 模式匹配护具
match robot.last_known_location() {
  // 如果模式匹配转移值，则不能添加 if 护具。因为值被转移后，就不能继续匹配了。
  // 解决办法是改为借用值，例如: Some(ref point)
  Some(point) if self.distance_to(point) < 10 => short_distance_strategy(point),
  Some(point) => long_distance_strategy(point),
  None => searching_strategy(point)
}

// @模式
match self.get_selection() {
  // Shape::Rect(top_left, bottom_right) => optimized_paint(&Shape::Rect(top_left, bottom_right)),
  rect @ Shape::Rect(..) => optimized_paint(&rect)          // @ 将匹配到的值转移或复制到 rect 中
  other_shape => paint_outline(other_shape.get_outline())
}

// @模式也使用于匹配范围 
match chars.next() {
  Some(digit @ '0' ... '9') => read_number(digit, chars)
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="可驳模式(refutable pattern)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 只处理一种特定的枚举
if let RoughTime::InTheFuture(_, _) = user.date_of_birth() {
  user.set_time_traveler(true);
}

// 尽在成功时运行某些代码
if let Some(document) = cache_map.get(&id) {
  return send_cached_response(document);
}

// 失败时重复做某件事
while let Err(err) = present_cheesy_anti_robot_task() {
  log_robot_attempt(err);
}

// 遍历一个迭代器
while let Some(_) = lines.peek() {
  read_paragraph(&mut lines);
}

]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>特型与泛型</c:title>
    <c:desc>
      <c:desc1 style="margin-bottom:0;"> <![CDATA[
<div>
  Rust 对多态的支持构建于两个相关特性之上: 特型(trait) 与 泛型(generic), 合理利用泛型与特型可以<b>避免虚拟方法消耗</b>和<b>向下类型转换</b>。
</div>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

trait Write {
  fn write(&mut self, buf: &[u8]) -> Result<usize>;
  fn flush(&mut self) -> Result<()>;
  fn write_all(&mut self, buf: &[u8]) -> Result<()>;
  ....
}

use std::io::Write;

// 接口
fn say_hello(out: &mut dyn Write) -> std::io::Result<()> {
  let _ = out.write_all(b"hello world");
  out.flush()
}

// 泛型函数
fn min<T: Ord>(value1: T, value2: T) -> T {
  if value1 <= value2 {
    value1
  } else {
    value2
  }
}

fn main() {
    // 写入内存
    let mut bytes = vec![];
    say_hello(&mut bytes).unwrap();

    assert_eq!(bytes, b"hello world");
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="在任意类型上实现任意特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 将自定义特型 IsEmoji 引入当前作用域时才可见
pub trait IsEmoji {
  fn is_emoji(&self) -> bool;
}

// 给一个已有的类型 char 添加 is_emoji 方法
impl IsEmoji for char {
  pub fn is_emoji(&self) -> bool {
    false
  }
}

// 给 str 类型添加 is_emoji 方法
impl IsEmoji for str {
  pub fn is_emoji(&self) -> bool {
    false
  }
}

fn main() {
  assert_eq!('%'.is_emoji(), false);
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="在某类型家族上使用泛型impl" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

use std::io::{self, Write};

pub trait WriteHtml {
  fn write_html(&mut self, html: &HtmlDocument) -> io::Result<()>;
}

// 为任意 std::io::writer 类型实现 WriteHtml 特型
// 对每个实现了 Write 的类型 W, 实现 WriteHtml 方法
impl<W: Write> WriteHtml for W {
  fn write_html(&mut self, html: &HtmlDocument) -> io::Result<()> {
    ....
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="参考 serde 库的特型实现" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 在 serde 源代码中: Vec、HashMap 这样标准的数据结构为 bool, i8, i16, i32, i64, 数组和元组等类型实现了 Serialize 特型
use std::env;
use std::error::Error;
use std::io::{Write, stderr};
use std::collections::HashMap;
use std::fs::File;
use serde::Serialize;
use serde_json;

pub fn print_error(mut err: &dyn Error) {
  
  let _ = writeln!(stderr(), "error: {}", err);

  while let Some(cause) = err.source() {
    let _ = writeln!(stderr(), "caused by: {}", cause);
    err = cause;
  }

}

pub fn save_configuration(file_name: &str, config: &HashMap<&str, &str>) -> std::io::Result<()> {
  // 创建一个JSON序列化处理程序将数据写入文件
  let writer = File::create(file_name)?;
  // let mut serializer = serde_json::Serializer::pretty(writer); // 格式化输出
  let mut serializer = serde_json::Serializer::new(writer);
  // 剩下的事交给 serde 的 serialize() 方法处理
  config.serialize(&mut serializer)?;
  Ok(())
}


fn main() {

    let args: Vec<String> = env::args().collect();

    let mut contacts = HashMap::new();

    contacts.insert("Daniel", "798-1364");
    contacts.insert("Ashley", "645-7689");
    contacts.insert("Katie", "435-8291");
    contacts.insert("Robert", "956-1745");

    let file_name = 
        if args.len() > 1 {
          &args[1][..]     // 接收命令行参数文件名
        } else {
          "file_1.json"
        };

    save_configuration(file_name, &contacts).unwrap_or_else( |_err| print_error(&_err));

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="特型中的 Self" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 谁调用了 x.clone(), Selft 就是谁的类型
// 如果 x 是 String，那 Self 的类型就是 String
pub trait Clone {
  fn clone(&self) -> Self;
  ...
}

// 指定 Self 的特型
pub trait Spliceable {
  // 这样声明函数意味着: self 和 other 的类型必须完全一样
  fn splice(&self, other: &Self) -> Self;
}

// Self 是 CherryTree(樱桃树) 的别名
impl Spliceable for CherryTree {
  fn splice(&self, other: &Self) -> Self {
    ....
  }
}

// Self 是 Mammoth(猛犸象) 的别名
impl Spliceable for Mammoth {
  fn splice(&self, other: &Self) -> Self {
    ....
  }
}

// 错误: 使用 Self 类型的特性与特性目标不能共存
// Rust 拒绝编译这种代码, 因为它没办法对 left.splice(right) 调用做类型检查
// 特型目标的核心在于类型到运行时才能知道, 而在编译时 rust 没办法判断 left 和 right 是不是同一种类型
// 注: 此处的 “特型目标” 指的是: 实现了某特型的类型以特型的身份出现
pub fn splice_anything(left: &Spliceable, right: &Spliceable) {
  let combo = left.splice(right);
  ....
}

// 解决上边错误的办法是设计一个目标友好的特型
pub trait MagaSpliceable {
  // 这样定义使得 self 和 other 的类型不必完全一样(条件放宽了)
  fn splice(&self, other: &MagaSpliceable) -> Box<MagaSpliceable>;
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="子特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
可以将一个特型声明为另一个特型的扩展
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 所有可见的游戏角色
// 实现 Creature 的类型也必须实现 Visible 特型
pub trait Creature: Visible {
  fn position(&self) -> (i32, i32);
  fn facint(&self) -> Direction;
}

impl Visiable for Broom {
  ...
}

impl Creature for Broom {
  ...
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Rust 特型可以包含静态方法和构造函数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 字符串集合特型
// 注: 此处的 “特型目标” 指的是: 实现了某特型的类型以特型的身份出现
pub trait StringSet {
  
  // 静态方法: 不接收 self 参数的方法是静态方法
  // 由于特型目标不支持静态方法, 所以增加条件绑定 where Self: Sized
  // 增加这个条件绑定后就可以使用 &StringSet 特型目标了
  // 虽然增加了绑定条件，但是特型目标仍然不支持两个静态方法, 但是可以创建特型目标并调用其他的非静态方法
  // 同样的做法也适用于任何其他不兼容特型目标(即:不能与特性目标共存)的方法
  // fn new() -> Self;
  fn new() -> Self 
              where Self: Sized;

  // 静态方法: 返回一个包含 strings 中所有字符串的集合
  // 由于特型目标不支持静态方法, 所以增加条件绑定 where Self: Sized
  // 增加这个条件绑定后就可以使用 &StringSet 特型目标了
  // 同样的做法也适用于任何其他不兼容特型目标(即:不能与特性目标共存)的方法
  fn from_slice(strings: &[&str]) -> Self 
              where Self: Sized;

  // 确定当前集合是否包含特定的 string_value
  fn contains(&self, string_value: &str) -> bool;

  // 向当前集合中添加一个字符串
  fn add(&mut self, string: &str);

}

// 返回 document 中不再 wordlist 中的单词的集合
fn unknown_words<S: StringSet>(document: &Vec<String>, wordlist: &S) -> S {
  
  let mut unknowns = S::new();

  for word in document {
    if !wordlist.contains(word) {
      unknowns.add(word);
    }
  }

  unknowns

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="完全限定方法调用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 以下四种函数调用都是等价的
"hello".to_string();                      // 并没有说明要调用的是哪个 to_string() 方法，
                                          // rust会通过一个方法查找算法(根据类型、强制解引用等)，来判断将要调用哪个具体方法
str::to_string("hello");                  // 限定方法(即指定方法关联的类型或特型)
ToString::to_string("hello");             // 限定方法
<str as ToString>::to_string("hello");    // 完全限定方法

// 当 rust 无法推断 self 时需要使用完全限定方法
let zero = 0;     // 类型未指定，可能是 i8, u8
zero.abs();       // 错误，对于不确定的类型 rust 无法推断将要调用哪个方法
i64.abs(zero);    // 正确(因为使用了完全限定方法)

// 将函数本身作为值时需要使用完全限定方法
let words: Vec<String> = 
    line.split_whitespace()                 // 产生 &str 值的迭代器
        .map(<str as ToString>::to_string)  // 完全限定方法调用 
        .collect();

// 完全限定语法也适用于静态方法调用
S::new(); 等价于 StringSet::new(); 或 <S as StringSet>::new();

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="定义类型关系的特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
特型是类型可以实现的一组方法。在需要多个类型相互协作的情况下，特型可以用来描述类型之间的关系。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 关联类型 -- 之迭代器(Iterator)工作原理
pub trait Iterator {
  type Item;                                  // 一个关联类型, 即: 所有实现 Iterator 的类型都必须指定自己产生的项(item)的类型。
  fn next(&mut self) -> Option<Self::Item>;
}

impl Iterator for Args {
  
  type Item = String;

  fn next(&mut self) -> Option<String> {
    ...
  }

}

// 泛型函数同样可以使用关联类型
pub fn collect_into_vector<I: Iterator>(iter: I) -> Vec<I::Item> {
  
  let mut results = Vec::new();

  // 此处 rust 为推断出 value 的类型 
  for value in iter {
    results.push(value);
  }

  results

}

// 打印出一个迭代器的所有值
pub fn dump<I>(iter: I) 
           where I: Iterator {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // value 是不可以打印类型
  }
}

use std::fmt::Debug;

// 打印出一个迭代器的所有值
pub fn dump<I>(iter: I) 
           where I: Iterator, I::Item: Debug {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // Item 实现了 Debug
  }
}

// 打印出一个 String 迭代器的所有值
pub fn dump<I>(iter: I) 
           where I: Iterator<Item=String> {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // String 实现了 Debug
  }
}

// OR
pub fn dump(iter: &mut Iterator<Item=String>) {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // String 实现了 Debug
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="泛型特型(或操作符重载的原理)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// rust 中的乘法运算符, 支持 * 操作符的类型实现的特型
// RHS (Right Hand Side) 右手边的减写形式
pub trait Mul<RHS> {
  type Output;                                // 应用 * 操作符之后返回的结果类型
  fn mul(self, rhs: RHS) -> Self::Output;     // * 操作符对应的方法
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="伴型特型(或rand::random()的工作原理)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 任意 Rng 类型可以生成所有 Rand 类型的值

use rand::random;

// 推断类型
let x = random(); 

// 如果rust无法推断类型，则必须指明随机数类型
let a = random::<f64>();      
let a = random::<bool>();     

// rand 包中的所有随机数生成器都实现了一个公共特型
pub trait Rng {
  fn next_u32(&mut self) -> u32;
  ...
}

// rand 包提供了几中 Rng 的不同实现
// XorShiftRng 一个快速伪随机数生成器
// OsRng 无法预测的随机数生成器

// rand 包用到的一个伴型特型叫 Rand
/// 可以使用 Rng 随机生成的类型
pub trait Rand: Sized {
  fn rand<R: Rng>(rng: &mut R) -> Self;
}

// f64, bool 等类型都实现了这个 Rand 特型
let x = f64::rand(rng);
let b = bool::rand(rng);

// 实际上 random() 函数只是简单封装了下对 rand 方法的调用
pub fn random<T: Rand>() -> T {
  T::rand(&mut global_rng())
}

// ### 标准库中计算散列码的实现是伴型特型的另一个例子
// 1. 实现 Hash 的类型是可以散列化的, 因此可以用作散列表的键
// 2. 实现 Hasher 的类型是散列化算法。
// 3. Hash 有一个泛型方法 Hash::hash() 接收任何类型的 Hasher 作为参数

// ### serde 库的 Serialize 特型也用到了 "伴型特型" (Serializer)
// 1. serde 支持可插拔的序列化格式
// 2. 不同的 Serializer 实现了 JSON, Yaml, CBOR(二进制格式)

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="逆向工程绑定" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// *************************************************************************************************
// ***** 对以下示例中的 N 的绑定过程进行了逆向工程, 让编译器指导自己反复检查自己的工作，最终给出合理的条件绑定 *****
// *************************************************************************************************

// 常规函数
pub fn dot(v1: &[i64], v2: &[i64]) -> i64 {
  let mut total = 0;
  for i in 0 .. v1.len() {
    total = total + v1[i] * v2[i];
  }
  total
}

// 泛型函数(由于此处的泛型参数N可能并不支持乘法和加法，所以rust编译报错)
pub fn dot<N>(v1: &[N], v2: &[N]) -> N {
  let mut total = 0;                // 由于0的类型始终是整数
  for i in 0 .. v1.len() {
    total = total + v1[i] * v2[i];
  }
  total
}

// 需要给泛型参数 N 添加限定类型
pub fn dot<N: Add<Output=N> + Mul<Output=N> + Default>(v1: &[N], v2: &[N]) -> N {
  // 由于0的类型始终是整数, 所以需声明有默认值的类型才能调用此方法
  // 在 rust 标准库中有个 Default 特型，所有有默认值的类型都实现了 Default 特型 
  // let mut total = 0;
  let mut total = N.default();
  for i in 0 .. v1.len() {
    // 两个数相乘并不一定会得到相同的类型, 需要告诉rust这个泛型函数只适用于常规乘法运算
    // 需要给 Add, Mul 增加限定条件: Add<Output=N>, Mul<Output=N>
    // total = total + v1[i] * v2[i]; 
    total = total + v1[i] * v2[i];
  }
  total
}

// *************************************************************************************************
// ***** where N: Add<Output=N> + Mul<Output=N> + Default + Copy ***********************************
// ***** Rust这种"条件绑定"设计的优点是：****************************************************************
// ***** 1. 可以让泛型代码具有向前兼容的能力 *************************************************************
// ***** 2. 绑定的另一个优点是可以通过编译器报错知道要解决的麻烦在哪里 ***************************************
// ***** 3. 相比C++编译器设计模版的错误信息要比 Rust 啰嗦的多，是模版呢还是调用者，通常难于分辨 ****************
// ***** 4. 最终要的优点是代码即文档: 代码里已经明确了程序的运行原理 ****************************************
// *************************************************************************************************
// 增加可读性: 将限定条件转移到 where 子句中
pub fn dot<N>(v1: &[N], v2: &[N]) -> N 
          where N: Add<Output=N> + Mul<Output=N> + Default + Copy {

  // 由于0的类型始终是整数, 所以需声明有默认值的类型才能调用此方法
  // 在 rust 标准库中有个 Default 特型，所有有默认值的类型都实现了 Default 特型 
  // let mut total = 0;
  let mut total = N.default();

  for i in 0 .. v1.len() {
    
    // 两个数相乘并不一定会得到相同的类型, 需要告诉rust这个泛型函数只适用于常规乘法运算
    // 需要给 Add, Mul 增加限定条件: Add<Output=N>, Mul<Output=N>
    // total = total + v1[i] * v2[i]; 

    // v1[i] 会把值从切片中转移，但函数声明中的 N 可能是不可复制类型
    // 所以需要让 rust 知道 N 是可复制类型: + Copy 
    // total = total + v1[i] * v2[i]; 
    
    total = total + v1[i] * v2[i];
  
  }
  
  total

}

// 有一个流行的 rust 开源库 num，
// 该库定义了 Num 特型用于表示所有 Number 类型
// (支持加，减，乘，除的都可以是 number)
pub fn dot<N>(v1: &[N], v2: &[N]) -> N 
          where N: Num + Copy {

  // let mut total = 0;
  let mut total = N.zero();

  for i in 0 .. v1.len() {
    // v1[i] 会把值从切片中转移，但函数声明中的 N 可能是不可复制类型
    // 所以需要让 rust 知道 N 是可复制类型: + Copy 
    // total = total + v1[i] * v2[i]; 
    total = total + v1[i] * v2[i];
  }
  
  total

}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>实用特型</c:title>
    <c:desc>
      <c:desc1 style="margin-bottom:0;"> <![CDATA[

<table style="margin:.5em 0;line-height:1.3em;width:100%;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="padding: 0;margin: 0;text-align: right;padding-right:1em;">特型</th>
            <th style="padding: 0;margin: 0;text-align: left;padding:.5em 0;padding-left:1em;">作用</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Drop</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">解构函数，清除值时Rust自动运行的清除代码。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Sized</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">标记特型，针对编译时可以知道大小的类型。而不是像切片那样动态大小的类型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Clone</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">针对支持克隆值的类型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Copy</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">标记特型，针对可以简单地对内存中包含的值进行逐字节复制来克隆的类型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Deref与DerefMut</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">智能指针类型的特型</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Default</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">针对有合理“默认值”的类型</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">AsRef与AsMut</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，借用某种类型的引用。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Borrow与BorrowMut</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，类似AsRef/AsMut，但额外保证一致的散列、顺序和相等</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">From与Into</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，将某种类型的值转换为另一种特型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">ToOwned</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，将引用转换为所有值。</td>
        </tr>
    </tbody>
</table>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="Drop" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 可以通过实现 std::ops::Drop 特型自定义 Rust 清除值的方式
// Rust 会在清除每个值之前调用 Drop::drop, 所以该方法接收到的值肯定是完全初始化的。
// 如果某类型实现了 Drop 就不能在实现 Copy 特型:
// 1. 如果一个类型是 Copy，就意味着简单的字节对字节的复制已经足以产生一个值的独立副本
// 2. 注意: 在同一份数据上不止一次调用同一个 drop 方法通常是错误的
pub trait Drop {
  fn drop(&mut self);
}

// Application 拥有字符串的内容和向量元素缓冲区对应的堆内存空间。
// Rust 会在 Applicaiton 被清除时自动释放这些存储空间
pub struct Application {
  name: String,             // String 内部使用 Vec<u8> 保存其文本，因此 String 自身不需要实现 Drop，而是有 Vec 负责释放其字符
  nicknames: Vec<String>    // Vec 类型实现了 Drop，可以清除自己的每个元素，然后释放他们占用的堆内存空间
}

// 为 Applicaiton 类型实现 Drop 的代码可以任意使用其字段
// 1. String 内部使用 Vec<u8> 保存其文本，因此 String 自身不需要实现 Drop，而是有 Vec 负责释放其字符
// 2. Vec 类型实现了 Drop，可以清除自己的每个元素，然后释放他们占用的堆内存空间
// 3. 保存 Application 值自身的内存也有所有者: 可能是一个局部变量或某个数据结构，他们会负责释放对应的内存
impl Drop for Application {
  
  pub fn drop(&self) {
    
    print!("Droping {}", self.name);

    if !self.nickname.is_empty() {
      print!("(AKA {})", self.nicknames.join(","));
    }

    println!("");

  }

}

fn main() {
  let mut a = Applicaiton(name: "Zues".to_string(), nicknames: vec!["cloudcollector".to_string()]);
  println!("before assignment");
  a = Applicaiton(name: "Hera".to_string(), nicknames: vec![]);
  println!("at end of block");
}


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 在 Unix 系统上，Rust 标准库在内部使用以下类型表示操作系统的文件描述符:
pub struct FileDesc {
  // c_int 是 i32 的别名
  // fd 表示文件描述符的编号
  // 在进程关闭时关闭该文件句柄
  pub fd: c_int,        
}

impl Drop for FileDesc {
  pub fn drop(&mut self) {
    // libc::close 是 C 库的 close 函数在 Rust 中的名字
    // Rust 代码只能在 unsafe 块中调用 C 函数
    let _ = unsafe { 
      libc::close(self.fd) 
    };
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Sized (固定大小类型)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// ### 固定大小
// 固定大小类型，指的是相同类型的值在内存中都具有相同大小。
// u64: 8字节
// (f32, f32, f32): 12字节
// 虽然 Vec<T> 拥有分配在堆上的大小可变的缓冲区，但Vec值本身只包含一个指向该缓冲区的指针、缓冲区的容量和长度。因此 Vec<T> 也是固定大小的类型。

// ### 非固定大小
// Rust 也有一些非固定大小的类型，其值的大小是不固定的。
// 1. 比如 str(注意没有 &) 类型是非固定大小的，字符串字面量 "diminutive" 和 "big" 是对占用 10 字节和3字节 str 切片的引用。
// 2. [T](注意没有 &) 这样的数组切片类型也是非固定大小的，即: 共享引用 &[u8] 可以指向任意大小的 [u8] 切片。
// 3. 对特型目标的引用也是非固定大小的
//    -- 特型目标是一个指向实现了给定特型的某个值的指针
//    -- &std::io::Write 和 Box<std::io::Write> 都是指向实现了 Write 特型的某个值的指针。
//    -- rust 不能在变量中存储非固定大小的值，也不能将他们作为参数传递，只能通过 &str 或 Box<Write> 这样本身是固定大小的指针来使用他们。
//    -- 指向非固定大小值的指针始终是一个"胖指针"，占两个字宽。
//    -- "胖指针"即包含指向切片的指针，也包含切片的长度。
//    -- 而"特型目标"包含一个指向方法实现的虚拟表的指针。
//    -- 不知道长度就不能使用索引访问 [u8] 值, 而不知道对 Write 的特定实现，就不能调用 Box<Write> 上的方法。
//    -- 胖指针补充了类型缺少的信息，给出了长度和虚拟表的指针。遗漏的信息被动态信息所取代。
// 4. 结构体类型的最后一个字段可能是非固定大小的，此时结构体本身也是非固定大小的。
// 5. rust 函数不可能返回非固定大小的值

struct RcBox<T: ?Sized> {
  ref_count: usize,
  value: T
}

use std::fmt::Display;

fn display(boxed: &RcBox<Display>) {
  println!("{:?}", boxed);
}

fn main() {
  let boxed_lunch: RcBox<String> = RcBox{ ref_count: 1, value: "lunch".to_string() };
  // let boxed_displayable: &RcBox<Display> = &box_lunch;
  display(&box_lunch);
}

// 1. 所有固定大小的类型都实现了 std::marker::Sized 特型。Rust 为其适用的所有类型自动实现了这个特型。
// 2. 开发者不能自己实现 Sized 特型，唯一需要使用 Sized 的场景是绑定类型变量。T: Sized 要求 T 必须是一个编译时大小已知的类型。这种特型称为标记特型。
// 3. 由于非固定大小的类型具有很大的局限性，因此大多数泛型变量应该被限制为使用 Sized 类型。
// 4. Rust 隐式的将 Sized 特型用作泛型变量的默认绑定限制，如果不想这样的限制就必须显示声明，比如: struct S<T: ?Sized> { ... }

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Clone" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Clone 特型适用于可以复制自身的类型, 定义如下:
// 由于函数不可能返回非固定大小的值，所以 Clone 特型本身扩展了 Sized 特型
// 调用 clone() 必须保证绝对成功，某些在复制过程中可能失败的类型不能实现 Clone 特型
// rust 标准库的很多类型均实现了 Clone: bool, f32, String, Vec<T>, HashMap
trait Clone: Sized {
  // 克隆一个值，通常涉及创建该值所拥有一切内容的副本及分配内存
  fn clone(&self) -> Self;
  // 该方法将 self 修改为 source 的一个副本：
  // 1. 假设 s 和 t 都是 String，则语句 s = t.clone()，必须先克隆 t，清除 s 的值，然后将克隆出来的值转移到 s 中
  // 2. 这涉及一次堆内存分配和一次堆内存释放，
  // 3. 如果 s 值所拥有的堆缓冲区有足够的容量可以装下 t 的内容，就无需分配或释放了
  // 4. 此时只要将 t 的文本复制到 s 的缓冲区，在调整下长度即可
  // 5. 在泛型代码中，应该尽量使用 clone_from
  // 如果你对Clone的实现只是简单地对自有类型的每个字段或元素应用 clone，然后在基于克隆的副本构建一个新的值，那么 clone_from 的默认定义就足够用了
  // 此种情况下: 只需要在类的定义上加 #[derive(Clone)]，rust 就会为你实现它
  fn clone_from(&mut self, source: &Self) {
    *self = source.clone(); 
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Copy" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 如果某类型实现了 std::marker::Copy 标记特型，那么它就是 Copy 类型。
// 1. Rust 只允许类型在"字节对字节的深度复制"能满足要求的情况下实现 Copy 特型
// 2. 如果某类型可能拥有任意资源，比如缓冲区或操作系统句柄的类型，不能实现 Copy
// 3. 任何实现了 Drop 的类型不可以在实现 Copy, Rust 认为如果一个类型需要特殊的清理代码，那么就一定要特殊的复制代码！！
// 4. 如果一个类型实现了 Copy，那么在变量赋值或传参时会产一个原始值的副本，而不是转移值。因此隐式复制的代价是很大的，谨慎使用 Copy 特型
// 5. 可以使用 #[derive(Copy)] 让 rust 为你派生 Copy
trait Copy: Clone {
  
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Deref 与 DerefMut" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 修改解引用操作符 * 和 . 在自定义类型上的行为。
// Box<T> 和 Rc<T> 这样的指针类型实现了这两个特型，从而可以像 Rust 内置的指针类型一样行事。
// -- 例如: Box<Complex> 类型的值 b，那么 *b 引用的就是 b 指向的 Complex 的值，而 b.re 指向的是类型字段的值
// 如果一次 deref 调用可以消除类型匹配错误，那 rust 会为你插入一次，这种操作被称为"解引用强制转型":
// 1. 假设有一个 Rc<String> 的值 r: 
//    -- String.find 可以简单地写成 r.find('?') 而不需要写成 (*r).find('?')，
//    -- 这里的方法调用隐式借用了 r，而 &Rc<String> 被强制转换成了 &String, 
//    -- 因为 Rc<T> 实现了 Deref<Target=T>
// 2. 虽然 split_at 是 str 切片类型的方法，可以在 String 值上使用 split_at 等方法:
//    -- 因为 String 实现了 Deref<Target=str>, 
//    -- 这样 String 就不需要在实现 str 的所有方法了
//    -- 因为可以将 &String 强制转型为 &str
//    -- 此时涉及到连续多次应用“解引用强制转型”: &Rc<String> to &String to &str
// 3. 假设有一个字节向量 v:
//    -- 可以将这个向量 &v 传给一个参数是 &[u8] 的函数，
//    -- 因为 Vec<T> 实现了 Deref<Target=[T]>
// 设计 Deref 和 DerefMut 设计的目的是：
// -- 为了实现智能指针类型(Box,Rc,Arc)和简化某些会频繁通过引用来使用的类型的所有者版本(例如Vec<T>和String是[T]和str的所有者版本)
pub trait Deref {
  type Target: ?Sized;
  fn deref(&self) -> &Self::Target;     // 将前一种类型的引用转换为后一种类型的引用
}

pub trait DerefMut: Deref {
  fn deref_mut(&mut self) -> &mut Self::Target;
}

// 例子:
pub struct Selector<T> {
  pub elements: Vec<T>,     // 所有元素用一个向量存储
  pub current: usize;       // 当前元素的索引
}

use std::ops::{Deref, DerefMut}

impl<T> Deref for Selector<T> {
  type Target = T;
  fn deref(&self) -> &T {
    &self.elements[self.current];
  }
}

impl<T> DerefMut for Selector<T> {
  fn deref_mut(&self) -> &mut T {
    &mut self.elements[self.current]
  }
}

fn main() {
  
  let mut s = Selector{ elements: vec!['x', 'y', 'z'], current: 2 };

  // 因为 Selector 实现了 Deref, 所以可以使用 * 操作符引用它的当前元素
  println!("{}", *s);

  // 通过"解引用强制转型"直接在 Selector 上使用 char 的方法
  println!("{}", s.is_alphabetic());

  // 通过给 Selector 的引用赋值，将 'z' 自改为 'w'
  *s = 'w';

  println!("{}", s);

}

]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  


</c:component>
