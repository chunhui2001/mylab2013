<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div style="margin-bottom:1em;line-height:1.625;">
  Rust是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust在语法上和C++类似，但是设计者想要在保证性能的同时提供更好的内存安全。 Rust最初是由Mozilla研究院的Graydon Hoare设计创造，然后在Dave Herman, Brendan Eich以及很多其他人的贡献下逐步完善的。Rust的设计者们通过在研发Servo网站浏览器布局引擎过程中积累的经验优化了Rust语言和Rust编译器。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  Rust编译器是在MIT License 和 Apache License 2.0双重协议声明下的免费开源软件。Rust已经连续七年（2016，2017，2018，2019，2020, 2021, 2022）在Stack Overflow开发者调查的“最受喜爱编程语言”评选项目中折取桂冠。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  Rust的灵感来自多种语言的知识，其中值得一提的是Cyclone(一种安全的C语言变体)的基于区域的内存管理技术、C++的RAII原则、Haskell的类型系统、异常处理类型和类型类。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  Rust还借鉴了C++的RAII原则用于资源初始化，这种技术的本质是将资源的生命周期和对象的生命周期绑定，而堆分配类型的解除分配是通过执行drop特征上的drop()方法实现的。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  当变量的生命周期超出作用域时，程序会自动调用此方法。它还用Result和Option类型替代了空指针的概念，这意味着Rust不允许代码中出现null/undefined的值。
</div>

<div style="margin-bottom:1em;line-height:1.625;">
  <b>你需要深入理解 rust 如何确保引用永远不会指向已经离开作用域的变量。</b>
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>日常开发常用Rust库</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Web/HTTP" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>HTTP客户端</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/seanmonstar/reqwest">reqwest</a> 一个简单又强大的 HTTP 客户端，reqwest 是目前使用最多的 HTTP 库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Web框架</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/axum">axum</a> 基于 Tokio 和 Hyper 打造，模块化设计较好，目前口碑很好，值得使用 Ergonomic and modular web framework built with Tokio, Tower, and Hyper</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/SergioBenitez/Rocket">Rocket</a> 功能强大，API 简单的 Web 框架，但是主要开发者目前因为个人原因无法进行后续开发，未来存在不确定性</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/actix/actix-web">actix-web</a> 性能极高的 Web 框架，就是团队内部有些问题，未来存在一定的不确定性</li>
      <li style="margin-top:.325em;">总体来说，上述三个 web 框架都有很深的用户基础，其实都可以选用，如果让我推荐，顺序如下: axum > Rocket > actix-web。不过如果你不需要多么完善的 web 功能，只需要一个性能极高的 http 库，那么 actix-web 是非常好的选择，它的性能非常非常非常高！</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="日志监控" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>日志 <a style="text-decoration: underline;color:teal;" href="https://crates.io/keywords/log">[crates.io]</a> [github]</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/tracing">tokio-rs/tracing</a> 强大的日志框架，同时还支持 OpenTelemetry 格式，无缝打通未来的监控</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rust-lang/log">rust-lang/log</a> 官方日志库，事实上的 API 标准, 但是三方库未必遵循</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/estk/log4rs">estk/log4rs</a> 模仿 JAVA logback 和 log4j 实现的日志库, 可配置性较强</li>
      <li style="margin-top:.325em;">在其它文章中，也许会推荐 slog，但是我们不推荐，一个是因为近半年未更新，一个是 slog 自己也推荐使用 tracing。</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>监控</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/open-telemetry/opentelemetry-rust">OpenTelemetry</a> 是现在非常火的可观测性解决方案，提供了协议、API、SDK 等核心工具，用于收集监控数据，最后将这些 metrics/logs/traces 数据写入到 prometheus, jaeger 等监控平台中。最主要是，它后台很硬，后面有各大公司作为背书，未来非常看好！</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/vectordotdev/vector">vectordotdev/vector</a> 一个性能很高的数据采集 agent，采集本地的日志、监控等数据，发送到远程的 kafka、jaeger 等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="SQL客户端" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>通用</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/launchbadge/sqlx">launchbadge/sqlx</a> 异步实现、高性能、纯 Rust 代码的 SQL 库，支持 PostgreSQL, MySQL, SQLite 和 MSSQL.</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>ORM</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rbatis/rbatis">rbatis/rbatis</a> 国内团队开发的 ORM，异步、性能高、简单易上手</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/diesel-rs/diesel">diesel-rs/diesel</a> 安全、扩展性强的 Rust ORM 库，支持 Mysql、Postgre、SqlLite</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Mysql</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/blackbeam/rust-mysql-simple">blackbeam/rust-mysql-simple</a> 纯Rust实现的 Mysql 驱动,提供连接池</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/blackbeam/mysql_async">blackbeam/mysql_async</a> 基于 Tokio 实现的异步 Mysql 驱动</li>
      <li style="margin-top:.325em;">上面两个都是一个团队出品，前者文档更全, star 更多，建议使用前者</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Postgre</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/sfackler/rust-postgres">sfackler/rust-postgres</a> 纯 Rust 实现的 Postgre 客户端</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Sqlite</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rusqlite/rusqlite">rusqlite</a> 用于 Sqlite3 的 Rust 客户端</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="NoSql客户端" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Redis</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/redis-rs/redis-rs">mitsuhiko/redis-rs</a> 虽然最近更新不太活跃，但是它依然是最好的 redis 客户端，说实话，我期待更好的，可能这也是 Rust 生态的未来可期之处吧</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Canssandra</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/krojew/cdrs-tokio">krojew/cdrs-tokio</a> [cdrs-tokio] 生产可用的 Cassandra 客户端，异步、纯 Rust 实现，就是个人项目 + star 较少，未来不确定会不会不维护</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/scylladb/scylla-rust-driver">scylla-rust-driver</a> ScyllaDB 提供的官方库，支持 cql 协议，由于背靠大山，未来非常可期</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>MongoDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/mongodb/mongo-rust-driver">mongodb/mongo-rust-driver</a> 官方 MongoDB 客户端，闭着眼睛选就对了</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="分布式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>服务发现</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/lodrem/etcd-rs">luncj/etcd-rs</a> 异步实现的 Rust etcd 客户端，优点是有一定的文档、作者较为活跃, 意味着你提问题他可能会回答，不过，如果你不放心，还是考虑使用 HTTP 的方式访问 ETCD</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="消息队列" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Kafka</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/fede1024/rust-rdkafka">fede1024/rust-rdkafka</a> Rust Kafka 客户端，基于C版本的 Kafka 库 [librdkafka] 实现，文档较全、功能较为全面</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/kafka-rust/kafka-rust">kafka-rust/kafka-rust</a> 相比上一个库，它算是纯 Rust 实现，文档还行，支持 Kafka0.8.2 及以后的版本，但是对于部分0.9版本的特性还不支持。同时有一个问题：最初的作者不维护了，转给了现在的作者，但是感觉好像也不是很活跃</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Nats</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a href="https://github.com/nats-io/nats.rs">nats-io/nats.rs</a> Nats 官方提供的客户端</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="网络、通信协议" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Websocket</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/snapview/tokio-tungstenite">snapview/tokio-tungstenite</a> 更适合 Web 应用使用的生产级 Websocket 库，它是异步非阻塞的，基于下下面的 tungstenite-rs 库和 tokio 实现</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/websockets-rs/rust-websocket">rust-websocket</a> 老牌 Websocket 库，提供了客户端和服务器端实现，但是。。。很久没更新了</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/snapview/tungstenite-rs">snapview/tungstenite-rs</a> 轻量级的 Websocket 流实现，该库更偏底层，例如，你可以用来构建其它网络库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>gRPC</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/hyperium/tonic">hyperium/tonic</a> 纯 Rust 实现的 gRPC 客户端和服务器端，支持 async/await 异步调用，文档和示例较为清晰</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tikv/grpc-rs">tikv/grpc-rs</a> 国产开源之光 Tidb 团队出品的 gRPC 框架, 基于C的代码实现, 就是最近好像不是很活跃</li>
      <li style="margin-top:.325em;">其实这两个实现都很优秀，把 tonic 放在第一位，主要是因为它是纯 Rust 实现，同时社区也更为活跃，但是并不代表它比 tikv 的更好！</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>QUIC</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/cloudflare/quiche">cloudflare/quiche</a> 大名鼎鼎 cloudflare 提供的 QUIC 实现，据说在公司内部重度使用，有了大规模生产级别的验证，非常值得信任，同时该库还实现了 HTTP/3</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quinn-rs/quinn">quinn-rs/quinn</a> 提供异步 API 调用，纯 Rust 实现，同时提供了几个有用的网络库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>MQTT</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/bytebeamio/rumqtt">bytebeamio/rumqtt</a> MQTT3.1.1/5 协议库，同时实现了客户端与服务器端 broker</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/ntex-rs/ntex-mqtt">ntex-rs/ntex-mqtt</a> 客户端与服务端框架，支持 MQTT3.1.1 与5协议</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/eclipse/paho.mqtt.rust">eclipse/paho.mqtt.rust</a> 老牌 MQTT 框架，对 MQTT 支持较全, 其它各语言的实现也有</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="异步网络编程" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/tokio">tokio-rs/tokio</a> 最火的异步网络库，除了复杂上手难度高一些外，没有其它大的问题。同时tokio团队提供了多个非常优秀的Rust库，整个生态欣欣向荣，用户认可度很高</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://async.rs/">async-std</a> 跟标准库API很像的异步网络库，相对简单易用，但是貌似开发有些停滞，还有就是功能上不够完善。但是对于普通用户来说，这个库非常值得一试，它在功能和简单易用上取得了很好的平衡</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/actix/actix">actix</a> 基于Actor模型的异步网络库，但这个库的开发貌似已经停滞，他们团队一直在专注于actix-web的开发</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/mio">mio</a> 严格来说，MIO与之前三个不是同一个用途的，MIO = Meta IO，是一个底层IO库，往往用于构建其它网络库，当然如果你对应用网络性能有非常极限的要求，可以考虑它，因为它的层次比较低，所带来的抽象负担小，所以性能损耗小</li>
  <li style="margin-top:.325em;">如果你要开发生产级别的项目，我推荐使用 tokio，稳定可靠，功能丰富，控制粒度细；自己的学习项目或者没有那么严肃的开源项目，我推荐 async-std，简单好用，值得学习；当你确切知道需要 Actor 网络模型时，就用 actix</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="搜索引擎" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>ElasticSearch客户端</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/elastic/elasticsearch-rs">elastic/elasticsearch</a> 官方es客户端，目前第三方的基本都处于停滞状态，所以不管好坏，用呗</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Rust搜索引擎</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quickwit-oss/tantivy">Tantivy</a> 是Rust实现的本地搜索库，功能对标 lucene，如果你不需要分布式，那么引入 tantivy 作为自己本地 Rust 服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Rust搜索平台</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quickwit-oss/quickwit">quickwit</a> 对标 ElasticSearch，一个通用目的的分布式搜索平台，目前还在起步阶段(0.2版本)，未来非常可期，目前还不建议使用</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a> 虽然也是一个搜索平台，但是并不是通用目的的，MeiliSearch 目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="代码Debug" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>GDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/cs01/gdbgui">gdbgui</a> 提供浏览器支持的 gdb debug工具，支持 C，C++，Rust 和 Go.</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>LLDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> — 专门为VSCode设计的LLDB Debug扩展</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="性能优化" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/bheisler/criterion.rs">bheisler/criterion.rs</a> 比官方提供的 benchmark 库更好，目前已经成为事实上标准的性能测试工具</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/koute/bytehound">Bytehound</a> Linux 下的内存分析工具，可以用来分析：内存泄漏、内存分配、调用栈追踪，甚至它还有一个浏览器UI! 懂的人都懂，性能测试工具的UI服务是多么稀缺和珍贵！</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/llogiq/flame">llogiq/flame</a> 专为Rust打造的火焰图分析工具，可以告诉你程序在哪些代码上花费的时间过多，非常适合用于代码性能瓶颈的分析。与 perf 不同，flame 库允许你自己定义想要测试的代码片段，只需要在代码前后加上相应的指令即可，非常好用</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/sharkdp/hyperfine">sharkdp/hyperfine</a> 一个命令行 benchmark 工具，支持任意 shell 命令，支持缓存清除、预热、多次运行统计分析等，尽量保证结果的准确性</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="编解码" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/serde-rs/serde">Serde</a> 一个超高性能的通用序列化/反序列化框架，可以跟多种协议的库联合使用，实现统一编解码格式</li>
  <li style="margin-top:.625em;">CSV -- <a style="text-decoration: underline;color:teal;" href="https://github.com/BurntSushi/rust-csv">BurntSushi/rust-csv</a> 高性能CSV读写库，支持Serde</li>
  <li style="margin-top:.625em;">JSON -- <a style="text-decoration: underline;color:teal;" href="https://github.com/serde-rs/json">serde-rs/json</a> 快到上天的JSON库，也是Rust事实上的标准JSON库，你也可以使用它的大哥serde，一个更通用的序列化/反序列化库</li>
  <li style="margin-top:.625em;">MsgPack -- <a style="text-decoration: underline;color:teal;" href="https://github.com/3Hren/msgpack-rust">3Hren/msgpack-rust</a> 纯Rust实现的MessagePack编解码协议</li>
  <li style="margin-top:.625em;">
    <div>ProtocolBuffers</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/prost">tokio-rs/prost</a> tokio出品，基本都属精品，此库也不例外，简单易用，文档详细</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/stepancheg/rust-protobuf">stepancheg/rust-protobuf</a> 纯 Rust 实现</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>TOML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/toml-rs/toml-rs">alexcrichton/toml-rs</a> TOML编码/解码，可以配合serde使用</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>XML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tafia/quick-xml">tafia/quick-xml</a> 高性能XML库，可以配合serde使用，文档较为详细</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>YAML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/dtolnay/serde-yaml">dtolnay/serde-yaml</a> 使用serde编解码YAML格式的数据</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Email" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/lettre/lettre">lettre/lettre</a> — Rust SMTP 库</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Install Rust Development Environment</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="安装 cargo &amp; rust-analyzer" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
### 安装完成后可以使用 cargo
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

### 安装 macOS 包管理工具 brew
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

### 安装 rust-analyzer (安装Rust官方支持的代码分析前端程序), 耗时较长
$ brew install rust-analyzer

    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="安装 sublime text 4 rust 插件" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

### 打开sublime，快捷键 command + shift + p 调出命令选项，输入 install package control 安装 sublime 包管理工具
## 1. LSP（必须）
-- Language Server Protocol，语言服务器协议，此插件为 sublime 实现了 LSP 功能（有兴趣自行查阅资料），以关联 rust-analyzer，实现代码分析

## Rust Enhanced（必须）
-- 这是Rust社区官方维护的sublime插件，提供语法高亮、快捷构建等功能。

## sublimecodeintel
-- 全功能代码智能补全

## All Autocomplete
-- 在所有打开的文件中进行关键字搜索以及补全（面对所有文本，不受编程语言以及单个文件的限制）

## rust syntax
-- 为代码提供语法高亮。

## toml
-- Rust 使用 toml 做项目的配置管理。

## Tabnine
-- 基于 AI 的自动补全，可以帮助你更快地撰写代码。一位来自加拿大的大四学霸，开发了一款”Deep TabNine“代码补全工具，实现了这一大胆的想法。它支持23种编程语言、5种编辑器，使用简单，效果惊艳。

### 设置 LSP 
## 通过 sublime 打开一个随意的 rust 文件或项目文件夹，快捷键 command + shift + p 调出命令选项，有两种命令可选：
-- LSP: Enable Language Server Globally 此命令会让 sublime 只要启动就加载所选的代码分析前端（不建议，会影响s ublime 的冷启动性能）
-- LSP: Enable Language Server In Project 此命令会让 sublime 在打开当前文件/项目时才加载所选的代码分析前端，重启后需要重新操作一遍
-- 回车后，在下拉菜单中选择 'rust-analyzer' 就完成了全部配置，一切顺利的话界面显示类似下图，左下角会显示 rust-analyzer 对代码进行索引分析，
-- 指针悬停于代码有相应提示

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/1395949-20211205193017709-311037346.png" />
</div>

<blockquote style="font-size:1em;line-height:1.6em;">
  <div style="margin-bottom:1em;">
    Rust 语言服务器（RLS）基于 LSP（Language Server Protocol），即语言服务器协议，LSP 由红帽、微软和 Codenvy 联合推出，可以让不同的程序编辑器与集成开发环境（IDE）方便地嵌入各种编程语言，允许开发人员在最喜爱的工具中使用各种语言来编写程序。
  </div> 
  <div style="margin-bottom:1em;">
    它通过用于开发工具和语言服务器间通信的 JSON-RPC 标准，能够让编程工具提供实时反馈的详细信息并以此实现多种强大功能，比如符号搜寻、语法分析、代码自动补全、移至定义、描绘轮廓与重构等。Rust 语言服务器集成了这些逻辑作为后端，并通过标准的 LSP 提供给前端工具，它被设计为与前端无关，可以被不同的编辑器和 IDE 广泛采用，但目前项目团队仅在 VS Code 中进行测试。用户可以在 VS Code 扩展商店中找到基于 RLS 实现的 Rust 官方插件。
   </div>
  <div style="margin-bottom:1em;">
    <b>rust-anlyzer（RA）</b>是除了 RSL 以外的另一个 Rust 语言服务器，由社区驱动开发。自 2019 年末发布第一个预编译 Release 以来，RA 都会在每周二稳定发布新版本并保持至今。经过快速的迭代，目前 RA 各方面的优化和提升已经超越 RSL，所以也被官方纳入 RSL 2.0 计划的一部分。 Rust 的 VS Code 官方插件也已经增加了对 RA 的支持。
   </div>
  <div style="margin-bottom:1em;">
    RA 目前已经支持 Vim、Emac、Sublime Text 3 和 VSCode 等编辑器，可通过官方文档获取详细的安装指导。
   </div>
 </blockquote>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Cargo 工作空间</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
  管理多个相互关联且需要协同开发的包
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="创建工作空间" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
$ mkdir rustlabs && cd rustlabs && touch Cargo.toml

### Cargo.toml 内容
[workspace]
members = [
  "lab1",
  "lib1"
]

### 在该工作空间下创建 lab1 二进制包
$ cargo new lab1 && cargo build

### 继续在该工作空间下创建 lib1 代码包 (--lib)
$ cargo new lib1 --lib && cargo build

### 在 lib1/src/lib.rs 文件中添加一个 add_one 函数
pub fn add_one(x: i32) -> i32 {
  x + 1
}

### 将 lib1 代码包添加到lab1二进制包中, 在 lab1 中将要使用 lib1 导出的函数
$ vi lab1/Cargo.toml
[dependencies]
lib1 = { path = "../lib1" }

### 在 lab1 中使用来自 lib1 包的 add_one 函数
$ vi lab1/src/main.rs
use lib1;

fn main() {
  let num = 10;
  println!("Hello world! {} plus one is: {}!", num, lib1::add_one(num));
}

### 构建整个工作空间
$ cargo build

### 运行指定的二进制包
$ cargo run -p lab1

### 添加外部依赖包
$ vi lib1/Cargo.toml
[dependencies]
rand = "0.3.14"

### 再次构建整个工作空间, 此时 Cargo 就会引入并编译新添加的 rand 包
$ cargo build
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="为当前工作空间增加测试" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 为 lib1::add_one 函数增加一个测试
$ vi lib1/src/lib.rs
#[cfg(test)]
mod tests {

  use super::*;

  #[test]
  fn it_works() {
    assert_eq!(3, add_one(2));
  }
}

// 运行当前工作空间下的所有测试
$ cargo test

// 运行某个特定包的测试
$ cargo test -p lib1

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用 cargo install 从 crates.io 上安装可执行程序" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 输出结果的最后一行显示了二进制文件的安装路径和名称
$ cargo install ripgrep
    Finished release [optimized + debuginfo] target(s) in 1m 06s
  Installing /Users/keesh/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用自定义命令扩展 cargo 的功能" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// cargo 允许我们添加子命令来扩展它的功能而无需修改 Cargo 自身, 只要你的 $PATH 路径中存在指定的二进制文件即可, 就好像它是 cargo 的子命令一样
$ cargo rg

// 显示当前包的依赖图
$ cargo tree OR cargo tree -p tera

// 列出 cargo 的内置子命令
$ cargo --list
Installed Commands:
    add                  Add dependencies to a Cargo.toml manifest file
    b                    alias: build
    bench                Execute all benchmarks of a local package
    build                Compile a local package and all of its dependencies
    c                    alias: check
    check                Check a local package and all of its dependencies for errors
    clean                Remove artifacts that cargo has generated in the past
    clippy               Checks a package to catch common mistakes and improve your Rust code.
    config               Inspect configuration values
    d                    alias: doc
    doc                  Build a package's documentation
    fetch                Fetch dependencies of a package from the network
    fix                  Automatically fix lint warnings reported by rustc
    fmt                  Formats all bin and lib files of the current crate using rustfmt.
    generate-lockfile    Generate the lockfile for a package
    git-checkout         This command has been removed
    help                 Displays help for a cargo subcommand
    init                 Create a new cargo package in an existing directory
    install              Install a Rust binary. Default location is $HOME/.cargo/bin
    locate-project       Print a JSON representation of a Cargo.toml file's location
    login                Save an api token from the registry locally. If token is not specified, it will be read from stdin.
    logout               Remove an API token from the registry locally
    metadata             Output the resolved dependencies of a package, the concrete used versions including overrides, in machine-readable format
    miri
    new                  Create a new cargo package at <path>
    owner                Manage the owners of a crate on the registry
    package              Assemble the local package into a distributable tarball
    pkgid                Print a fully qualified package specification
    publish              Upload a package to the registry
    r                    alias: run
    read-manifest        Print a JSON representation of a Cargo.toml manifest.
    remove               Remove dependencies from a Cargo.toml manifest file
    report               Generate and display various kinds of reports
    rm                   alias: remove
    run                  Run a binary or example of the local package
    rustc                Compile a package, and pass extra options to the compiler
    rustdoc              Build a package's documentation, using specified custom flags.
    search               Search packages in crates.io
    t                    alias: test
    test                 Execute all unit and integration tests and build examples of a local package
    tree                 Display a tree visualization of a dependency graph
    uninstall            Remove a Rust binary
    update               Update dependencies as recorded in the local lock file
    vendor               Vendor all dependencies for a project locally
    verify-project       Check correctness of crate manifest
    version              Show version information
    yank                 Remove a pushed crate from the index

    ]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>可修改引用</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn main() {
    let mut i: i32 = 19;
    change_number(&mut i);
}

// 省略写法
pub fn change_string(s: &mut String) {
    s.push_str("asdf");
}

pub fn change_number(i: &mut i32) {
    *i += 1;
}

// 等价写法
pub fn change_string<'a>(s: &'a mut String) {
    s.push_str("asdf");
}

pub fn change_number<'a>(i: &'a mut i32) {
    *i += 1;
}


    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>泛型函数</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::str::FromStr;

pub fn parse_number<T: FromStr>(s: &str) -> Option<T> {
    match T::from_str(s) {
        Ok(l) => Some(l),
        _ => None,
    }
}


#[cfg(test)]
mod tests {
    #[test]
    fn it_parse_number() {
        let i: f64 = parse_number("3").expect("error parseing u32");
        assert_eq!(3.0, i);
    }
}

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>数组、向量和切片</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 1. 数组是在编译是确定大小的常量，不能在数组中追加或删除元素
// [T; N] 表示一个N个值的数组, 每个元素的类型都是 T, 
// 数组长度是类型的一部分，在编译时就确定了，N必须是常量，无法在运行时指定N的值。
let lazy_caterer: [u32; 6] = [1,3,3,4];
let taxonomy = ["Animalia", "Arthropoda", "Insects"];

// 2. 向量是一种动态分配，可扩展的值序列，向量的元素保存在堆上，可随意缩放它
//    每当向量增长到超过其缓冲区容量时，它都会选择一个比原来大1倍的新缓冲区。
// Vec<T> 表示一个向量，每个元素的类型都是T，可动态调整大小
let v1 = vec![1, 2, 3];
let mut v2: Vec<u32> = Vec::<u32>::new();
let v22 = Vec::<u32>::new();
let vv = vec![0; 14];
let v: Vec<i32> = (0..5).collect(); // 使用collect时通常要明确写出类型

println!("{:?}", v2);

// 3. 切片是对其他值中部分元素序列的引用。切片的引用的是一个胖指针，即一个双字宽的值，保存着切片中第一个元素的指针和切片中的元素个数。
//    切片表示数组或向量的一个范围，由于切片可以是任意长度，因此不能直接保存到变量中，也不能作为函数参数传递，切片永远只能按引用传递。
// &[T] 读作"共享切片"，可以由多个线程读取，但不可以修改
// &mut [T] 读作"可修改切片"，允许读写元素，但是不能共享
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.797]; // 向量
let a: [f64; 4] =     [0.0, -0.707, -1.0, -0.797]; // 数组

let sv: &[f64] = &v; // 切片
let sa: &[f64] = &a; // 切片

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/array-vec-slice.png" style="max-width:100%;" />
</div>
<div style="text-align: center;">
  向量、数组、切片、引用 之间的内存布局逻辑图
</div>

<ul style="margin-left:1em;list-style-type:disc;margin-top:1.325em;">
  <li style="margin-top:.325em;">普通引用是对单个值的非所有型指针</li>
  <li style="margin-top:.325em;">切片引用是对多个值的非所有型指针</li>
  <li style="margin-top:.325em;">切片引用的是一个胖指针，即一个双字宽的值，保存着切片中第一个元素的指针和切片中的元素个数。</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="向量 Vec" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 显示写出类型
fn build_vector() -> Vec<i16> {
  let mut v: Vec<i16> = Vec::<i16>::new();
  v.push(10i16)
  v.push(20i16)
  v
}

// 类型推断, 提高代码可读性
fn build_vector() -> Vec<i16> {
  let mut v = Vec::new();
  v.push(10)
  v.push(20)
  v
}
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>字符串类型</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let noodles = "noodles".to_string();
let oodles = &noodles[1..];
let poodles = "中_国";

println!("{}", poodles.len()); // 字节数, > 7
println!("{}", poodles.chars().count()); // 字符长度, > 3
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/string-&str-str.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>所有权</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
在 Rust 中每个值都<b>只有一个</b>决定其生命期的所有者，当这个所有者被释放(dropped)时，其所有的值也会被清除。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="所有权与函数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制。 
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {

  let s = String::from("hello");  // 变量 s 进入作用域

  takes_ownership(s);             // s 的值被移动进了函数
                                  // 所以它从这里开始不在有效

  let x: i32 = 5;                 // 变量 x 进入作用域

  makes_copy(x);                  // 变量x同样被传递进了函数
                                  
  println!("{}", x);              // 但是由于 i32 是 Copy 的, 所以 x 仍然有效           

} // x 首先离开作用域，然后是 s

fn takes_ownership(some_string: String) {    // some_string 进入作用域
  println!("{}", some_string);
} // some_string 在这里离开作用域, drop 函数被自动调用 
  // some_string 占用的内存也随之被释放

fn makes_copy(some_integer: i32) {           // some_integer 进入作用域
  println!("{}", some_integer); 
} // some_integer 在这里离开作用域, 由于是值类型没有什么特别的事发生

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="向量 Vector" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn print_padovan() {
  let mut padovan = vec![1,1,1]; // 分配内存
  for i in 3..10 {
    let next = padovan[i - 3] + padovan[i - 2];
    padovan.push(next);
  }
  println!("P(1..10) = {:?}", padovan);
} // 清除 padovan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/vecu32.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Box" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Rust 的 Box 类型是说明所有权的一个典型例子，Box<T> 是一个指针，其指向存储在堆中的T类型的值。
// 调用 Box::new(v) 会在堆上分配相应的内存缓冲区，并将值v转移进去。最后返回
{
  let point = Box::new((0.625, 0.5); 
  let label = format!("{:?}", point);

    println!(
        "{}, {}, {}, {}",
        label,
        label.len(),
        label.chars().count(),
        label.capacity()
    ); // > (0.625, 0.5), 12, 12, 16
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/point&label-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="结构体 struct" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
struct Person { name: String, birth: i32 }

let mut composers = Vec::new();

composers.push(Person{ name: "Palestrina".to_string(), birth: 1525 });
composers.push(Person{ name: "Dowland".to_string(), birth: 1563 });
composers.push(Person{ name: "Lully".to_string(), birth: 1632 });

for c in composers {
    println!("{:?}, {}, {}", c, c.name, c.birth);
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/struct-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>转移</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
在 Rust 中给<b>变量赋值</b>、给<b>函数传参</b>、从<b>函数返回值</b>这样的操作都不会复制值，而是<b>转移(move)</b>值。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="Python" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
s = ['udon', 'ramen', 'soba']
t = s    // 赋值代价较小，引用计数相对麻烦。
u = s
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/python-string-array-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="C++" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
using namespace std;
vector<string> s = { "udon", "ramen", "soba" };
vector<string> t = s; // 产生深度复制, 即复制s到t。保证了内存所有权的清晰!
vector<string> u = s; // 产生深度复制, 即复制s到t。保证了内存所有权的清晰!
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/c++-vec-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Rust" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s; // 转移所有权
let u = s; // s的值已经被转移，编译器拒绝编译这行代码
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/rust-vec-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Copy类型 &amp;mdash; 转移的例外" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
#[derive(Copy, Clone)] // 如果自定义结构体的所有字段都是copy类型，那可以在该结构体上加该注释
struct Label { number: u32 }

fn print_label(l: Label) {
  println!("STAMP: {}", l.number);
}

let l = Label { number: 3 };

// 如果Label不是Copy类型，编译器拒绝编译这行代码
// 把非copy类型的值传给print会把值的所有权转移给print, print会在返回前将该值清除
print_label(l);

println!("My label number is: {}", l.number); 

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Rc &amp; Arc 共享所有权" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::rc::Rc;

let s: Rc<String> = Rc::new("shirataki".to_string()); // Rust 假设 Rc 指针指向的值通常是共享的

s.push_str("aa"); // 编译器拒绝编译这行代码, Rust 里不存在即共享又可以修改的值

let t: Rc<String> = s.clone();
let u: Rc<String> = s.clone();

println!("{:?}", s);
println!("{:?}", t);
println!("{:?}", u);

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/rc-string-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="共享引用 &amp; 可修改引用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

let x = 1000;
let r = &x;     // 共享引用
let f = *r;     // 对 r 解引用进而读取存储在 x 里值

println!("{}, {}", *r, f);

let mut a = 10; 
let b = &mut a; // &mut a 是 y 的可修改引用

*b += 1;        // 显示对 b 解引用进而修改 a 的值

println!("{}", b);

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="给引用赋值" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let x = 10;
let y = 20;
let mut r = &x;

if true {
  r = &y; // 给引用赋值会导致它指向新值
}

println!("{}", r);

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>悬空指针</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="悬空指针 -- 例子1" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
{
  let r;
  {
    let x = 1;
    r = &x;
  }
  println!("{}", r)
}

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
以上代码编译会报错
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
cargo build
   Compiling lab2 v0.1.0 (/Users/keesh/workspace/rs-labs/lab2)
error[E0597]: `x` does not live long enough
 --> lab2/src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |     println!("{}", r)
  |                    - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `lab2` due to previous error
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="悬空指针 -- 例子2" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn dangle() -> &String {
  let s = String::from("hello");        // s 被绑定到新的 String 上。由于 s 是在函数内部创建，所以它会在执行完毕时随之释放。
                                        // 但是以下代码依旧尝试返回一个指向 s 的引用，这个引用将指向的内存不在有效
  &s                                    // 所以 rust 编译器拒绝编译这行代码
}

    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="借用向量中的元素" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let v = vec![1, 2, 3];
let r = &v[1]; // 借用

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.6;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
  由于 v 拥有向量, 而向量拥有自己的元素, 因此 v 的生命周期必须涵盖引用类型 &v[1] 的生命期。类似的，如果把引用保存在某个数据结构中，该引用的生命期必须涵盖该数据结构的生命期。比如，对于一个引用向量而言，(作为向量元素的) 所有引用的生命周期都必须涵盖拥有这个向量的变量的生命期。
</div>
<div style="margin-top:.625em;">
  例如本例中, r 借用了 v 里的某个元素的引用, 那么 v 的生命期必须大于 r 的生命期。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>生命周期</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn f<'a>(p: &'a i32) {     // 'a 相当于任意生命周期, 如果能让他的生命周期尽可能短，即恰好包含对 f 的调用，事情就比较好办
  println!("{}", p);
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="静态生命周期 &amp;mdash; 与整个程序的运行时间一样长" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

static mut STASH: &i32 = &10;

fn f(p: &'static i32) {
  unsafe {                    // 对静态变量的读写是非线程安全的，所以将赋值动作放到 unsafe 代码块中
    STASH = p;
  }
}

static WORTH_POINTING_AT: i32 = 1000;

f(&WORTH_POINTING_AT);

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
以上代码编译会报错
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="将引用作为参数传递" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 等价于 fn g(p: &i32) 
fn g<'a> (p: &'a i32) {
  ...
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="从函数返回引用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn main() {
  let s;
  {
    let parabola = [9,234934993,3,3,12,8,0,-1];
    s = smallest(&parabola);
  }
  println!("{}", s); // rust 编译器拒绝编译这行代码, 因为 s 引用的值已经超出作用域
}

// 返回切片中最小值的元素引用
fn smallest(v: &[i32]) -> &32 {
  let mut a = &v[0];
  for r in &v[1..] {
    if *r < *a {
      a = r;
    }
  }
  a
}

// 等价于
fn smallest<'a>(v: &'a [i32]) -> &'a 32 {
  let mut a = &v[0];
  for r in &v[1..] {
    if *r < *a {
      a = r;
    }
  }
  a
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="结构体包含引用 &amp;mdash; Rust 要求包含引用的结构体不能省略生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
struct S {
  r: &i32             // 编译器拒绝编译这行代码
}

// 当引用类型出现在另一个类型的定义中时，必须写出其生命周期
struct S {
  r: &'static i32     // 把 r 标记为 &'static 时意味着, r 只能引用和程序生命周期一样长的值
}

// 在类型上定义生命周期
// 每个类型 S 的值都会有一个新的生命周期 'a, 它会限制你使用这个值的方式
// 保存在 r 中的任何引用的生命周期最好包含 'a, 而 'a 也必须比保存 S 的任何值都长寿
#[derive(Debug)]
struct S<'a> {
    r: &'a i32,
}

fn main() {
  let i = 19;
  // 创建了一个带有生命周期 'a 的新 S 的值
  // 在把 &i 保存在 r 字段时，等于把 'a 完全限定在了 i 的生命周期内
  let s = S { r: &i };   
  println!("{:?}", s);
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="不同的生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
struct S<'a> {
    x: &'a i32,
    y: &'a i32,
}

// 以下代码不会创建悬空指针，
// 1. y 的引用保存在 s 中，而 s 会先于 y 被销毁。
// 2. x 的引用最终保存在 r 中，而 r 和 x 被一同销毁
// 但是如果用早期 rust 版本编译这段代码，rust 会抱怨说 y 活的不够长
// 尽管明显足够长，为什么 rust 会担心呢？仔细分析一下，你会发现它这样担心是有道理的


                        
           
fn main() {
    let x = 10;                                       |'a
    let r;                                            |
    {                                                 |
        let y = 20;                              |'b  |
        {                                        |    |
            let s = S { x: &x, y: &y };     |'c  |    |
            r = s.x;                        |    |    |
            println!("{}, {}", s.x, s.y);   |    |    |
        }                                   |    |    |
    }                                            |    |
    println!("{}", r);                                | // 编译器拒绝编译这行代码, 对于 S 来说, 编译器并不知道 x,y 谁先被销毁，  
}                                                     | // 只能通过某种标记告诉他每个字段的生命周期    
                                                        // 通过给 x,y 定义不同的生命周期标记(<'a, 'b>)解决这个问题  
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="函数签名的生命周期" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn f<'a, 'b>(r<'a>: &i32, s<'b>: &i32) -> &<'a>i32 {
  r
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="省略生命周期参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// rust 会在生命周期参数明显合理的时候，可以省略他们
struct S<'a, 'b> {
  x: &<'a>i32,
  y: &<'b>i32
}

// 省略写法
fn sum_rxy(r: &i32, s: S) -> i32 {
  r + s.x + s.y
}

// 完整写法
fn sum_rxy<'a, 'b, 'c>(r: &'a i32, s: S<'b, 'c>) -> i32 {
  r + s.x + s.y
}

// 当函数返回引用时，也需要携带生命周期参数
// 省略写法
fn first_and_third(point: &[i32, 3]) -> (&i32, &i32) {
  (&point[0], &point[2])
}

// 完整写法
fn first_and_third(point: &'a [i32, 3]) -> (&'a i32, &'a i32) {
  (&point[0], &point[2])
}

// 如果函数参数中有多个生命周期，则 rust 无法推断哪个生命周期更适合返回值, 此时 rust 要求你明确写出返回值的生命周期属性
// ....
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="某个类型的函数参数接受引用形式的 self 参数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// rust 会假设 self 的生命周期就是返回值需要的生命周期
struct StringTable {
  elements: Vec[String],
}

// 省略写法
impl StringTable {
  fn find_by_prefix(&self, prefix: &str) -> Option<&String> {
    for i in 0 .. self.elements.len() {
      if self.elements[i].starts_with(prefix) {
        return Some(&self.elements[i])
      }
    }
    None
  }
}

// 完整写法
impl StringTable {
  fn find_by_prefix<'a, 'b>(&'a self, prefix: &'b str) -> Option<&String> {
    // 此时 rust 假设你无论借用的是什么，都是从 self 中借用的
    ... 
  }
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="共享与修改" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  Rust 关于修改引用和共享引用的规则
</div>
<ul style="margin-left:0em;list-style-type:none;margin-top:.625em;line-height:1.6;">
  <li>
    <b>共享访问是只读访问</b> 共享引用借用的值是只读的。在共享引用的整个生命周期内，任何事物都不能修改其引用目标，也不能修改其引用目标的可触达的值。结构体中不存在指向任何目标的可修改引用，所有者是只读的 &mdash;&mdash; 实际上是这个值被冻结了。
  </li>
  <li style="margin-top:.625em;">
    <b>可修改访问是排他访问</b> 可修改引用借用的值只能通过该引用访问。在可修改引用的整个生命周期内，没有其他路径可触及其引用目标，或触及其引用目标可触及的值。唯一能够与可修改引用的生命周期重叠的，就是从该可修改引用自身借用的引用。
  </li>
</ul>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 以下代码可能引入悬空指针
let v = vec![4, 8, 19, 27, 34, 10];
let r = &v;
let aside = v;    // 给 aside 赋值会转移向量，导致 v 变成未初始化状态
r[0];             // 由于 v 变成了未初始化状态，所以 r 变成了悬空指针


// 修复以上错误
let v = vec![4, 8, 19, 27, 34, 10];
{
  let r = &v;       | 引用的生命周期在 v 转移给 aside 之前结束  
  r[0];             |   
}                   |     
let aside = v;      // v 分配的内存转移给 aside 

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/flag1.png" style="width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="extend_from_slice &amp;mdash; 由于向量重新分配内存空间导致切片变成悬空指针" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[   
fn extend_slice(vec: &mut Vec<f64>, slice: &[f64]) {
  for elt in slice {
    vec.push(*elt);
  }
}     

fn main() {

  let mut wave = Vec::new();
  let head = vec![0.0, 1.0];
  let tail = [1.2, 0.34];

  extend_slice(&mut wave, &head);     // 用另一个向量扩展 wave
  extend_slice(&mut wave, &tail);     // 用数组扩展 wave

  // 追加一个元素，将自动扩容1倍
  <!-- wave.push(1.0); -->

  // 用向量自身追加向量, 
  // 在给向量追加元素时，如果缓冲区慢了，系统会自动分配一个更大的缓冲区
  // 当缓冲区自动扩容时，slice 参数仍然指向原来的四个元素缓冲区，该内存已经被清除，此时 slice 变成了悬空指针
  // rust 编译器拒绝编译这行代码
  extend_slice(&mut wave, &wave)   

  // 当 Java 中出现此问题时会抛出 ConcurrentModificationException
  // ....   

}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/flag2.png" style="width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<ul style="margin-left:2em;list-style-type:decimal;margin-top:.625em;line-height:1.6;">
  <li>
    在调用 extend_slice 函数时传入的第一个参数 &mut wave，意味着该函数已经向 wave 借用了一个可修改引用，这意味着该可修改引用必须是可触及这个向量及其元素的唯一路径。
  </li>
  <li style="margin-top:.625em;">
    而传入的第二个参数，意味着对 slice 切片需要向 wave 再次借用一个共享引用，这违反了前面提到的第二条原则。rust 拒绝这样的操作, 即编译报错。
  </li>
  <li style="margin-top:.625em;">
    rust 也可以认为 extend_slice 函数违反了第二条原则: 在待用该函数时 slice 参数已经借用了对 wave 元素的共享引用，所以无论是元素还是 vec 本身都是只读的。此时就不能再次向一个只读的值借用可修改引用了。
  </li>
</ul>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/flag3.png" style="width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="通过一下例子解释上边这张图" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[   
// 以下代码详细阐述了共享引用的借用规则
let mut x = 10;

let r1 = &x;          // 第一次借用 x 的不可修改引用
let r2 = &x;          // 第二次借用 x 的不可修改引用。可以，允许多次借出共享引用

x += 2;               // 错误，一个值如果把他的引用借出去了，在还回来之前不可以修改。

let m = &mut x;       // 错误，因为 x 已经借出了不可修改引用, 此时不能再次借出x的可修改引用。

let mut y = 20;
let m1 = &mut y;      // m1 借用了 y 的可修改引用
let m2 = &mut y;      // 错误，不能借用2次可修改引用
let z = y;            // 错误，此时不能用 y，因为它已经借出了可修改引用


// 从共享引用借用共享引用是可以的
let mut w = (107, 109);
let r = &w;
let r0 = &r.0;        // 可以，共享引用可以在借为共享引用
let r1 = &mut r.1;    // 错误，共享引用不可以在借为可修改引用

// 可修改引用可以在借为可修改引用
let mut v = (136, 139);   
let m = &mut v;
let m0 = &mut m.0;    // 可以，可修改引用可以在借为可修改引用

*m0 = 137;            
let r1 = &m.1;        // 可以，可修改引用可以在借为共享引用

v.1                   // 错误，已经借出可修改引用，禁止通过其他路径访问

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>错误处理</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
painc(诧异) 和 Result 是 Rust 的错误处理机制。
</div>
<div style="margin-top:.625em;">
普通的错误使用 Result 处理，这些错误通常由程序外部的情况导致，比如错误输入、网络中断、或者权限问题。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="painc 诧异" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {

    let r = pirate_share(500, 0);

    println!("{}", r);
    println!("{}", r / 1 as f64);
    println!("{}", r.is_infinite());

    let a = r; // 复制

    println!("{}", a);

    if r.is_infinite() {
        panic!("error"); // 诧异
    }
    
}

fn pirate_share(total: u64, crew_size: usize) -> f64 {
    let half = total as f64 / 2.0;
    half / crew_size as f64
}


]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.8;font-family:monospace;margin-top:1em;">
      <![CDATA[

<div style="margin-top:.625em;">
painc(诧异) 用于处理永远不会发生的错误。当程序发生诧异时会<b>展开栈</b>。
</div>

<div style="margin-top:.425em;">
诧异不是崩溃也不是未定义行为，它是安全的且不违反 Rust 的任何安全规则。
</div>

<div style="margin-top:.425em;">
painc(诧异) 是线程级别的，一个线程诧异时其他线程可以正常运行自己的业务。<b>父线程可以捕获子线程的诧异，并优雅地处理相应的错误。</b>
</div>

<div style="margin-top:.425em;">
还有一种方法可以<b>捕获栈展开</b>，它允许诧异线程存活并继续运行。标准库函数 std::panic::catch_unwind() 就是为此设计的。
</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="中止进程" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.8;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.625em;">
展开栈是默认的诧异行为，但在两种情况下 Rust 不会展开栈。
</div>

<div style="margin-top:.425em;">
如果在 Rust 展开第一个函数之后的清理期间 .drop() 方法触发了第二个诧异，那么这个诧异被认为是致命的。此时 Rust 会停止展开栈并中止整个进程。
</div>

<div style="margin-top:.425em;">
如果编译时加上 -C panic=abort，那么编译后程序中的第一个诧异就会立即终止进程。（此选项能够减小编译后代码的大小）
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Result 结果" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.8;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.625em;">
Rust 没有异常，在 Rust 中函数执行失败可以通过一个返回类型来表示。
</div>

<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li>再 rust 中要比在其他语言中花更多时间来思考和权衡错误处理。</li>
  <li>rust 要求程序员在所有可能发生错误的地方做出某种决定，并记录在代码中。</li>
  <li>rust 会检查是否使用了 Result 值，因此不可能静默传递某个错误。</li>
  <li>向外传播错误，最简单的办法是只写一个 ? 操作符，且传播路径是可见的，就算是一堆代码只需一眼就能定位错误是从哪些地方传播出来的。</li>
</ul>

<pre style="margin-top:1em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
fn get_weather(location: LatLng) -> Result&lt;WeatherReport, io::Error&gt; {
  // .....

}

// 啰嗦写法
match get_weather(hometown) {
  Ok(report) => {
    display_weather(hometown, &report);
  }
  Err(err) => {
    println!("error query the weather: {}", err);
    schedule_weather_retry();
  }
}

// 简化写法1
let report = get_weather(hometown).unwrap_or_else( |_err| vague_prediction(hometown));

// 简化写法2
let report = get_weather(hometown).unwrap(); // 仅返回成功的值，如果 result 是错误的结果会触发诧异。

// 简化写法2
let report = get_weather(hometown).expect(message_here); // 失败时返回自定义错误信息。

// 将结果转换为引用
result.as_ref() 将 Result<T, E> 转换为 Result<&T, &E>，即借用现有 result 中成功或错误值的引用

// 将结果转换为可修改引用
result.as_mut() 将 Result<T, E> 转换为 Result<&mut T, &mut E>，即借用现有 result 中成功或错误值的可修改引用

// 取得 &str 类型的错误信息
err.description();

// 返回一个 Option<&Error>，取得触发 err 的底层错误(如果有的话)
err.cause()

</pre>

<div style="margin-top:1em;">
打印错误信息不一定会打印出错误原因。可以使用这个函数打印所有可用信息。
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
use std::error::Error;
use std::io::{Write, stderr};

/// 把错误信息转存到 stderr
/// 
/// 如果在构建当前错误信息或写入 stderr 时发生另一个错误，则忽略该错误
pub fn print_error(mut err: &dyn Error) {
  
  let _ = writeln!(stderr(), "error: {}", err);

  while let Some(cause) = err.source() {
    let _ = writeln!(stderr(), "caused by: {}", cause);
    err = cause;
  }

}

</pre>

<div style="margin-top:1em;">
<b>标准库的错误类型不包含栈跟踪信息，但是使用 error_chain 包可以方便地定义自己的错误类型，以支持在创建时获取栈跟踪信息。</b>
</div>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="传播错误" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[

<div style="margin-top:.625em;">
在尝试可能出错的操作时，有时并不希望立即处理错误。如果在每个可能出错的地方都写上 10 行 match 语句，就显得有点啰嗦了。
</div>

<div style="margin-top:.325em;">
我们通常希望调用者来处理错误。换句话说，我们希望错误可以沿着调用栈向上传播。
</div>

<div style="margin-top:.325em;">
Rust 的 ? 操作符可以传播错误。可在任何产生 Result 的表达式后面加 ?，例如：
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
let weather = get_weather(hometome)?;
</pre>

<div style="margin-top:1.625em;">
? 操作符的行为取决于这个函数是返回一个成功结果，还是返回一个错误结果。
</div>

<ul style="margin-left:2em;list-style-type:disc;margin-top: .325em;">
  <li>如果是成功结果，那么它会打开 Result 并取出其中的值。</li>
  <li>如果是错误结果，那么它会立即从闭合函数中返回，并将错误结果沿调用链向上传播。为确保传播成功，只能对返回类型为 Result 的函数使用 ?。</li>
</ul>

<div style="margin-top:.325em;">
? 操作符并不神秘。同样的操作使用一个 match 表达式也能实现，只不过太长了：
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
let weather = match get_weather(hometown) {
  Ok(succes_value) => succes_value,
  Err(err) => return Err(err)
}
</pre>

<div style="margin-top:1em;">
出错概率极高的代码示例子
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
use std::fs;
use std::io;
use std::path::Path;

fn main() {
    let src_path = Path::new("./foo/bar.txt");
    let dst_path = Path::new("./foo/bar.txt2");

    move_all(src_path, dst_path).unwrap_or_else(|_err| println!("{}", _err.to_string()));
}

fn move_all(src: &Path, dst: &Path) -> io::Result<()> {

    // 判断文件夹是否存在
    if !fs::metadata(dst).is_ok() {
        fs::create_dir_all(dst)?; // 创建文件夹
    }

    // 判断源文件夹是否存在
    if !fs::metadata(src).is_ok() {
        panic!("src not exists: path={}", String::from(src.to_string_lossy()));
    }

    // 读取dir可能失败
    for entry_result in src.read_dir()? {
        let entry = entry_result?;                    // 读取文件可能失败
        let dst_file = dst.join(entry.file_name());   // 拼接目标路径
        println!("src_file={:?}, dist_file={}", entry.path(), dst_file.display().to_string());  // 打印日志
        fs::rename(entry.path(), dst_file).unwrap();  // 重命名可能失败
    }

    // 删除文件夹
    fs::remove_dir_all(src)?;

    Ok(()) // 成功
}

</pre>

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="处理多种错误类型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[


<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
use std::io::{self, BufRead};

// 当一个函数可能产生两种不同的潜在错误类型时，rust 拒绝编译代码
// 有多种办法可以处理这种情况:
// 1. 使用 error-chain 包, 它可以帮你用几行代码就定义出灵活的错误类型
// 2. 另一个简单的方法是使用 rust 内置的特性。即：所有标准库的错误类型都可以转换为 Box&lt;std::error::Error&gt; 类型
//    -- 因此处理多种错误类型的一个简单方案就是定义如下类型别名:
//    -- type GenError = Box&lt;std::error::Error&gt;
//    -- type GenResult&lt;T&gt; = Result&lt;T, GenError&gt;
//    -- 如果调用的函数返回 GenResult，但是你只想处理一种特定的错误，而让其他所有错误传播出去，
//    -- 此时可以使用范型方法 error.downcast_ref::&lt;ErrorType&gt;()
//    -- 很多语言为完成此类操作提供了内置语法，实际上完全没必要。Rust 只是专门为此提供了一个方法。
fn read_numbers(file: &mut BufRead) -> Result&lt;Vec&lt;i63&gt;, io::Error&gt; {

  let mut numbers = vec![];

  for line_result in file.lines() {
      let line = line_result?;        // 读取行可能失败，错误类型为：Result&lt;String, std::io::Error&gt;
      numbers.push(line.parse()?);    // 解析整数有可能失败，错误类型为：Result&lt;i64, std::num::ParseIntError&gt;
  }
  
  Ok(numbers)

}

</pre>


    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="在 main() 中处理错误" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[
<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
fn main() {
  invoke_func()?; // 错误，不能把错误再向外传播了
}

fn main() {
  invoke_func().expect("err"); // 主动抛出错误
}

fn main() {
  if let Err(err) = invoke_func() {
    print_error(&err);
    std::process::exit(1);
  }
}
</pre>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="声明自定义错误类型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.6;font-family:monospace;">
      <![CDATA[
<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
#[derive(Debug, Clone)]
pub struct JsonError {
  pub message: String,
  pub line: usize;
  pub colume: usize,
}

// 创建一个这种类型的错误时，可以这样写:
return Err(JsonError{
  message: "expected ']' at end of array".to_string(),
  line: current_line,
  colume: current_colume 
});



// 让该错误类型的行为接近标准错误类型
use std;
use std::fmt;

impl fmt::Display for JsonError {
  fn fmt(&self, f: &mut fmt::Formatter) -> Result&lt;(), fmt::Error&gt; {
    write!(f, "{} ({}:{})", self.message, self.line, self.column)
  }
}

// 该错误还应该实现 std::error::Error 特型
impl std::error::Error for JsonError {
  fn description(&self) -> &str {
    &self.message
  }
}

</pre>
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  
  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>结构体</c:title>
    <c:desc>
      <c:desc1> <![CDATA[

]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="命名字段结构体 &amp;mdash; GrayscaleMap" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
结构体布局 .....
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

fn main() {

  let width = 1024;
  let height = 576;

  let _image = GrayscaleMap{
    pixels: vec![0; width * height],
    size: (width, height)
  };

  // OR 
  let _image = GrayscaleMap::new_map(width, height);

  assert_eq!(_image.size, (1024, 576));
  assert_eq!(_image.pixels.len(), 1024 * 576);

  println!("capacity: {}", _image.pixels.capacity())

}

/// 8位灰阶像素的矩形
pub struct GrayscaleMap {
  pub pixels: Vec<u8>,
  pub size: (usize, usize)
}

// 给结构体增加方法
impl GrayscaleMap {
  
  // 通过函数创建结构体实例
  pub fn new_map(width: usize, height: usize) -> GrayscaleMap {
    GrayscaleMap{
      pixels: vec![0; width * height],
      size: (width, height)
    }
  }

}


]]>
    </c:sourceContent>
    <c:sourceContent type="" title="命名字段结构体 &amp;mdash; GrayscaleMap" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn main() {

    let b = Broom {
        name: "Hokey".to_string(),
        height: 60,
        health: 100,
        position: (100.0, 2.0, 0.0),
        intent: BroomIntent::FetchWater,
    };

    let (broom1, mut broom2) = Broom::chop(b);

    broom2.intent = BroomIntent::DumpWater;

    println!("{:?}", broom1);
    println!("{:?}", broom2);

}

/// 用于表示怪物
#[derive(Debug)]
#[allow(dead_code)]
pub struct Broom {
    pub name: String,
    pub height: u32,
    pub health: u32,
    pub position: (f32, f32, f32),
    pub intent: BroomIntent,
}

/// 扫帚枚举，用于表示怪物可能干的两件事
#[derive(Copy, Clone, Debug)]
pub enum BroomIntent {
    FetchWater,
    DumpWater,
}

impl Broom {
    // 按值接收怪物，取得所有权
    pub fn chop(b: Broom) -> (Broom, Broom) {
        // 基于 b 初始化 broom1，只修改 height。因为 String 不是可复制类型
        // 所以此时broom1取得了b.name的所有权
        let mut broom1 = Broom {
            height: b.height / 2,
            ..b
        };

        // 基于 broom1 初始化 broom2，由于 (broom1.name) String 不是可复制类型，所以必须显示地克隆 broom1.name
        let mut broom2 = Broom {
            name: broom1.name.clone(),
            ..broom1
        };

        // 给两个怪物扫帚取一个不一样的名字
        broom1.name.push_str("_1");
        broom2.name.push_str("_2");

        (broom1, broom2)
    }
}


]]>
    </c:sourceContent>
    <c:sourceContent type="" title="类元组结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 创建这种类型的结构体就像创建元组一样，只不过要加上结构体的名字。
pub struct Bounds (pub usize, pub usize);

let image_bounds = Bounds(1024, 768);

// 类元组结构体体非常适合创建新类型，即只包含一个要经过严格类型检查的组件的结构体。
// 例如想只使用 ASCII 文本，可以像这样定义一个新的类型
pub struct Ascii(Vec<u8>);

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="类基元结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 这种结构体在使用特型的时候有用
// 这种类型的结构体值，不占内存，也不会生成操作他们的代码。
// 例如：表达式 .. 是对类基元结构体值 RangeFull 的简写
pub struct Onesuch;
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="通过 impl 给结构体增加方法" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug,Clone)]
pub struct Queue {
  older: Vec<char>,     // 旧元素，最老的在最后
  younger: Vec<char>,   // 新元素，最新的在后边
}

impl Queue {

  pub fn pop(&mut self) -> Option<char> {

    if self.older.is_empty() {
      
      if self.younger.is_empty() {
        return None;
      }
      
      use std::mem::swap;

      // 把 younger 中的元素转移到 older 中，并保持对外承诺的顺序
      swap(&mut self.older, &mut self.younger);

      self.older.reverse();

    }

    // 到这里 older 里肯定有元素
    self.older.pop()

  }
  
  // &mut self, &self, self 方法调用表达式可以根据函数参数推断出要借用哪种引用　

  // 接 self 的收共享可修改引用
  pub fn push(&mut self, c: char) {
    self.younger.push(c);
  }

  // 接收 self 的共享引用
  pub fn is_empty(&self) -> bool {
    self.older.is_empty() && self.younger.is_empty()
  }

  // 取得 self 的所有权
  pub fn split(self) -> (Vec<char>, Vec<char>) {
    (self.older, self.younger)
  }

}

fn main () {
  
  let mut queue = Queue{
    older: vec![],
    younger: vec![],
  };

  // 只要写 queue.push(...) 就能借用一个对 queue 的可修改引用
  // 就像 (&mut queue).push(...) 一样, 因为 push 的 self 参数就是这样要求的。
  queue.push('0');
  queue.push('1');
  queue.push('2');
  queue.push('3');
  queue.push('4');
  queue.push('5');

  let l = queue.pop();

  println!("{:?}", queue);
  println!("{}", l.unwrap());

  let _ = queue.pop();
  let l = queue.pop();

  println!("{:?}", queue);
  println!("{}", l.unwrap());


}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="泛型结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
#[derive(Debug)]
pub struct Queue<T> {
  pub older: Vec<T>,
  pub younger: Vec<T>
}

impl<T> Queue<T> {
  
  pub fn new() -> Queue<T> {
    Queue{ older: Vec::new(), younger: Vec::new() }
  }

  pub fn push(&mut self, c: T) -> &mut Queue<T> {
    self.younger.push(c);
    self
  }

}

fn main () {
  let mut q = Queue::<usize>::new();
  q.push(1).push(2).push(3).push(4);
  println!("{:?}", q);
}
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="带声明周期参数的结构体" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
如果结构体字段包含引用，则必须指定这些引用的生命周期。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
pub struct Extrema<'elt> {
  pub greatest: &'elt i32,      // 最大
  pub least: &'elt i32,         // 最小
}

impl Extrema<'_> {
  
  pub fn find_extrema<'a>(slice: &'a [i32]) -> Extrema<'a> {

    let mut greatest = &slice[0];
    let mut least = &slice[0];

    for i in 1..slice.len() {
      if slice[i] < *least {
        least = &slice[i];
      }
      if slice[i] > *greatest {
        greatest = &slice[i];
      }
    }

    Extrema{
      greatest, least
    }

  }

  // 鉴于返回的类型经常使用与某个参数相同的生命期，rust 在能推断出生命周期时，允许将其省略
  // 索引 find_extrema 可以写成下边这样
  pub fn find_extrema(slice: &[i32]) -> Extrema {
    // ..
  }

}

fn main() {
  
  let a = [0,-3,0,15,48];
  let e = Extrema::find_extrema(&a);

  println!("{:?}", a);
  println!("{:?}", e);

}


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="为结构体类型派生共有特型(trait)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Debug 可打印
// Clone 克隆
// Copy 可复制
// PartialEq 相等: =, !=
// PartialOrd 比较大小: >,<,>=,<=
// 只要结构体的每个字段都实现了共有特型，那么该结构体就能自动实现他们
#[derive(Debug, Clone, Copy, PartialEq, PartialOrd)]
pub struct Point {
  x: f64,
  y: f64
}
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="内部修改能力" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
过渡使用内部修改能力会出问题！
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 爬虫机器人，包含设置及I/O句柄
pub struct SpiderRobot {
  pub species: String,
  pub web_enable: bool,
  pub leg_devices: [fd::FileDest; 8]
}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>枚举与模式</c:title>
    <c:desc>
      <c:desc1> <![CDATA[

]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="枚举(enum)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
Rust 枚举还可以包含数据，而且可以是不同类型的数据。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
use std::fmt;

#[derive(Debug)]
pub enum TimeUnit {
  Seconds, Minutes, Hours, Days, Months, Years
}

// rust 枚举也可以有方法
impl TimeUnit {
  
  // 返回这个时间单位的复数名词
  pub fn plural(&self) -> &'static str {

    match self {
      TimeUnit::Seconds => "seconds",
      TimeUnit::Minutes => "minutes",
      TimeUnit::Hours => "hours",
      TimeUnit::Days => "days",
      TimeUnit::Months => "months",
      TimeUnit::Years => "years",
    }

  }

  pub fn singular(&self) -> &'static str {
    self.plural().trim_end_matches('s')
  }

}

impl fmt::Display for TimeUnit {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        write!(f, "{}", self.plural())
    }
}

fn main() {
  let s = TimeUnit::Seconds;
  println!("{}", s.plural());
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="包含数据的枚举" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
显示一个对用户更友好的近似时间。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
use std::fmt;

#[derive(Debug)]
pub enum RoughTime {
  InThePast(TimeUnit, u32),
  JustNow,
  InTheFuture(TimeUnit, u32)
}

impl fmt::Display for RoughTime {
    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        match self {
            RoughTime::InThePast(a, b) => write!(f, "{}{} 以前", b, a),
            RoughTime::JustNow => write!(f, "{}", "Just now"),
            RoughTime::InTheFuture(a, b) => write!(f, "将来 {}{}", b, a),
        }
    }
}

fn main() {
  let t1 = RoughTime::InThePast(TimeUnit::Years, 20 * 4 + 7);
  let t2 = RoughTime::InThePast(TimeUnit::Hours, 3);
  let t3 = RoughTime::JustNow;
  println!("{:?}", t1);
  println!("{:?}", t2);
  println!("{:?}", t3);
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:650px" src="/images/rust/RoughTime-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="结构体变体枚举" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
与常规结构体一样包含命名字段。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

pub enum Shape {
  Sphere { center: Point3d, radius: f32 },
  Cuboid { corner1: Point3d, corner2: Point3d },
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

pub enum RelationshipStatus {

  // 基元枚举
  Single,
  InArelationship, 

  // 元组枚举
  ItsComplicated(Option<String>), 

  // 命名字段枚举
  ItsExtremelyComplicated {
    car: DifferentialEquation, 
    cdr: EarlyModernistPoem
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="使用枚举的富数据结构" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
枚举也可以用来快速实现类似树的数据结构。比如任何 Json 文档都可以用这个 Rust 类型表示:
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

pub enum Json {
  Null,                                 // 一个机器字
  Boolean(bool),                        // 一个机器字
  Number(f64),                          
  String(String),                       // 占三个机器字
  Array(Vec<Json>),                     // 占三个机器字
  Object(Box<HashMap<String, Json>>)    // HashMap 占8个机器字, 用Box封装只占1个机器字节
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:650px" src="/images/rust/json-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="泛型枚举" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
Rust 标准库中的最常用的两个枚举类型都是泛型枚举: Option&lt;T&gt;, Result&lt;T,E&gt;
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

#[derive(Debug)]
pub enum Option<T> {
  None,
  Some(T)
}

#[derive(Debug)]
pub enum Result<T, E> {
  Ok(T),
  Err(E)
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="基于 rust 泛型数据结构实现的二叉树" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/binary-tree-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:.85em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use self::BinaryTree::*;

/// T类型值的有序集合
#[derive(Debug)]
pub enum BinaryTree<T> {
  Empty, 
  NonEmpty(Box<TreeNode<T>>)    // 一个指向位于堆内存的 TreeNode 的指针
}

/// 用于表示二叉树的节点
#[derive(Debug)]
pub struct TreeNode<T> {
  pub element: T, 
  pub left: BinaryTree<T>,
  pub right: BinaryTree<T>
} 

impl<T: Ord> BinaryTree<T> {
  
  pub fn add(&mut self, value: T) {

    match *self {
      Empty => *self = NonEmpty(Box::new(TreeNode{ element: value, left: Empty, right: Empty })),
      NonEmpty(ref mut node) => {
        if value <= node.element {
          node.left.add(value);
        } else {
          node.right.add(value);
        }
      }
    }

  }

}

fn main() {
  
  let mercury_tree  = NonEmpty(Box::new(TreeNode{ element: "Mercury",  left: Empty,         right: Empty }));
  let jupiter_tree  = NonEmpty(Box::new(TreeNode{ element: "Juptiter", left: Empty,         right: Empty }));
  let mars_tree     = NonEmpty(Box::new(TreeNode{ element: "Mars",     left: jupiter_tree,  right: mercury_tree }));
  let venus_tree    = NonEmpty(Box::new(TreeNode{ element: "Venus",    left: Empty,         right: Empty }));
  let uranus_tree   = NonEmpty(Box::new(TreeNode{ element: "Uranus",   left: Empty,         right: venus_tree }));
  let saturn_tree   = NonEmpty(Box::new(TreeNode{ element: "Saturn",   left: mars_tree,     right: uranus_tree }));

  println!("{:?}", saturn_tree);

  let mut tree = BinaryTree::Empty;

  tree.add(8);
  tree.add(9);
  tree.add(6);
  tree.add(2);
  tree.add(6);
  tree.add(11);
  tree.add(1);

  println!("print2: {:?}", tree);

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="枚举模式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
pub enum RoughTime {
  InThePast(TimeUnit, u32),
  JustNow,
  InTheFuture(TimeUnit, u32)
}

impl RoughTime {
  
  pub fn to_string(&self) -> String {
    // 模式匹配
    match self {
      RoughTime::InThePast(units, count) => format!("{} {} ago", count, units.plural()),
      RoughTime::JustNow => format!("just now"),
      RoughTime::InTheFuture(units, count) => format!("{} {} ago", count, units.plural()),
    }
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="字面量模式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

match meadow.count_rabbits() {
  0 => {},
  1 => println!("A rabbit is nosing around in the clover."),
  n => println!("There are {} rabbits hopping abount in the meadow", n),
}

let calendar = match settings.get_string("calendar") {
  "gregorian"   => Calendar::Gregorian,
  "chinese"     => Calendar::Chinese,
  "ethiopian"   => Calendar::Ethiopian,
  other         => return parse_error("calendar", other),
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="通配符模式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

let caption = match photo.tagged_pet() {
  Pet::Tyrannosaur    => "RRRAAAAAHHHHHHH",
  Pet::Samoyed        => "RRRAAAAAHHHHHHH",
  Pet::Tyrannosaur    => "*dog thoughts",
  _                   => "I'm cute, love me"              // 通用标题，任何宠物都适用
} 

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

match document.selection() {
  Shape::TextSpan(start, end) => paint_text_selection(start, end),
  Shape::Rectangle(rect)      => paint_rect_selection(rect),
  _                           => panic!("unexpected selection type")
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[

fn check_move(current_hex: Hex, click: Point) -> game::Result<Hex> {
  
  match point_to_hex(click) {
    None => Err("That's not a game space."),
    // Some(current_hex) 错误: 模式匹配时会引入新的变量，他会遮住函数参数 current_hex
    // Some(current_hex) => Err("You are already there! You must click somewhere else."),
    Some(hex) => 
      if hex == current_hex {
        Err("You are already there! You must click somewhere else.")
      } else {
        Ok(hex)
      }
    Some(other_hex) => Ok(other_hex)
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="元组模式匹配" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

fn describe_point(x: i32, y: i32) -> &'static str {
  
  use std::cmp::Ordering::*;

  match (x.cmp(&0), y.cmp(&0)) {
    (Equal, Equal) => "at the origin",
    (_, Equal) => "on the x axis",
    (Equal, _) => "on the y axis",
    (Greater, Greater) => "in the first quadrant",
    (Less, Greater) => "in the second quadrant",
    _ => "somewhere else",
  }

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="结构体模式匹配" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

match balloon.location {
  Point{ x: 0, y: height } => println!("straiht up {} meters", height),
  Point{ x: x, y: y } => println!("at {{}m, {}m}", x, y)
}

match get_account(id) {
  Some(Account{ name, language, .. }) => language.show_custom_greeting(name),
  None => {}
}

match account {
  // 注意: 匹配不可复制的值会转移值
  // 这里 account.name, account.language 被转移到了 name, language 中，其他元素则被丢弃了
  Account{ name, language, ...} => {
    ui.greeting(&name, &language);
    ui.show_settings(&account); // 错误: 此处 account 已经被转移了
  }
}

// 使用 ref 借用匹配的值
match account {
  Account{ ref name, ref language, ...} => {
    ui.greeting(&name, &language);
    ui.show_settings(&account); // 没问题
  }
}

// 匹配可修改引用
match line_result {
  Err(ref err) => log_error(err),   // 此处 err 是 &Error (共享引用)
  Ok(ref mut line) => {             // line 是可修改引用 (&mut String)
    trim_comments(line);            // 原地修改
    handle(line);
  }
}

// & 模式匹配
match chars.peek() {
  Some(&c) => println!("coming up: {:?}", c),
  None => println!("end of chars")
}

match sphere.center() {
  &Point3d{ x, y, z } => ...
}

// 匹配不可复制值
match friend.borrow_car() {
  // Some(&Car{ engine, ... }) => ...     // 如果 engine 是不可复制则会触发错误
  Some(&Car{ ref engine, ... } )          // 正确: 对不可复制值用 ref 取得值的引用
  None => {}
}

// 匹配多种可能性
let at_end = match chars.peek() {
  Some(&'\r') | Some(&'\n') | None => true,
  _ => false
}

// ... 匹配某个范围的值
// 0 ... 9 (全纳: 包含0和9)
// 0 .. 9 (半开放: 包含0但不包含9)
match next_char {
  '0' ... '9' => self.read_number(),
  'a' ... 'z' | 'A' ... 'Z' => self.read_word(),
  ' ' | '\t' | '\n' => self.skip_whitespace(),
  _ => self.handle_punctuation()
}

// 模式匹配护具
match robot.last_known_location() {
  // 如果模式匹配转移值，则不能添加 if 护具。因为值被转移后，就不能继续匹配了。
  // 解决办法是改为借用值，例如: Some(ref point)
  Some(point) if self.distance_to(point) < 10 => short_distance_strategy(point),
  Some(point) => long_distance_strategy(point),
  None => searching_strategy(point)
}

// @模式
match self.get_selection() {
  // Shape::Rect(top_left, bottom_right) => optimized_paint(&Shape::Rect(top_left, bottom_right)),
  rect @ Shape::Rect(..) => optimized_paint(&rect)          // @ 将匹配到的值转移或复制到 rect 中
  other_shape => paint_outline(other_shape.get_outline())
}

// @模式也使用于匹配范围 
match chars.next() {
  Some(digit @ '0' ... '9') => read_number(digit, chars)
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="可驳模式(refutable pattern)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 只处理一种特定的枚举
if let RoughTime::InTheFuture(_, _) = user.date_of_birth() {
  user.set_time_traveler(true);
}

// 尽在成功时运行某些代码
if let Some(document) = cache_map.get(&id) {
  return send_cached_response(document);
}

// 失败时重复做某件事
while let Err(err) = present_cheesy_anti_robot_task() {
  log_robot_attempt(err);
}

// 遍历一个迭代器
while let Some(_) = lines.peek() {
  read_paragraph(&mut lines);
}

]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>特型与泛型</c:title>
    <c:desc>
      <c:desc1 style="margin-bottom:0;"> <![CDATA[
<div>
  Rust 对多态的支持构建于两个相关特性之上: 特型(trait) 与 泛型(generic), 合理利用泛型与特型可以<b>避免虚拟方法消耗</b>和<b>向下类型转换</b>。
</div>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

trait Write {
  fn write(&mut self, buf: &[u8]) -> Result<usize>;
  fn flush(&mut self) -> Result<()>;
  fn write_all(&mut self, buf: &[u8]) -> Result<()>;
  ....
}

use std::io::Write;

// 接口
fn say_hello(out: &mut dyn Write) -> std::io::Result<()> {
  let _ = out.write_all(b"hello world");
  out.flush()
}

// 泛型函数
fn min<T: Ord>(value1: T, value2: T) -> T {
  if value1 <= value2 {
    value1
  } else {
    value2
  }
}

fn main() {
    // 写入内存
    let mut bytes = vec![];
    say_hello(&mut bytes).unwrap();

    assert_eq!(bytes, b"hello world");
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="在任意类型上实现任意特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 将自定义特型 IsEmoji 引入当前作用域时才可见
pub trait IsEmoji {
  fn is_emoji(&self) -> bool;
}

// 给一个已有的类型 char 添加 is_emoji 方法
impl IsEmoji for char {
  pub fn is_emoji(&self) -> bool {
    false
  }
}

// 给 str 类型添加 is_emoji 方法
impl IsEmoji for str {
  pub fn is_emoji(&self) -> bool {
    false
  }
}

fn main() {
  assert_eq!('%'.is_emoji(), false);
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="在某类型家族上使用泛型impl" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

use std::io::{self, Write};

pub trait WriteHtml {
  fn write_html(&mut self, html: &HtmlDocument) -> io::Result<()>;
}

// 为任意 std::io::writer 类型实现 WriteHtml 特型
// 对每个实现了 Write 的类型 W, 实现 WriteHtml 方法
impl<W: Write> WriteHtml for W {
  fn write_html(&mut self, html: &HtmlDocument) -> io::Result<()> {
    ....
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="参考 serde 库的特型实现" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 在 serde 源代码中: Vec、HashMap 这样标准的数据结构为 bool, i8, i16, i32, i64, 数组和元组等类型实现了 Serialize 特型
use std::env;
use std::error::Error;
use std::io::{Write, stderr};
use std::collections::HashMap;
use std::fs::File;
use serde::Serialize;
use serde_json;

pub fn print_error(mut err: &dyn Error) {
  
  let _ = writeln!(stderr(), "error: {}", err);

  while let Some(cause) = err.source() {
    let _ = writeln!(stderr(), "caused by: {}", cause);
    err = cause;
  }

}

pub fn save_configuration(file_name: &str, config: &HashMap<&str, &str>) -> std::io::Result<()> {
  // 创建一个JSON序列化处理程序将数据写入文件
  let writer = File::create(file_name)?;
  // let mut serializer = serde_json::Serializer::pretty(writer); // 格式化输出
  let mut serializer = serde_json::Serializer::new(writer);
  // 剩下的事交给 serde 的 serialize() 方法处理
  config.serialize(&mut serializer)?;
  Ok(())
}


fn main() {

    let args: Vec<String> = env::args().collect();

    let mut contacts = HashMap::new();

    contacts.insert("Daniel", "798-1364");
    contacts.insert("Ashley", "645-7689");
    contacts.insert("Katie", "435-8291");
    contacts.insert("Robert", "956-1745");

    let file_name = 
        if args.len() > 1 {
          &args[1][..]     // 接收命令行参数文件名
        } else {
          "file_1.json"
        };

    save_configuration(file_name, &contacts).unwrap_or_else( |_err| print_error(&_err));

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="特型中的 Self" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 谁调用了 x.clone(), Selft 就是谁的类型
// 如果 x 是 String，那 Self 的类型就是 String
pub trait Clone {
  fn clone(&self) -> Self;
  ...
}

// 指定 Self 的特型
pub trait Spliceable {
  // 这样声明函数意味着: self 和 other 的类型必须完全一样
  fn splice(&self, other: &Self) -> Self;
}

// Self 是 CherryTree(樱桃树) 的别名
impl Spliceable for CherryTree {
  fn splice(&self, other: &Self) -> Self {
    ....
  }
}

// Self 是 Mammoth(猛犸象) 的别名
impl Spliceable for Mammoth {
  fn splice(&self, other: &Self) -> Self {
    ....
  }
}

// 错误: 使用 Self 类型的特性与特性目标不能共存
// Rust 拒绝编译这种代码, 因为它没办法对 left.splice(right) 调用做类型检查
// 特型目标的核心在于类型到运行时才能知道, 而在编译时 rust 没办法判断 left 和 right 是不是同一种类型
// 注: 此处的 “特型目标” 指的是: 实现了某特型的类型以特型的身份出现
pub fn splice_anything(left: &Spliceable, right: &Spliceable) {
  let combo = left.splice(right);
  ....
}

// 解决上边错误的办法是设计一个目标友好的特型
pub trait MagaSpliceable {
  // 这样定义使得 self 和 other 的类型不必完全一样(条件放宽了)
  fn splice(&self, other: &MagaSpliceable) -> Box<MagaSpliceable>;
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="子特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
可以将一个特型声明为另一个特型的扩展
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 所有可见的游戏角色
// 实现 Creature 的类型也必须实现 Visible 特型
pub trait Creature: Visible {
  fn position(&self) -> (i32, i32);
  fn facint(&self) -> Direction;
}

impl Visiable for Broom {
  ...
}

impl Creature for Broom {
  ...
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Rust 特型可以包含静态方法和构造函数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 字符串集合特型
// 注: 此处的 “特型目标” 指的是: 实现了某特型的类型以特型的身份出现
pub trait StringSet {
  
  // 静态方法: 不接收 self 参数的方法是静态方法
  // 由于特型目标不支持静态方法, 所以增加条件绑定 where Self: Sized
  // 增加这个条件绑定后就可以使用 &StringSet 特型目标了
  // 虽然增加了绑定条件，但是特型目标仍然不支持两个静态方法, 但是可以创建特型目标并调用其他的非静态方法
  // 同样的做法也适用于任何其他不兼容特型目标(即:不能与特性目标共存)的方法
  // fn new() -> Self;
  fn new() -> Self 
              where Self: Sized;

  // 静态方法: 返回一个包含 strings 中所有字符串的集合
  // 由于特型目标不支持静态方法, 所以增加条件绑定 where Self: Sized
  // 增加这个条件绑定后就可以使用 &StringSet 特型目标了
  // 同样的做法也适用于任何其他不兼容特型目标(即:不能与特性目标共存)的方法
  fn from_slice(strings: &[&str]) -> Self 
              where Self: Sized;

  // 确定当前集合是否包含特定的 string_value
  fn contains(&self, string_value: &str) -> bool;

  // 向当前集合中添加一个字符串
  fn add(&mut self, string: &str);

}

// 返回 document 中不再 wordlist 中的单词的集合
fn unknown_words<S: StringSet>(document: &Vec<String>, wordlist: &S) -> S {
  
  let mut unknowns = S::new();

  for word in document {
    if !wordlist.contains(word) {
      unknowns.add(word);
    }
  }

  unknowns

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="完全限定方法调用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

// 以下四种函数调用都是等价的
"hello".to_string();                      // 并没有说明要调用的是哪个 to_string() 方法，
                                          // rust会通过一个方法查找算法(根据类型、强制解引用等)，来判断将要调用哪个具体方法
str::to_string("hello");                  // 限定方法(即指定方法关联的类型或特型)
ToString::to_string("hello");             // 限定方法
<str as ToString>::to_string("hello");    // 完全限定方法

// 当 rust 无法推断 self 时需要使用完全限定方法
let zero = 0;     // 类型未指定，可能是 i8, u8
zero.abs();       // 错误，对于不确定的类型 rust 无法推断将要调用哪个方法
i64.abs(zero);    // 正确(因为使用了完全限定方法)

// 将函数本身作为值时需要使用完全限定方法
let words: Vec<String> = 
    line.split_whitespace()                 // 产生 &str 值的迭代器
        .map(<str as ToString>::to_string)  // 完全限定方法调用 
        .collect();

// 完全限定语法也适用于静态方法调用
S::new(); 等价于 StringSet::new(); 或 <S as StringSet>::new();

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="定义类型关系的特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
特型是类型可以实现的一组方法。在需要多个类型相互协作的情况下，特型可以用来描述类型之间的关系。
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 关联类型 -- 之迭代器(Iterator)工作原理
pub trait Iterator {
  type Item;                                  // 一个关联类型, 即: 所有实现 Iterator 的类型都必须指定自己产生的项(item)的类型。
  fn next(&mut self) -> Option<Self::Item>;
}

impl Iterator for Args {
  
  type Item = String;

  fn next(&mut self) -> Option<String> {
    ...
  }

}

// 泛型函数同样可以使用关联类型
pub fn collect_into_vector<I: Iterator>(iter: I) -> Vec<I::Item> {
  
  let mut results = Vec::new();

  // 此处 rust 为推断出 value 的类型 
  for value in iter {
    results.push(value);
  }

  results

}

// 打印出一个迭代器的所有值
pub fn dump<I>(iter: I) 
           where I: Iterator {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // value 是不可以打印类型
  }
}

use std::fmt::Debug;

// 打印出一个迭代器的所有值
pub fn dump<I>(iter: I) 
           where I: Iterator, I::Item: Debug {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // Item 实现了 Debug
  }
}

// 打印出一个 String 迭代器的所有值
pub fn dump<I>(iter: I) 
           where I: Iterator<Item=String> {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // String 实现了 Debug
  }
}

// OR
pub fn dump(iter: &mut Iterator<Item=String>) {
  for (index, value) in iter.enumerate() {
    println!("{}: {:?}", index, value);     // String 实现了 Debug
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="泛型特型(或操作符重载的原理)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// rust 中的乘法运算符, 支持 * 操作符的类型实现的特型
// RHS (Right Hand Side) 右手边的减写形式
pub trait Mul<RHS> {
  type Output;                                // 应用 * 操作符之后返回的结果类型
  fn mul(self, rhs: RHS) -> Self::Output;     // * 操作符对应的方法
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="伴型特型(或rand::random()的工作原理)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 任意 Rng 类型可以生成所有 Rand 类型的值

use rand::random;

// 推断类型
let x = random(); 

// 如果rust无法推断类型，则必须指明随机数类型
let a = random::<f64>();      
let a = random::<bool>();     

// rand 包中的所有随机数生成器都实现了一个公共特型
pub trait Rng {
  fn next_u32(&mut self) -> u32;
  ...
}

// rand 包提供了几中 Rng 的不同实现
// XorShiftRng 一个快速伪随机数生成器
// OsRng 无法预测的随机数生成器

// rand 包用到的一个伴型特型叫 Rand
/// 可以使用 Rng 随机生成的类型
pub trait Rand: Sized {
  fn rand<R: Rng>(rng: &mut R) -> Self;
}

// f64, bool 等类型都实现了这个 Rand 特型
let x = f64::rand(rng);
let b = bool::rand(rng);

// 实际上 random() 函数只是简单封装了下对 rand 方法的调用
pub fn random<T: Rand>() -> T {
  T::rand(&mut global_rng())
}

// ### 标准库中计算散列码的实现是伴型特型的另一个例子
// 1. 实现 Hash 的类型是可以散列化的, 因此可以用作散列表的键
// 2. 实现 Hasher 的类型是散列化算法。
// 3. Hash 有一个泛型方法 Hash::hash() 接收任何类型的 Hasher 作为参数

// ### serde 库的 Serialize 特型也用到了 "伴型特型" (Serializer)
// 1. serde 支持可插拔的序列化格式
// 2. 不同的 Serializer 实现了 JSON, Yaml, CBOR(二进制格式)

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="逆向工程绑定" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// *************************************************************************************************
// ***** 对以下示例中的 N 的绑定过程进行了逆向工程, 让编译器指导自己反复检查自己的工作，最终给出合理的条件绑定 *****
// *************************************************************************************************

// 常规函数
pub fn dot(v1: &[i64], v2: &[i64]) -> i64 {
  let mut total = 0;
  for i in 0 .. v1.len() {
    total = total + v1[i] * v2[i];
  }
  total
}

// 泛型函数(由于此处的泛型参数N可能并不支持乘法和加法，所以rust编译报错)
pub fn dot<N>(v1: &[N], v2: &[N]) -> N {
  let mut total = 0;                // 由于0的类型始终是整数
  for i in 0 .. v1.len() {
    total = total + v1[i] * v2[i];
  }
  total
}

// 需要给泛型参数 N 添加限定类型
pub fn dot<N: Add<Output=N> + Mul<Output=N> + Default>(v1: &[N], v2: &[N]) -> N {
  // 由于0的类型始终是整数, 所以需声明有默认值的类型才能调用此方法
  // 在 rust 标准库中有个 Default 特型，所有有默认值的类型都实现了 Default 特型 
  // let mut total = 0;
  let mut total = N.default();
  for i in 0 .. v1.len() {
    // 两个数相乘并不一定会得到相同的类型, 需要告诉rust这个泛型函数只适用于常规乘法运算
    // 需要给 Add, Mul 增加限定条件: Add<Output=N>, Mul<Output=N>
    // total = total + v1[i] * v2[i]; 
    total = total + v1[i] * v2[i];
  }
  total
}

// *************************************************************************************************
// ***** where N: Add<Output=N> + Mul<Output=N> + Default + Copy ***********************************
// ***** Rust这种"条件绑定"设计的优点是：****************************************************************
// ***** 1. 可以让泛型代码具有向前兼容的能力 *************************************************************
// ***** 2. 绑定的另一个优点是可以通过编译器报错知道要解决的麻烦在哪里 ***************************************
// ***** 3. 相比C++编译器设计模版的错误信息要比 Rust 啰嗦的多，是模版呢还是调用者，通常难于分辨 ****************
// ***** 4. 最终要的优点是代码即文档: 代码里已经明确了程序的运行原理 ****************************************
// *************************************************************************************************
// 增加可读性: 将限定条件转移到 where 子句中
pub fn dot<N>(v1: &[N], v2: &[N]) -> N 
          where N: Add<Output=N> + Mul<Output=N> + Default + Copy {

  // 由于0的类型始终是整数, 所以需声明有默认值的类型才能调用此方法
  // 在 rust 标准库中有个 Default 特型，所有有默认值的类型都实现了 Default 特型 
  // let mut total = 0;
  let mut total = N.default();

  for i in 0 .. v1.len() {
    
    // 两个数相乘并不一定会得到相同的类型, 需要告诉rust这个泛型函数只适用于常规乘法运算
    // 需要给 Add, Mul 增加限定条件: Add<Output=N>, Mul<Output=N>
    // total = total + v1[i] * v2[i]; 

    // v1[i] 会把值从切片中转移，但函数声明中的 N 可能是不可复制类型
    // 所以需要让 rust 知道 N 是可复制类型: + Copy 
    // total = total + v1[i] * v2[i]; 
    
    total = total + v1[i] * v2[i];
  
  }
  
  total

}

// 有一个流行的 rust 开源库 num，
// 该库定义了 Num 特型用于表示所有 Number 类型
// (支持加，减，乘，除的都可以是 number)
pub fn dot<N>(v1: &[N], v2: &[N]) -> N 
          where N: Num + Copy {

  // let mut total = 0;
  let mut total = N.zero();

  for i in 0 .. v1.len() {
    // v1[i] 会把值从切片中转移，但函数声明中的 N 可能是不可复制类型
    // 所以需要让 rust 知道 N 是可复制类型: + Copy 
    // total = total + v1[i] * v2[i]; 
    total = total + v1[i] * v2[i];
  }
  
  total

}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>实用特型</c:title>
    <c:desc>
      <c:desc1 style="margin-bottom:0;"> <![CDATA[

<table style="margin:.5em 0;line-height:1.3em;width:100%;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="padding: 0;margin: 0;text-align: right;padding-right:1em;">特型</th>
            <th style="padding: 0;margin: 0;text-align: left;padding:.5em 0;padding-left:1em;">作用</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Drop</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">解构函数，清除值时Rust自动运行的清除代码。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Sized</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">标记特型，针对编译时可以知道大小的类型。而不是像切片那样动态大小的类型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Clone</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">针对支持克隆值的类型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Copy</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">标记特型，针对可以简单地对内存中包含的值进行逐字节复制来克隆的类型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Deref与DerefMut</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">智能指针类型的特型</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Default</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">针对有合理“默认值”的类型</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">AsRef与AsMut</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，借用某种类型的引用。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Borrow与BorrowMut</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，类似AsRef/AsMut，但额外保证一致的散列、顺序和相等</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">From与Into</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，将某种类型的值转换为另一种特型。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">ToOwned</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">转换特型，将引用转换为所有值。</td>
        </tr>
    </tbody>
</table>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="Drop" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 可以通过实现 std::ops::Drop 特型自定义 Rust 清除值的方式
// Rust 会在清除每个值之前调用 Drop::drop, 所以该方法接收到的值肯定是完全初始化的。
// 如果某类型实现了 Drop 就不能在实现 Copy 特型:
// 1. 如果一个类型是 Copy，就意味着简单的字节对字节的复制已经足以产生一个值的独立副本
// 2. 注意: 在同一份数据上不止一次调用同一个 drop 方法通常是错误的
pub trait Drop {
  fn drop(&mut self);
}

// Application 拥有字符串的内容和向量元素缓冲区对应的堆内存空间。
// Rust 会在 Applicaiton 被清除时自动释放这些存储空间
pub struct Application {
  name: String,             // String 内部使用 Vec<u8> 保存其文本，因此 String 自身不需要实现 Drop，而是有 Vec 负责释放其字符
  nicknames: Vec<String>    // Vec 类型实现了 Drop，可以清除自己的每个元素，然后释放他们占用的堆内存空间
}

// 为 Applicaiton 类型实现 Drop 的代码可以任意使用其字段
// 1. String 内部使用 Vec<u8> 保存其文本，因此 String 自身不需要实现 Drop，而是有 Vec 负责释放其字符
// 2. Vec 类型实现了 Drop，可以清除自己的每个元素，然后释放他们占用的堆内存空间
// 3. 保存 Application 值自身的内存也有所有者: 可能是一个局部变量或某个数据结构，他们会负责释放对应的内存
impl Drop for Application {
  
  pub fn drop(&self) {
    
    print!("Droping {}", self.name);

    if !self.nickname.is_empty() {
      print!("(AKA {})", self.nicknames.join(","));
    }

    println!("");

  }

}

fn main() {
  let mut a = Applicaiton(name: "Zues".to_string(), nicknames: vec!["cloudcollector".to_string()]);
  println!("before assignment");
  a = Applicaiton(name: "Hera".to_string(), nicknames: vec![]);
  println!("at end of block");
}


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 在 Unix 系统上，Rust 标准库在内部使用以下类型表示操作系统的文件描述符:
pub struct FileDesc {
  // c_int 是 i32 的别名
  // fd 表示文件描述符的编号
  // 在进程关闭时关闭该文件句柄
  pub fd: c_int,        
}

impl Drop for FileDesc {
  pub fn drop(&mut self) {
    // libc::close 是 C 库的 close 函数在 Rust 中的名字
    // Rust 代码只能在 unsafe 块中调用 C 函数
    let _ = unsafe { 
      libc::close(self.fd) 
    };
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Sized (固定大小类型)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// ### 固定大小
// 固定大小类型，指的是相同类型的值在内存中都具有相同大小。
// u64: 8字节
// (f32, f32, f32): 12字节
// 虽然 Vec<T> 拥有分配在堆上的大小可变的缓冲区，但Vec值本身只包含一个指向该缓冲区的指针、缓冲区的容量和长度。因此 Vec<T> 也是固定大小的类型。

// ### 非固定大小
// Rust 也有一些非固定大小的类型，其值的大小是不固定的。
// 1. 比如 str(注意没有 &) 类型是非固定大小的，字符串字面量 "diminutive" 和 "big" 是对占用 10 字节和3字节 str 切片的引用。
// 2. [T](注意没有 &) 这样的数组切片类型也是非固定大小的，即: 共享引用 &[u8] 可以指向任意大小的 [u8] 切片。
// 3. 对特型目标的引用也是非固定大小的
//    -- 特型目标是一个指向实现了给定特型的某个值的指针
//    -- &std::io::Write 和 Box<std::io::Write> 都是指向实现了 Write 特型的某个值的指针。
//    -- rust 不能在变量中存储非固定大小的值，也不能将他们作为参数传递，只能通过 &str 或 Box<Write> 这样本身是固定大小的指针来使用他们。
//    -- 指向非固定大小值的指针始终是一个"胖指针"，占两个字宽。
//    -- "胖指针"即包含指向切片的指针，也包含切片的长度。
//    -- 而"特型目标"包含一个指向方法实现的虚拟表的指针。
//    -- 不知道长度就不能使用索引访问 [u8] 值, 而不知道对 Write 的特定实现，就不能调用 Box<Write> 上的方法。
//    -- 胖指针补充了类型缺少的信息，给出了长度和虚拟表的指针。遗漏的信息被动态信息所取代。
// 4. 结构体类型的最后一个字段可能是非固定大小的，此时结构体本身也是非固定大小的。
// 5. rust 函数不可能返回非固定大小的值

struct RcBox<T: ?Sized> {
  ref_count: usize,
  value: T
}

use std::fmt::Display;

fn display(boxed: &RcBox<Display>) {
  println!("{:?}", boxed);
}

fn main() {
  let boxed_lunch: RcBox<String> = RcBox{ ref_count: 1, value: "lunch".to_string() };
  // let boxed_displayable: &RcBox<Display> = &box_lunch;
  display(&box_lunch);
}

// 1. 所有固定大小的类型都实现了 std::marker::Sized 特型。Rust 为其适用的所有类型自动实现了这个特型。
// 2. 开发者不能自己实现 Sized 特型，唯一需要使用 Sized 的场景是绑定类型变量。T: Sized 要求 T 必须是一个编译时大小已知的类型。这种特型称为标记特型。
// 3. 由于非固定大小的类型具有很大的局限性，因此大多数泛型变量应该被限制为使用 Sized 类型。
// 4. Rust 隐式的将 Sized 特型用作泛型变量的默认绑定限制，如果不想这样的限制就必须显示声明，比如: struct S<T: ?Sized> { ... }

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Clone" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Clone 特型适用于可以复制自身的类型, 定义如下:
// 由于函数不可能返回非固定大小的值，所以 Clone 特型本身扩展了 Sized 特型
// 调用 clone() 必须保证绝对成功，某些在复制过程中可能失败的类型不能实现 Clone 特型
// rust 标准库的很多类型均实现了 Clone: bool, f32, String, Vec<T>, HashMap
trait Clone: Sized {
  // 克隆一个值，通常涉及创建该值所拥有一切内容的副本及分配内存
  fn clone(&self) -> Self;
  // 该方法将 self 修改为 source 的一个副本：
  // 1. 假设 s 和 t 都是 String，则语句 s = t.clone()，必须先克隆 t，清除 s 的值，然后将克隆出来的值转移到 s 中
  // 2. 这涉及一次堆内存分配和一次堆内存释放，
  // 3. 如果 s 值所拥有的堆缓冲区有足够的容量可以装下 t 的内容，就无需分配或释放了
  // 4. 此时只要将 t 的文本复制到 s 的缓冲区，在调整下长度即可
  // 5. 在泛型代码中，应该尽量使用 clone_from
  // 如果你对Clone的实现只是简单地对自有类型的每个字段或元素应用 clone，然后在基于克隆的副本构建一个新的值，那么 clone_from 的默认定义就足够用了
  // 此种情况下: 只需要在类的定义上加 #[derive(Clone)]，rust 就会为你实现它
  fn clone_from(&mut self, source: &Self) {
    *self = source.clone(); 
  }
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Copy" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 如果某类型实现了 std::marker::Copy 标记特型，那么它就是 Copy 类型。
// 1. Rust 只允许类型在"字节对字节的深度复制"能满足要求的情况下实现 Copy 特型
// 2. 如果某类型可能拥有任意资源，比如缓冲区或操作系统句柄的类型，不能实现 Copy
// 3. 任何实现了 Drop 的类型不可以在实现 Copy, Rust 认为如果一个类型需要特殊的清理代码，那么就一定要特殊的复制代码！！
// 4. 如果一个类型实现了 Copy，那么在变量赋值或传参时会产一个原始值的副本，而不是转移值。因此隐式复制的代价是很大的，谨慎使用 Copy 特型
// 5. 可以使用 #[derive(Copy)] 让 rust 为你派生 Copy
trait Copy: Clone {
  
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Deref 与 DerefMut" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 修改解引用操作符 * 和 . 在自定义类型上的行为。
// Box<T> 和 Rc<T> 这样的指针类型实现了这两个特型，从而可以像 Rust 内置的指针类型一样行事。
// -- 例如: Box<Complex> 类型的值 b，那么 *b 引用的就是 b 指向的 Complex 的值，而 b.re 指向的是类型字段的值
// 如果一次 deref 调用可以消除类型匹配错误，那 rust 会为你插入一次，这种操作被称为"解引用强制转型":
// 1. 假设有一个 Rc<String> 的值 r: 
//    -- String.find 可以简单地写成 r.find('?') 而不需要写成 (*r).find('?')，
//    -- 这里的方法调用隐式借用了 r，而 &Rc<String> 被强制转换成了 &String, 
//    -- 因为 Rc<T> 实现了 Deref<Target=T>
// 2. 虽然 split_at 是 str 切片类型的方法，可以在 String 值上使用 split_at 等方法:
//    -- 因为 String 实现了 Deref<Target=str>, 
//    -- 这样 String 就不需要在实现 str 的所有方法了
//    -- 因为可以将 &String 强制转型为 &str
//    -- 此时涉及到连续多次应用“解引用强制转型”: &Rc<String> to &String to &str
// 3. 假设有一个字节向量 v:
//    -- 可以将这个向量 &v 传给一个参数是 &[u8] 的函数，
//    -- 因为 Vec<T> 实现了 Deref<Target=[T]>
// 设计 Deref 和 DerefMut 设计的目的是：
// -- 为了实现智能指针类型(Box,Rc,Arc)和简化某些会频繁通过引用来使用的类型的所有者版本(例如Vec<T>和String是[T]和str的所有者版本)
pub trait Deref {
  type Target: ?Sized;
  fn deref(&self) -> &Self::Target;     // 将前一种类型的引用转换为后一种类型的引用
}

pub trait DerefMut: Deref {
  fn deref_mut(&mut self) -> &mut Self::Target;
}

// 例子:
pub struct Selector<T> {
  pub elements: Vec<T>,     // 所有元素用一个向量存储
  pub current: usize       // 当前元素的索引
}

use std::ops::{Deref, DerefMut};

impl<T> Deref for Selector<T> {
  type Target = T;
  fn deref(&self) -> &T {
    &self.elements[self.current]
  }
}

impl<T> DerefMut for Selector<T> {
  fn deref_mut(&mut self) -> &mut T {
    &mut self.elements[self.current]
  }
}

fn main() {
  
  let mut s = Selector{ elements: vec!['x', 'y', 'z'], current: 2 };

  // 因为 Selector 实现了 Deref, 所以可以使用 * 操作符引用它的当前元素
  // 当使用 *s 时，发生了"强制解引用转换"
  println!("{}", *s);

  // 通过"解引用强制转型"直接在 Selector 上使用 char 的方法
  // 当使用 s.is_alphabetic() 时，发生了"强制解引用转换"
  println!("{}", s.is_alphabetic());

  // 通过给 Selector 的引用赋值，将 'z' 自改为 'w'
  *s = 'w';

  println!("{}", *s);

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// "解引用强制转型"用来解决类型冲突，但是在做"类型变量的绑定"时无法应用这种规则
fn show_it(thing: &str) {
  println!("{}", thing);
}

use std::fmt::Display;

fn show_it_generic<T: Display>(thing: T) {
  println!("{}", thing);
}

let s = Selector{elements: vec!["good", "bad", "ugly"], current: 2};

// 在调用 show_it(&s) 时, 实参是: &Selector<&str>, 形参是: &str
// 并且 rust 发现了 Deref<Target=str> 的实现, 于是就把调用重写为 show_it(s.deref())
show_it(&s);

// 此时的参数类型是 Selector<&str> 这个实参没有实现 Display
show_it_generic(&s);

// 可通过类型转换，改变传递给 show_it_generic 的实参, 来解决此问题
show_it_generic(&s as &str);


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Default" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 在 rust 中有默认值的类型都实现了 std::default::Default 特型
// Vec, HashMap, BinaryHeap, i32, u32, bool 等等
// 如果结构体的所有字段都实现了 Default, 则可以使用 #[derive(Default)] 自动为结构体实现 Default
pub trait Default {
  fn default() -> Self;
}

// String 对 Default 的实现很直观
impl Default for String {
  fn default() -> Self {
    String::new()
  }
}

// ### 例如如果你想构建某个值的集合，但是希望调用者决定到底构建什么样的集合时非常有用。
// 1. Iterator 特型的 partition 方法会将迭代器产生的值分成2个集合，而哪个值分到哪个集合由一个闭包决定：
use std::collections::HashSet;

fn main() {
    let squares = [4, 9, 16, 25, 36, 49, 64];
    let (powers_of_two, impure): (HashSet<i32>, HashSet<i32>) = squares.iter().partition(|&n| {
        println!("{}", n);
        n & (n - 1) == 0
    });
    println!("{:?}", powers_of_two);
    println!("{:?}", impure);
    println!("{}", 4 & (4 - 1));
    println!("{}", 9 & (9 - 1));
}

// ### Default 的另一个常见用途是为具有大量字段的结构体生成默认值
let params = glium::DrawParameters{
  line_width: Some(0.02),
  point_size: Some(0.02),
  .. Default::default()       // 用所有字段的默认值初始化 DrawParameters 结构体
                              // 然后用结构体的 .. 语法为需要修改的 line_width 和 point_size 字段创建新的值
}

target.draw(..., &params).unwrap();


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="AsRef 与 AsMut" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 一个类型如果实现了 AsRef<T>，就意味着可以向这个类型借用一个 &T
// Vec<T> 实现了 AsRef<[T]>, String 实现了 AsRef<str>
// 可以将 String 的内容借用为字节数组，是因为 String 也实现了 AsRef<[u8]>
trait AsRef<T: ?Sized> {
  fn as_ref(&self) -> &T;
}

trait AsMut<T: ?Sized> {
  fn as_mut(&mut self) -> &mut T;
}

// AsRef 通常用于使函数在接收参数的类型中更加灵活, 例如, std::fs::File::open 函数的声明如下:
fn open<P: AsRef<Path>>(path: P) -> Result<File> { ... }

// 从函数声明中可以知道任何实现了 AsRef<Path> 的类型都可以调用这个函数: String, str, OsString, OsStr, PathBuf, Path 等等
// 因此可以给 open 传入一个字符串字面量
let dot_emacs = std::fs::File.open("_file_path/_here")?;

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Borrow 与 BorrowMut" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 如果一个类型实现了 Borrow<T>, 那么他的 borrow 方法可以从自身有效地借用一个 &T
// 只有当 &T 与他所借用的值具有相同的散列和比较特型时，一个类型才可以实现 Borrow<T>
// 例如: String 实现了 AsRef<T>, AsRef<[u8]>, AsRef<Path>, 但是这三种目标类型通常具有不同的散列值。
//      -- 只有 &str 切片能保证与对应的 String 有相同的散列化结果，因此 String 只实现了 Borrow<str>
trait Borrow<Borrowed: ?Sized> {
  fn borrow(&self) -> &Borrowed;
}

// 例子1: 从 std::collections::HashMap<String, i32> 中查询一条记录的方法的签名可以定义如下: 
impl HashMap<K, V> where K: Eq + Hash {
  // 这里的 key 被强制要求传入一个 String 值, 实际上这里只需要传入一个键的引用
  fn get(&self, key: K) -> Option<&V> {
    ....
  }
}

// 改进版本, 此时如果想查询一个常量字符串必须写成这样, 这很荒谬: 
// 1. 先在堆上分配一个 String 的缓冲区，
// 2. 在把文本复制进去，
// 3. 接着用 &String 来借用它，
// 4. 然后传给 get，
// 5. 最后清理掉键的缓冲区
hashtable.get("twenty-two".to_string());
impl HashMap<K, V> where K: Eq + Hash {
  // 传入一个键的 &String, 取得键对应的值
  fn get(&self, key: &K) -> Option<&V> {
    ....
  }
}

// 最终版本:
// 如果可以通过 &Q 借用记录的键，而且可引用的散列和比较与键本身一样，那么 &Q 可以作为键类型
// 因为 String 实现了 Borrow<String> 和 Borrow<str>, 所以 &String 和 &str 都可以作为键
impl HashMap<K, V> where K: Eq + Hash {
  fn get<Q: ?Sized>(&self, key: &Q) -> Option<&V> where K: Borrow<Q>, Q: Eq + Hash {
    ....
  }
}


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="From 与 Into" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 消费一种类型的值，然后返回另一种类型的值
// From 和 Into 可以取得他们参数的所有权
// AsRef 和 AsMut 从一种类型借用另一种类型的引用
trait std::convert::Into<T>: Sized {
  fn into(self) -> T;
}

trait std::convert::From<T>: Sized {
  fn from(T) -> Self;
}

// 通常使用 Into 让函数更灵活地接收参数
use std::net::Ipv4Addr;

// ping 函数不仅可以接收 Ipv4Address 作为参数, 也可以接收 u32 或 [u8; 4] 数组 (因为后边两个类型实现了 Into<Ipv4Address> 特型)
// 有时候把 Ipv4Address 当成一个 32 位整数或者一个 4 字节数组来处理会更有用
fn ping<A>(address: A) -> std::io::Result<bool> where A: Into<Ipv4Addr> {
  let ipv4_address = address.into();
  ... 
}

fn main() {

  // into
  println!("{:?}", ping(Ipv4Addr::new(23, 21, 68, 141))); // 传入 Ipv4Addr
  println!("{:?}", ping([66, 146, 219, 98]));             // 传入 [u8; 4]
  println!("{:?}", ping(0xd076eb94_u32));                 // 传入u32

  // from
  let addr1 = Ipv4Addr::from([66, 146, 219, 98]);         // 从数组创建ip地址
  let addr2 = Ipv4Addr::from(0xd076eb94_u32);             // 将整数转成ip地址

  println!("{:?}", addr1);
  println!("{:?}", addr2);

  let text = "Beautiful Soup".to_string();
  // 找 String 堆缓冲区, 将其作为向量元素的缓冲区并返回
  // 这种转换无须重新分配或复制文本，这也是转移可以提高实现效率的另一个例子
  // 由于 into 取得的是参数的值，所以 text 在转换之后就变成未初始化状态了
  let bytes: Vec<u8> = text.into();                 

  println!("{:?}", bytes);

  // String 实现了 From<&str>, 可以将字符串切片复制到一个在堆内存上新分配的缓冲区并返回 String
  let _string = String::from("hello world");

  println!("{}", _string);

}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="ToOwned" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 给定一个引用，产生其引用目标的所有型副本的通常方式是调用 clone() 方法
// 1. 如果想克隆一个 &str 或 &[i32] 怎么办? 
// 2. 克隆一个 &T 必须返回一个类型的值，str 和 [u8] 都是非固定大小的，他们都不是函数可以返回的类型！！

// 把引用转换为所有型的值
trait ToOwned {
  // 根据定义 Owned 必须实现 Borrow<Self>
  type Owned: Borrow<Self>;
  // to_owned 可以返回能借用为 &Self 的任何类型
  // 可以从 Vec<T> 借用一个 &[T], 因此 [T] 可以实现 ToOwned<Owned=Vec<T>>, 只要 T 实现了 Clone 即可
  fn to_owned(&self) -> Self::Owned;
}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Borrow 与 ToOwned 实例" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 要想用好 Rust，必须把所有权相关的问题想清楚！！
// 一个函数到底应该按引用传递还是按值传递，有时候只能到程序运行时才能决定到底是借用还是取得所有权更合适。
// 写时克隆 std::borrow::Cow (clone on write) 类型为此提供了一种解决方案:
// 1. 可以借用一个对B的共享引用
// 2. 也可以拥有一个值
// 3. Cow 实现了 Deref, 所以可以把它当成一个对 B 的共享引用, 进而调用B的任何方法
// 4. 如果它是 Owned，就借用对这个所有值的共享引用
// 5. 如果它是 Borrowed, 就交出它持有的引用
pub enum Cow<'a, B: ?Sized + 'a> where B: ToOwned {
  Borrowed(&'a B);                // '
  Owned(<B as ToOwned>::Owned),
}



// ## 写时复制
// 1. 调用 to_mut 方法也可以取得对一个 Cow 值的可修改引用，此时方法返回的是 &mut B
// 2. 如果 Cow 恰好是 Cow::Borrowed, 
//    -- to_mut 就直接调用引用的 to_owned 方法, 取得对引用目标的所有型副本
//    -- 将 Cow 改为 Cow::Owned, 并借用对这个新所有值的可修改引用。这就是"写时复制"

// Cow 的一个常见用途是返回静态分配的字符串常量或者计算的字符串。
// 假设你需要将一个错误枚举转换为一条消息，这个信息有时是不确定长度的，此时可以返回一个 Cow<'static, str>
use std::path::PathBuf;
use std::borrow::Cow;

// 在 Cow 的帮助下 describe 及其调用者得以把内存分配推迟到了真正必要的时候
fn describe(error: &Error) -> Cow<'static, str> { // '
  math *error {
    Error::OutOfMemory => "out of memory".into(),         // 返回 Cow::Borrowed, 引用一个静态分配的字符串
    Error::StackOverflow => "stack overflow".into(),      // 返回 Cow::Borrowed, 引用一个静态分配的字符串
    Error::MachineOnFire => "machine on fire".into(),     // 返回 Cow::Borrowed, 引用一个静态分配的字符串
    Error::Infathomable => "machine bewildered".into(),   // 返回 Cow::Borrowed, 引用一个静态分配的字符串
    Error::FileNotFound(ref path) => {
      format!("file not found: Path={}", path.display()).into()   // 返回 Cow::Owned
    }
  }
}

fn main() {
  let mut log: Vec<String> = Vec::new();
  log.push(describe(&error).into_owned());                            // 取得所有型的值并放到向量中
  println!("Disaster has struck: error_mesage={}", describe(&error)); // 把 Cow 当成 &str
  println!("logs: error_message={:?}", log);
}

]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>闭包</c:title>
    <c:desc>
    </c:desc>

    <c:sourceContent type="" title="排序" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 对一个自定义结构体排序
// 对一个自定义结构体排序
#[derive(Debug)]
pub struct City {
    pub name: String,
    pub population: i64,
    pub country: String,
    pub monster_attack_risk: f64,
}

impl City {
  pub fn get_statistic(&self, &stat: Statisic) -> i64 {
    11
  }
}

fn sort_cities(cities: &mut [City]) {
    cities.sort_by_key(|city| -city.population); // 利用闭包排序
}

fn main() {
    let mut cities = vec![
        City { name: "name1".to_string(), population: 54, country: "c1".to_string(), },
        City { name: "name2".to_string(), population: 56, country: "c2".to_string(), },
        City { name: "name3".to_string(), population: 6, country: "c3".to_string(), },
    ];

    sort_cities(&mut cities);

    println!("{:?}", cities);
}


]]>
    </c:sourceContent>

    <c:sourceContent type="" title="盗用闭包的值" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::thread;

pub fn start_sorting_thread(mut cities: Vec<City>, stat: Statisic) -> thread::JoinHandle<Vec<City>> {
  
  // 此处的 move 转移了 stat
  lt key_fn = move |city: &City| -> i64 {
    -city.get_statistic(stat)
  }

  // 此处的 move 转移了 cities 和 key_fn
  thread::spawn(move || {
    // 在新线程中调用闭包
    cities.sort_by_key(key_fn);
    cities
  })

}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="函数与闭包类型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 函数和闭包可以被当作值来使用，这意味着他们也有自己的类型
// 结构体可以包含函数类型的字段，泛型类型如 Vec 可以存储一批函数, 只要他们的值一样就行
// 函数值很小，一个 fn 值就是这个函数机器码的内存地址，与C++中的函数指针类似
// fn(&T) -> bool           // fn 类型(仅函数)
// Fn(&T) -> bool           // Fn 特型(包括函数和闭包)
// ## 每个闭包都有自己的类型，因为闭包可能包含任意多个变量(从作用域中借来或偷来的)
//    -- 因此编译器会为每个闭包创建一个临时类型，大到足以容纳它的数据
//    -- 任意两个闭包的类型都不相同
//    -- 所有闭包都会实现 Fn 特型
fn city_population_descending(city: &City) -> i64 {
  -city.population
}

fn city_monster_attack_risk_descending(city: &City) -> f64 {
  -city.monster_attack_risk
}

let my_key_fn: fn(&City) -> i64 = 
    if user.prefs.by_population {
      city_population_descending
    } else {
      city_monster_attack_risk_descending
    }

clients.sort_by_key(my_key_fn);

fn has_monster_attacks(city: &City) -> bool {
  city.monster_attack_risk > 0.0
}

// ### 一个函数可以接收另一个函数作为参数
fn count_selected_cities(cities: &Vec<City>, test_fn: fn(&City) -> bool) -> usize {
  
  let mut count = 0;

  for city in cities {
    if test_fn(city) {
      count += 1;
    }
  }

  count

}

// 泛型函数
fn count_selected_cities_generic<F>(cities: &Vec<City>, test_fn: F) -> usize where F: Fn(&City) -> bool {
  
  let mut count = 0;

  for city in cities {
    if test_fn(city) {
      count += 1;
    }
  }

  count

}

fn main() {
  let n = count_selected_cities(&my_cities, has_monster_attacks);                             // 仅函数
  let n = count_selected_cities_generic(&my_cities, has_monster_attacks);                     // 包括函数和闭包
  let n = count_selected_cities_generic(&my_cities, |city| city.monster_attack_risk > 0.0);   // 包括函数和闭包
  println!("{}", n)
}



]]>
    </c:sourceContent>

    <c:sourceContent type="" title="闭包的性能" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Rust 闭包的设计保证它非常快，比函数指针还要快，快到完全可以用在强度和性能要求极高的环境下。
// 1. 在大多数语言中闭包是分配在堆上的，动态分派，然后由垃圾回收程序负责回收。
// 2. 传统编译器很难对闭包应用“行内化”优化策略以减少函数调用并进而应用其他优化。
// 3. Rust 闭包不会被分配到堆上，除非你把他们装到 Box, Vec 或其他容器里(此时需通过特型对象动态调用它, 稍稍慢一点点, 但仍然和其他特型对象一样快)
// 4. 每个闭包都有自己的类型，所以 Rust 编译器只要知道了闭包的类型，就可以将该闭包的代码行内化。
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/fn-layout.png" />
</div>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="杀值的闭包" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn call_twice(closure: F) where F: Fn() -> () {
  closure();
  closure();
}

fn main() {
    let my_str = "hello world".to_string();
    println!("{}", my_str);
    let f = || drop(my_str);      // 释放, 杀值的闭包: FnOnce
    f();
    f();                          // 错误, 不能重复释放
    println!("{}", my_str); // 错误，
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="FnOnce 与 FnMut" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn call_twice<F>(closure: F) where F: FnOnce() -> () {
  closure();
  // closure();
}

fn main() {
    let my_str = "hello world".to_string();
    let f = || drop(my_str);                  // 被 Rust 推断为只能调用一次的闭包
    call_twice(f);
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="FnMut" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn call_twice<F>(mut closure: F)
where
    F: FnMut() -> (),
{
    closure();
    // closure();
}

fn main() {
    let mut i = 0;
    let mut f = || {
        println!("{}", i);
        i += 1;               // 被 Rust 推断为可修改数据的闭包
    };
    f();
    f();
    f();
    f();
    f();
    call_twice(f);
    println!("{}", i);
}


]]>
    </c:sourceContent>


    <c:sourceContent type="" title="回调" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
  let mut router = Router::new();

  router.get("/", get_form, "root");
  router.post("/gcd", post_gcd, "gcd");

  router.get("/get", |_: &mut Request| {
    Ok(get_form_response())
  }, "root1");

  router.post("/gcd2", |request: &mut Request| {
    let numbers = get_numbers(request)?;
    Ok(get_gcd_response(numbers))
  }, "root1");

}
]]>
    </c:sourceContent>


    <c:sourceContent type="" title="一个简单的路由系统" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::collections::BTreeMap;

#[derive(Default)]
pub struct Request {
    pub method: String,
    pub url: String,
    pub headers: BTreeMap<String, String>,
    pub body: Vec<u8>,
}

#[derive(Default)]
pub struct Response {
    pub code: u32,
    pub headers: BTreeMap<String, String>,
    pub body: Vec<u8>,
}

// pub struct BasicRouter<C> where C: Fn(&Request) -> Response {
//   routers: HashMap<String, C>
// }

// 如果需要这个路由系统支持多个路由, 需要将路由对应的处理函数装箱
// 每个"箱子"可以包含不同的类型, 因此一个 HashMap 可以处理所有不同类型的回调(请求)
type BoxedCallback = Box<dyn Fn(&Request) -> Response>;

pub struct BasicRouter {
    routers: BTreeMap<String, BoxedCallback>,
}

impl BasicRouter {
    pub fn new() -> BasicRouter {
        BasicRouter {
            routers: BTreeMap::new(),
        }
    }

    // pub fn add_route(&mut self, url: &str, callback: C) {
    //   self.routers.insert(url.to_string(), callback);
    // }

    pub fn add_route<C>(&mut self, url: &str, callback: C)
    where
        C: Fn(&Request) -> Response + 'static,
    {
        // '
        // 不加 'static 标签, Box::new(callback) 会报错，因为如果闭包中包含超出作用域的变量或引用, 那么这个调用是不安全的
        self.routers.insert(url.to_string(), Box::new(callback));
    }
}

fn main() {

    let mut router = BasicRouter::new();

    router.add_route("/", |_| {
        println!("index");
        Response { ..Default::default() }
    }); // 每个回调都是不同的类型

    router.add_route("/gcd", |req| {
        println!("{}", req.url);
        Response { ..Default::default() }
    }); // 每个回调都是不同的类型

    for (key, _val) in (&router.routers).into_iter() {
        let req = Request { url: "fff".to_string(), ..Default::default() };
        _val(&req);
        println!("{}", key);
    }

    println!("routers: Size={}", router.routers.len());

}
]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="有效使用闭包" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
<div>
在 Java、C#、JavaScript 中常见的设计模式无法原封不动照搬到 Rust 里来。例如: <b>MVC (Model-View-Controller), </b>对于用户界面的每个元素，MVC框架都会创建三个对象: 模型、视图、控制器，其中<b>模型表示UI元素的状态</b>，<b>视图负责处理元素的外观</b>，<b>控制器处理用户交互</b>。
</div>
<div>
  <img style="max-width:100%" src="/images/rust/mvc-digram.png" />
</div>
<div style="margin-top:.325em;">
如上图所示: 通常每个对象都会有另一个或另外两个对象的引用。可能是直接引用，也可能是通过回调来引用。当三个对象中的一个发生了某个事件时，它会通知另外两个对象，因此一切立即更新。问题在于，哪个对象"拥有"其他对象则永远说不清。
</div>
<div style="margin-top:.325em;">
&hearts; 传统的MVC模式在未经修改的情况下无法在 Rust 中使用。在 Rust 中必须明确所有权，必须消除循环引用。模型和控制器之间不能直接互相引用。
</div>
<div style="margin-top:.325em;">
&hearts; Rust 的激进赌注就是一定存在优秀的设计。有时候可以让每个闭包接收它需要的引用作为参数，通过闭包所有权和生命周期来解决问题。
</div>
<div style="margin-top:.325em;">
&hearts; 有时候可以在系统中给每件东西分配一个数值，然后传递数值而不传递引用。或者，可以实现诸多MVC变体中的一种，保证对象之间并不是都互相引用。
</div>
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>迭代器 - Iterator </c:title>
    <c:desc>
      <c:desc1 style="line-height:1.6;"> <![CDATA[
<div>
  通过<b>"迭代器"</b>可以产生一系列的值，通常需要用循环来操作它。Rust 标准库提供了遍历向量、字符串、散列表、和其他集合的迭代器，也提供了从输入流、网络连接和线程间通信渠道产生的文本行的迭代器。
</div>
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Rust 迭代器非常灵活、擅长表达且高效率。
fn triangle(n: i32) -> i32 {
  let mut sum = 0;
  for i in 1 .. n+1 {
    sum += i;
  }
  sum
}

fn triangle_fold(n: i32) -> i32 {
  
  // 累计值从 0 开始
  // fold 取得 1..n+1 产生的每个值，
  // 把累加的值和当前值传给闭包 |sum, item| sum + item, 然后闭包的返回值又作为新的累加值
  // 最终返回的值就是 fold 自己的返回值
  (1 .. n+1).fold(0, |sum, item| sum + item)

  // ### Rust 会把上边这行代码编译为优化的机器码:
  // 1. Rust 知道 fold 的定义，会将其嵌入 triangle_fold 中
  // 2. 闭包 |sum, item| sum + item 也会嵌入其中 
  // 3. Rust 检查了组合后的代码, 发现有更简单的方式
  // 4. 最终 Rust 将其转换为1条乘法指令和几个算数运算: 
  // (n * (n + 1)) / 2

}

fn main() {
  println!("{}", triangle(199));
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="Iterator 和 IntoIterator" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Rust 迭代器迭代器指的是任何实现了 std::iter::Iterator 特型的值
trait Iterator {
  type Item;                                // 产生的值的类型
  fn next(&mut self) -> Option<Self::Item>;
  ...
}

// into_iter 接收一个值，然后基于这个值返回一个迭代器
// 任何实现 IntoIterator 的类型为"可迭代类型", 即可以在需要的时候通过循环来访问它
trait IntoIterator where Self::IntoIter::Item == Self::Item {
  type Item;                                // 产生的值的类型
  type IntoIter: Iterator;                  // 迭代器自身类型
  fn into_iter(self) -> Self::IntoIter;
}

fn main() {

  // Rust 的 for 循环实现了迭代器操作, 要迭代某个向量的元素可以这样写:
  let v = vec!["antimony", "arsenic", "aluminum", "selenium"];

  for element in &v {
    println!("{}", element);
  }

  // 在后台，每个 for 循环都只是对调用 IntoIterator 和 Iterator 方法的简写形式:
  let mut iterator = (&v).into_iter();

  while let Some(element) = iterator.next() {
    println!("{}", element);
  }

  println!("{:?}", v);
}

]]>
    </c:sourceContent>

    <c:sourceContent type="" title="iter 和 iter_mut 方法" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 大多数集合都提供了 iter 和 iter_mut 方法, 用于产生该类型的迭代器的共享和可修改引用。
// 每个类型都可以实现 iter 和 iter_mut, 适合什么实现方式由自己决定。
// std::path::Path 的 iter 就是一个迭代器的典型实现方式
// use std::ffi::OsStr;
use std::path::Path;

fn main () {
  
  let path = Path::new("/tmp/log.txt");
  let mut iterator = path.iter();

  while let Some(p) = iterator.next() {
    println!("{}", p.to_str().unwrap());
  }

}
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="IntoIterator 实现" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 如果类型实现了 IntoIterator, 则可以调用它的 into_iter 方法
// 对于"共享引用", into_iter 会返回产生迭代项"共享引用的迭代器": for element in &collection { ... }
// 对于"可修改引用", into_iter 会返回产生迭代项"可修改引用的迭代器": for element in &mut collection { ... }
// 对于"按值传递的集合", into_iter 返回的集合会取得集合的所有权: for element in collection { ... }
use std::collections::BTreeSet;

fn main() {

    let mut favorites = BTreeSet::new();

    favorites.insert("Liebestraume No. 3".to_string());
    favorites.insert("Lucy in the Sky With Diamonds".to_string());
    favorites.insert("5".to_string());
    favorites.insert("1".to_string());
    favorites.insert("2".to_string());
    favorites.insert("7".to_string());

    let mut it = (&favorites).into_iter();

    while let Some(f) = it.next() {
        println!("{}", f);
    }

    for f in (&favorites).into_iter() {
        println!("{}", f);
    }

    for f in (&favorites).into_iter() {
        println!("{}", f);
    }

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="IntoIterator 之泛型实现" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 打印任何可迭代类型
use std::fmt::Debug;

// 不能使用 iter 和 iter_mut 来实现这个泛型函数，因为他们不是任何特型的方法
// 大多数可迭代类型只是恰好有以这两个名字命名的方法而已
pub fn dump<T, U>(t: T) where T: IntoIterator<Item=U>, U: Debug {
  for u in t {
    println!("{:?}", u);
  }
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="drain 方法" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 很多集合类型都会提供 drain 方法, 以一个集合的可修改引用为参数, 返回一个能把每个元素所有权传给消费者的迭代器。
// 与按值接收并消费集合的 into_iter() 方法不同, drain 只是借用对集合的引用, 在迭代器被清除后, 它会清空集合中所有剩余的元素。
// 在可以通过范围指定索引的类型如 String、向量和 VecDeque 中, drain 方法接收要移除元素的值, 而不是提取(drain)整个序列
use std::iter::FromIterator;

fn main() {
  let mut outer = "Earth".to_string();
  let inner = String::from_iter(outer.drain(..)); // 如果使用全范围(..)作为参数, 则可以提取整个序列
  println!("{}", outer);
  println!("{}", inner);
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="其他迭代器源" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: right;padding-right:1em;" width="80">类型或特型</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">表达式</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">说明</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::ops::Range</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">1..10</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">端点必须是可以迭代的整数类型。范围包含起始值，不包含终止值。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::ops::RangeFrom</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">1..</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">无穷迭代，起始值必须是整数。如果值超过类型限制可能会诧异或溢出。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Option&lt;T&gt;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">Some(10).iter()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">类似长度为 0(None) 或 1(Some(v)) 的向量。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Result&lt;T, E&gt;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">Ok("blah").iter()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">类似 Option, 产生 Ok 值。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Vec&lt;T&gt;, &[T]</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.windows(16)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">从左到右产生给定长度的每个连续切片, 窗口重叠。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.chunks(16)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">从左到右产生给定长度的非重叠连续切片。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.chunks_mut(16)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">类似 chunks, 但切片是可修改的。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.split(|byte|byte & 1 != 0)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生以匹配给定断言的元素分割的切片。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.split_mut(|byte|byte & 1 != 0)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">类似 split，但产生可修改的切片。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.rsplit(|byte|byte & 1 != 0)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">类似 split，但从右到左产生切片。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v.splitn(n, ...)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">类似 split，但最多产生 n 个切片。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">String, &str</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">s.bytes()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生 UTF-8 形式的字节</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">s.chars()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生 UTF-8 形式的</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">s.split_whitespace()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">以空白字符分割字符</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">s.lines()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生字符串行的切片</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">s.split('/')</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">以给定的模式分割字符串，产生匹配之间内容的切片。模式可以是字符、字符串、闭包等。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">s.matches(char::is_numeric)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生匹配给定模式的切片。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::collections.HashMap, std::collections::BTreeMap</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">map.keys(), map.values()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生对映射键或值的共享引用。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">map.values_mut()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生对映值的可修改引用。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::collections.HashSet, std::collections::BTreeSet</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">set1.union(set2)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生2个集合元素的共享引用。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">set1.intersection(set2)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生2个集合交集的共享引用。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::sync::mpsc::Receiver</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">recv.iter()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生另一个线程中对应Sender发送的值。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::io.Read</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">stream.bytes()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">从I/O流产生字节。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">stream.chars()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">将流作为UTF-8解析并产生字符。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::io::BufRead</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">bufstream.lines()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">将流作为UTF-8解析并产生String行。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">bufstream.split(0)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">以给定字节分割流，产生该字节间的Vec&lt;u8&gt;缓冲</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::fs::ReadDir</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">std::fs::read_dir(path)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">读取目录项</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">std::net::TcpListener</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">listener.incoming()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">产生到来的网络连接。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Free functions</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">std::iter::empty()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">立即返回None</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">std::iter::once(5)</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">返回给定的值，然后结束。</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">std::iter::repeat("#9")</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">一直返回给定的值。</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 map 和 filter" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
  
  let text = " poies \n giraffes\niguanas \nsquid".to_string();

  let v: Vec<&str> = text.lines()                       // 不会真正从字符串中解析出任何行，只会返回一个迭代器，将来在根据需要解析
                         .map(str::trim)                // 在一个迭代器上调用适配器不会消费任何项，只会返回一个新的迭代器
                         .filter(|s| *s != "squid")
                         .collect();                    // 在 collect 调用 filter 迭代器的 next 之前，不会发生真正的操作

  println!("{:?}", v);

  // 迭代器适配器属于零开销抽象，因为 map、filter 及其同类方法是泛型的
  // 所以把它们应用给迭代器会针对涉及的特定迭代器类型优化它们的代码
  // 这意味着 Rust 有足够的信息把每个迭代器的 next 方法行内化到消费者中，
  // 然后将整套代码作为一个单位翻译为机器码
  
  // 以上基于适配器的代码“行内化”之后，类似于下边的样子: 

  let mut v: Vec<&str> = vec![]

  for line in text.lines() {
    let line = line.trim();
    if line != "squid" {
      v.push(line);
    }
  }

  println!("{:?}", v);

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 filter_map" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// map 适配器适合一个进项对应一个出项的场景。
// 有时候，可能需要在迭代中清除某些项，或者用零或多项替代一项。
// 此时 filter_map 和 flat_map 适配器可以满足要求。
use std::str::FromStr;

fn main() {
  let text = "1\nfrond .25 289 \n3.1415926 estuary\n";

  for number in text.split_whitespace().filter_map(|w|f64::from_str(w).ok()) {
    println!("{:.20}", number);
  }

  text.split_whitespace()
      .map(|w|f64::from_str(w))
      .filter(|r|r.is_ok())
      .map(|r|r.unwrap());

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 flat_map" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::collections::HashMap;

fn main() {

  let mut major_cities = HashMap::new();

  major_cities.insert("Japan", vec!["Tokyo", "Kyoto"]);
  major_cities.insert("The United States", vec!["Portland", "Nashville"]);
  major_cities.insert("Brazil", vec!["Sao Paulo", "Brasilia"]);
  major_cities.insert("Kenya", vec!["Nairobi", "Mombasa"]);
  major_cities.insert("The Netherlands", vec!["Amsterdam", "Utrecht"]);

  let countries = ["Japan", "Brazil", "Kenya"];

  // 传给 flat_map 的闭包必须返回一个可迭代类型
  // 别忘了: 只有 for 循环调用 flat_map 迭代器的 next 方法时才会实际发生操作
  //        -- 拼接完整的序列不会在内存中发生
  for &city in countries.iter().flat_map(|country| &major_cities[country]) {
    println!("{}", city)
  }

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 scan" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// scan 适配器类似于 map, 区别在于它会传给闭包一个可修改的值，而且可以选择提前终止迭代。
// 它接收一个初始状态值和一个闭包，闭包又接收一个对这个状态的可修改引用和底层迭代器的下一项。
// 这个闭包必须返回 Option, scan 适配器将其作为自己的下一项。
fn main() {
    
    // item 是底层迭代器的下一项。
    // sum 是迭代器闭包的私有变量的可修改引用, 在 scan 的第一个参数中初始化, 这里就是 0。
    let list: Vec<i32> = (0..10)
              .scan(0, |sum, item| {
                *sum += item;
                if *sum > 10 {
                  None
                } else {
                  Some(item * item)
                }
              }).collect();

    println!("{:?}", list);

    let iter = (0..10)
              .scan(0, |sum, item| {
                *sum += item;
                if *sum > 10 {
                  None
                } else {
                  Some(item * item)
                }
              });

    for i in iter {
        println!("{}", i);
    }

    let iter = (0..10)
              .scan(0, |sum, item| {
                *sum += item;
                if *sum > 10 {
                  None
                } else {
                  Some(item * item)
                }
              });

    let list = iter.collect::<Vec<i32>>();

    println!("{:?}", list);

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 take 和 take_while" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// take 适配器在产生最多n个后返回 None。
// take_while 适配器对每一项应用 predicate(条件), 在遇到第一个 predicate 是 false 的项时返回 None, 后续每次调用 next 也都返回 None。
// 这2个适配器都会取得一个迭代器的所有权，并返回一个新的迭代器，这个新的迭代器会从第一项开始产生值。
fn main() {
   
  let messages = "To: jimb\r\n\
                  From: superego <editor@oreilly.com>\r\n\
                  \r\n\
                  Did you get any writing done today?\r\n\
                  When will you stop wasting time plotting fractals?\r\n";

  for header in messages.lines().take_while(|l| !l.is_empty()) {
    println!("{}", header);
  }

  println!("{}", messages);

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 skip 和 skip_while" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// skip 适配器在清除n个后开始返回。
// skip_while 适配器对每一项应用 predicate(条件), 在遇到第一个 predicate 是 false 时开始返回项, 然后将剩余的项原封不动的返回。
// 这2个适配器都会取得一个迭代器的所有权，并返回一个新的迭代器，这个新的迭代器会从第一项开始产生值。
fn main() {
   
  for arg in std::env::args().skip(i) {
    println!("{}", arg);
  }

  // 取得邮件正文
  for body in messages.lines().skip_while(|l| !l.is_empty()).skip(1) {
    println!("{}", body)
  }

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 peekable" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 让代码在不消费下一项的情况下探测下一项, 调用这个方法可以将几乎任何迭代器转换为可探测的迭代器。
// 1. Peekable 适配器有一个 peek 方法, 该方法返回 Option<&Item>:
//    -- 如果底层迭代器终止就返回 None, 否则返回 Some(r), 其中 r 是下一项的共享引用。
//    -- (注意: 如果迭代器的项类型已经是某个值的引用, 那 r 就是引用的引用)
// 2. 调用 peek 会尝试从底层迭代器取出下一项，如果取到了，就将其缓存到下一次调用 next:
//    -- Peekable 上的其他 Iterator 方法都知道这个缓存。
//    -- 例如可以探测迭代器 iter 上的 iter.last() 在耗尽底层迭代器之后知道检查缓存。
//    -- 如果一开始并不知道要消费某个迭代器有多少项，直到消费过程中才了解，那么探测迭代器是非常必要的。
//    -- 例如: 要从一个字符流中解析数值，在发现其后面第一个非数值字符之前无法确定数值是否结束。
use std::iter::Peekable;

fn parse_number<I>(tokens: &mut Peekable<I>) -> u32 where I: Iterator<Item=char> {
  
  let mut n = 0;

  loop {

    match tokens.peek() {
      Some(r) if r.is_digit(10) => {
        n = n * 10 + r.to_digit(10).unwrap();
      }
      _ => return n
    }

    tokens.next();      // 不是数字, 留在迭代器中
  }

}

fn main() {
  
  let mut chars = "226153980,1766319049,-1".chars().peekable();

  println!("{}", parse_number(&mut chars));
  println!("{:?}", chars.next());             // parse_number 没有消费逗号！因此需要手工消费掉
  println!("{}", parse_number(&mut chars));
  println!("{:?}", chars.next());  
  println!("{:?}", chars.next());  
  println!("{}", parse_number(&mut chars));

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 fuse" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 该适配器可以将任何适配器转换为第一次返回 None 之后始终继续返回 None 的迭代器
// fuse 适配器最适合需要处理不确定来源迭代器的泛型代码。这时候不用假设所有迭代器行为一致，可以使用 fuse 确保这一点。
use std::iter::Iterator;

pub struct Flaky(bool);

impl Iterator for Flaky {
  
  type Item = &'static str;   // '

  fn next(&mut self) -> Option<Self::Item> {

    if self.0 {
      self.0 = false;
      Some("totally the last item")
    } else {
      self.0 = true;          // 在来!
      None
    }

  }

}

fn main() {
  
  let mut flaky = Flaky(true);

  println!("{:?}", flaky.next());       // totally the last item
  println!("{:?}", flaky.next());       // None
  println!("{:?}", flaky.next());       // totally the last item

  let mut not_flaky = Flaky(true).fuse();
  
  println!("{:?}", not_flaky.next());       // totally the last item
  println!("{:?}", not_flaky.next());       // None
  println!("{:?}", not_flaky.next());       // None

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="可逆迭代器与 rev" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 有些迭代器可以从顺序两端取得，可以使用 rev 适配器反转这种迭代器
// 并不是所有迭代器都可以实现双向迭代器，要查询标准库文档来确定一个迭代器是否实现了 DoubleEndedIterator
use std::iter::DoubleEndedIterator;

fn main() {

  let bee_parts = ["head", "thorax", "abdomen"];

  // let mut iter = bee_parts.iter();
  // while let Some(r) = iter.next_back() {
  //     println!("{}", r);
  // }

  let mut iter = bee_parts.iter().rev();
  while let Some(r) = iter.next() {
      println!("{}", r);
  }

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 inspect" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 用于迭代器适配管道的调试
fn main() {
    let upper_case: String = "groSe"
        .chars()
        .inspect(|c| print!("Before: {:?}\t", c))
        .flat_map(|c| c.to_uppercase())
        .inspect(|c| println!("After: {:?}", c))
        .collect();
    println!("{}", upper_case);
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 chain" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
    // 将一个迭代器添加到另一个迭代器的后面
    let v: Vec<i32> = (1..4).chain(vec![20, 30, 40]).collect();
    println!("{:?}", v)
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 enumerate" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Iterator 的 enumerate 适配器可以向序列中添加连续的索引
// 例如: A,B,C ... 的迭代器, 其返回的迭代器则产生 (0,A), (1,B), (2,C) ...
fn main() {
    let columns = 4;
    let rows = 900;

    let mut pixels = vec![0; columns * rows];

    let threads = 8;
    let band_rows = rows / threads + 1;

    let bands: Vec<&mut [u8]> = pixels.chunks_mut(band_rows * columns).collect();

    for (i, _) in bands.into_iter().enumerate() {
        let top = band_rows * i;
        // 启动一个线程渲染 top .. top + band_rows
        println!("i:{}, from:{}, to:{}", i, top, top + band_rows);
    }
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 zip" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 将2个适配器组合为一个适配器, 就像拉链一样把分开的两边粘到一起。
// 可以把 zip 看成是通用的 enumerate, enumerate 只能给其他序列添加索引, 而 zip 可以添加任何迭代项。
use std::iter::repeat;

fn main() {

  let v: Vec<_> = (0..).zip("ABCD".chars()).collect();
  println!("{:?}", v);

  let endings = vec!["once", "twice", "chicken soup with rice"];
  let rhyme: Vec<_> = repeat("going").zip(endings).collect();

  println!("{:?}", rhyme);

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 by_ref" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 把适配器应用到迭代器之后还能在取消适配器么? 通常不能!!
// 因为适配器会取得底层迭代器的所有权，没办法在退回去了!!
// 迭代器的 by_ref 方法可以借用迭代器的一个可修改引用，以便我们能够把适配器应用给这个引用。
// 在通过适配器消费完迭代器的项之后，借用结束，恢复对原始迭代器的访问。

// ### by_ref 适配器的定义
// I 是某种迭代器的类型, 那么 &mut I 也是迭代器, 其 next 和 size_hint 方法会解引用到它的引用值。
// 在对迭代器的可修改引用调用适配器时，适配器取得引用而非迭代器本身的所有权。
impl<'a, I: Iterator + ?Sized> Iterator for &'a mut I {
  
  type Item = I::Item;

  fn next(&mut self) -> Option<I::Item> {
    (**self).next()
  }

  fn size_hint(&self) -> (usize, Option<usize>) {
    (**self).sized_hint()
  }

}

// ### 重写之前的读取邮件正文的例子
fn main() {
    let messages = "To: jimb\r\n\
                  From: superego <editor@oreilly.com>\r\n\
                  \r\n\
                  Did you get any writing done today?\r\n\
                  When will you stop wasting time plotting fractals?\r\n";

    let mut lines_iter = messages.lines();

    for header in lines_iter.by_ref().take_while(|l| !l.is_empty()) {
        println!("{}", header);
    }

    println!("-----");

    for body in lines_iter {
        println!("{}", body);
    }
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 cloned" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
    // 该适配器将一个产生引用的迭代器转换为产生基于引用克隆的值的迭代器
    let a = ["1", "2", "3", "4"];

    assert_eq!(a.iter().next(), Some(&"1"));
    assert_eq!(a.iter().cloned().next(), Some("1"));

    println!("{:?}", a.iter().next());
    println!("{:?}", a.iter().cloned().next());
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="迭代器适配器之 cycle" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 该适配器返回一个无休止重复底层迭代器的迭代器, 
// 底层迭代器必须实现 std::clone::Clone, 以便 cycle 可以保存其初始状态并在每次循环开始时重用
fn main() {
  let dirs = ["North", "East", "South", "West"];
  let mut spin = dirs.iter().cycle();

  for s in spin {
    println!("{}", s);
  }
}

// 一个小孩子的文字游戏, 用"fizz"替换可以被3整除的数, 用"buzz"替换可以被5整除的数, 可以被二者整除的数就会得到"fizzbuzz"
use std::iter::{once, repeat};

fn main() {

    let fizzes = repeat("").take(2).chain(once("fizz")).cycle();
    let buzzes = repeat("").take(4).chain(once("buzz")).cycle();

    let fizzes_buzzes = fizzes.zip(buzzes);

    let fizz_buzz = (1..100).zip(fizzes_buzzes).map(|t| match t {
        (i, ("", "")) => format!("{} -", i),
        (i, (fizz, buzz)) => format!("{} - {}{}", i, fizz, buzz),
    });

    for s in fizz_buzz {
        println!("{}", s);
    }
    
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 count、sum、product、max、min" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::io::prelude::*;

pub fn triangle(n: u64) -> u64 {
    (1..n + 1).sum()
}

pub fn factorial(n: u64) -> u64 {
    (1..n + 1).product()
}

pub fn counts(n: u64) -> usize {
    (1..n + 1).count()
}

fn main() {
    println!("{}", triangle(20));
    println!("{}", factorial(20));
    println!("{}", counts(20));
    // let stdin = std::io::stdin();
    // println!("{}", stdin.lock().lines().count());
    println!("{}", [1,3,4,5,6,8,24,67,23,76,3545].iter().max().unwrap());
    println!("{}", [1,3,4,5,6,8,24,67,23,76,3545].iter().min().unwrap());
    println!("{}", ['A','C'].iter().min().unwrap());
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 max_by、min_by" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::cmp::{Ordering, PartialOrd};

fn cmp(lhs: &&f64, rhs: &&f64) -> Ordering {
    lhs.partial_cmp(rhs).unwrap()
}

fn main() {

    let numbers = [1.0, 2.0, 4.0, 3.0];
    let numbers2 = [1.0, 2.0, 4.0, 3.0, std::f64::NAN];

    println!("{}", numbers.iter().max_by(cmp).unwrap());
    println!("{}", numbers.iter().min_by(cmp).unwrap());
    println!("{}", numbers2.iter().min_by(cmp).unwrap());     // 诧异

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 max_by_key、min_by_key" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::collections::HashMap;

fn main() {
  
  let mut populations = HashMap::new();

  populations.insert("Portland", 583_776);
  populations.insert("Fossil", 449);
  populations.insert("Greenhorn", 2);
  populations.insert("Boring", 7762);
  populations.insert("The Dalles", 15340);

  // 线性搜索，效率很低，可以有更高效的方式
  println!("{:?}", populations.iter().max_by_key(|&(_key, _val)| _val).unwrap());
  println!("{:?}", populations.iter().min_by_key(|&(_key, _val)| _val).unwrap());

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 any、all" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
    let id = "Iterator";
    println!("{:?}", id.chars().any(char::is_uppercase));     // 任何一项符合条件，返回 true
    println!("{:?}", id.chars().all(char::is_lowercase));     // 所有项符合条件，返回 true
}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 position、rpositon、ExactSizeIterator" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
    
    let text = "Xerxes";
    println!("{:?}", text.chars().position(|c| c == 'e'));
    println!("{:?}", text.chars().position(|c| c == 'z'));

    // rposition 要求使用可逆迭代器，且迭代器大小固定
    // "固定大小迭代器"是指实现了 std::iter::ExactSizeIterator 特型的迭代器
    let bytes = b"Xerxes";
    println!("{:?}", bytes.iter().rposition(|&c| c == b'e'));   
    println!("{:?}", bytes.iter().rposition(|&c| c == b'z'));

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 fold" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// fold 可以对迭代器产生的整个序列执行某些累计操作。
// 这个方法接收一个名为"累计器"的初始值和一个闭包, 然后对当前累计器和迭代器的下一项重复应用闭包。
fn main() {

    let a = [5, 6, 7, 8, 8, 34, 23, 7, 3];
    
    println!("{}", a.iter().fold(0, |a, _| a + 1)); // count
    println!("{}", a.iter().fold(0, |a, i| a + i)); // sum

    let a = [
        "Pack", " my", " box", " with", " five", " dozen", " liquor", " jugs", ".",
    ];

    let pangram = a.iter().fold(String::new(), |mut s, &w| {
        s.push_str(w);
        s
    });

    println!("{}", pangram);
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 nth、last，find" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
    let mut squares = (0..10).map(|m| m);
    println!("{:?}", squares.nth(0));                 // 等同于调用 .next()
    println!("{:?}", squares.find(|i| i > &3));       // 取出第一个返回 true 的值
    println!("{:?}", squares.find(|i| i > &5));
    // println!("{:?}", squares.by_ref().last());     // 消费迭代器的所有项, 并返回最后1项
    println!("{:?}", squares.by_ref().rev().next());  // 反转迭代器并返回下一项, 即最后一项
    println!("{:?}", squares.by_ref().rev().next()); 
}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="构建集合之 collect、FromIterator" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::collections::{ HashSet, BTreeSet, LinkedList, HashMap, BTreeMap };

fn main() {
  
  // collect() 只是一个快捷方式, 底层依赖 std::iter::FromIterator 特型
  let args                        = std::env::args().collect::<HashSet<String>>();
  let args                        = std::env::args().collect::<BTreeSet<String>>();
  let args                        = std::env::args().collect::<LinkedList<String>>();

  let args: HashSet<String>       = std::env::args().collect();
  let args: BTreeSet<String>      = std::env::args().collect();
  let args: LinkedList<String>    = std::env::args().collect();

  let args: HashMap<String, usize>  = std::env::args().zip(0..).collect();
  let args: BTreeMap<String, usize> = std::env::args().zip(0..).collect();

}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="消费迭代器之 nth、last，find" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn main() {
    let mut squares = (0..10).map(|m| m);
    println!("{:?}", squares.nth(0));                 // 等同于调用 .next()
    println!("{:?}", squares.find(|i| i > &3));       // 取出第一个返回 true 的值
    println!("{:?}", squares.find(|i| i > &5));
    // println!("{:?}", squares.by_ref().last());     // 消费迭代器的所有项, 并返回最后1项
    println!("{:?}", squares.by_ref().rev().next());  // 反转迭代器并返回下一项, 即最后一项
    println!("{:?}", squares.by_ref().rev().next()); 
}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Extend 特型" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 可以将一个迭代器的项添加到集合中
fn main() {
    let mut v: Vec<i32> = (0..5).collect();
    v.extend(&[31, 33, 45, 32, 65]);
    println!("{:?}", v);
}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="partition" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 把一个迭代器的项分成两个集合, 使用闭包决定哪一项属于哪个集合
fn main() {
    let things = ["doorknob", "mushroom", "noodle", "giraffe", "grapefurit"];
    // 凡事有生命的其名字的首字母始终是奇数个字母
    let (living, nonliving): (Vec<&str>, Vec<&str>) =
        things.iter().partition(|name| name.as_bytes()[0] & 1 != 0);
    println!("{:?}, {:?}", living, nonliving);
}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="实现自己的迭代器" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
[dependencies]
serde = { version = "1.0.152", features = ["derive"] }
serde_json = "1.0.93"

// 为二叉树实现迭代器方法
use serde::Serialize;
use self::BinaryTree::*;

/// T类型值的有序集合
#[derive(Debug, Serialize)]
pub enum BinaryTree<T> {
  Empty, 
  NonEmpty(Box<TreeNode<T>>)    // 一个指向位于堆内存的 TreeNode 的指针
}

/// 用于表示二叉树的节点
#[derive(Debug, Serialize)]
pub struct TreeNode<T> {
  pub element: T, 
  pub left: BinaryTree<T>,
  pub right: BinaryTree<T>
} 

// 给 BinaryTree 定义一个 iter 方法, 返回二叉树的迭代器
impl<T> BinaryTree<T> {
  
  // 根据给定的值，创建新的二叉树节点
  fn make_node(value: T, left: BinaryTree<T>, right: BinaryTree<T>) -> BinaryTree<T> {
    NonEmpty(Box::new(TreeNode{ element: value, left: left, right: right }))
  }

  fn iter(&self) -> TreeIter<T> {
    let mut iter = TreeIter{unvisited: Vec::new()};
    iter.push_left_edge(self);
    iter
  }

}

impl<T: Ord> BinaryTree<T> {

  pub fn add(&mut self, value: T) {

    match *self {
      // Empty => *self = NonEmpty(Box::new(TreeNode{ element: value, left: Empty, right: Empty })),
      Empty => *self = BinaryTree::make_node(value, Empty, Empty),
      NonEmpty(ref mut node) => {
        if value <= node.element {
          node.left.add(value);
        } else {
          node.right.add(value);
        }
      }
    }

  }

}

// BinaryTree 的按序遍历状态
pub struct TreeIter<'a, T: 'a> {
  // 树节点引用的栈, 因为使用的是 Vec 的 push 和 pop 方法, 所以栈顶是向量的末尾
  // 节点迭代器将从栈顶取得下一个值, 未访问的祖先节点在下边, 如果该栈空了，则迭代结束
  unvisited: Vec<&'a TreeNode<T>>       // '
}

impl<'a, T: 'a> TreeIter<'a, T> {       // '
  
  // 常见的操作是先将树左边的节点推到栈里, 为此, 在迭代器上定义这么个一个方法
  fn push_left_edge(&mut self, mut tree: &'a BinaryTree<T>) {  // '

    while let NonEmpty(ref node) = *tree {
      self.unvisited.push(node);              // 最左边的节点在栈的上边
      tree = &node.left;
    }
  }

}

// 接下来在树的共享引用上实现 IntoIterator, 调用 BinaryTree::iter 返回迭代器
impl<'a, T: 'a> IntoIterator for &'a BinaryTree<T> {      // 'a
    
    type Item = &'a T;                  // '
    // 这个 IntoIter 定义将 TreeIter 作为 &BinaryTree 的迭代器类型
    type IntoIter = TreeIter<'a, T>;    // ' 

    fn into_iter(self) -> Self::IntoIter {
      self.iter()
    }

}

// 实际遍历树
impl<'a, T> Iterator for TreeIter<'a, T> {
  
  type Item = &'a T;                        // '

  fn next(&mut self) -> Option<&'a T> {     // '

    // 查找迭代必须产生的节点, 或者结束迭代
    let node = match self.unvisited.pop() {
      None => return None,
      Some(n) => n
    };

    // 当前节点后面的下一个节点是当前节点右子节点的最左子节点, 因此把它推进栈里
    self.push_left_edge(&node.right);

    // 产生对节点值的引用

    Some(&node.element)

  }

}

fn main() {
  
  let mercury_tree  = BinaryTree::make_node("Mercury", Empty, Empty); 
  let jupiter_tree  = BinaryTree::make_node("Juptiter", Empty, Empty);
  let mars_tree     = BinaryTree::make_node("Mars", jupiter_tree, mercury_tree);
  let venus_tree    = BinaryTree::make_node("Venus", Empty, Empty);
  let uranus_tree   = BinaryTree::make_node("Uranus", Empty, venus_tree);
  let mut saturn_tree   = BinaryTree::make_node("Saturn", mars_tree, uranus_tree);

  saturn_tree.add("Abc");
  saturn_tree.add("Zip");
  saturn_tree.add("Mars");
  saturn_tree.add("Saturn");

  for (i, item) in (0..).zip(&saturn_tree) {
      println!("{}: {}", i, item);
  }

  println!("-------");

  let mut tree = BinaryTree::Empty;

  tree.add(8);
  tree.add(9);
  tree.add(6);
  tree.add(2);
  tree.add(6);
  tree.add(11);
  tree.add(1);

  println!("print2: {}", serde_json::to_string(&tree).unwrap());

}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>集合</c:title>
    <c:desc>
      <c:desc1 style="line-height:1.6;"> <![CDATA[

]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th rowspan="2" style="margin: 0;text-align: right;padding-right:1em;" width="360">集合</th>
            <th rowspan="2" style="margin: 0;text-align: left;padding-left:1em;">说明</th>
            <th colspan="3" style="margin: 0;text-align: left;padding-left:1em;">其他语言中类似的集合</th>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: left;padding-left:1em;">C++</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">Java</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">Python</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">Vec&lt;T&gt;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">长度可变的向量</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">vector</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">ArrayList</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">list</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">VecDeque&lt;T&gt;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">双端队列，可增长环形缓冲区</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">deque</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">ArrayDeque</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">collections.deque</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">LinkedList&lt;T&gt;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">双向链表</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">list</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">LinkedList</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">BinaryHeap&lt;K, V&gt; where K: Eq + Hash</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">最大堆</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">priority_queue</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">PriorityQueue</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">heapq</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">HashMap&lt;K, V&gt; where K: Eq + Hash</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">键 - 值散列表</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">unordered_map</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">HashMap</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">dict</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">BTreeMap&lt;K, V&gt; where K: Ord</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">有序键 - 值表</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">map</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">TreeMap</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">HashSet&lt;T&gt; where T: Eq + Hash</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">散列表</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">unordered_set</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">HashSet</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">set</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">BTreeSet&lt;T&gt; where T: Ord</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">有序集合</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">set</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">TreeSet</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="切片拆分方法示意图" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/slice_split.png" />
</div>
]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>字符串和文本</c:title>
    <c:desc>
      <c:desc1 style="line-height:1.6;"> <![CDATA[

]]></c:desc1>
    </c:desc>

    <c:sourceContent type="html" title="UTF-8" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
....
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="检测字符类别的方法" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: right;padding-right:1em;" width="260">方法</th>
            <th style="margin: 0;text-align: left;padding-left:1em;" width="260">简介</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">示例</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">ch.is_numeric()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">是否是数字</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">'4'.is_numeric()</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">ch.is_alphabetic()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">是否是字母</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">'a'.alphabetic()</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">ch.is_alphanumeric()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">字母或数字</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">'4'.is_alphanumeric(), <br />'a'.alphabetic()</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">ch.is_whitespace()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">空白字符</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">' '.is_whitespace(), <br />'\n'.is_whitespace(), <br />'\u{A0}'.is_whitespace()</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">ch.is_control()</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">控制字符</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">'\n'.is_whitespace(), <br />'\u{85}'.is_whitespace()</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>

    <c:sourceContent type="" title="阻止分配" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::borrow::Cow;

fn get_name() -> String {
    std::env::var("USER1").unwrap_or("whoever you are".to_string())
}

// Clone-on-Write
fn get_name2() -> Cow<'static, str> {     // '
    // 具体是哪种类型，之后到运行时才知道
    std::env::var("USER2") // 类型是所有型的 String
        .map(|v| Cow::Owned(v))
        .unwrap_or(Cow::Borrowed("whoever you are2")) // 类型是 &'static str', 在返回静态字符串时，不应该有内存分配
}

fn get_title() -> Option<&'static str> {  // '
    Some("my title")
}

fn main() {

    let mut name = get_name2();

    if let Some(t) = get_title() {
        name.to_mut().push_str(", ");
        name.to_mut().push_str(t);
    }

    println!("{}", get_name());
    println!("{}", name);
    
}

]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="格式化值的例子" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: right;padding-right:1em;" width="320">字符串模版</th>
            <th style="margin: 0;text-align: left;padding-left:1em;" width="260">参数</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">结果</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">"number of {}: {}"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"elephants", 19</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">number of <b>elephants</b>: <b>19</b></td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">"from {1} to {0}"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"the grave", "the cradle"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">from <b>the grave</b> to <b>the cradle</b></td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">"v = {:?}"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">vec![0,1,43,6,76,39]</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">v = <b>[0,1,43,6,76,39]</b></td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">"name = {:?}"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"Nemo"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"name = \"Nemo"\"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">"{:8.2} km/s"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">11.186</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">&nbsp;&nbsp;&nbsp;11.19 km/s</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">包含小数点总长度是8,小数部分长度是2</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">"{:10}, {:02x}, {:02x}"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">"adc#42",105,42</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">adc#42&nbsp;&nbsp;&nbsp;&nbsp;, 69, 2a</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">"{1:02x}, {2:02x}, {0:10}."</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">"adc#42",105,42</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">69, 2a, adc#42&nbsp;&nbsp;&nbsp;&nbsp;.</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">"{lsb:02x}, {msb:02x}, {insn}."</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">insn="adc#42",lsb=105,msb=42</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">69, 2a, adc#42.</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;vertical-align: top;">"{:p}"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">&345.0</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;vertical-align: top;">0x10a8f4250</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">输出内存地址</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="格式化文本值" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: right;padding-right:1em;" width="320">使用的特型</th>
            <th style="margin: 0;text-align: left;padding-left:1em;" width="260">模版字符串</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">结果</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">默认</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">最小字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:4}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends&nbsp;&nbsp;&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">文本长度限制</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:.4}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"book"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:.12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">字段宽度及长度限制</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12.20}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends&nbsp;&nbsp;&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:4.20}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:4.6}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"booken"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:6.4}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"book&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">左对齐，字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:<12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"bookends&nbsp;&nbsp;&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">局中对齐，字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:^12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;bookends&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">右对齐，字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:>12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;bookends"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">填充=，局中对齐，字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:=^12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"==bookends=="</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">填充*，右对齐，字段宽度，长度限制</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:*>12.4}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"********book"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="格式化整数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: right;padding-right:1em;" width="320">使用的特型</th>
            <th style="margin: 0;text-align: left;padding-left:1em;" width="260">模版字符串</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">结果</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">默认</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">强制符号</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"+1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>

        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">最小字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:2}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">符号，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">前置0，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:012}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">符号，前置0，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+012}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"+00000001234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">左对齐，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:<12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">右对齐，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:>12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">左对齐，符号，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:<+12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"+1234&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">剧中，符号，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:^+12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;+1234&nbsp;&nbsp;&nbsp;&nbsp;"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">右对齐，符号，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:>+12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+1234"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">填充=，剧中，宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:=^12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"====1234===="</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">二进制计数法</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:b}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"10011010010"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">宽度，八进制计数法</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12o}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2322"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">符号，宽度，十六进制计数法</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+12x}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+4d2"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">符号，宽度，大写十六进制计数法</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+12X}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+4D2"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">符号，基数前缀，宽度，十六进制</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+#12x}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+0x4d2"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">符号，基数，补0，宽度，十六进制</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+#012x}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"+0x0000004d2"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">-</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:+#06x}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"+0x4d2"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="格式化浮点数" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[

<table style="margin:.5em 0;line-height:1.425em;width:100%;font-size:.925em;">
    <thead>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-style: dashed;
          border-top: solid 1px black;border-style: dashed;">
            <th style="margin: 0;text-align: right;padding-right:1em;" width="320">使用的特型</th>
            <th style="margin: 0;text-align: left;padding-left:1em;" width="260">模版字符串</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">结果</th>
            <th style="margin: 0;text-align: left;padding-left:1em;">描述</th>
        </tr>
    </thead>
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">默认</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1234.5678"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">精度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:.2}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1234.57"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">-</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:.7}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1234.5678000"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">最小字段宽度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:.12}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;1234.5678"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">宽度，精度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12.2}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1234.57"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">&nbsp;</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12.6}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;1234.567800"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">前置0，宽度，精度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:012.6}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"01234.567800"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">科学计数法</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:e}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1.2345678e3"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">科学计数法，精度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:.3e}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"1.235e3"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">科学计数法，宽度，精度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12.3e}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.235e3"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px black;border-top: solid 1px black;border-style: dashed;">
            <td style="margin:0;text-align:right;padding:.5em 1em;">科学计数法，宽度，精度</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">{:12.3E}</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1.235E3"</td>
            <td style="margin:0;text-align:left;padding:.5em 1em;">-</td>
        </tr>
    </tbody>
</table>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="正则表达式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
$ cargo add regex
// regex 值表示解析之后的正则表达式
use regex::Regex;

fn main() {
    
    // semver 版本号, 比如: 0.2.1
    let semver = Regex::new(r"(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?").unwrap();
    let haystack = r#"regex = "0.12.50"#;
    let captures = semver.captures(haystack).unwrap();
    println!("is_match: {}", semver.is_match(haystack));
    println!("captures[0]: {}", &captures[0]);
    println!("captures[1]: {}", &captures[1]);
    println!("captures[2]: {}", &captures[2]);
    println!("captures[3]: {}", &captures[3]);

    println!("{:>30}: {}", "captures.get(3)", captures.get(3).unwrap().as_str());
    println!("{:>30}: {}", "captures.get(3).start()", captures.get(3).unwrap().start());
    println!("{:>30}: {}", "captures.get(3).end()", captures.get(3).unwrap().end());
    println!("{:>30}: {:?}", "captures.get(4)", captures.get(4));

    let haystack = "In the beginning, there was 1.0.0 \
                    For a while, we used 1.0.1-beta \
                    but in the end, we settled on 1.2.4";

    let _matchs: Vec<&str> = semver
        .find_iter(haystack)
        .map(|_match| _match.as_str())
        .collect();

    println!("{:?}", _matchs);

}

]]>
    </c:sourceContent>
    <c:sourceContent type="" title="正则表达式 - 懒构建 Regex 值" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// lazy_static 包提供了首次使用时懒构建静态值的优雅方式
$ cargo add lazy_static
#[macro_use] extern crate lazy_static;

use regex::Regex;

// 第一次用到的时候在构建
lazy_static! {
    static ref SEMVER: Regex =
        Regex::new(r"(\d+)\.(\d+)\.(\d+)(-[-.[:alnum:]]*)?").expect("error parsing regex");
}

fn main() {
    // semver 版本号, 比如: 0.2.1
    let haystack = r#"regex = "0.12.50"#;
    let captures = SEMVER.captures(haystack).unwrap();

    println!("is_match: {}", SEMVER.is_match(haystack));
    println!("captures[0]: {}", &captures[0]);
    println!("captures[1]: {}", &captures[1]);
    println!("captures[2]: {}", &captures[2]);
    println!("captures[3]: {}", &captures[3]);

    println!(
        "{:>30}: {}",
        "captures.get(3)",
        captures.get(3).unwrap().as_str()
    );
    println!(
        "{:>30}: {}",
        "captures.get(3).start()",
        captures.get(3).unwrap().start()
    );
    println!(
        "{:>30}: {}",
        "captures.get(3).end()",
        captures.get(3).unwrap().end()
    );
    println!("{:>30}: {:?}", "captures.get(4)", captures.get(4));

    let haystack = "In the beginning, there was 1.0.0 \
                    For a while, we used 1.0.1-beta \
                    but in the end, we settled on 1.2.4";

    let _matchs: Vec<&str> = SEMVER
        .find_iter(haystack)
        .map(|_match| _match.as_str())
        .collect();

    println!("{:?}", _matchs);

}
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>输入和输出</c:title>
    <c:desc>
      <c:desc1 style="line-height:1.6;font-size:1.1em;"> <![CDATA[
Rust 标准库针对输入和输出的特型是通过 3 个特型，即: Read, BufRead, Write
]]></c:desc1>
    </c:desc>

    <c:sourceContent type="" title="从任何读取器将全部字节复制到任何写入器" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 关键字 self 在这里将 io 声明为 std::io 模块的别名
// 1. std::io::Result 可以写成 io::Result
// 2. std::io::Error 可以写成 io::Error
use std::io::{self, ErrorKind, Read, Write};

const DEFAULT_BUF_SIZE: usize = 8 * 1024;

// 1. 可以将数据从 File 复制到 TcpStream
// 2. 从 stdin 复制到内存中的 Vec<u8>
// 3. etc.
// 4. 返回类型是 io::Result<u64>, 这是 io::Result<u64, io::Error> 的类型别名
pub fn copy<R, W>(reader: &mut R, writer: &mut W) -> io::Result<u64>
where
    R: ?Sized + Read,
    W: ?Sized + Write,
{
    let mut buf = [0; DEFAULT_BUF_SIZE];
    let mut written = 0;

    loop {
        let len = match reader.read(&mut buf) {
            Ok(0) => return Ok(written),
            Ok(readed_len) => readed_len,
            // ErrorKind::Interrupted: 对应 Unix 错误码 EINTR, 意思是读取操作被某个信号中断了，此时应该重试
            Err(ref e) if e.kind() == ErrorKind::Interrupted => continue,
            Err(e) => return Err(e),
        };

        writer.write_all(&buf[..len])?;
        written += len as u64;
    }
}

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="读取器" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.625em;list-style-type:decimal;">
  <li><b>reader.read(&mut buffer)</b> 从数据源读取某些字节，然后存储到传如的 buffer 中。buffer 的类型是 &mut [u8], 读取的字节数就是 buffer 的长度。</li>
  <li><b>reader.read_to_end(&mut byte_vec)</b> 从读取器中读出所有剩余输入，并追加到 byte_vec 中。这个方法对添加到向量中的数据量没有限制，因此不要对不可信数据源使用它</li>
  <li><b>reader.read_to_string(&mut data_string)</b> 从读取器中读出所有剩余输入，并追加到给定的 String。如果输入流不是有效的 UTF-8。这个方法会返回 ErrorKind::InvalidData 错误。</li>
  <li><b>reader.read_exact(&mut buf)</b> 读取恰好足够的数据填充到给定的 buffer 中。这个参数类型是 &[u8]。如果读取器在读取到 buf.len() 字节前已经把数据读完了，这个方法会返回 ErrorKind::UnexceptedEof 错误。</li>
</ul>

<div style="margin-top: 1em;">
  没有关闭读取器的方法，读取器和写入器通常都会实现 Drop, 因而会自动关闭。
</div>

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="读取器缓冲器" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<div>
  为提高效率，读取器和写入器可以缓冲起来。所谓<b>"缓冲"</b>，简单来说就是给读取器和写入器一块内存(缓冲区), 用来暂时保存输入和输出数据。缓冲可以减少系统调用。
</div>


]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

</c:component>
