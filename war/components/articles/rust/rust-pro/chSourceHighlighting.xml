<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div style="margin-bottom:1em;">
  Rust是一门系统编程语言，专注于安全，尤其是并发安全，支持函数式和命令式以及泛型等编程范式的多范式语言。Rust在语法上和C++类似，但是设计者想要在保证性能的同时提供更好的内存安全。 Rust最初是由Mozilla研究院的Graydon Hoare设计创造，然后在Dave Herman, Brendan Eich以及很多其他人的贡献下逐步完善的。Rust的设计者们通过在研发Servo网站浏览器布局引擎过程中积累的经验优化了Rust语言和Rust编译器。
</div>

<div style="margin-bottom:1em;">
  Rust编译器是在MIT License 和 Apache License 2.0双重协议声明下的免费开源软件。Rust已经连续七年（2016，2017，2018，2019，2020, 2021, 2022）在Stack Overflow开发者调查的“最受喜爱编程语言”评选项目中折取桂冠。
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>日常开发常用Rust库</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Web/HTTP" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>HTTP客户端</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/seanmonstar/reqwest">reqwest</a> 一个简单又强大的 HTTP 客户端，reqwest 是目前使用最多的 HTTP 库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Web框架</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/axum">axum</a> 基于 Tokio 和 Hyper 打造，模块化设计较好，目前口碑很好，值得使用 Ergonomic and modular web framework built with Tokio, Tower, and Hyper</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/SergioBenitez/Rocket">Rocket</a> 功能强大，API 简单的 Web 框架，但是主要开发者目前因为个人原因无法进行后续开发，未来存在不确定性</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/actix/actix-web">actix-web</a> 性能极高的 Web 框架，就是团队内部有些问题，未来存在一定的不确定性</li>
      <li style="margin-top:.325em;">总体来说，上述三个 web 框架都有很深的用户基础，其实都可以选用，如果让我推荐，顺序如下: axum > Rocket > actix-web。不过如果你不需要多么完善的 web 功能，只需要一个性能极高的 http 库，那么 actix-web 是非常好的选择，它的性能非常非常非常高！</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="日志监控" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>日志 <a style="text-decoration: underline;color:teal;" href="https://crates.io/keywords/log">[crates.io]</a> [github]</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/tracing">tokio-rs/tracing</a> 强大的日志框架，同时还支持 OpenTelemetry 格式，无缝打通未来的监控</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rust-lang/log">rust-lang/log</a> 官方日志库，事实上的 API 标准, 但是三方库未必遵循</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/estk/log4rs">estk/log4rs</a> 模仿 JAVA logback 和 log4j 实现的日志库, 可配置性较强</li>
      <li style="margin-top:.325em;">在其它文章中，也许会推荐 slog，但是我们不推荐，一个是因为近半年未更新，一个是 slog 自己也推荐使用 tracing。</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>监控</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/open-telemetry/opentelemetry-rust">OpenTelemetry</a> 是现在非常火的可观测性解决方案，提供了协议、API、SDK 等核心工具，用于收集监控数据，最后将这些 metrics/logs/traces 数据写入到 prometheus, jaeger 等监控平台中。最主要是，它后台很硬，后面有各大公司作为背书，未来非常看好！</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/vectordotdev/vector">vectordotdev/vector</a> 一个性能很高的数据采集 agent，采集本地的日志、监控等数据，发送到远程的 kafka、jaeger 等数据下沉端，它最大的优点就是能从多种数据源(包括Opentelemetry)收集数据，然后推送到多个数据处理或者存储等下沉端。</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="SQL客户端" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>通用</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/launchbadge/sqlx">launchbadge/sqlx</a> 异步实现、高性能、纯 Rust 代码的 SQL 库，支持 PostgreSQL, MySQL, SQLite 和 MSSQL.</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>ORM</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rbatis/rbatis">rbatis/rbatis</a> 国内团队开发的 ORM，异步、性能高、简单易上手</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/diesel-rs/diesel">diesel-rs/diesel</a> 安全、扩展性强的 Rust ORM 库，支持 Mysql、Postgre、SqlLite</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Mysql</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/blackbeam/rust-mysql-simple">blackbeam/rust-mysql-simple</a> 纯Rust实现的 Mysql 驱动,提供连接池</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/blackbeam/mysql_async">blackbeam/mysql_async</a> 基于 Tokio 实现的异步 Mysql 驱动</li>
      <li style="margin-top:.325em;">上面两个都是一个团队出品，前者文档更全, star 更多，建议使用前者</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Postgre</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/sfackler/rust-postgres">sfackler/rust-postgres</a> 纯 Rust 实现的 Postgre 客户端</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Sqlite</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/rusqlite/rusqlite">rusqlite</a> 用于 Sqlite3 的 Rust 客户端</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="NoSql客户端" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Redis</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/redis-rs/redis-rs">mitsuhiko/redis-rs</a> 虽然最近更新不太活跃，但是它依然是最好的 redis 客户端，说实话，我期待更好的，可能这也是 Rust 生态的未来可期之处吧</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Canssandra</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/krojew/cdrs-tokio">krojew/cdrs-tokio</a> [cdrs-tokio] 生产可用的 Cassandra 客户端，异步、纯 Rust 实现，就是个人项目 + star 较少，未来不确定会不会不维护</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/scylladb/scylla-rust-driver">scylla-rust-driver</a> ScyllaDB 提供的官方库，支持 cql 协议，由于背靠大山，未来非常可期</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>MongoDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/mongodb/mongo-rust-driver">mongodb/mongo-rust-driver</a> 官方 MongoDB 客户端，闭着眼睛选就对了</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="分布式" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>服务发现</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/lodrem/etcd-rs">luncj/etcd-rs</a> 异步实现的 Rust etcd 客户端，优点是有一定的文档、作者较为活跃, 意味着你提问题他可能会回答，不过，如果你不放心，还是考虑使用 HTTP 的方式访问 ETCD</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="消息队列" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Kafka</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/fede1024/rust-rdkafka">fede1024/rust-rdkafka</a> Rust Kafka 客户端，基于C版本的 Kafka 库 [librdkafka] 实现，文档较全、功能较为全面</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/kafka-rust/kafka-rust">kafka-rust/kafka-rust</a> 相比上一个库，它算是纯 Rust 实现，文档还行，支持 Kafka0.8.2 及以后的版本，但是对于部分0.9版本的特性还不支持。同时有一个问题：最初的作者不维护了，转给了现在的作者，但是感觉好像也不是很活跃</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Nats</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a href="https://github.com/nats-io/nats.rs">nats-io/nats.rs</a> Nats 官方提供的客户端</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="网络、通信协议" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>Websocket</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/snapview/tokio-tungstenite">snapview/tokio-tungstenite</a> 更适合 Web 应用使用的生产级 Websocket 库，它是异步非阻塞的，基于下下面的 tungstenite-rs 库和 tokio 实现</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/websockets-rs/rust-websocket">rust-websocket</a> 老牌 Websocket 库，提供了客户端和服务器端实现，但是。。。很久没更新了</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/snapview/tungstenite-rs">snapview/tungstenite-rs</a> 轻量级的 Websocket 流实现，该库更偏底层，例如，你可以用来构建其它网络库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>gRPC</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/hyperium/tonic">hyperium/tonic</a> 纯 Rust 实现的 gRPC 客户端和服务器端，支持 async/await 异步调用，文档和示例较为清晰</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tikv/grpc-rs">tikv/grpc-rs</a> 国产开源之光 Tidb 团队出品的 gRPC 框架, 基于C的代码实现, 就是最近好像不是很活跃</li>
      <li style="margin-top:.325em;">其实这两个实现都很优秀，把 tonic 放在第一位，主要是因为它是纯 Rust 实现，同时社区也更为活跃，但是并不代表它比 tikv 的更好！</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>QUIC</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/cloudflare/quiche">cloudflare/quiche</a> 大名鼎鼎 cloudflare 提供的 QUIC 实现，据说在公司内部重度使用，有了大规模生产级别的验证，非常值得信任，同时该库还实现了 HTTP/3</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quinn-rs/quinn">quinn-rs/quinn</a> 提供异步 API 调用，纯 Rust 实现，同时提供了几个有用的网络库</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>MQTT</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/bytebeamio/rumqtt">bytebeamio/rumqtt</a> MQTT3.1.1/5 协议库，同时实现了客户端与服务器端 broker</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/ntex-rs/ntex-mqtt">ntex-rs/ntex-mqtt</a> 客户端与服务端框架，支持 MQTT3.1.1 与5协议</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/eclipse/paho.mqtt.rust">eclipse/paho.mqtt.rust</a> 老牌 MQTT 框架，对 MQTT 支持较全, 其它各语言的实现也有</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="异步网络编程" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/tokio">tokio-rs/tokio</a> 最火的异步网络库，除了复杂上手难度高一些外，没有其它大的问题。同时tokio团队提供了多个非常优秀的Rust库，整个生态欣欣向荣，用户认可度很高</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://async.rs/">async-std</a> 跟标准库API很像的异步网络库，相对简单易用，但是貌似开发有些停滞，还有就是功能上不够完善。但是对于普通用户来说，这个库非常值得一试，它在功能和简单易用上取得了很好的平衡</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/actix/actix">actix</a> 基于Actor模型的异步网络库，但这个库的开发貌似已经停滞，他们团队一直在专注于actix-web的开发</li>
  <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/mio">mio</a> 严格来说，MIO与之前三个不是同一个用途的，MIO = Meta IO，是一个底层IO库，往往用于构建其它网络库，当然如果你对应用网络性能有非常极限的要求，可以考虑它，因为它的层次比较低，所带来的抽象负担小，所以性能损耗小</li>
  <li style="margin-top:.325em;">如果你要开发生产级别的项目，我推荐使用 tokio，稳定可靠，功能丰富，控制粒度细；自己的学习项目或者没有那么严肃的开源项目，我推荐 async-std，简单好用，值得学习；当你确切知道需要 Actor 网络模型时，就用 actix</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="搜索引擎" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>ElasticSearch客户端</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/elastic/elasticsearch-rs">elastic/elasticsearch</a> 官方es客户端，目前第三方的基本都处于停滞状态，所以不管好坏，用呗</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Rust搜索引擎</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quickwit-oss/tantivy">Tantivy</a> 是Rust实现的本地搜索库，功能对标 lucene，如果你不需要分布式，那么引入 tantivy 作为自己本地 Rust 服务的一个搜索，是相当不错的选择，该库作者一直很活跃，而且最近还创立了搜索引擎公司，感觉大有作为. 该库的优点在于纯Rust实现，性能高(lucene的2-3倍)，资源占用低(对比java自然不是一个数量级)，社区活跃。</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>Rust搜索平台</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/quickwit-oss/quickwit">quickwit</a> 对标 ElasticSearch，一个通用目的的分布式搜索平台，目前还在起步阶段(0.2版本)，未来非常可期，目前还不建议使用</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/meilisearch/MeiliSearch">MeiliSearch</a> 虽然也是一个搜索平台，但是并不是通用目的的，MeiliSearch 目标是为终端用户提供边输入边提示的即刻搜索功能，因此是一个轻量级搜索平台，不适用于数据量大时的搜索目的。总之，如果你需要在网页端或者APP为用户提供一个搜索条，然后支持输入容错、前缀搜索时，就可以使用它。</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="代码Debug" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:0em;list-style-type:none;margin-top: 1.325em;">
  <li>
    <div><b>GDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/cs01/gdbgui">gdbgui</a> 提供浏览器支持的 gdb debug工具，支持 C，C++，Rust 和 Go.</li>
    </ul>
  </li>
  <li style="margin-top:1.325em;">
    <div><b>LLDB</b></div>
    <ul style="margin-left:2.625em;list-style-type:decimal;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://marketplace.visualstudio.com/items?itemName=vadimcn.vscode-lldb">CodeLLDB</a> — 专门为VSCode设计的LLDB Debug扩展</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="性能优化" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/bheisler/criterion.rs">bheisler/criterion.rs</a> 比官方提供的 benchmark 库更好，目前已经成为事实上标准的性能测试工具</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/koute/bytehound">Bytehound</a> Linux 下的内存分析工具，可以用来分析：内存泄漏、内存分配、调用栈追踪，甚至它还有一个浏览器UI! 懂的人都懂，性能测试工具的UI服务是多么稀缺和珍贵！</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/llogiq/flame">llogiq/flame</a> 专为Rust打造的火焰图分析工具，可以告诉你程序在哪些代码上花费的时间过多，非常适合用于代码性能瓶颈的分析。与 perf 不同，flame 库允许你自己定义想要测试的代码片段，只需要在代码前后加上相应的指令即可，非常好用</li>
  <li style="margin-top:.625em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/sharkdp/hyperfine">sharkdp/hyperfine</a> 一个命令行 benchmark 工具，支持任意 shell 命令，支持缓存清除、预热、多次运行统计分析等，尽量保证结果的准确性</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="编解码" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/serde-rs/serde">Serde</a> 一个超高性能的通用序列化/反序列化框架，可以跟多种协议的库联合使用，实现统一编解码格式</li>
  <li style="margin-top:.625em;">CSV -- <a style="text-decoration: underline;color:teal;" href="https://github.com/BurntSushi/rust-csv">BurntSushi/rust-csv</a> 高性能CSV读写库，支持Serde</li>
  <li style="margin-top:.625em;">JSON -- <a style="text-decoration: underline;color:teal;" href="https://github.com/serde-rs/json">serde-rs/json</a> 快到上天的JSON库，也是Rust事实上的标准JSON库，你也可以使用它的大哥serde，一个更通用的序列化/反序列化库</li>
  <li style="margin-top:.625em;">MsgPack -- <a style="text-decoration: underline;color:teal;" href="https://github.com/3Hren/msgpack-rust">3Hren/msgpack-rust</a> 纯Rust实现的MessagePack编解码协议</li>
  <li style="margin-top:.625em;">
    <div>ProtocolBuffers</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tokio-rs/prost">tokio-rs/prost</a> tokio出品，基本都属精品，此库也不例外，简单易用，文档详细</li>
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/stepancheg/rust-protobuf">stepancheg/rust-protobuf</a> 纯 Rust 实现</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>TOML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/toml-rs/toml-rs">alexcrichton/toml-rs</a> TOML编码/解码，可以配合serde使用</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>XML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/tafia/quick-xml">tafia/quick-xml</a> 高性能XML库，可以配合serde使用，文档较为详细</li>
    </ul>
  </li>
  <li style="margin-top:.625em;">
    <div>YAML</div>
    <ul style="margin-left:1em;list-style-type:disc;margin-top:.325em;">
      <li style="margin-top:.325em;"><a style="text-decoration: underline;color:teal;" href="https://github.com/dtolnay/serde-yaml">dtolnay/serde-yaml</a> 使用serde编解码YAML格式的数据</li>
    </ul>
  </li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Email" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: 1.325em;">
  <li><a style="text-decoration: underline;color:teal;" href="https://github.com/lettre/lettre">lettre/lettre</a> — Rust SMTP 库</li>
</ul>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Install Rust Development Environment</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="安装 cargo &amp; rust-analyzer" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
### 安装完成后可以使用 cargo
$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

### 安装 macOS 包管理工具 brew
$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

### 安装 rust-analyzer (安装Rust官方支持的代码分析前端程序), 耗时较长
$ brew install rust-analyzer

    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="安装 sublime text 4 rust 插件" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

### 打开sublime，快捷键 command + shift + p 调出命令选项，输入 install package control 安装 sublime 包管理工具
## 1. LSP（必须）
-- Language Server Protocol，语言服务器协议，此插件为 sublime 实现了 LSP 功能（有兴趣自行查阅资料），以关联 rust-analyzer，实现代码分析

## Rust Enhanced（必须）
-- 这是Rust社区官方维护的sublime插件，提供语法高亮、快捷构建等功能。

## sublimecodeintel
-- 全功能代码智能补全

## All Autocomplete
-- 在所有打开的文件中进行关键字搜索以及补全（面对所有文本，不受编程语言以及单个文件的限制）

## rust syntax
-- 为代码提供语法高亮。

## toml
-- Rust 使用 toml 做项目的配置管理。

## Tabnine
-- 基于 AI 的自动补全，可以帮助你更快地撰写代码。一位来自加拿大的大四学霸，开发了一款”Deep TabNine“代码补全工具，实现了这一大胆的想法。它支持23种编程语言、5种编辑器，使用简单，效果惊艳。

### 设置 LSP 
## 通过 sublime 打开一个随意的 rust 文件或项目文件夹，快捷键 command + shift + p 调出命令选项，有两种命令可选：
-- LSP: Enable Language Server Globally 此命令会让 sublime 只要启动就加载所选的代码分析前端（不建议，会影响s ublime 的冷启动性能）
-- LSP: Enable Language Server In Project 此命令会让 sublime 在打开当前文件/项目时才加载所选的代码分析前端，重启后需要重新操作一遍
-- 回车后，在下拉菜单中选择 'rust-analyzer' 就完成了全部配置，一切顺利的话界面显示类似下图，左下角会显示 rust-analyzer 对代码进行索引分析，
-- 指针悬停于代码有相应提示

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
  <img style="max-width:100%" src="/images/rust/1395949-20211205193017709-311037346.png" />
</div>

<blockquote style="font-size:1em;line-height:1.6em;">
  <div style="margin-bottom:1em;">
    Rust 语言服务器（RLS）基于 LSP（Language Server Protocol），即语言服务器协议，LSP 由红帽、微软和 Codenvy 联合推出，可以让不同的程序编辑器与集成开发环境（IDE）方便地嵌入各种编程语言，允许开发人员在最喜爱的工具中使用各种语言来编写程序。
  </div> 
  <div style="margin-bottom:1em;">
    它通过用于开发工具和语言服务器间通信的 JSON-RPC 标准，能够让编程工具提供实时反馈的详细信息并以此实现多种强大功能，比如符号搜寻、语法分析、代码自动补全、移至定义、描绘轮廓与重构等。Rust 语言服务器集成了这些逻辑作为后端，并通过标准的 LSP 提供给前端工具，它被设计为与前端无关，可以被不同的编辑器和 IDE 广泛采用，但目前项目团队仅在 VS Code 中进行测试。用户可以在 VS Code 扩展商店中找到基于 RLS 实现的 Rust 官方插件。
   </div>
  <div style="margin-bottom:1em;">
    <b>rust-anlyzer（RA）</b>是除了 RSL 以外的另一个 Rust 语言服务器，由社区驱动开发。自 2019 年末发布第一个预编译 Release 以来，RA 都会在每周二稳定发布新版本并保持至今。经过快速的迭代，目前 RA 各方面的优化和提升已经超越 RSL，所以也被官方纳入 RSL 2.0 计划的一部分。 Rust 的 VS Code 官方插件也已经增加了对 RA 的支持。
   </div>
  <div style="margin-bottom:1em;">
    RA 目前已经支持 Vim、Emac、Sublime Text 3 和 VSCode 等编辑器，可通过官方文档获取详细的安装指导。
   </div>
 </blockquote>

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  
  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>Cargo 工作空间</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
  管理多个相互关联且需要协同开发的包
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="创建工作空间" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
$ mkdir rustlabs && cd rustlabs && touch Cargo.toml

### Cargo.toml 内容
[workspace]
members = [
  "lab1",
  "lib1"
]

### 在该工作空间下创建 lab1 二进制包
$ cargo new lab1 && cargo build

### 继续在该工作空间下创建 lib1 代码包 (--lib)
$ cargo new lib1 --lib && cargo build

### 在 lib1/src/lib.rs 文件中添加一个 add_one 函数
pub fn add_one(x: i32) -> i32 {
  x + 1
}

### 将 lib1 代码包添加到lab1二进制包中, 在 lab1 中将要使用 lib1 导出的函数
$ vi lab1/Cargo.toml
[dependencies]
lib1 = { path = "../lib1" }

### 在 lab1 中使用来自 lib1 包的 add_one 函数
$ vi lab1/src/main.rs
use lib1;

fn main() {
  let num = 10;
  println!("Hello world! {} plus one is: {}!", num, lib1::add_one(num));
}

### 构建整个工作空间
$ cargo build

### 运行指定的二进制包
$ cargo run -p lab1

### 添加外部依赖包
$ vi lib1/Cargo.toml
[dependencies]
rand = "0.3.14"

### 再次构建整个工作空间, 此时 Cargo 就会引入并编译新添加的 rand 包
$ cargo build
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="为当前工作空间增加测试" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 为 lib1::add_one 函数增加一个测试
$ vi lib1/src/lib.rs
#[cfg(test)]
mod tests {

  use super::*;

  #[test]
  fn it_works() {
    assert_eq!(3, add_one(2));
  }
}

// 运行当前工作空间下的所有测试
$ cargo test

// 运行某个特定包的测试
$ cargo test -p lib1

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用 cargo install 从 crates.io 上安装可执行程序" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 输出结果的最后一行显示了二进制文件的安装路径和名称
$ cargo install ripgrep
    Finished release [optimized + debuginfo] target(s) in 1m 06s
  Installing /Users/keesh/.cargo/bin/rg
   Installed package `ripgrep v13.0.0` (executable `rg`)
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="使用自定义命令扩展 cargo 的功能" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// cargo 允许我们添加子命令来扩展它的功能而无需修改 Cargo 自身, 只要你的 $PATH 路径中存在指定的二进制文件即可, 就好像它是 cargo 的子命令一样
$ cargo rg

// 显示当前包的依赖图
$ cargo tree OR cargo tree -p tera

// 列出 cargo 的内置子命令
$ cargo --list
Installed Commands:
    add                  Add dependencies to a Cargo.toml manifest file
    b                    alias: build
    bench                Execute all benchmarks of a local package
    build                Compile a local package and all of its dependencies
    c                    alias: check
    check                Check a local package and all of its dependencies for errors
    clean                Remove artifacts that cargo has generated in the past
    clippy               Checks a package to catch common mistakes and improve your Rust code.
    config               Inspect configuration values
    d                    alias: doc
    doc                  Build a package's documentation
    fetch                Fetch dependencies of a package from the network
    fix                  Automatically fix lint warnings reported by rustc
    fmt                  Formats all bin and lib files of the current crate using rustfmt.
    generate-lockfile    Generate the lockfile for a package
    git-checkout         This command has been removed
    help                 Displays help for a cargo subcommand
    init                 Create a new cargo package in an existing directory
    install              Install a Rust binary. Default location is $HOME/.cargo/bin
    locate-project       Print a JSON representation of a Cargo.toml file's location
    login                Save an api token from the registry locally. If token is not specified, it will be read from stdin.
    logout               Remove an API token from the registry locally
    metadata             Output the resolved dependencies of a package, the concrete used versions including overrides, in machine-readable format
    miri
    new                  Create a new cargo package at <path>
    owner                Manage the owners of a crate on the registry
    package              Assemble the local package into a distributable tarball
    pkgid                Print a fully qualified package specification
    publish              Upload a package to the registry
    r                    alias: run
    read-manifest        Print a JSON representation of a Cargo.toml manifest.
    remove               Remove dependencies from a Cargo.toml manifest file
    report               Generate and display various kinds of reports
    rm                   alias: remove
    run                  Run a binary or example of the local package
    rustc                Compile a package, and pass extra options to the compiler
    rustdoc              Build a package's documentation, using specified custom flags.
    search               Search packages in crates.io
    t                    alias: test
    test                 Execute all unit and integration tests and build examples of a local package
    tree                 Display a tree visualization of a dependency graph
    uninstall            Remove a Rust binary
    update               Update dependencies as recorded in the local lock file
    vendor               Vendor all dependencies for a project locally
    verify-project       Check correctness of crate manifest
    version              Show version information
    yank                 Remove a pushed crate from the index

    ]]>
    </c:sourceContent>



    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>泛型函数</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::str::FromStr;

pub fn parse_number<T: FromStr>(s: &str) -> Option<T> {
    match T::from_str(s) {
        Ok(l) => Some(l),
        _ => None,
    }
}


#[cfg(test)]
mod tests {
    #[test]
    fn it_parse_number() {
        let i: f64 = parse_number("3").expect("error parseing u32");
        assert_eq!(3.0, i);
    }
}

    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>数组、向量和切片</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 1. 数组是在编译是确定大小的常量，不能在数组中追加或删除元素
// [T; N] 表示一个N个值的数组, 每个元素的类型都是 T, 
// 数组长度是类型的一部分，在编译时就确定了，N必须是常量，无法在运行时指定N的值。
let lazy_caterer: [u32; 6] = [1,3,3,4];
let taxonomy = ["Animalia", "Arthropoda", "Insects"];

// 2. 向量是一种动态分配，可扩展的值序列，向量的元素保存在堆上，可随意缩放它
//    每当向量增长到超过其缓冲区容量时，它都会选择一个比原来大1倍的新缓冲区。
// Vec<T> 表示一个向量，每个元素的类型都是T，可动态调整大小
let v1 = vec![1, 2, 3];
let mut v2: Vec<u32> = Vec::<u32>::new();
let v22 = Vec::<u32>::new();
let vv = vec![0; 14];
let v: Vec<i32> = (0..5).collect(); // 使用collect时通常要明确写出类型

println!("{:?}", v2);

// 3. 切片是对其他值中部分元素序列的引用。切片的引用的是一个胖指针，即一个双字宽的值，保存着切片中第一个元素的指针和切片中的元素个数。
//    切片表示数组或向量的一个范围，由于切片可以是任意长度，因此不能直接保存到变量中，也不能作为函数参数传递，切片永远只能按引用传递。
// &[T] 读作"共享切片"，可以由多个线程读取，但不可以修改
// &mut [T] 读作"可修改切片"，允许读写元素，但是不能共享
let v: Vec<f64> = vec![0.0, 0.707, 1.0, 0.797]; // 向量
let a: [f64; 4] =     [0.0, -0.707, -1.0, -0.797]; // 数组

let sv: &[f64] = &v; // 切片
let sa: &[f64] = &a; // 切片

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/array-vec-slice.png" style="max-width:100%;" />
</div>
<div style="text-align: center;">
  向量、数组、切片、引用 之间的内存布局逻辑图
</div>

<ul style="margin-left:1em;list-style-type:disc;margin-top:1.325em;">
  <li style="margin-top:.325em;">普通引用是对单个值的非所有型指针</li>
  <li style="margin-top:.325em;">切片引用是对多个值的非所有型指针</li>
  <li style="margin-top:.325em;">切片引用的是一个胖指针，即一个双字宽的值，保存着切片中第一个元素的指针和切片中的元素个数。</li>
</ul>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="向量 Vec" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// 显示写出类型
fn build_vector() -> Vec<i16> {
  let mut v: Vec<i16> = Vec::<i16>::new();
  v.push(10i16)
  v.push(20i16)
  v
}

// 类型推断, 提高代码可读性
fn build_vector() -> Vec<i16> {
  let mut v = Vec::new();
  v.push(10)
  v.push(20)
  v
}
    ]]>
    </c:sourceContent>


    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>字符串类型</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let noodles = "noodles".to_string();
let oodles = &noodles[1..];
let poodles = "中_国";

println!("{}", poodles.len()); // 字节数, > 7
println!("{}", poodles.chars().count()); // 字符长度, > 3
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/string-&str-str.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>所有权</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
在 Rust 中每个值都<b>只有一个</b>决定其生命期的所有者，当这个所有者被释放(dropped)时，其所有的值也会被清除。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="向量 Vector" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
fn print_padovan() {
  let mut padovan = vec![1,1,1]; // 分配内存
  for i in 3..10 {
    let next = padovan[i - 3] + padovan[i - 2];
    padovan.push(next);
  }
  println!("P(1..10) = {:?}", padovan);
} // 清除 padovan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/vecu32.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Box" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
// Rust 的 Box 类型是说明所有权的一个典型例子，Box<T> 是一个指针，其指向存储在堆中的T类型的值。
// 调用 Box::new(v) 会在堆上分配相应的内存缓冲区，并将值v转移进去。最后返回
{
  let point = Box::new((0.625, 0.5); 
  let label = format!("{:?}", point);

    println!(
        "{}, {}, {}, {}",
        label,
        label.len(),
        label.chars().count(),
        label.capacity()
    ); // > (0.625, 0.5), 12, 12, 16
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/point&label-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="结构体 struct" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

#[derive(Debug)]
struct Person { name: String, birth: i32 }

let mut composers = Vec::new();

composers.push(Person{ name: "Palestrina".to_string(), birth: 1525 });
composers.push(Person{ name: "Dowland".to_string(), birth: 1563 });
composers.push(Person{ name: "Lully".to_string(), birth: 1632 });

for c in composers {
    println!("{:?}, {}, {}", c, c.name, c.birth);
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/struct-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>转移</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div style="font-size:1.2em;">
在 Rust 中给<b>变量赋值</b>、给<b>函数传参</b>、从<b>函数返回值</b>这样的操作都不会复制值，而是<b>转移(move)</b>值。
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="Python" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
s = ['udon', 'ramen', 'soba']
t = s    // 赋值代价较小，引用计数相对麻烦。
u = s
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/python-string-array-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="C++" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
using namespace std;
vector<string> s = { "udon", "ramen", "soba" };
vector<string> t = s; // 产生深度复制, 即复制s到t。保证了内存所有权的清晰!
vector<string> u = s; // 产生深度复制, 即复制s到t。保证了内存所有权的清晰!
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/c++-vec-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Rust" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let s = vec!["udon".to_string(), "ramen".to_string(), "soba".to_string()];
let t = s; // 转移所有权
let u = s; // s的值已经被转移，编译器拒绝编译这行代码
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/rust-vec-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Copy类型 &amp;mdash; 转移的例外" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
#[derive(Copy, Clone)] // 如果自定义结构体的所有字段都是copy类型，那可以在该结构体上加该注释
struct Label { number: u32 }

fn print_label(l: Label) {
  println!("STAMP: {}", l.number);
}

let l = Label { number: 3 };

// 如果Label不是Copy类型，编译器拒绝编译这行代码
// 把非copy类型的值传给print会把值的所有权转移给print, print会在返回前将该值清除
print_label(l);

println!("My label number is: {}", l.number); 

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="Rc &amp; Arc 共享所有权" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
use std::rc::Rc;

let s: Rc<String> = Rc::new("shirataki".to_string()); // Rust 假设 Rc 指针指向的值通常是共享的

s.push_str("aa"); // 编译器拒绝编译这行代码, Rust 里不存在即共享又可以修改的值

let t: Rc<String> = s.clone();
let u: Rc<String> = s.clone();

println!("{:?}", s);
println!("{:?}", t);
println!("{:?}", u);

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.3;font-family:monospace;">
      <![CDATA[
<div>
  <img src="/images/rust/rc-string-heap.png" style="max-width:100%;" />
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="共享引用 &amp; 可修改引用" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[

let x = 1000;
let r = &x;     // 共享引用
let f = *r;     // 对 r 解引用进而读取存储在 x 里值

println!("{}, {}", *r, f);

let mut a = 10; 
let b = &mut a; // &mut a 是 y 的可修改引用

*b += 1;        // 显示对 b 解引用进而修改 a 的值

println!("{}", b);

    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="给引用赋值" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let x = 10;
let y = 20;
let mut r = &x;

if true {
  r = &y; // 给引用赋值会导致它指向新值
}

println!("{}", r);

    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title>悬空指针</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="" title="悬空指针 -- 例子1" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
{
  let r;
  {
    let x = 1;
    r = &x;
  }
  println!("{}", r)
}

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;margin-top:1em;">
      <![CDATA[
以上代码编译会报错
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
cargo build
   Compiling lab2 v0.1.0 (/Users/keesh/workspace/rs-labs/lab2)
error[E0597]: `x` does not live long enough
 --> lab2/src/main.rs:6:13
  |
6 |         r = &x;
  |             ^^ borrowed value does not live long enough
7 |     }
  |     - `x` dropped here while still borrowed
8 |     println!("{}", r)
  |                    - borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `lab2` due to previous error
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="借用向量中的元素" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.325em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.3;font-family:monospace;">
      <![CDATA[
let v = vec![1, 2, 3];
let r = &v[1]; // 借用

    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1.2em;line-height:1.6;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
  由于 v 拥有向量, 而向量拥有自己的元素, 因此 v 的生命周期必须涵盖引用类型 &v[1] 的生命期。类似的，如果把引用保存在某个数据结构中，该引用的生命期必须涵盖该数据结构的生命期。比如，对于一个引用向量而言，(作为向量元素的) 所有引用的生命周期都必须涵盖拥有这个向量的变量的生命期。
</div>
<div style="margin-top:.625em;">
  例如本例中, r 借用了 v 里的某个元素的引用, 那么 v 的生命期必须大于 r 的生命期。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  

</c:component>
