<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div>
The <b>connection reset by peer</b> is a <a href="https://www.ibm.com/docs/en/db2/11.1?topic=message-tcpip-errors">TCP/IP</a> error that occurs when the other end (peer) has unexpectedly closed the connection. It happens when you send a packet from your end, but the other end crashes and forcibly closes the connection with the <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> packet instead of the <a href="https://ipwithease.com/what-is-tcp-fin-packet/">TCP FIN</a>, which is used to close a connection under normal circumstances. In Go, you can detect the connection reset by peer by checking if the error returned by the peer is equal to <a href="https://pkg.go.dev/syscall#ECONNRESET">syscall.ECONNRESET</a>.
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">Reproduce the connection reset by peer error</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
<div>We can reproduce the error by creating a server and client that do the following:</div>
<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .325em;">
  <li>the server reads a single byte and then closes the connection</li>
  <li>the client sends more than one byte</li>
</ul>
<div style="margin-top:.625em;">If the server closes the connection with the remaining bytes in the socket’s receive buffer, then an <b>RST</b> packet is sent to the client. When the client tries to read from such a closed connection, it will get the <b>connection reset by peer</b> error.</div>
<div style="margin-top:.625em;">See the following example, which simulates this behavior.</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
package main

import (
    "errors"
    "log"
    "net"
    "os"
    "syscall"
    "time"
)

func server() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatal(err)
    }

    defer listener.Close()

    conn, err := listener.Accept()
    if err != nil {
        log.Fatal("server", err)
        os.Exit(1)
    }
    data := make([]byte, 1)
    if _, err := conn.Read(data); err != nil {
        log.Fatal("server", err)
    }

    conn.Close()
}

func client() {
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        log.Fatal("client", err)
    }

    if _, err := conn.Write([]byte("ab")); err != nil {
        log.Printf("client: %v", err)
    }

    time.Sleep(1 * time.Second) // wait for close on the server side

    data := make([]byte, 1)
    if _, err := conn.Read(data); err != nil {
        log.Printf("client: %v", err)
        if errors.Is(err, syscall.ECONNRESET) {
            log.Print("This is connection reset by peer error")
        }
    }
}

func main() {
    go server()

    time.Sleep(3 * time.Second) // wait for server to run

    client()
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;margin-top:1em;">
      <![CDATA[
Output:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
2021/10/20 19:01:58 client: read tcp [::1]:59897->[::1]:8080: read: connection reset by peer
2021/10/20 19:01:58 This is connection reset by peer error
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Handle the connection reset by peer error" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
Typically, you can see the <b>connection reset by peer</b> error in response to a request being sent from the client to the server. It means that something bad has happened to the server: it has rebooted, the program has crashed, or other problems have occurred that cause the connection to be forcibly closed. Since TCP connections can be broken, there is no need to handle the <b>connection reset by peer</b> in any special way on the client side. You can log the error, ignore it or retry the connection when it occurs. In the example above, we detect the error using the <a href="https://gosamples.dev/check-error-type">errors.Is()</a> function by checking if the returned error is an instance of <a href="https://pkg.go.dev/syscall#ECONNRESET">syscall.ECONNRESET</a>.
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="Difference between 'connection reset by peer' and 'broken pipe'" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
<div>
Both connection reset by peer and broken pipe errors occur when a peer (the other end) unexpectedly closes the underlying connection. However, there is a subtle difference between them. Usually, you get the connection reset by peer when you read from the connection after the server sends the RST packet, and when you write to the connection after the RST instead, you get the broken pipe error.
</div>
<div style="margin-top:.625em;">
Check <a href="#Handle-broken-pipe-error-in-Go">how to handle the broken pipe error in Go</a> post, where will find another example of generating an <b>RST</b> packet and the <b>broken pipe</b> error.
</div>
<div style="margin-top:.625em;">
Replace the <b>client()</b> function in the example above with the following code to reproduce the <b>broken pipe</b> error.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
func client() {

    conn, err := net.Dial("tcp", "localhost:8080")

    if err != nil {
        log.Fatal("client", err)
    }

    if _, err := conn.Write([]byte("ab")); err != nil {
        log.Printf("client: %v", err)
    }

    time.Sleep(1 * time.Second) // wait for close on the server side

    if _, err := conn.Write([]byte("b")); err != nil {
        log.Printf("client: %v", err)
    }

}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;margin-top:1em;">
      <![CDATA[
With the new client, you will see the output:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
2021/10/20 19:55:40 client: write tcp [::1]:60399->[::1]:8080: write: broken pipe
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;margin-top:1em;">
      <![CDATA[
Note that these simple examples do not cover all cases where <b>connection reset by peer</b> and <b>broken pipe</b> may occur. There are much more situations where you can see these errors, and what error you see in what situation requires a deep understanding of the <a href="https://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</a> design.
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Handle-broken-pipe-error-in-Go">Handle 'broken pipe' error in Go"</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
The <b>broken pipe</b> is a <a href="https://www.ibm.com/docs/en/db2/11.1?topic=message-tcpip-errors">TCP/IP</a> error occurring when you write to a stream where the other end (the peer) has closed the underlying connection. The first write to the closed connection causes the peer to reply with an <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> packet indicating that the connection should be terminated immediately. The second write to the socket that has already received the <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> causes the <b>broken pipe</b> error. To detect the <b>broken pipe</b> in Go, check if the error returned by the peer is equal to <a href="https://pkg.go.dev/syscall#EPIPE">syscall.EPIPE</a>. Usually, this error can be seen when the server crashes while the client is sending data to it.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Reproduce the broken pipe error" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
<div>In the following example, we reproduce the <b>broken pipe</b> error by creating a server and client that do the following:</div>
<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .325em;">
  <li>the server reads a single byte and then closes the connection</li>
  <li>the client sends three bytes with an interval of one second between them</li>
</ul>
<div style="margin-top:.625em;">The server receives the first client byte and closes the connection. The next byte of the client sent to the closed connection causes the server to reply with an <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> packet. The socket that received the <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> will return the <b>broken pipe</b> error when more bytes are sent to it. This is what happens when the client sends the last byte to the server.</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
package main

import (
    "errors"
    "log"
    "net"
    "os"
    "syscall"
    "time"
)

func server() {
    listener, err := net.Listen("tcp", ":8080")
    if err != nil {
        log.Fatal(err)
    }

    defer listener.Close()

    conn, err := listener.Accept()
    if err != nil {
        log.Fatal("server", err)
        os.Exit(1)
    }
    data := make([]byte, 1)
    if _, err := conn.Read(data); err != nil {
        log.Fatal("server", err)
    }

    conn.Close()
}

func client() {
    conn, err := net.Dial("tcp", "localhost:8080")
    if err != nil {
        log.Fatal("client", err)
    }

    // write to make the connection closed on the server side
    if _, err := conn.Write([]byte("a")); err != nil {
        log.Printf("client: %v", err)
    }

    time.Sleep(1 * time.Second)

    // write to generate an RST packet
    if _, err := conn.Write([]byte("b")); err != nil {
        log.Printf("client: %v", err)
    }

    time.Sleep(1 * time.Second)

    // write to generate the broken pipe error
    if _, err := conn.Write([]byte("c")); err != nil {
        log.Printf("client: %v", err)
        if errors.Is(err, syscall.EPIPE) {
            log.Print("This is broken pipe error")
        }
    }
}

func main() {
    go server()

    time.Sleep(3 * time.Second) // wait for server to run

    client()
}

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;margin-top:1em;">
      <![CDATA[
Output:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
2021/10/21 19:10:01 client: write tcp 127.0.0.1:50389->127.0.0.1:8080: write: broken pipe
2021/10/21 19:10:01 This is broken pipe error

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Handle the broken pipe error" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
To handle the <b>broken pipe</b>, you need to check if the error returned from the other end of the connection is an instance of <a href="https://pkg.go.dev/syscall#EPIPE">syscall.EPIPE</a>. In the example above, we perform this check using the <a href="https://gosamples.dev/check-error-type">errors.Is()</a> function and print the message <b>"This is broken pipe error"</b> if it occurs. The <b>broken pipe</b> can be seen on either the client or server side, depending on which one is trying to write to the closed connection. Typically there is no need to handle it in any special way since it is normal that a connection may be interrupted by either side of the communication. For example, you can ignore the error, log it or reconnect when it occurs.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Difference between 'broken pipe' and 'connection reset by peer'" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
Usually, you get the <b>broken pipe</b> error when you write to the connection after the <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> is sent, and when you read from the connection after the <a href="https://ipwithease.com/tcp-rst-flag/">RST</a> instead, you get the <b>connection reset by peer error</b>. Check our <a href="#Reproduce-the-connection-reset-by-peer-error">article about connection reset by peer</a> error to better understand the difference between these two errors.
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Handle-broken-pipe-error-in-Go">一文搞懂TCP的三次握手和四次挥手</c:title>
    <c:desc>
      <c:desc1> <![CDATA[
<div>
    TCP的三次握手和四次挥手实质就是TCP通信的连接和断开。
</div>
<div style="margin-top:1em;">
    <img style="max-width:380px;" src="/images/rust/20200829113323236.png" />
</div>
]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="三次握手" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
<div>
TCP协议位于传输层，作用是提供可靠的字节流服务，为了准确无误地将数据送达目的地，TCP协议采纳三次握手策略。
</div>
<div style="margin-top:.325em;">
为了对每次发送的数据量进行跟踪与协商，确保数据段的发送和接收同步，根据所接收到的数据量而确认数据发送、接收完毕后何时撤消联系，并建立虚连接。
</div>
<h4 style="margin-top:.625em;">
三次握手原理：
</h4>
<div style="margin-top:.325em;color: gray;">
第1次握手：客户端发送一个带有SYN（synchronize）标志的数据包给服务端；
</div>
<div style="margin-top:.325em;color: gray;">
第2次握手：服务端接收成功后，回传一个带有SYN/ACK标志的数据包传递确认信息，表示我收到了；
</div>
<div style="margin-top:.325em;color: gray;">
第3次握手：客户端再回传一个带有ACK标志的数据包，表示我知道了，握手结束。
</div>
<div style="margin-top:.325em;color: gray;">
其中：SYN标志位数置1，表示建立TCP连接；ACK标志表示验证字段。
</div>
<div style="margin-top:.325em;">
可通过以下趣味图解理解三次握手：
</div>
<div style="margin-top:1em;">
    <img style="max-width:380px;" src="/images/rust/20200829115116478.png" />
</div>
<h4 style="margin-top:.625em;">
三次握手过程详细说明：
</h4>
<div style="margin-top:.325em;color: gray;">
1、客户端发送建立TCP连接的请求报文，其中报文中包含seq序列号，是由发送端随机生成的，并且将报文中的SYN字段置为1，表示需要建立TCP连接。（SYN=1，seq=x，x为随机生成数值）；
</div>
<div style="margin-top:.325em;color: gray;">
2、服务端回复客户端发送的TCP连接请求报文，其中包含seq序列号，是由回复端随机生成的，并且将SYN置为1，而且会产生ACK字段，ACK字段数值是在客户端发送过来的序列号seq的基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP建立请求已得到验证。（SYN=1，ACK=x+1，seq=y，y为随机生成数值）这里的ack加1可以理解为是确认和谁建立连接；
</div>
<div style="margin-top:.325em;color: gray;">
3、客户端收到服务端发送的TCP建立验证请求后，会使自己的序列号加1表示，并且再次回复ACK验证请求，在服务端发过来的seq上加1进行回复。（SYN=1，ACK=y+1，seq=x+1）。
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="四次挥手" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:.625em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[
即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;margin-top:.625em;">
      <![CDATA[
<div>
由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。
</div>
<h4 style="margin-top:.625em;">
三次握手原理：
</h4>
<div style="margin-top:.325em;color: gray;">
第1次挥手：客户端发送一个FIN，用来关闭客户端到服务端的数据传送，客户端进入FIN_WAIT_1状态；
</div>
<div style="margin-top:.325em;color: gray;">
第2次挥手：服务端收到FIN后，发送一个ACK给客户端，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），服务端进入CLOSE_WAIT状态；
</div>
<div style="margin-top:.325em;color: gray;">
第3次挥手：服务端发送一个FIN，用来关闭服务端到客户端的数据传送，服务端进入LAST_ACK状态；
</div>
<div style="margin-top:.325em;color: gray;">
第4次挥手：客户端收到FIN后，客户端t进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，服务端进入CLOSED状态，完成四次挥手。
</div>
<div style="margin-top:.325em;">
其中：FIN标志位数置1，表示断开TCP连接。
</div>
<div style="margin-top:.325em;">
可通过以下趣味图解理解四次挥手：
</div>
<div style="margin-top:1em;">
    <img style="max-width:380px;" src="/images/rust/20200829121601962.png" />
</div>
<h4 style="margin-top:.625em;">
四次挥手过程详细说明：
</h4>
<div style="margin-top:.325em;color: gray;">
1、客户端发送断开TCP连接请求的报文，其中报文中包含seq序列号，是由发送端随机生成的，并且还将报文中的FIN字段置为1，表示需要断开TCP连接。（FIN=1，seq=x，x由客户端随机生成）；
</div>
<div style="margin-top:.325em;color: gray;">
2、服务端会回复客户端发送的TCP断开请求报文，其包含seq序列号，是由回复端随机生成的，而且会产生ACK字段，ACK字段数值是在客户端发过来的seq序列号基础上加1进行回复，以便客户端收到信息时，知晓自己的TCP断开请求已经得到验证。（FIN=1，ACK=x+1，seq=y，y由服务端随机生成）；
</div>
<div style="margin-top:.325em;color: gray;">
3、服务端在回复完客户端的TCP断开请求后，不会马上进行TCP连接的断开，服务端会先确保断开前，所有传输到A的数据是否已经传输完毕，一旦确认传输数据完毕，就会将回复报文的FIN字段置1，并且产生随机seq序列号。（FIN=1，ACK=x+1，seq=z，z由服务端随机生成）；
</div>
<div style="margin-top:.325em;color: gray;">
4、客户端收到服务端的TCP断开请求后，会回复服务端的断开请求，包含随机生成的seq字段和ACK字段，ACK字段会在服务端的TCP断开请求的seq基础上加1，从而完成服务端请求的验证回复。（FIN=1，ACK=z+1，seq=h，h为客户端随机生成）
至此TCP断开的4次挥手过程完毕。
</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  


</c:component>
