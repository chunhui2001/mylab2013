<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div>
    绿色线程解决了一个开发中的常见问题。你不希望代码阻塞 CPU，使它无法执行有意义的工作。我们通过使用多任务来解决这个问题，它允许我们暂停执行某一段代码同时唤醒执行另一段代码，并在他们的“上下文”之间切换。
</div>
<div style="margin-top:.625em;">
    不要把它与并行性（parallelism）混淆，虽然这确实容易混淆，但它们是两个不同的东西。可以这样理解，绿色线程让我们更爽也更高效地工作，从而更有效地利用资源，而并行性就像在问题上投入更多资源。
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">绪论及基本概念</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<h3>这篇文章是写给谁的？</h3>

<div>在这篇文章中，我们会探索兔子洞中的世界（译者注：引喻爱丽丝漫游奇境记中的新世界），如果这听起来很可怕，那么这篇文章可能不适合你，回去过自己幸福的小日子吧。</div>

<div style="margin-top:.625em;">如果你是一个好奇的人，想要了解这些东西的运作方式，那么请继续读下去。也许你已经听说过 Go 及其提供的 goroutine，或者 Ruby、Julia 中的等价物，你知道如何使用它们但想知道它们是如何工作的——那么也请继续读下去。</div>

<div style="margin-top:.625em;">此外，这应该会很有趣，如果：</div>

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .325em;">
  <li>你是 Rust 的新手，想要了解有关其功能的更多信息。</li>
  <li>你已经跟进 Rust 社区中有关 async / await 、Pin-API 以及我们需要 Generator 的原因的讨论。考虑这种情况，我尝试将所有这些一并放在本文中。</li>
  <li>你想学习Rust中内联汇编的基础知识。</li>
  <li>你只是好奇。</li>
</ul>

<div style="margin-top:.625em;">好吧，加入我，我们将试图弄清楚我们需要了解的关于它们的一切。</div>

<div style="margin-top:.625em;">你不必是 Rust 程序员就能理解本文，但强烈建议你首先阅读一些基本语法。如果你想长时间跟踪或克隆代码仓库并且跑一下代码，你应该安装 Rust 并学习相关的基础知识。</div>

<div style="margin-top:.625em;">我在这里提供的所有代码都在一个文件中并且没有依赖项，这意味着你可以轻松地启动自己的工程并跟着本文完成编码，只要你真的想（我建议你想）。你甚至可以在Rust的代码演练页面上运行大部分代码。只是要记得使用编译器的nightly版本。</div>

<h3>可移植性和一些问题</h3>

<div>目前 <b>asm！</b> 宏存在一个问题，它不能在 <b>release</b> 模式下编译。它似乎与我在内联宏中使用的 <b>"= m"</b> 约束有关。</div>

<div style="margin-top:.625em;">2019-06-21 补充编辑：</div>

<div style="margin-top:.325em;">我决定解决这个问题并更改内联汇编以在发布版本上编译和运行。我已经在 OSX，Linux 和 Windows 上测试了代码。</div>

<h3>免责声明</h3>

<div>我不打算在这里做一个完美的实现。我正在一步步的尝试深入了解本质，并将其融入原本打算成为文章的内容，而不是扩展为一本小书。这个实现并不能体现 Rust 语言的最大优势 —— Rust的安全保证机制 —— 不过这确实显示了 Rust 的一个有趣的用法，代码大多非常干净，易于跟进。</div>

<div style="margin-top:.625em;">但是，如果你发现了可以使代码更安全而不会显著增加复杂性的地方，欢迎你在 Github 仓库中创建一个问题，甚至能提一个 Pull Request 就更棒了。</div>

<h3>鸣谢</h3>

<div>Quentin Carbonneaux 在 2013 年写了一篇很棒的文章，我以它作为主要的代码示例的灵感来源。感谢 nickelpro 提供有关 Windows 支持的帮助和反馈。</div>

<h3>补充编辑</h3>

<div>2019-06-18：实现 Windows 支持的新章节.</div>

<div style="margin-top:.325em;">2019-06-21：相当大的改变和清理。Valgrind 报告了一些代码问题并且崩溃了。现在已经修复，目前还没有未解决的问题。此外，代码现在可以在 debug 和 release 两种 build 模式上运行，而不会在所有平台上出现任何问题。感谢各位报告你们发现的问题。</div>

<div style="margin-top:.325em;">2019-06-26：支持 Windows 附录将 XMM 字段视为 64 位，但它们是 128 位，这是我的疏忽。纠正这一点为那一章增加了一些有趣的材料，但不幸的是也增加了一些复杂性。不管怎样，它现在已得到纠正和解释。</div>

<div style="margin-top:.325em;">2019-22-12: 增加一行代码来确保我们从分配器获取的内存是 16 字节对齐的。重构为在写入堆栈时使用“高”内存地址作为偏移量的基地址，因为这使对齐更加容易。感谢 @Veetaha 解决了这个问题。</div>

<h3>绿色线程</h3>

<div>绿色线程解决了一个开发中的常见问题。你不希望代码阻塞 CPU，使它无法执行有意义的工作。我们通过使用多任务来解决这个问题，它允许我们暂停执行某一段代码同时唤醒执行另一段代码，并在他们的 “上下文” 之间切换。</div>

<div style="margin-top:.325em;">不要把它与并行性（parallelism）混淆，虽然这确实容易混淆，但它们是两个不同的东西。可以这样理解，绿色线程让我们更爽也更高效地工作，从而更有效地利用资源，而并行性就像在问题上投入更多资源。</div>

<div style="margin-top:.325em;">通常有两种方法可以做到这一点：</div>

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .125em;">
  <li>抢占式多任务处理</li>
  <li>非抢占式多任务处理（或协同多任务处理）</li>
</ul>

<h3>抢占式多任务处理</h3>

<div>某个外部调度程序停止当前任务并在切换回去之前运行另一个任务。在这种情况下，任务本身没有什么发言权，决定是由 “另外的东西”（通常是某种调度程序）做出的。操作系统内核用的就是这种方式，即允许你在一个单线程系统上使用 UI 界面的同时还进行 CPU 进行计算。我们不打算探讨这种线程，但我觉得当你理解一个其中一个范式时，你会更好的理解这两种范式。</div>

<h3>非抢占式多任务处理</h3>

<div>这就是我们要探讨的内容。一个任务由自己决定什么时候 CPU 会更好地做其他事情而不是等待当前任务会发生的事情。通常，它是通过对调度程序产生（yielding）控制来实现的。一个正常的用例是，在会造成阻塞的事情发生时产生控制，比如 IO 操作。当控制产生时，中央调度程序会指示 CPU 继续处理另一个就绪的任务，而不会阻塞。</div>

<h3>背景信息</h3>

<div>这是本书中最技术性的部分，但如果我们真的想要理解，这是必经之路。我将保证尽可能快地回归重点，我们很快就会开始写代码。</div>

<div style="margin-top:.325em;">让我们开始吧! 首先，我们将直接干扰和控制 CPU。这样可移植性不是很好，因为有很多种 CPU。不过主要思路是一样的，但实现细节的一小部分将有所不同。</div>

<div style="margin-top:.325em;">我们将介绍一种比较常用的体系结构：x86-64。</div>

<div style="margin-top:.325em;">在这种架构中，CPU 具有一组16个寄存器：</div>


<table style="color:darkslateblue;margin:.5em 0;line-height:1.3em;width:100%;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:140px;">Register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:600px;">Usage</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee saved</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rax</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary register; with variable arguments passes information about the number of vector registers used; 1<sup>st</sup> return register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rbx</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rcx</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 4<sup>th</sup> integer argument to functions used to pass 3<sup>rd</sup> argument to functions; 2<sup>nd</sup> return register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rdx</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 3<sup>rd</sup> argument to functions; 2<sup>nd</sup> return register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rsp</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">stack pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rbp</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved register; optionally used as frame pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rsi</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 2<sup>nd</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rdi</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 1<sup>st</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r8</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 5<sup>th</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r9</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 6<sup>th</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r10</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary register, used for passing a function's static chain pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r11</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r12-r14</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r15</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved register; optionally used as GOT base pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%xmm0-%xmm1</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass and return floating point arguments</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%xmm2-%xmm7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass floating point arguments</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%xmm8-%xmm15</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%mm0-%mm7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%k0-%k7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%st0,%st1</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers, used to return long double arguments</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%st2,%st7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%fs</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Reserved for system (as thread specific data register)</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">mxcsr</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">SSE2 control and status word</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">partial</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">x87 SW</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">x87 status word</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">x87 CW</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">x87 control word</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
    </tbody>
</table>

<div style="margin-top:.325em;">如果你有兴趣，可以在这里找到规范的其余部分：https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI。</div>

<div style="margin-top:.325em;">我们现在感兴趣的是标记为 “callee saved” 的寄存器。正是这些寄存器记录我们程序的上下文：下一个的运行指令、基本指针、栈指针等等。我们稍后会详细了解这一点。</div>

<div style="margin-top:.325em;">如果我们想直接向 CPU 发号施令，我们需要一些用汇编语言编写的最小代码，幸运的是我们只需要知道一些非常基本的汇编指令。比如如何在寄存器之间移动值：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
mov  rax, rsp
</pre>

<div style="margin-top:.625em;">Windows 的约定略有不同。在 Windows 上，寄存器 XMM6:XMM15 也是被调用者保存的，如果我们的函数使用它们，则必须保存和恢复。我们的代码在 Windows 上运行正常，即使我们在此示例中仅使用 psABI 约定。</div>

<div style="margin-top:.625em;">还有一个细微的区别，你可以在附录：支持 Windows 中读到我们解决的整个过程。你仍然可以继续跟进，因为所有内容都可以在 Windows 上运行，但这不会是一个正确的实现。</div>

<h3>汇编语言的超级快速介绍</h3>

<div>首先，也是最重要的，汇编语言的可移植性不是很好，每个 CPU 可能都有一组特殊的指令，但有些指令在今天的大多数台式计算机上很常见。有两种流行的方言：AT&T方言和英特尔方言。</div>

<div style="margin-top:.325em;">在 Rust 中编写内联汇编时，AT&T 方言是标准，但在 Rust 中我们可以指定我们想要使用 “英特尔”方言。Rust 主要将它留给 LLVM （译者注：LLVM 是 Rust 编译器的后端）来处理内联汇编，而 LLVM 的内联汇编非常类似于在 C 中编写内联汇编时使用的语法。这样可以更容易地查看 C 内联 ASM 以进行学习，因为语法将非常熟悉（虽然不完全相同）。</div>

<div style="margin-top:.325em;">我们将在示例中使用AT&T方言。</div>

<div style="margin-top:.325em;">汇编语言具有强大的向后兼容性保证。这就是为什么你会看到相同的寄存器以不同的方式处理。让我们看一下我们先前那个例子里的%rax寄存器：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
%rax  # 64位寄存器（8字节）
%eax  # “rax”寄存器的低32位 
%ax   # “rax”寄存器的低16位 
%ah   # “rax”寄存器的“ax”部分的高8位 
%al   # “rax”寄存器的“ax”部分的低8位
</pre>

<div style="margin-top:.625em;">正如你所看到的，这基本上就是 CPU 发展的历史。由于目前大多数 CPU 都是 64 位，我们将在代码中使用 64 位寄存器。</div>

<div style="margin-top:.625em;">汇编中的字长（原文: the word size）也有历史原因。它起源于 CPU 拥有 16 位数据总线的时候，因此一个字是 16 位。这与我们的主题相关，因为在 AT&T 方言中，你会看到许多带有 “q”（四字，quad-word）或 “l”（长字，long-word）的说明。因此，movq 意味着移动 4 * 16位 = 64位。</div>

<div style="margin-top:.625em;">而一个普通的 mov 将使用寄存器的大小。这是英特尔方言的标准，也是我们在代码中使用的标准。</div>

<div style="margin-top:.625em;">我们将在下一章中详细介绍更多内联汇编的语法。</div>

<div style="margin-top:.625em;">还有一点需要注意的是，x86-64 上的堆栈对齐方式是 16 字节。记住这一点，后面要用。</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">一个能跑通的例子</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<h3>创建我们的项目</h3>

<div>首先，让我们在名为 green_threads 的文件夹中启动一个新项目。命令行执行：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
$ cargo init
</pre>

<div style="margin-top:.825em;">我们需要使用 nightly 版本的 Rust，因为我们将使用一些尚未稳定的功能：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
$ rustup override set nightly
</pre>

<div style="margin-top:.825em;">在我们的 main.rs 文件中，我们首先启用一个功能，它允许我们使用 asm! 宏：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
use core::arch::asm;
</pre>

<div style="margin-top:.825em;">我们在这里设置一个较小的栈尺寸，只有 48 个字节，这样我们可以在切换上下文之前打印并查看这个栈：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
const SSIZE: isize = 48;
</pre>

<div style="margin-top:.825em;">在 OSX 中使用这么小的栈的好像有些问题。此代码运行的最小值是 624 字节的栈大小。如果你想要遵循这个确切的例子，代码可以在 Rust Playground 上运行（但是由于最终代码中的循环，你需要等待大概 30 秒的超时时间）。</div>

<div style="margin-top:.825em;">然后，我们添加一个表示 CPU 状态的结构。我们现在只关注存储 “栈指针” 的寄存器，所以只需要添加下面的代码：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
#[derive(Debug, Default)]
#[repr(C)]
struct ThreadContext {
    rsp: u64,
}
</pre>

<div style="margin-top:.825em;">在后面的示例中，我们将使用之前链接中的规范文档中标记为 “callee saved”（由被调用者保存的）的所有寄存器。这些就是 x86-64 ABI 描述的寄存器中那些用来保存上下文的寄存器，但是现在我们只需要一个寄存器来使 CPU 跳转到我们的栈。</div>

<div style="margin-top:.825em;">需要注意的是，这个结构定义需要加上 #[repr(C)]，因为我们需要按照汇编代码的方式去访问数据。Rust 没有稳定的 ABI，因此我们无法确保它会在内存中以 rsp 作为前 8 个字节来表示。C 具有稳定的 ABI，这一属性正是在告诉编译器使用兼容 C-ABI 的内存布局。当然，我们的结构现在只有一个字段，但我们稍后会添加更多字段。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// 对于这个非常简单的例子，我们将定义一个函数，它只打印一条消息，然后永远循环：
fn hello() -> ! {
    println!("I LOVE WAKING UP ON A NEW STACK!");
    loop {}
}
</pre>

<div style="margin-top:.825em;">接下来是我们的内联汇编，我们切换到自己的栈。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// unsafe fn gt_switch(new: *const ThreadContext) {
//     asm!("
//         mov 0x00($0), %rsp
//         ret
//         "
//     :
//     : "r"(new)
//     :
//     : "alignstack" // 目前没有这句也可以工作，不过后面会用到
//     );
// }

unsafe fn gt_switch(new: *const ThreadContext) {
    asm!(
        "mov rsp, [{0} + 0x00]",
        "ret",
        in(reg) new,
    );
}

</pre>

<div style="margin-top:.825em;">我们在这里使用了一个技巧。我们写入要在新栈上运行的函数的地址。然后我们将存储此地址的第一个字节的地址传递给 rsp 寄存器（我们设置给 new.rsp 的地址值将指向位于我们自己的栈上的地址，该地址将导致上述函数被调用）。我讲清楚了吗？</div>

<div style="margin-top:.825em;">ret 关键字将程序控制转移到位于栈顶部的返回地址。由于我们将地址推送到 %rsp 寄存器，因此CPU会认为它是当前运行的函数的返回地址，因此当我们传递 ret 指令时，它会直接返回到我们自己的栈中。CPU 做的第一件事就是读取函数的地址并运行它。</div>

<h3>Rust 内联汇编宏的快速入门</h3>

<div>如果您之前没有使用内联汇编，可能会看起来很陌生，但我们稍后会使用扩展版本来切换上下文，所以我将逐行解释我们正在做什么: 
unsafe 是一个关键字，表示 Rust 无法在我们编写的函数中强制执行安全保证。由于我们直接操作 CPU，这绝对是不安全的。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
gt_switch(new: *const ThreadContext)
</pre>

<div style="margin-top:.825em;">在这里我们获取一个指向 ThreadContext 实例的指针，我们只读取一个字段。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
asm!("
</pre>

<div style="margin-top:.825em;">这是 Rust 标准库中的 asm! 宏。它将检查我们的语法，在遇到看起来不像 AT&T（默认情况下）汇编语法的情况时会产生一个错误消息。
这个宏里第一个输入是汇编模板：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
mov 0x00($0), %rsp
</pre>

<div style="margin-top:.825em;">这是一个简单的指令，它将存储在基地址为 {0} 偏移量为 0x00 处的值（这意味着在十六进制中完全没有偏移）移动到 rsp 寄存器。由于 rsp 寄存器存储指向栈上下一个值的指针，因此我们有效地将我们提供的地址压到当前的栈上，覆盖了当前已有的值。</div>

<div style="margin-top:.825em;">在普通的汇编代码中，你不会看到这样使用的 $0。这是汇编模板的一部分，是第一个参数的占位符。参数编号为 0,1,2 …… 从输出参数开始，然后继续输入参数。我们这里只有一个输入参数，对应于 $0。</div>

<div style="margin-top:.825em;">如果在普通汇编中遇到 $，它很可能意味着一个立即值（一个整数常量），但这取决于（是的，$可以表示方言之间以及 x86 汇编和 x86-64 汇编之间的不同之处）。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
ret
</pre>

<div style="margin-top:.825em;">ret 关键字指示 CPU 从栈顶部弹出一个内存位置，然后无条件跳转到该位置。实际上我们已经劫持了我们的 CPU 并使其返回到我们的栈:</div>

<div style="margin-top:.825em;">内联 ASM 与普通 ASM 略有不同。我们在汇编模板后传递了四个附加参数。这是第一个被称为 output（输出）的，它是我们传递输出参数的地方，这些参数是我们想要在 Rust 函数中用作返回值的参数。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
: "r"(new)
</pre>

<div style="margin-top:.825em;">第二个是我们的输入参数。在编写内联汇编时，"r" 被称为一个 constraint（约束）。您可以使用这些约束来有效地指导编译器决定放置输入的位置（例如，在一个寄存器中作为值或将其用作“内存”位置）。 "r" 仅表示将其放入编译器选择的通用寄存器中。内联汇编中的约束本身是一个很大的课题，幸运的是我们的需求很简单:</div>

<div style="margin-top:.825em;">下一个选项是 clobber 列表，您可以在其中指定编译器不应触及的寄存器，并让它知道我们要在汇编代码中管理这些寄存器。如果我们弹出栈的任何值，我们需要在这里指定哪些寄存器并让编译器知道，因此它知道它不能自由地使用这些寄存器。我们不需要它，因为我们返回了一个全新的栈。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
: "alignstack"
</pre>

<div style="margin-top:.825em;">最后一个是我们的 options（选项）。这些对于 Rust 来说是独一无二的，我们可以设置的选项由三种：alignstack，volatile 和 intel。我会向你介绍文档以了解它们，在这里有具体解释。值得注意的是，我们需要为代码指定 “对齐栈（alignstack）” 才能在 Windows 上运行。</div>

<h3>运行我们的例子</h3>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// fn main(){
// 
//     let mut ctx = ThreadContext::default();
//     let mut stack = vec![0_u8; SSIZE as usize];
//     let stack_ptr = stack.as_mut_ptr();
// 
//     unsafe {
//         std::ptr::write(stack_ptr.offset(SSIZE - 16) as * mut u64, hello as u64);
//         ctx.rsp = stack_ptr.offset(SSIZE - 16) as u64;
//         gt_switch(&mut ctx);
//     }
// 
// }

fn main() {

    let mut ctx = ThreadContext::default();
    let mut stack = vec![0_u8; SSIZE as usize];

    unsafe {
        let stack_bottom = stack.as_mut_ptr().offset(SSIZE);
        let sb_aligned = (stack_bottom as usize & !15) as *mut u8;
        std::ptr::write(sb_aligned.offset(-16) as *mut u64, hello as u64);
        ctx.rsp = sb_aligned.offset(-16) as u64;
        gt_switch(&mut ctx);
    }

}
</pre>

<div style="margin-top:.825em;">所以这实际上是在设计我们的新栈。 hello 已经是一个指针了（一个函数指针），所以我们可以直接把它转换为一个 u64，因为 64 位系统上的所有指针都是 64 位，然后我们将这个指针写入我们的新栈。</div>

<div style="margin-top:.825em;">我们将在下一章中详细讨论栈，但现在我们需要知道的一件事是栈向下增长。如果我们的 48 字节栈在索引 0处开始，并在索引 47 处结束，则索引 32 将是从栈末尾开始的 16 字节偏移量的第一个索引。</div>

<div style="margin-top:.825em;">请注意，我们将指针写入距离栈底部16字节的偏移量（还记得我写的关于16字节对齐的内容吗？）。</div>

<div style="margin-top:.825em;">我们把它作为指向 u64 的指针而不是指向 u8 的指针。我们想要写入位置 32、33、34、35、36、37、38、39，这是我们存储 u64 所需的 8 字节空间。如果我们不进行这个类型转换，我们实际上是在尝试将 u64 写入位置 32（译者注：即将一个 u64 写入到一个 u8 中，显然存不下），这不是我们想要的。</div>

<div style="margin-top:0.825em;background-color:antiquewhite;padding:0.8em 1em;color:blueviolet;">译者注：stack_ptr 的类型为 * mut u8，stack_ptr.offset(SSIZE - 16) 也是 * mut u8。</div>

<div style="margin-top:.825em;">我们将 rsp（栈指针）设置为 栈中索引为 32 的内存地址，我们传递的不是存储在该位置的 u64 值而是首字节的地址。</div>

<div style="margin-top:0.825em;background-color:antiquewhite;padding:0.8em 1em;color:blueviolet;">译者注：如果传递的是存储在该位置的值，代码就应该是 (stack_ptr.offset(SSIZE - 16) as * mut u64).read()，即 hello 函数指针的值；如果是首字节地址，就是上面那段代码中的 stack_ptr.offset(SSIZE - 16) as u64（这个地址以 u64 类型存储，因为我们要把它赋值给 u64 类型的 ctx.rsp）。</div>

<div style="margin-top:.825em;">当我们执行 cargo run 命令时，我们将看到如下输出：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:black;color:white;font-size:.825em;">
Finished dev [unoptimized + debuginfo] target(s) in 0.58s
Running `target\debug\green_thread_start.exe`
I LOVE WAKING UP ON A NEW STACK!
</pre>

<div style="margin-top:.825em;">好的，究竟发生了什么？我们在任何时候都没有调用函数 hello，但它仍然运行了。发生的事情是我们实际上让 CPU 跳转到我们自己的栈并在那里执行代码。我们迈出了实现上下文切换的第一步。</div>

<div style="margin-top:.825em;">在接下来的章节中，我们会在实现绿色线程之前先探讨一点栈相关的内容，这个过程会更加容易，因为目前我们已经涵盖了很多基础知识。</div>

<div style="margin-top:.825em;">如果要运行它，可以在这里查看完整代码。</div>

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">栈</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<div>这一点很重要。计算机只有内存，它没有特殊的“栈”内存和“堆”内存，它们都是同一个内存的某一部分。</div>

<div style="margin-top:.825em;">它们不同之处在于如何访问和使用该部分内存。栈支持在内存的连续部分上使用简单的入栈/弹栈指令，这使得它使用起来很快。堆内存由内存分配器按需分配，并且可以分散在不同的位置。</div>

<div style="margin-top:.825em;">我们不会在这里讨论栈和堆之间的差异，因为有很多文章详细解释它们，包括 Rust 编程语言中的一章。</div>

<h3>栈是什么样的</h3>

<div>
  <img style="max-width:260px" src="/images/rust/14143541_62a82c3d42cd576347.webp" />
</div>

<div style="margin-top:.625em;">让我们从这张简化的栈示意图开始。64 位 CPU 一次读取 8 个字节，尽管我们看到栈的自然方式是一长行的 <b>u8</b>；所以当我们传递指针时，我们需要确保传入的指针指向 <b>0016</b>, <b>0008</b> 或上例中的 <b>0000</b>。</div>

<div style="margin-top:.625em;">栈向下增长，因此我们从顶部开始向下工作。</div>

<div style="margin-top:.625em;">当我们将栈指针设置为 <b>16 字节对齐</b> 的栈时，我们需要确保栈指针指向那些地址值为 16 的倍数的位置。在上面的示例中，满足此要求的唯一地址是 0008（记住栈从顶部开始）。</div>

<div style="margin-top:.625em;">如果我们在上一章中添加以下代码行，就在我们在 <b>main</b> 函数中进行切换之前，我们可以有效地打印出我们的栈并查看它：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// for i in (0..SSIZE).rev() {
//   println!("mem: {}, val: {}", stack_ptr.offset(i as isize) as usize, *stack_ptr.offset(i as isize))
// }

for i in (0..SSIZE).rev() {
    println!("mem: {}, val: {}", sb_aligned.offset(i as isize) as usize, *sb_aligned.offset(i as isize))
}
</pre>

<div style="margin-top:.825em;">我们得到的输出是：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:black;color:white;font-size:.625em;">
<span style="color:gray;">01.</span> mem: 94846750517871, val: 0          <span style="color:gray;">01.</span> mem: 140259484523967, val: 255
<span style="color:gray;">02.</span> mem: 94846750517870, val: 0          <span style="color:gray;">02.</span> mem: 140259484523966, val: 255
<span style="color:gray;">03.</span> mem: 94846750517869, val: 0          <span style="color:gray;">03.</span> mem: 140259484523965, val: 255
<span style="color:gray;">04.</span> mem: 94846750517868, val: 0          <span style="color:gray;">04.</span> mem: 140259484523964, val: 255
<span style="color:gray;">05.</span> mem: 94846750517867, val: 0          <span style="color:gray;">05.</span> mem: 140259484523963, val: 255
<span style="color:gray;">06.</span> mem: 94846750517866, val: 0          <span style="color:gray;">06.</span> mem: 140259484523962, val: 255
<span style="color:gray;">07.</span> mem: 94846750517865, val: 0          <span style="color:gray;">07.</span> mem: 140259484523961, val: 255
<span style="color:gray;">08.</span> mem: 94846750517864, val: 0          <span style="color:gray;">08.</span> mem: 140259484523960, val: 255
<span style="color:gray;">09.</span> mem: 94846750517863, val: 0          <span style="color:gray;">09.</span> mem: 140259484523959, val: 0
<span style="color:gray;">10.</span> mem: 94846750517862, val: 0          <span style="color:gray;">10.</span> mem: 140259484523958, val: 0
<span style="color:gray;">11.</span> mem: 94846750517861, val: 86         <span style="color:gray;">11.</span> mem: 140259484523957, val: 0  
<span style="color:gray;">12.</span> mem: 94846750517860, val: 67         <span style="color:gray;">12.</span> mem: 140259484523956, val: 0  
<span style="color:gray;">13.</span> mem: 94846750517859, val: 56         <span style="color:gray;">13.</span> mem: 140259484523955, val: 0  
<span style="color:gray;">14.</span> mem: 94846750517858, val: 252        <span style="color:gray;">14.</span> mem: 140259484523954, val: 0  
<span style="color:gray;">15.</span> mem: 94846750517857, val: 205        <span style="color:gray;">15.</span> mem: 140259484523953, val: 0  
<span style="color:gray;">16.</span> mem: 94846750517856, val: 240        <span style="color:gray;">16.</span> mem: 140259484523952, val: 2  
<span style="color:gray;">17.</span> mem: 94846750517855, val: 0          <span style="color:gray;">17.</span> mem: 140259484523951, val: 0
<span style="color:gray;">18.</span> mem: 94846750517854, val: 0          <span style="color:gray;">18.</span> mem: 140259484523950, val: 0
<span style="color:gray;">19.</span> mem: 94846750517853, val: 0          <span style="color:gray;">19.</span> mem: 140259484523949, val: 0
<span style="color:gray;">20.</span> mem: 94846750517852, val: 0          <span style="color:gray;">20.</span> mem: 140259484523948, val: 0
<span style="color:gray;">21.</span> mem: 94846750517851, val: 0          <span style="color:gray;">21.</span> mem: 140259484523947, val: 0
<span style="color:gray;">22.</span> mem: 94846750517850, val: 0          <span style="color:gray;">22.</span> mem: 140259484523946, val: 6
<span style="color:gray;">23.</span> mem: 94846750517849, val: 0          <span style="color:gray;">23.</span> mem: 140259484523945, val: 5
<span style="color:gray;">24.</span> mem: 94846750517848, val: 0          <span style="color:gray;">24.</span> mem: 140259484523944, val: 185
<span style="color:gray;">25.</span> mem: 94846750517847, val: 0          <span style="color:gray;">25.</span> mem: 140259484523943, val: 77
<span style="color:gray;">26.</span> mem: 94846750517846, val: 0          <span style="color:gray;">26.</span> mem: 140259484523942, val: 85
<span style="color:gray;">27.</span> mem: 94846750517845, val: 0          <span style="color:gray;">27.</span> mem: 140259484523941, val: 84
<span style="color:gray;">28.</span> mem: 94846750517844, val: 0          <span style="color:gray;">28.</span> mem: 140259484523940, val: 90
<span style="color:gray;">29.</span> mem: 94846750517843, val: 0          <span style="color:gray;">29.</span> mem: 140259484523939, val: 0
<span style="color:gray;">30.</span> mem: 94846750517842, val: 0          <span style="color:gray;">30.</span> mem: 140259484523938, val: 0
<span style="color:gray;">31.</span> mem: 94846750517841, val: 0          <span style="color:gray;">31.</span> mem: 140259484523937, val: 0
<span style="color:gray;">32.</span> mem: 94846750517840, val: 0          <span style="color:gray;">32.</span> mem: 140259484523936, val: 0
<span style="color:gray;">33.</span> mem: 94846750517839, val: 0          <span style="color:gray;">33.</span> mem: 140259484523935, val: 0
<span style="color:gray;">34.</span> mem: 94846750517838, val: 0          <span style="color:gray;">34.</span> mem: 140259484523934, val: 0
<span style="color:gray;">35.</span> mem: 94846750517837, val: 0          <span style="color:gray;">35.</span> mem: 140259484523933, val: 32
<span style="color:gray;">36.</span> mem: 94846750517836, val: 0          <span style="color:gray;">36.</span> mem: 140259484523932, val: 160
<span style="color:gray;">37.</span> mem: 94846750517835, val: 0          <span style="color:gray;">37.</span> mem: 140259484523931, val: 0
<span style="color:gray;">38.</span> mem: 94846750517834, val: 0          <span style="color:gray;">38.</span> mem: 140259484523930, val: 0
<span style="color:gray;">39.</span> mem: 94846750517833, val: 0          <span style="color:gray;">39.</span> mem: 140259484523929, val: 0
<span style="color:gray;">40.</span> mem: 94846750517832, val: 0          <span style="color:gray;">40.</span> mem: 140259484523928, val: 0
<span style="color:gray;">41.</span> mem: 94846750517831, val: 0          <span style="color:gray;">41.</span> mem: 140259484523927, val: 0
<span style="color:gray;">42.</span> mem: 94846750517830, val: 0          <span style="color:gray;">42.</span> mem: 140259484523926, val: 0
<span style="color:gray;">43.</span> mem: 94846750517829, val: 0          <span style="color:gray;">43.</span> mem: 140259484523925, val: 0
<span style="color:gray;">44.</span> mem: 94846750517828, val: 0          <span style="color:gray;">44.</span> mem: 140259484523924, val: 0
<span style="color:gray;">45.</span> mem: 94846750517827, val: 0          <span style="color:gray;">45.</span> mem: 140259484523923, val: 77
<span style="color:gray;">46.</span> mem: 94846750517826, val: 0          <span style="color:gray;">46.</span> mem: 140259484523922, val: 85
<span style="color:gray;">47.</span> mem: 94846750517825, val: 0          <span style="color:gray;">47.</span> mem: 140259484523921, val: 84
<span style="color:gray;">48.</span> mem: 94846750517824, val: 0          <span style="color:gray;">48.</span> mem: 140259484523920, val: 90
I LOVE WAKING UP ON A NEW STACK!
-----------------------------------
</pre>

<div style="margin-top:.825em;">我已经在这里把内存地址打印成 <b>u64</b> 类型，这样如果你不熟悉十六进制也容易肉眼解析。</div>

<div style="margin-top:.425em;">首先要注意的是，这只是一块连续的内存，从地址 94846750517824 开始，到 94846750517871 结束。</div>

<div style="margin-top:.425em;">地址 94846750517856 到 94846750517863 应该需要我们特别注意。第一个地址是我们的“栈指针”的地址，我们写入 CPU 的 <b>%rsp</b> 寄存器的值。范围表示在我们进行切换之前写入栈的值。</div>

<div style="margin-top:.425em;">换句话说，值 <b>240,205,252,56,67,86,0,0</b> 是指向我们的 <b>hello()</b> 函数的指针，只是写成了多个 <b>u8</b> 类型的值。</div>

<div style="margin-top:.425em;">这里有一个有趣的注意事项是 CPU 将 <b>u64</b> 写为 <b>u8</b> 字节的顺序取决于它的字节顺序。我将简单地参考维基百科的文章，但如果你试图手动解析这些数字，你必须牢记这一点。</div>

<div style="margin-top:.425em;">当我们编写更复杂的函数时，我们极小的 48 字节栈将很快耗尽空间，你看，当我们运行我们在 Rust 中编写的函数时，我们的代码将指示 CPU 在我们的栈上入栈和弹出值来执行我们的程序。</div>

<h3>栈尺寸</h3>

<div>当你在大多数现代操作系统中启动进程时，标准栈大小通常为 8 MB，但可以进行不同的配置，这对于大多数程序来说已经足够了，但是需要由我们开发者保证使用的时候不会超出这个大小。这就是我们大多数人经历过的可怕的 “栈溢出” 的原因。</div>

<div style="margin-top:.425em;">但是，当我们自己控制栈时，我们可以选择我们想要的大小。例如，在 Web 服务器中运行简单函数时，每个上下文都用 8 MB 是超出我们的需要的，因此通过减少栈大小，我们可以在一台机器上运行数百万个绿色线程，而如果使用操作系统提供的栈，我们会更快把内存用光。</div>

<h3>可增长的栈</h3>

<div>某些实现使用可增长的栈。这让我们可以只分配一小部分内存就足够为大多数任务使用，但是当我们用光这个栈时它不会导致栈溢出，而是分配一个新的更大的栈并将所有内容从当前栈中移到这个新的更大的栈上，并可以恢复程序继续执行。</div>

<div style="margin-top:.425em;">Go 语言就是一个这样的例子。它从一个 8 KB 的栈开始，当它的空间用完时，它会重新分配到一个更大的栈。但是正如编程中的每一件事都是有代价的，所有指针都需要正确地被更新，这不是一件容易的事。如果你对 Go 如何处理它的栈更感兴趣（这是可增长栈的使用和权衡的一个很好的例子）可以参看这篇文章：https://blog.cloudflare.com/how-stacks-are-handled-in-go/</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

</c:component>
