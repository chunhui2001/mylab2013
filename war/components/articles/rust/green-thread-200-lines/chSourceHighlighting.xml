<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div>
    绿色线程解决了一个开发中的常见问题。你不希望代码阻塞 CPU，使它无法执行有意义的工作。我们通过使用多任务来解决这个问题，它允许我们暂停执行某一段代码同时唤醒执行另一段代码，并在他们的“上下文”之间切换。
</div>
<div style="margin-top:.625em;">
    不要把它与并行性（parallelism）混淆，虽然这确实容易混淆，但它们是两个不同的东西。可以这样理解，绿色线程让我们更爽也更高效地工作，从而更有效地利用资源，而并行性就像在问题上投入更多资源。
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">绪论及基本概念</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<h3>这篇文章是写给谁的？</h3>

<div>在这篇文章中，我们会探索兔子洞中的世界（译者注：引喻爱丽丝漫游奇境记中的新世界），如果这听起来很可怕，那么这篇文章可能不适合你，回去过自己幸福的小日子吧。</div>

<div style="margin-top:.625em;">如果你是一个好奇的人，想要了解这些东西的运作方式，那么请继续读下去。也许你已经听说过 Go 及其提供的 goroutine，或者 Ruby、Julia 中的等价物，你知道如何使用它们但想知道它们是如何工作的——那么也请继续读下去。</div>

<div style="margin-top:.625em;">此外，这应该会很有趣，如果：</div>

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .325em;">
  <li>你是 Rust 的新手，想要了解有关其功能的更多信息。</li>
  <li>你已经跟进 Rust 社区中有关 async / await 、Pin-API 以及我们需要 Generator 的原因的讨论。考虑这种情况，我尝试将所有这些一并放在本文中。</li>
  <li>你想学习Rust中内联汇编的基础知识。</li>
  <li>你只是好奇。</li>
</ul>

<div style="margin-top:.625em;">好吧，加入我，我们将试图弄清楚我们需要了解的关于它们的一切。</div>

<div style="margin-top:.625em;">你不必是 Rust 程序员就能理解本文，但强烈建议你首先阅读一些基本语法。如果你想长时间跟踪或克隆代码仓库并且跑一下代码，你应该安装 Rust 并学习相关的基础知识。</div>

<div style="margin-top:.625em;">我在这里提供的所有代码都在一个文件中并且没有依赖项，这意味着你可以轻松地启动自己的工程并跟着本文完成编码，只要你真的想（我建议你想）。你甚至可以在Rust的代码演练页面上运行大部分代码。只是要记得使用编译器的nightly版本。</div>

<h3>可移植性和一些问题</h3>

<div>目前 <b>asm！</b> 宏存在一个问题，它不能在 <b>release</b> 模式下编译。它似乎与我在内联宏中使用的 <b>"= m"</b> 约束有关。</div>

<div style="margin-top:.625em;">2019-06-21 补充编辑：</div>

<div style="margin-top:.325em;">我决定解决这个问题并更改内联汇编以在发布版本上编译和运行。我已经在 OSX，Linux 和 Windows 上测试了代码。</div>

<h3>免责声明</h3>

<div>我不打算在这里做一个完美的实现。我正在一步步的尝试深入了解本质，并将其融入原本打算成为文章的内容，而不是扩展为一本小书。这个实现并不能体现 Rust 语言的最大优势 —— Rust的安全保证机制 —— 不过这确实显示了 Rust 的一个有趣的用法，代码大多非常干净，易于跟进。</div>

<div style="margin-top:.625em;">但是，如果你发现了可以使代码更安全而不会显著增加复杂性的地方，欢迎你在 Github 仓库中创建一个问题，甚至能提一个 Pull Request 就更棒了。</div>

<h3>鸣谢</h3>

<div>Quentin Carbonneaux 在 2013 年写了一篇很棒的文章，我以它作为主要的代码示例的灵感来源。感谢 nickelpro 提供有关 Windows 支持的帮助和反馈。</div>

<h3>补充编辑</h3>

<div>2019-06-18：实现 Windows 支持的新章节.</div>

<div style="margin-top:.325em;">2019-06-21：相当大的改变和清理。Valgrind 报告了一些代码问题并且崩溃了。现在已经修复，目前还没有未解决的问题。此外，代码现在可以在 debug 和 release 两种 build 模式上运行，而不会在所有平台上出现任何问题。感谢各位报告你们发现的问题。</div>

<div style="margin-top:.325em;">2019-06-26：支持 Windows 附录将 XMM 字段视为 64 位，但它们是 128 位，这是我的疏忽。纠正这一点为那一章增加了一些有趣的材料，但不幸的是也增加了一些复杂性。不管怎样，它现在已得到纠正和解释。</div>

<div style="margin-top:.325em;">2019-22-12: 增加一行代码来确保我们从分配器获取的内存是 16 字节对齐的。重构为在写入堆栈时使用“高”内存地址作为偏移量的基地址，因为这使对齐更加容易。感谢 @Veetaha 解决了这个问题。</div>

<h3>绿色线程</h3>

<div>绿色线程解决了一个开发中的常见问题。你不希望代码阻塞 CPU，使它无法执行有意义的工作。我们通过使用多任务来解决这个问题，它允许我们暂停执行某一段代码同时唤醒执行另一段代码，并在他们的 “上下文” 之间切换。</div>

<div style="margin-top:.325em;">不要把它与并行性（parallelism）混淆，虽然这确实容易混淆，但它们是两个不同的东西。可以这样理解，绿色线程让我们更爽也更高效地工作，从而更有效地利用资源，而并行性就像在问题上投入更多资源。</div>

<div style="margin-top:.325em;">通常有两种方法可以做到这一点：</div>

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .125em;">
  <li>抢占式多任务处理</li>
  <li>非抢占式多任务处理（或协同多任务处理）</li>
</ul>

<h3>抢占式多任务处理</h3>

<div>某个外部调度程序停止当前任务并在切换回去之前运行另一个任务。在这种情况下，任务本身没有什么发言权，决定是由 “另外的东西”（通常是某种调度程序）做出的。操作系统内核用的就是这种方式，即允许你在一个单线程系统上使用 UI 界面的同时还进行 CPU 进行计算。我们不打算探讨这种线程，但我觉得当你理解一个其中一个范式时，你会更好的理解这两种范式。</div>

<h3>非抢占式多任务处理</h3>

<div>这就是我们要探讨的内容。一个任务由自己决定什么时候 CPU 会更好地做其他事情而不是等待当前任务会发生的事情。通常，它是通过对调度程序产生（yielding）控制来实现的。一个正常的用例是，在会造成阻塞的事情发生时产生控制，比如 IO 操作。当控制产生时，中央调度程序会指示 CPU 继续处理另一个就绪的任务，而不会阻塞。</div>

<h3>背景信息</h3>

<div>这是本书中最技术性的部分，但如果我们真的想要理解，这是必经之路。我将保证尽可能快地回归重点，我们很快就会开始写代码。</div>

<div style="margin-top:.325em;">让我们开始吧! 首先，我们将直接干扰和控制 CPU。这样可移植性不是很好，因为有很多种 CPU。不过主要思路是一样的，但实现细节的一小部分将有所不同。</div>

<div style="margin-top:.325em;">我们将介绍一种比较常用的体系结构：x86-64。</div>

<div style="margin-top:.325em;">在这种架构中，CPU 具有一组16个寄存器：</div>


<table style="color:darkslateblue;margin:.5em 0;line-height:1.3em;width:100%;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:140px;">Register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:600px;">Usage</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee saved</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rax</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary register; with variable arguments passes information about the number of vector registers used; 1<sup>st</sup> return register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rbx</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rcx</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 4<sup>th</sup> integer argument to functions used to pass 3<sup>rd</sup> argument to functions; 2<sup>nd</sup> return register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rdx</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 3<sup>rd</sup> argument to functions; 2<sup>nd</sup> return register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rsp</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">stack pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rbp</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved register; optionally used as frame pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rsi</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 2<sup>nd</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%rdi</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 1<sup>st</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r8</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 5<sup>th</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r9</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass 6<sup>th</sup> argument to functions</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r10</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary register, used for passing a function's static chain pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r11</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary register</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r12-r14</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%r15</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">callee-saved register; optionally used as GOT base pointer</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%xmm0-%xmm1</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass and return floating point arguments</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%xmm2-%xmm7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">used to pass floating point arguments</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%xmm8-%xmm15</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%mm0-%mm7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%k0-%k7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%st0,%st1</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers, used to return long double arguments</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%st2,%st7</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">temporary registers</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">%fs</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Reserved for system (as thread specific data register)</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">mxcsr</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">SSE2 control and status word</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">partial</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">x87 SW</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">x87 status word</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">No</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight: normal;">x87 CW</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">x87 control word</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Yes</td>
        </tr>
    </tbody>
</table>

<div style="margin-top:.325em;">如果你有兴趣，可以在这里找到规范的其余部分：https://github.com/hjl-tools/x86-psABI/wiki/X86-psABI。</div>

<div style="margin-top:.325em;">我们现在感兴趣的是标记为 “callee saved” 的寄存器。正是这些寄存器记录我们程序的上下文：下一个的运行指令、基本指针、栈指针等等。我们稍后会详细了解这一点。</div>

<div style="margin-top:.325em;">如果我们想直接向 CPU 发号施令，我们需要一些用汇编语言编写的最小代码，幸运的是我们只需要知道一些非常基本的汇编指令。比如如何在寄存器之间移动值：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
mov  rax, rsp
</pre>

<div style="margin-top:.625em;">Windows 的约定略有不同。在 Windows 上，寄存器 XMM6:XMM15 也是被调用者保存的，如果我们的函数使用它们，则必须保存和恢复。我们的代码在 Windows 上运行正常，即使我们在此示例中仅使用 psABI 约定。</div>

<div style="margin-top:.625em;">还有一个细微的区别，你可以在附录：支持 Windows 中读到我们解决的整个过程。你仍然可以继续跟进，因为所有内容都可以在 Windows 上运行，但这不会是一个正确的实现。</div>

<h3>汇编语言的超级快速介绍</h3>

<div>首先，也是最重要的，汇编语言的可移植性不是很好，每个 CPU 可能都有一组特殊的指令，但有些指令在今天的大多数台式计算机上很常见。有两种流行的方言：AT&T方言和英特尔方言。</div>

<div style="margin-top:.325em;">在 Rust 中编写内联汇编时，AT&T 方言是标准，但在 Rust 中我们可以指定我们想要使用 “英特尔”方言。Rust 主要将它留给 LLVM （译者注：LLVM 是 Rust 编译器的后端）来处理内联汇编，而 LLVM 的内联汇编非常类似于在 C 中编写内联汇编时使用的语法。这样可以更容易地查看 C 内联 ASM 以进行学习，因为语法将非常熟悉（虽然不完全相同）。</div>

<div style="margin-top:.325em;">我们将在示例中使用AT&T方言。</div>

<div style="margin-top:.325em;">汇编语言具有强大的向后兼容性保证。这就是为什么你会看到相同的寄存器以不同的方式处理。让我们看一下我们先前那个例子里的%rax寄存器：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslateblue;color:white;font-size:.825em;">
%rax  # 64位寄存器（8字节）
%eax  # “rax”寄存器的低32位 
%ax   # “rax”寄存器的低16位 
%ah   # “rax”寄存器的“ax”部分的高8位 
%al   # “rax”寄存器的“ax”部分的低8位
</pre>

<div style="margin-top:.625em;">正如你所看到的，这基本上就是 CPU 发展的历史。由于目前大多数 CPU 都是 64 位，我们将在代码中使用 64 位寄存器。</div>

<div style="margin-top:.625em;">汇编中的字长（原文: the word size）也有历史原因。它起源于 CPU 拥有 16 位数据总线的时候，因此一个字是 16 位。这与我们的主题相关，因为在 AT&T 方言中，你会看到许多带有 “q”（四字，quad-word）或 “l”（长字，long-word）的说明。因此，movq 意味着移动 4 * 16位 = 64位。</div>

<div style="margin-top:.625em;">而一个普通的 mov 将使用寄存器的大小。这是英特尔方言的标准，也是我们在代码中使用的标准。</div>

<div style="margin-top:.625em;">我们将在下一章中详细介绍更多内联汇编的语法。</div>

<div style="margin-top:.625em;">还有一点需要注意的是，x86-64 上的堆栈对齐方式是 16 字节。记住这一点，后面要用。</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>




  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">一个能跑通的例子</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<h3>创建我们的项目</h3>

<div>首先，让我们在名为 green_threads 的文件夹中启动一个新项目。命令行执行：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
$ cargo init
</pre>

<div style="margin-top:.825em;">我们需要使用 nightly 版本的 Rust，因为我们将使用一些尚未稳定的功能：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
$ rustup override set nightly
</pre>

<div style="margin-top:.825em;">在我们的 main.rs 文件中，我们首先启用一个功能，它允许我们使用 asm! 宏：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
use core::arch::asm;
</pre>

<div style="margin-top:.825em;">我们在这里设置一个较小的栈尺寸，只有 48 个字节，这样我们可以在切换上下文之前打印并查看这个栈：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
const SSIZE: isize = 48;
</pre>

<div style="margin-top:.825em;">在 OSX 中使用这么小的栈的好像有些问题。此代码运行的最小值是 624 字节的栈大小。如果你想要遵循这个确切的例子，代码可以在 Rust Playground 上运行（但是由于最终代码中的循环，你需要等待大概 30 秒的超时时间）。</div>

<div style="margin-top:.825em;">然后，我们添加一个表示 CPU 状态的结构。我们现在只关注存储 “栈指针” 的寄存器，所以只需要添加下面的代码：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
#[derive(Debug, Default)]
#[repr(C)]
struct ThreadContext {
    rsp: u64,
}
</pre>

<div style="margin-top:.825em;">在后面的示例中，我们将使用之前链接中的规范文档中标记为 “callee saved”（由被调用者保存的）的所有寄存器。这些就是 x86-64 ABI 描述的寄存器中那些用来保存上下文的寄存器，但是现在我们只需要一个寄存器来使 CPU 跳转到我们的栈。</div>

<div style="margin-top:.825em;">需要注意的是，这个结构定义需要加上 #[repr(C)]，因为我们需要按照汇编代码的方式去访问数据。Rust 没有稳定的 ABI，因此我们无法确保它会在内存中以 rsp 作为前 8 个字节来表示。C 具有稳定的 ABI，这一属性正是在告诉编译器使用兼容 C-ABI 的内存布局。当然，我们的结构现在只有一个字段，但我们稍后会添加更多字段。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// 对于这个非常简单的例子，我们将定义一个函数，它只打印一条消息，然后永远循环：
fn hello() -> ! {
    println!("I LOVE WAKING UP ON A NEW STACK!");
    loop {}
}
</pre>

<div style="margin-top:.825em;">接下来是我们的内联汇编，我们切换到自己的栈。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// unsafe fn gt_switch(new: *const ThreadContext) {
//     asm!("
//         mov 0x00($0), %rsp
//         ret
//         "
//     :
//     : "r"(new)
//     :
//     : "alignstack" // 目前没有这句也可以工作，不过后面会用到
//     );
// }

unsafe fn gt_switch(new: *const ThreadContext) {
    asm!(
        "mov rsp, [{0} + 0x00]",
        "ret",
        in(reg) new,
    );
}

</pre>

<div style="margin-top:.825em;">我们在这里使用了一个技巧。我们写入要在新栈上运行的函数的地址。然后我们将存储此地址的第一个字节的地址传递给 rsp 寄存器（我们设置给 new.rsp 的地址值将指向位于我们自己的栈上的地址，该地址将导致上述函数被调用）。我讲清楚了吗？</div>

<div style="margin-top:.825em;">ret 关键字将程序控制转移到位于栈顶部的返回地址。由于我们将地址推送到 %rsp 寄存器，因此CPU会认为它是当前运行的函数的返回地址，因此当我们传递 ret 指令时，它会直接返回到我们自己的栈中。CPU 做的第一件事就是读取函数的地址并运行它。</div>

<h3>Rust 内联汇编宏的快速入门</h3>

<div>如果您之前没有使用内联汇编，可能会看起来很陌生，但我们稍后会使用扩展版本来切换上下文，所以我将逐行解释我们正在做什么: 
unsafe 是一个关键字，表示 Rust 无法在我们编写的函数中强制执行安全保证。由于我们直接操作 CPU，这绝对是不安全的。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
gt_switch(new: *const ThreadContext)
</pre>

<div style="margin-top:.825em;">在这里我们获取一个指向 ThreadContext 实例的指针，我们只读取一个字段。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
asm!("
</pre>

<div style="margin-top:.825em;">这是 Rust 标准库中的 asm! 宏。它将检查我们的语法，在遇到看起来不像 AT&T（默认情况下）汇编语法的情况时会产生一个错误消息。
这个宏里第一个输入是汇编模板：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
mov 0x00($0), %rsp
</pre>

<div style="margin-top:.825em;">这是一个简单的指令，它将存储在基地址为 {0} 偏移量为 0x00 处的值（这意味着在十六进制中完全没有偏移）移动到 rsp 寄存器。由于 rsp 寄存器存储指向栈上下一个值的指针，因此我们有效地将我们提供的地址压到当前的栈上，覆盖了当前已有的值。</div>

<div style="margin-top:.825em;">在普通的汇编代码中，你不会看到这样使用的 $0。这是汇编模板的一部分，是第一个参数的占位符。参数编号为 0,1,2 …… 从输出参数开始，然后继续输入参数。我们这里只有一个输入参数，对应于 $0。</div>

<div style="margin-top:.825em;">如果在普通汇编中遇到 $，它很可能意味着一个立即值（一个整数常量），但这取决于（是的，$可以表示方言之间以及 x86 汇编和 x86-64 汇编之间的不同之处）。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
ret
</pre>

<div style="margin-top:.825em;">ret 关键字指示 CPU 从栈顶部弹出一个内存位置，然后无条件跳转到该位置。实际上我们已经劫持了我们的 CPU 并使其返回到我们的栈:</div>

<div style="margin-top:.825em;">内联 ASM 与普通 ASM 略有不同。我们在汇编模板后传递了四个附加参数。这是第一个被称为 output（输出）的，它是我们传递输出参数的地方，这些参数是我们想要在 Rust 函数中用作返回值的参数。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
: "r"(new)
</pre>

<div style="margin-top:.825em;">第二个是我们的输入参数。在编写内联汇编时，"r" 被称为一个 constraint（约束）。您可以使用这些约束来有效地指导编译器决定放置输入的位置（例如，在一个寄存器中作为值或将其用作“内存”位置）。 "r" 仅表示将其放入编译器选择的通用寄存器中。内联汇编中的约束本身是一个很大的课题，幸运的是我们的需求很简单:</div>

<div style="margin-top:.825em;">下一个选项是 clobber 列表，您可以在其中指定编译器不应触及的寄存器，并让它知道我们要在汇编代码中管理这些寄存器。如果我们弹出栈的任何值，我们需要在这里指定哪些寄存器并让编译器知道，因此它知道它不能自由地使用这些寄存器。我们不需要它，因为我们返回了一个全新的栈。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
: "alignstack"
</pre>

<div style="margin-top:.825em;">最后一个是我们的 options（选项）。这些对于 Rust 来说是独一无二的，我们可以设置的选项由三种：alignstack，volatile 和 intel。我会向你介绍文档以了解它们，在这里有具体解释。值得注意的是，我们需要为代码指定 “对齐栈（alignstack）” 才能在 Windows 上运行。</div>

<h3>运行我们的例子</h3>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// fn main(){
// 
//     let mut ctx = ThreadContext::default();
//     let mut stack = vec![0_u8; SSIZE as usize];
//     let stack_ptr = stack.as_mut_ptr();
// 
//     unsafe {
//         std::ptr::write(stack_ptr.offset(SSIZE - 16) as * mut u64, hello as u64);
//         ctx.rsp = stack_ptr.offset(SSIZE - 16) as u64;
//         gt_switch(&mut ctx);
//     }
// 
// }

fn main() {

    let mut ctx = ThreadContext::default();
    let mut stack = vec![0_u8; SSIZE as usize];

    unsafe {
        let stack_bottom = stack.as_mut_ptr().offset(SSIZE);
        let sb_aligned = (stack_bottom as usize & !15) as *mut u8;
        std::ptr::write(sb_aligned.offset(-16) as *mut u64, hello as u64);
        ctx.rsp = sb_aligned.offset(-16) as u64;
        gt_switch(&mut ctx);
    }

}
</pre>

<div style="margin-top:.825em;">所以这实际上是在设计我们的新栈。 hello 已经是一个指针了（一个函数指针），所以我们可以直接把它转换为一个 u64，因为 64 位系统上的所有指针都是 64 位，然后我们将这个指针写入我们的新栈。</div>

<div style="margin-top:.825em;">我们将在下一章中详细讨论栈，但现在我们需要知道的一件事是栈向下增长。如果我们的 48 字节栈在索引 0处开始，并在索引 47 处结束，则索引 32 将是从栈末尾开始的 16 字节偏移量的第一个索引。</div>

<div style="margin-top:.825em;">请注意，我们将指针写入距离栈底部16字节的偏移量（还记得我写的关于16字节对齐的内容吗？）。</div>

<div style="margin-top:.825em;">我们把它作为指向 u64 的指针而不是指向 u8 的指针。我们想要写入位置 32、33、34、35、36、37、38、39，这是我们存储 u64 所需的 8 字节空间。如果我们不进行这个类型转换，我们实际上是在尝试将 u64 写入位置 32（译者注：即将一个 u64 写入到一个 u8 中，显然存不下），这不是我们想要的。</div>

<div style="margin-top:0.825em;background-color:antiquewhite;padding:0.8em 1em;color:blueviolet;">译者注：stack_ptr 的类型为 * mut u8，stack_ptr.offset(SSIZE - 16) 也是 * mut u8。</div>

<div style="margin-top:.825em;">我们将 rsp（栈指针）设置为 栈中索引为 32 的内存地址，我们传递的不是存储在该位置的 u64 值而是首字节的地址。</div>

<div style="margin-top:0.825em;background-color:antiquewhite;padding:0.8em 1em;color:blueviolet;">译者注：如果传递的是存储在该位置的值，代码就应该是 (stack_ptr.offset(SSIZE - 16) as * mut u64).read()，即 hello 函数指针的值；如果是首字节地址，就是上面那段代码中的 stack_ptr.offset(SSIZE - 16) as u64（这个地址以 u64 类型存储，因为我们要把它赋值给 u64 类型的 ctx.rsp）。</div>

<div style="margin-top:.825em;">当我们执行 cargo run 命令时，我们将看到如下输出：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:black;color:white;font-size:.825em;">
Finished dev [unoptimized + debuginfo] target(s) in 0.58s
Running `target\debug\green_thread_start.exe`
I LOVE WAKING UP ON A NEW STACK!
</pre>

<div style="margin-top:.825em;">好的，究竟发生了什么？我们在任何时候都没有调用函数 hello，但它仍然运行了。发生的事情是我们实际上让 CPU 跳转到我们自己的栈并在那里执行代码。我们迈出了实现上下文切换的第一步。</div>

<div style="margin-top:.825em;">在接下来的章节中，我们会在实现绿色线程之前先探讨一点栈相关的内容，这个过程会更加容易，因为目前我们已经涵盖了很多基础知识。</div>

<div style="margin-top:.825em;">如果要运行它，可以在这里查看完整代码。</div>

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>





  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">栈</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<div>这一点很重要。计算机只有内存，它没有特殊的“栈”内存和“堆”内存，它们都是同一个内存的某一部分。</div>

<div style="margin-top:.825em;">它们不同之处在于如何访问和使用该部分内存。栈支持在内存的连续部分上使用简单的入栈/弹栈指令，这使得它使用起来很快。堆内存由内存分配器按需分配，并且可以分散在不同的位置。</div>

<div style="margin-top:.825em;">我们不会在这里讨论栈和堆之间的差异，因为有很多文章详细解释它们，包括 Rust 编程语言中的一章。</div>

<h3>栈是什么样的</h3>

<div>
  <img style="max-width:260px" src="/images/rust/14143541_62a82c3d42cd576347.webp" />
</div>

<div style="margin-top:.625em;">让我们从这张简化的栈示意图开始。64 位 CPU 一次读取 8 个字节，尽管我们看到栈的自然方式是一长行的 <b>u8</b>；所以当我们传递指针时，我们需要确保传入的指针指向 <b>0016</b>, <b>0008</b> 或上例中的 <b>0000</b>。</div>

<div style="margin-top:.625em;">栈向下增长，因此我们从顶部开始向下工作。</div>

<div style="margin-top:.625em;">当我们将栈指针设置为 <b>16 字节对齐</b> 的栈时，我们需要确保栈指针指向那些地址值为 16 的倍数的位置。在上面的示例中，满足此要求的唯一地址是 0008（记住栈从顶部开始）。</div>

<div style="margin-top:.625em;">如果我们在上一章中添加以下代码行，就在我们在 <b>main</b> 函数中进行切换之前，我们可以有效地打印出我们的栈并查看它：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// for i in (0..SSIZE).rev() {
//   println!("mem: {}, val: {}", stack_ptr.offset(i as isize) as usize, *stack_ptr.offset(i as isize))
// }

for i in (0..SSIZE).rev() {
    println!("mem: {}, val: {}", sb_aligned.offset(i as isize) as usize, *sb_aligned.offset(i as isize))
}
</pre>

<div style="margin-top:.825em;">我们得到的输出是：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:black;color:white;font-size:.625em;">
<span style="color:gray;">01.</span> mem: 94846750517871, val: 0          <span style="color:gray;">01.</span> mem: 140259484523967, val: 255
<span style="color:gray;">02.</span> mem: 94846750517870, val: 0          <span style="color:gray;">02.</span> mem: 140259484523966, val: 255
<span style="color:gray;">03.</span> mem: 94846750517869, val: 0          <span style="color:gray;">03.</span> mem: 140259484523965, val: 255
<span style="color:gray;">04.</span> mem: 94846750517868, val: 0          <span style="color:gray;">04.</span> mem: 140259484523964, val: 255
<span style="color:gray;">05.</span> mem: 94846750517867, val: 0          <span style="color:gray;">05.</span> mem: 140259484523963, val: 255
<span style="color:gray;">06.</span> mem: 94846750517866, val: 0          <span style="color:gray;">06.</span> mem: 140259484523962, val: 255
<span style="color:gray;">07.</span> mem: 94846750517865, val: 0          <span style="color:gray;">07.</span> mem: 140259484523961, val: 255
<span style="color:gray;">08.</span> mem: 94846750517864, val: 0          <span style="color:gray;">08.</span> mem: 140259484523960, val: 255
<span style="color:gray;">09.</span> mem: 94846750517863, val: 0          <span style="color:gray;">09.</span> mem: 140259484523959, val: 0
<span style="color:gray;">10.</span> mem: 94846750517862, val: 0          <span style="color:gray;">10.</span> mem: 140259484523958, val: 0
<span style="color:gray;">11.</span> mem: 94846750517861, val: 86         <span style="color:gray;">11.</span> mem: 140259484523957, val: 0  
<span style="color:gray;">12.</span> mem: 94846750517860, val: 67         <span style="color:gray;">12.</span> mem: 140259484523956, val: 0  
<span style="color:gray;">13.</span> mem: 94846750517859, val: 56         <span style="color:gray;">13.</span> mem: 140259484523955, val: 0  
<span style="color:gray;">14.</span> mem: 94846750517858, val: 252        <span style="color:gray;">14.</span> mem: 140259484523954, val: 0  
<span style="color:gray;">15.</span> mem: 94846750517857, val: 205        <span style="color:gray;">15.</span> mem: 140259484523953, val: 0  
<span style="color:gray;">16.</span> mem: 94846750517856, val: 240        <span style="color:gray;">16.</span> mem: 140259484523952, val: 2  
<span style="color:gray;">17.</span> mem: 94846750517855, val: 0          <span style="color:gray;">17.</span> mem: 140259484523951, val: 0
<span style="color:gray;">18.</span> mem: 94846750517854, val: 0          <span style="color:gray;">18.</span> mem: 140259484523950, val: 0
<span style="color:gray;">19.</span> mem: 94846750517853, val: 0          <span style="color:gray;">19.</span> mem: 140259484523949, val: 0
<span style="color:gray;">20.</span> mem: 94846750517852, val: 0          <span style="color:gray;">20.</span> mem: 140259484523948, val: 0
<span style="color:gray;">21.</span> mem: 94846750517851, val: 0          <span style="color:gray;">21.</span> mem: 140259484523947, val: 0
<span style="color:gray;">22.</span> mem: 94846750517850, val: 0          <span style="color:gray;">22.</span> mem: 140259484523946, val: 6
<span style="color:gray;">23.</span> mem: 94846750517849, val: 0          <span style="color:gray;">23.</span> mem: 140259484523945, val: 5
<span style="color:gray;">24.</span> mem: 94846750517848, val: 0          <span style="color:gray;">24.</span> mem: 140259484523944, val: 185
<span style="color:gray;">25.</span> mem: 94846750517847, val: 0          <span style="color:gray;">25.</span> mem: 140259484523943, val: 77
<span style="color:gray;">26.</span> mem: 94846750517846, val: 0          <span style="color:gray;">26.</span> mem: 140259484523942, val: 85
<span style="color:gray;">27.</span> mem: 94846750517845, val: 0          <span style="color:gray;">27.</span> mem: 140259484523941, val: 84
<span style="color:gray;">28.</span> mem: 94846750517844, val: 0          <span style="color:gray;">28.</span> mem: 140259484523940, val: 90
<span style="color:gray;">29.</span> mem: 94846750517843, val: 0          <span style="color:gray;">29.</span> mem: 140259484523939, val: 0
<span style="color:gray;">30.</span> mem: 94846750517842, val: 0          <span style="color:gray;">30.</span> mem: 140259484523938, val: 0
<span style="color:gray;">31.</span> mem: 94846750517841, val: 0          <span style="color:gray;">31.</span> mem: 140259484523937, val: 0
<span style="color:gray;">32.</span> mem: 94846750517840, val: 0          <span style="color:gray;">32.</span> mem: 140259484523936, val: 0
<span style="color:gray;">33.</span> mem: 94846750517839, val: 0          <span style="color:gray;">33.</span> mem: 140259484523935, val: 0
<span style="color:gray;">34.</span> mem: 94846750517838, val: 0          <span style="color:gray;">34.</span> mem: 140259484523934, val: 0
<span style="color:gray;">35.</span> mem: 94846750517837, val: 0          <span style="color:gray;">35.</span> mem: 140259484523933, val: 32
<span style="color:gray;">36.</span> mem: 94846750517836, val: 0          <span style="color:gray;">36.</span> mem: 140259484523932, val: 160
<span style="color:gray;">37.</span> mem: 94846750517835, val: 0          <span style="color:gray;">37.</span> mem: 140259484523931, val: 0
<span style="color:gray;">38.</span> mem: 94846750517834, val: 0          <span style="color:gray;">38.</span> mem: 140259484523930, val: 0
<span style="color:gray;">39.</span> mem: 94846750517833, val: 0          <span style="color:gray;">39.</span> mem: 140259484523929, val: 0
<span style="color:gray;">40.</span> mem: 94846750517832, val: 0          <span style="color:gray;">40.</span> mem: 140259484523928, val: 0
<span style="color:gray;">41.</span> mem: 94846750517831, val: 0          <span style="color:gray;">41.</span> mem: 140259484523927, val: 0
<span style="color:gray;">42.</span> mem: 94846750517830, val: 0          <span style="color:gray;">42.</span> mem: 140259484523926, val: 0
<span style="color:gray;">43.</span> mem: 94846750517829, val: 0          <span style="color:gray;">43.</span> mem: 140259484523925, val: 0
<span style="color:gray;">44.</span> mem: 94846750517828, val: 0          <span style="color:gray;">44.</span> mem: 140259484523924, val: 0
<span style="color:gray;">45.</span> mem: 94846750517827, val: 0          <span style="color:gray;">45.</span> mem: 140259484523923, val: 77
<span style="color:gray;">46.</span> mem: 94846750517826, val: 0          <span style="color:gray;">46.</span> mem: 140259484523922, val: 85
<span style="color:gray;">47.</span> mem: 94846750517825, val: 0          <span style="color:gray;">47.</span> mem: 140259484523921, val: 84
<span style="color:gray;">48.</span> mem: 94846750517824, val: 0          <span style="color:gray;">48.</span> mem: 140259484523920, val: 90
I LOVE WAKING UP ON A NEW STACK!
-----------------------------------
</pre>

<div style="margin-top:.825em;">我已经在这里把内存地址打印成 <b>u64</b> 类型，这样如果你不熟悉十六进制也容易肉眼解析。</div>

<div style="margin-top:.425em;">首先要注意的是，这只是一块连续的内存，从地址 94846750517824 开始，到 94846750517871 结束。</div>

<div style="margin-top:.425em;">地址 94846750517856 到 94846750517863 应该需要我们特别注意。第一个地址是我们的“栈指针”的地址，我们写入 CPU 的 <b>%rsp</b> 寄存器的值。范围表示在我们进行切换之前写入栈的值。</div>

<div style="margin-top:.425em;">换句话说，值 <b>240,205,252,56,67,86,0,0</b> 是指向我们的 <b>hello()</b> 函数的指针，只是写成了多个 <b>u8</b> 类型的值。</div>

<div style="margin-top:.425em;">这里有一个有趣的注意事项是 CPU 将 <b>u64</b> 写为 <b>u8</b> 字节的顺序取决于它的字节顺序。我将简单地参考维基百科的文章，但如果你试图手动解析这些数字，你必须牢记这一点。</div>

<div style="margin-top:.425em;">当我们编写更复杂的函数时，我们极小的 48 字节栈将很快耗尽空间，你看，当我们运行我们在 Rust 中编写的函数时，我们的代码将指示 CPU 在我们的栈上入栈和弹出值来执行我们的程序。</div>

<h3>栈尺寸</h3>

<div>当你在大多数现代操作系统中启动进程时，标准栈大小通常为 8 MB，但可以进行不同的配置，这对于大多数程序来说已经足够了，但是需要由我们开发者保证使用的时候不会超出这个大小。这就是我们大多数人经历过的可怕的 “栈溢出” 的原因。</div>

<div style="margin-top:.425em;">但是，当我们自己控制栈时，我们可以选择我们想要的大小。例如，在 Web 服务器中运行简单函数时，每个上下文都用 8 MB 是超出我们的需要的，因此通过减少栈大小，我们可以在一台机器上运行数百万个绿色线程，而如果使用操作系统提供的栈，我们会更快把内存用光。</div>

<h3>可增长的栈</h3>

<div>某些实现使用可增长的栈。这让我们可以只分配一小部分内存就足够为大多数任务使用，但是当我们用光这个栈时它不会导致栈溢出，而是分配一个新的更大的栈并将所有内容从当前栈中移到这个新的更大的栈上，并可以恢复程序继续执行。</div>

<div style="margin-top:.425em;">Go 语言就是一个这样的例子。它从一个 8 KB 的栈开始，当它的空间用完时，它会重新分配到一个更大的栈。但是正如编程中的每一件事都是有代价的，所有指针都需要正确地被更新，这不是一件容易的事。如果你对 Go 如何处理它的栈更感兴趣（这是可增长栈的使用和权衡的一个很好的例子）可以参看这篇文章：https://blog.cloudflare.com/how-stacks-are-handled-in-go/</div>

<div style="margin-top:.425em;">请注意稍后会很重要的一件事：我们使用 Rust 标准库中普通的 <b>Vec<u8></b>。对我们来说非常方便，但也有一些问题。除了其它之外，我们无法保证它会留在内存中的同一位置。你可能会想到，如果栈移动到不同的地址空间，我们的程序会崩溃，因为我们的所有指针都将变为无效。比如对我们的栈执行 <b>push()</b> 这样简单的操作可能会触发一次增长，当 <b>Vec</b> 扩展它时会请求一个新的、更大的内存块并将值移动到新位置。</div>

<div style="margin-top:.425em;">好了，现在我们已经了解了栈的外观和工作原理，我们已准备好继续实现绿色线程。你已经完成了很多艰苦的工作，所以我答应你开始写代码。</div>

<h3>如何设置栈</h3>

<div>Windows x64-86 的栈设置与 x64-86 psABI 调用约定略有不同。我将在 <b>附录：支持Windows</b> 的章节中花更多时间介绍 Windows 栈，但重要的是要知道如果用那些并不接受多个参数的简单函数设置栈，两者的差异不是很大，就像我们目前做的这样。</div>

<div style="margin-top:.425em;">psABI 的栈布局如下：</div>

<div>
  <img style="max-width:100%" src="/images/rust/14143541_62a82c3d6d04388967.webp" />
</div>

<div style="margin-top:.425em;">如你所知，<b>%rsp</b> 是我们的栈指针。你可以看到，我们需要将栈指针放在距离我们的基地址为 16 的倍数位置。返回的地址位于相邻的 8 个字节中，如你所见，上面有一个内存参数的空间。当我们想要做比迄今为止更复杂的事情时，我们需要牢记这一点。</div>

<h3>幕后花絮</h3>

<div>如果你足够好奇，你可能想知道切换到栈后它发生了什么？</div>

<div style="margin-top:.425em;">答案是我们用 Rust 编写的代码被编译成 CPU 的指令，然后就像使用任何其他的栈一样，接管并使用我们的栈。</div>

<div style="margin-top:.425em;">遗憾的是，为了清楚地展示这一点，我得将栈大小增加到 1024 字节，才能为打印出栈本身获得足够的空间，所以目前这样我们无法打印。</div>

<h3>看一下栈</h3>

<div>不过，我制作了一个示例的更改版本，在运行时它会打印出两个文本文件，一个是 <b>BEFORE.txt</b>，在我们切换到栈之前打印出我们的栈，一个 </b>AFTER.txt</b> 打印出我们切换后的栈。然后，你可以自己查看栈现在是如何存活并由我们的代码使用的。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// <span style="color:burlywood;">01.</span> #![feature(asm)]
// <span style="color:burlywood;">02.</span> #![feature(naked_functions)]
// <span style="color:burlywood;">03.</span> use std::io::Write;
// <span style="color:burlywood;">04.</span> 
// <span style="color:burlywood;">05.</span> const SSIZE: isize = 1024;
// <span style="color:burlywood;">06.</span> static mut S_PTR: *const u8 = 0 as *const u8;
// <span style="color:burlywood;">07.</span> 
// <span style="color:burlywood;">08.</span> #[derive(Debug, Default)]
// <span style="color:burlywood;">09.</span> #[repr(C)]
// <span style="color:burlywood;">10.</span> struct ThreadContext {
// <span style="color:burlywood;">11.</span>     rsp: u64,
// <span style="color:burlywood;">12.</span>     r15: u64,
// <span style="color:burlywood;">13.</span>     r14: u64,
// <span style="color:burlywood;">14.</span>     r13: u64,
// <span style="color:burlywood;">15.</span>     r12: u64,
// <span style="color:burlywood;">16.</span>     rbx: u64,
// <span style="color:burlywood;">17.</span>     rbp: u64,
// <span style="color:burlywood;">18.</span> }
// <span style="color:burlywood;">19.</span> 
// <span style="color:burlywood;">20.</span> fn print_stack(filename: &str) {
// <span style="color:burlywood;">21.</span> let mut f = std::fs::File::create(filename).unwrap();
// <span style="color:burlywood;">22.</span> unsafe {
// <span style="color:burlywood;">23.</span> for i in (0..SSIZE).rev() {
// <span style="color:burlywood;">24.</span> writeln!(
// <span style="color:burlywood;">25.</span>                 f,
// <span style="color:burlywood;">26.</span> "mem: {}, val: {}",
// <span style="color:burlywood;">27.</span>                 S_PTR.offset(i as isize) as usize,
// <span style="color:burlywood;">28.</span> *S_PTR.offset(i as isize)
// <span style="color:burlywood;">29.</span>             )
// <span style="color:burlywood;">30.</span>                 .expect("Error writing to file.");
// <span style="color:burlywood;">31.</span>         }
// <span style="color:burlywood;">32.</span>     }
// <span style="color:burlywood;">33.</span> }
// <span style="color:burlywood;">34.</span> 
// <span style="color:burlywood;">35.</span> fn hello() {
// <span style="color:burlywood;">36.</span> println!("I LOVE WAKING UP ON A NEW STACK!");
// <span style="color:burlywood;">37.</span> print_stack("AFTER.txt");
// <span style="color:burlywood;">38.</span> 
// <span style="color:burlywood;">39.</span> loop {}
// <span style="color:burlywood;">40.</span> }
// <span style="color:burlywood;">41.</span> 
// <span style="color:burlywood;">42.</span> unsafe fn gt_switch(new: *const ThreadContext) {
// <span style="color:burlywood;">43.</span> asm!("
// <span style="color:burlywood;">44.</span>         mov 0x00($0), %rsp
// <span style="color:burlywood;">45.</span>         ret
// <span style="color:burlywood;">46.</span>         "
// <span style="color:burlywood;">47.</span>     :
// <span style="color:burlywood;">48.</span>     : "r"(new)
// <span style="color:burlywood;">49.</span>     :
// <span style="color:burlywood;">50.</span>     : "alignstack"
// <span style="color:burlywood;">51.</span>     );
// <span style="color:burlywood;">52.</span> }
// <span style="color:burlywood;">53.</span> 
// <span style="color:burlywood;">54.</span> fn main() {
// <span style="color:burlywood;">55.</span> let mut ctx = ThreadContext::default();
// <span style="color:burlywood;">56.</span> let mut stack = vec![0_u8; SSIZE as usize];
// <span style="color:burlywood;">57.</span> let stack_ptr = stack.as_mut_ptr();
// <span style="color:burlywood;">58.</span> 
// <span style="color:burlywood;">59.</span> unsafe {
// <span style="color:burlywood;">60.</span>         S_PTR = stack_ptr;
// <span style="color:burlywood;">61.</span>         std::ptr::write(stack_ptr.offset(SSIZE - 16) as *mut u64, hello as u64);
// <span style="color:burlywood;">62.</span> print_stack("BEFORE.txt");
// <span style="color:burlywood;">63.</span>         ctx.rsp = stack_ptr.offset(SSIZE - 16) as u64;
// <span style="color:burlywood;">64.</span> gt_switch(&mut ctx);
// <span style="color:burlywood;">65.</span>     }
// <span style="color:burlywood;">66.</span> }

<span style="color:burlywood;">01.</span> use std::arch::asm;
<span style="color:burlywood;">02.</span> use std::io::Write;
<span style="color:burlywood;">03.</span> 
<span style="color:burlywood;">04.</span> const SSIZE: isize = 1024;
<span style="color:burlywood;">05.</span> static mut S_PTR: *const u8 = 0 as *const u8;
<span style="color:burlywood;">06.</span> 
<span style="color:burlywood;">07.</span> #[derive(Debug, Default)]
<span style="color:burlywood;">08.</span> #[repr(C)]
<span style="color:burlywood;">09.</span> struct ThreadContext {
<span style="color:burlywood;">10.</span>     rsp: u64,
<span style="color:burlywood;">11.</span>     r15: u64,
<span style="color:burlywood;">12.</span>     r14: u64,
<span style="color:burlywood;">13.</span>     r13: u64,
<span style="color:burlywood;">14.</span>     r12: u64,
<span style="color:burlywood;">15.</span>     rbx: u64,
<span style="color:burlywood;">16.</span>     rbp: u64,
<span style="color:burlywood;">17.</span> }
<span style="color:burlywood;">18.</span> 
<span style="color:burlywood;">19.</span> fn print_stack(filename: &str) {
<span style="color:burlywood;">20.</span>     let mut f = std::fs::File::create(filename).unwrap();
<span style="color:burlywood;">21.</span>     unsafe {
<span style="color:burlywood;">22.</span>         for i in (0..SSIZE).rev() {
<span style="color:burlywood;">23.</span>             writeln!(
<span style="color:burlywood;">24.</span>                 f,
<span style="color:burlywood;">25.</span>                 "mem: {}, val: {}",
<span style="color:burlywood;">26.</span>                 S_PTR.offset(i as isize) as usize,
<span style="color:burlywood;">27.</span>                 *S_PTR.offset(i as isize)
<span style="color:burlywood;">28.</span>             )
<span style="color:burlywood;">29.</span>             .expect("Error writing to file.");
<span style="color:burlywood;">30.</span>         }
<span style="color:burlywood;">31.</span>     }
<span style="color:burlywood;">32.</span> }
<span style="color:burlywood;">33.</span> 
<span style="color:burlywood;">34.</span> fn hello() {
<span style="color:burlywood;">35.</span>     println!("I LOVE WAKING UP ON A NEW STACK!");
<span style="color:burlywood;">36.</span>     print_stack("AFTER.txt");
<span style="color:burlywood;">37.</span> 
<span style="color:burlywood;">38.</span>     loop {}
<span style="color:burlywood;">39.</span> }
<span style="color:burlywood;">40.</span> 
<span style="color:burlywood;">41.</span> unsafe fn gt_switch(new: *const ThreadContext) {
<span style="color:burlywood;">42.</span>     asm!(
<span style="color:burlywood;">43.</span>         "mov rsp, [{0} + 0x00]",
<span style="color:burlywood;">44.</span>         "ret",
<span style="color:burlywood;">45.</span>         in(reg) new
<span style="color:burlywood;">46.</span>     );
<span style="color:burlywood;">47.</span> }
<span style="color:burlywood;">48.</span> 
<span style="color:burlywood;">49.</span> pub fn main() {
<span style="color:burlywood;">50.</span>     let mut ctx = ThreadContext::default();
<span style="color:burlywood;">51.</span>     let mut stack = vec![0_u8; SSIZE as usize];
<span style="color:burlywood;">52.</span>     let stack_ptr = stack.as_mut_ptr();
<span style="color:burlywood;">53.</span> 
<span style="color:burlywood;">54.</span>     unsafe {
<span style="color:burlywood;">55.</span>         let stack_bottom = stack.as_mut_ptr().offset(SSIZE);
<span style="color:burlywood;">56.</span>         let sb_aligned = (stack_bottom as usize & !15) as *mut u8;
<span style="color:burlywood;">57.</span>         S_PTR = sb_aligned;
<span style="color:burlywood;">58.</span>         std::ptr::write(stack_ptr.offset(SSIZE - 16) as *mut u64, hello as u64);
<span style="color:burlywood;">59.</span>         print_stack("BEFORE.txt");
<span style="color:burlywood;">60.</span>         ctx.rsp = stack_ptr.offset(SSIZE - 16) as u64;
<span style="color:burlywood;">61.</span>         gt_switch(&mut ctx);
<span style="color:burlywood;">62.</span>     }
<span style="color:burlywood;">63.</span> }
</pre>


    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">一个绿色线程的实现</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.625;font-family:monospace;">
      <![CDATA[

<div>在我们开始之前，我得提醒你我们编写的代码非常不安全，并且这也不是编写 Rust 代码的 “最佳实践”。我希望在不引入很多不必要的复杂性的前提下使其尽可能安全，所以如果你发现了更安全方法，又不会让我们的代码过于复杂，那么我鼓励亲爱的你为该项目提一个 RP（Pull Request）。</div>

<h3>让我们开始吧</h3>

<div>
  我们要做的第一件事就是在 <b>main.rs</b> 中删除我们的示例。我们从头开始并添加以下内容：
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// #![feature(asm)]
// #![feature(naked_functions)]
// use std::ptr;
// 
// const DEFAULT_STACK_SIZE: usize = 1024 * 1024 * 2;
// const MAX_THREADS: usize = 4;
// static mut RUNTIME: usize = 0;

#![feature(naked_functions)]
use std::arch::asm;

const DEFAULT_STACK_SIZE: usize = 1024 * 1024 * 2;
const MAX_THREADS: usize = 4;
static mut RUNTIME: usize = 0;

</pre>

<div style="margin-top:.625em;">我们启用了两个特性（feature），我们之前介绍过的 <b>asm</b> 功能，以及我们需要解释的 <b>naked_functions</b> 功能。</div>

<h3>naked_functions</h3>

<div>
  当 Rust 编译一个函数时，它会为每个函数添加一个小的序言和尾声，这会在我们切换上下文时给我们带来一些问题，因为我们最终得到了一个未对齐的栈。这在我们的第一个简单示例中运行良好，但是一旦我们需要再次切换回相同的栈，我们就会遇到麻烦。将某个函数标记为 <b>#[naked]</b> 会删除序言和结尾。此属性主要用于内联汇编。
</div>

<div style="margin-top:.625em;">我们的 <b>DEFAULT_STACK_SIZE</b> 设置为 2 MB，这足够我们使用。我们还将 <b>MAX_THREADS</b> 设置为 4，因为我们的示例不需要太大。</div>

<div style="margin-top:.625em;">最后一个常量 <b>RUNTIME</b> 是一个指向我们运行时的指针（是的，我知道，一个可变的全局变量不是很好，但我们稍后需要它，我们只在运行时初始化时设置这个变量）。</div>

<div style="margin-top:.625em;">我们开始填上一些代表数据的内容：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// pub struct Runtime {
//     threads: Vec<Thread>,
//     current: usize,
// }
// 
// #[derive(PartialEq, Eq, Debug)]
// enum State {
//     Available,
//     Running,
//     Ready,
// }
// 
// struct Thread {
//     id: usize,
//     stack: Vec<u8>,
//     ctx: ThreadContext,
//     state: State,
// }
// 
// #[derive(Debug, Default)]
// #[repr(C)]
// struct ThreadContext {
//     rsp: u64,
//     r15: u64,
//     r14: u64,
//     r13: u64,
//     r12: u64,
//     rbx: u64,
//     rbp: u64,
// }

pub struct Runtime {
    threads: Vec<Thread>,
    current: usize,
}

#[derive(PartialEq, Eq, Debug)]
enum State {
    Available,
    Running,
    Ready,
}

struct Thread {
    id: usize,
    stack: Vec<u8>,
    ctx: ThreadContext,
    state: State,
}

#[derive(Debug, Default)]
#[repr(C)]
struct ThreadContext {
    rsp: u64,
    r15: u64,
    r14: u64,
    r13: u64,
    r12: u64,
    rbx: u64,
    rbp: u64,
}
</pre>

<div style="margin-top:.625em;"><b>Runtime</b> 将是我们的主要入口。我们会创建一个非常小的、简单的运行时来调度和切换我们的线程。运行时包含一个 <b>Thread</b> 的数组和一个 <b>current</b> 字段，以指示我们当前正在运行的线程。</div>

<div style="margin-top:.625em;"><b>Thread</b> 保存线程的数据。每个线程都有一个 <b>id</b>，这样我们就可以将不同的线程区分开。栈类似于我们在前面章节中的第一个示例中看到的内容。<b>ctx</b> 字段是一个上下文，表示我们的 CPU 需要在栈上剩余的位置恢复的数据，以及一个 <b>state</b>，它是我们的线程状态。</div>

<div style="margin-top:.625em;">整篇文章中的 “线程” 以及 <b>Thread</b> 指的就是我们要实现的 “绿色线程（Grean Thread）”，而不是操作系统线程。</div>

<div style="margin-top:.625em;"><b>State</b> 是一个枚举，代表我们的线程所处的状态：</div>

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .125em;">
  <li><b>Available</b> 表示线程可用，并且可以根据需要分配任务；</li>
  <li><b>Running</b> 意味着线程正在运行；</li>
  <li><b>Ready</b> 意味着线程已准备好继续前进和恢复执行。</li>
</ul>

<div style="margin-top:.625em;"><b>ThreadContext</b> 保存 CPU 需要在栈上恢复执行的寄存器的数据。</div>

<div style="margin-top:.625em;">如果你不记得，请返回 <b>绪论及基本概念</b> 一章以了解寄存器。这些是 x86-64 体系结构规范中标记为 <b>“callee saved”</b> 的寄存器。</div>

<div style="margin-top:.625em;">让我们继续：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// impl Thread {
// fn new(id: usize) -> Self {
//         Thread {
//             id,
//             stack: vec![0_u8; DEFAULT_STACK_SIZE],
//             ctx: ThreadContext::default(),
//             state: State::Available,
//         }
//     }
// }
impl Thread {
    fn new(id: usize) -> Self {
        Thread {
            id,
            stack: vec![0_u8; DEFAULT_STACK_SIZE],
            ctx: ThreadContext::default(),
            state: State::Available,
        }
    }
}
</pre>

<div style="margin-top:.625em;">这部分很简单。新线程在 <b>Available</b> 状态下启动，表示已准备好为其分配任务。</div>

<div style="margin-top:.625em;">需要注意的一点是我们在这里分配了栈内存。这不是必需的，也不是资源的最佳使用方法，因为我们没有在首次使用时分配,，而为一个只是可能需要的线程分配了内存。不过，这降低了我们代码的复杂性，而我们的代码有比为栈分配内存更重要的关注点。</div>

<div style="margin-top:.625em;">需要着重注意的是，一旦分配了栈，它就不能移动（move）！不应使用数组的 <b>push()</b> 或任何方法触发内存重分配。如果要把这部分代码写的更好一些，我们可以创建自己的类型，只暴露那些我们认为可以安全使用的方法。值得一提的是，<b>Vec<T></b> 有一个名为 <b>into_boxed_slice()</b> 的方法，它返回一个堆分配的切片 <b>Box<[T]></b>。切片不能增长，所以如果我们改为使用它，我们可以避免重新分配问题。</div>

<h3>实现运行时</h3>

<div>
  此段中的所有代码都在 <b>impl Runtime</b> 代码块中，这意味着它们是 <b>Runtime</b> 结构上的方法。
</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// impl Runtime {
// pub fn new() -> Self {
// // 这将是我们的基本线程, 会被初始化为
// // Running 状态
// let base_thread = Thread {
//             id: 0,
//             stack: vec![0_u8; DEFAULT_STACK_SIZE],
//             ctx: ThreadContext::default(),
//             state: State::Running,
//         };
// 
// let mut threads = vec![base_thread];
// let mut available_threads: Vec<Thread> = (1..MAX_THREADS).map(|i| Thread::new(i)).collect();
//         threads.append(&mut available_threads);
// 
//         Runtime {
//             threads,
//             current: 0,
//         }
//     }
impl Runtime {
    pub fn new() -> Self {
        // This will be our base thread, which will be initialized in 
        // the `running` state
        let base_thread = Thread {
            id: 0,
            stack: vec![0_u8; DEFAULT_STACK_SIZE],
            ctx: ThreadContext::default(),
            state: State::Running,
        };

        let mut threads = vec![base_thread];
        let mut available_threads: Vec<Thread> = (1..MAX_THREADS).map(|i| Thread::new(i)).collect();
        threads.append(&mut available_threads);

        Runtime {
            threads,
            current: 0,
        }
    }
</pre>

<div style="margin-top:.625em;">当我们实例化 <b>Runtime</b> 时，我们创建了一个基础线程。此线程将设置为 <b>Running</b> 状态，并确保我们保持运行时运行，直到所有任务完成。</div>

<div style="margin-top:.625em;">然后我们实例化其余的线程并将当前线程设置为 <b>0</b> ，也就是我们的基本线程。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// /// 这里有点作弊，但是我们需要一个指向存储的 Runtime 的指针
// /// 这样即便我们没有它的引用，
// /// 也可以对其调用 yield.
// pub fn init(&self) {
//   unsafe {
//     let r_ptr: *const Runtime = self;
//     RUNTIME = r_ptr as usize;
//   }
// }

/// This is cheating a bit, but we need a pointer to our Runtime 
/// stored so we can call yield on it even if we don't have a 
/// reference to it.
pub fn init(&self) {
    unsafe {
        let r_ptr: *const Runtime = self;
        RUNTIME = r_ptr as usize;
    }
}
</pre>

<div style="margin-top:.625em;">然后我们需要这样（译者注：为那个可变的全局变量赋值），正如我在定义常量时所提到的，我们需要以后能够调用 <b>yield</b>。代码有点难看，但我们知道只要有任何线程可以 <b>yield</b>，我们的运行时就会存活，只要我们不滥用它就可以安全地运行。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// pub fn run(&mut self) -> ! {
//   while self.t_yield() {}
//   std::process::exit(0);
// }
pub fn run(&mut self) -> ! {
  while self.t_yield() {}
  std::process::exit(0);
}
</pre>

<div style="margin-top:.625em;">这是我们开始启动运行时的地方。它将不断调用 <b>t_yield()</b> 直到返回 <b>false</b>，<b>false</b> 意味着没有工作要做了，我们可以退出进程。</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// fn t_return(&mut self) {
//   if self.current != 0 {
//     self.threads[self.current].state = State::Available;
//     self.t_yield();
//   }
// }
fn t_return(&mut self) {
    if self.current != 0 {
        self.threads[self.current].state = State::Available;
        self.t_yield();
    } 
}
</pre>

<div style="margin-top:.625em;">这是我们在线程完成时调用的返回函数。<b>return</b> 是 Rust 中的另一个保留关键字，因此我们将此命名为 <b>t_return()</b>。请注意我们的线程用户不会调用它，我们设置栈，以便在任务完成时调用它。如果调用线程是 <b>base_thread</b>（即基础线程），我们什么都不做。我们的运行时将在基础线程上为我们调用 <b>yield</b>。如果从生成的线程中调用它，我们知道它已经完成，因为所有线程都在它们的栈顶部有一个 <b>guard</b> 函数（我们将下面进一步展示），并且这个 <b>t_return</b> 函数唯一被调用的地方就是我们的 <b>guard</b> 函数。我们将当前线程状态设置为 <b>Available</b>，让运行时知道它已准备好接受新任务，然后立即调用 <b>t_yield</b>，它将调度新的线程运行。</div>

<div style="margin-top:.625em;">接下来是我们的 <b>yield</b> 函数：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// fn t_yield(&mut self) -> bool {
//   let mut pos = self.current;
//   while self.threads[pos].state != State::Ready {
//               pos += 1;
//   if pos == self.threads.len() {
//                   pos = 0;
//               }
//   if pos == self.current {
//   return false;
//               }
//           }
// 
//   if self.threads[self.current].state != State::Available {
//   self.threads[self.current].state = State::Ready;
//           }
// 
//   self.threads[pos].state = State::Running;
//   let old_pos = self.current;
//   self.current = pos;
// 
//   unsafe {
//   switch(&mut self.threads[old_pos].ctx, &self.threads[pos].ctx);
//           }
// 
//   // 防止 Windows 的编译器优化我们的代码。
//   self.threads.len() > 0
// }
#[inline(never)]
fn t_yield(&mut self) -> bool {
    let mut pos = self.current;
    while self.threads[pos].state != State::Ready {
        pos += 1;
        if pos == self.threads.len() {
            pos = 0;
        }
        if pos == self.current {
            return false;
        }
    }

    if self.threads[self.current].state != State::Available {
        self.threads[self.current].state = State::Ready;
    }

    self.threads[pos].state = State::Running;
    let old_pos = self.current;
    self.current = pos;

    unsafe {
        let old: *mut ThreadContext = &mut self.threads[old_pos].ctx;
        let new: *const ThreadContext = &self.threads[pos].ctx;
        asm!("call switch", in("rdi") old, in("rsi") new, clobber_abi("C"));
    }
    self.threads.len() > 0
}
</pre>

<div style="margin-top:.625em;">这是我们运行时的核心。我们必须将此命名为 <b>t_yield</b>，因为 <b>yield</b> 是 Rust 中的保留关键字。在这里，我们遍历所有线程，看看是否有线程处于 <b>Ready</b> 状态，<b>Ready</b> 表明它已准备好恢复执行。在现实世界的程序中，这可能是一个数据库调用的返回。</div>

<div style="margin-top:.625em;">如果没有线程是 <b>Ready</b> 的，就直接返回。这是一个非常简单的调度程序，只使用轮询算法，真正的调度程序可能有更复杂的方法来决定下一个要运行的任务。</div>

<div style="margin-top:.625em;">这是一个为我们的例子量身定制的非常简单的实现。如果我们的线程尚未准备好进行（未处于 <b>Ready</b> 状态）并仍在等待比如来自数据库的响应，会发生什么？
解决这个问题并不困难，当一个线程 <b>Ready</b> 时，我们可以轮询它的状态，而不是直接运行我们的代码，。比如，如果它真的准备好运行它可以返回 <b>IsReady</b>，如果仍旧在等待某些操作完成它可以返回 <b>Pending</b>。在后一种情况下，我们可以直接它处于 <b>Ready</b> 状态，以便稍后再次进行轮询。是不是听起来很熟悉？如果您已经阅读了Future在Rust中的工作方式，那么我们将开始就它们如何组合在一起提供一些建议。</div>

<div style="margin-top:.625em;">如果我们找到一个准备运行的线程，那就将当前线程的状态从 <b>Running</b> 修改为 <b>Ready</b>。</div>

<div style="margin-top:.625em;">然后我们调用 <b>switch</b> 来保存当前上下文（旧上下文）并将新上下文加载到 CPU 中。新上下文要么是新任务，要么是 CPU 在现有任务上恢复工作所需的所有信息。</div>

<div style="margin-top:.625em;">最终的 <b>self.threads.len() > 0</b> 的部分只是阻止编译器优化代码的一种方法。这种情况发生在 Windows 上，但不发生在 Linux 上，例如在运行性能测试时是一个常见问题。因此，我们可以使用 <b>std::hint::black_box</b> 来防止编译器为了更快地执行代码而走得太远并跳过我们需要的步骤。我选择了另外一种方法，只要是有注释的就应该没问题，无论如何代码永远不会执行到这里。</div>

<div style="margin-top:.625em;">接下来是我们的 <b>spawn()</b> 函数：</div>

<pre style="margin-top:.5em;padding:.825em 1.2em;background-color:darkslategray;color:white;font-size:.825em;">
// pub fn spawn(&mut self, f: fn()) {
// 
//   let available = self
//       .threads
//       .iter_mut()
//       .find(|t| t.state == State::Available)
//       .expect("no available thread.");
// 
//   let size = available.stack.len();
//   let s_ptr = available.stack.as_mut_ptr();
// 
//   unsafe {
//     ptr::write(s_ptr.offset((size - 24) as isize) as *mut u64, guard as u64);
//     ptr::write(s_ptr.offset((size - 32) as isize) as *mut u64, f as u64);
//     available.ctx.rsp = s_ptr.offset((size - 32) as isize) as u64;
//   }
// 
//   available.state = State::Ready;
// 
// }

pub fn spawn(&mut self, f: fn()) {
    let available = self
        .threads
        .iter_mut()
        .find(|t| t.state == State::Available)
        .expect("no available thread.");

    let size = available.stack.len();
    unsafe {
        let s_ptr = available.stack.as_mut_ptr().offset(size as isize);
        let s_ptr = (s_ptr as usize & !15) as *mut u8;
        std::ptr::write(s_ptr.offset(-16) as *mut u64, guard as u64);
        std::ptr::write(s_ptr.offset(-24) as *mut u64, skip as u64);
        std::ptr::write(s_ptr.offset(-32) as *mut u64, f as u64);
        available.ctx.rsp = s_ptr.offset(-32) as u64;
    }
    available.state = State::Ready;
}

// Remember to close "}" the `impl Runtime` block here
</pre>

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

</c:component>
