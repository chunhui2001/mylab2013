<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div style="font-size:1.1em;line-height:1.625;">
This article is a sample from <a href="https://zero2prod.com/">Zero To Production In Rust</a>, a book on backend development in Rust.
You can get a copy of the book on <a href="https://zero2prod.com/">zero2prod.com</a>.
<a href="https://www.lpalmieri.com/subscribe">Subscribe to the newsletter</a> to be notified when a new episode is published.
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">TL;DR</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>In the previous episode we established that 'Basic' Authentication is not a great fit when dealing with a browser: it requires the user to present their credentials on <code>every single page</code>.</div>
<div style="margin-top:.625em;">In this episode we will explore a viable alternative, <code>session-based authentication</code>.
The user is asked to authenticate once, via a login form: if successful, the server generates a one-time secret, stored in the browser as a cookie.</div>
<div style="margin-top:.625em;">We will build - from scratch - an admin dashboard. It will include a login form, a logout button and a form to change your password. It will give us an opportunity to discuss a few security challenges <code>(i.e. XSS)</code>, introduce new concepts <code>(e.g. cookies, HMAC tags)</code> and try out new tooling <code>(e.g. flash messages, actix-session)</code>.</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:0em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">1. Serving HTML Pages</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>So far we have steered away from the complexity of browsers and web pages - it helped us in limiting the number of new concepts we had to pick up early on in our learning journey.
We have now built enough expertise to make the jump - we will handle both the HTML page and the payload submission for our login form.</div>
<div style="margin-top:.625em;">Let's start from the basics: how do we return an HTML page from our API? <br /> We can begin by adding a dummy home page endpoint.</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/mod.rs
 
// [...]
// New module!
mod home;
pub use home::*;
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/home/mod.rs
use actix_web::HttpResponse;

pub async fn home() -> HttpResponse {
    HttpResponse::Ok().finish()
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/startup.rs
use crate::routes::home;
// [...]

fn run(/* */) -> Result</* */> {
    // [...]
    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/", web::get().to(home))
            // [...]
    })
    // [...]
}
    ]]>
    </c:sourceContent>

    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>Not much to be seen here - we are just returning a 200 OK without a body. <br />
Let's add a very simple HTML landing page1 to the mix:</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<!-- src/routes/home/home.html -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Home</title>
    </head>
    <body>
        <p>Welcome to our newsletter!</p>
    </body>
</html>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>We want to read this file and return it as the body of our <code>GET /</code> endpoint.
We can use <code>include_str!</code>, a macro from Rust's standard library: it reads the file at the provided path and returns its content as a <code>&'static str</code>.</div>
<div style="margin-top:.625em;">This is possible because <code>include_str!</code> operates <code>at compile-time</code> - the file content is stored as part of the application binary, therefore ensuring that a pointer to its content (<code>&str</code>) remains valid indefinitely (<code>'static</code>)<sup>2</sup>.</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/home/mod.rs
// [...]

pub async fn home() -> HttpResponse {
    HttpResponse::Ok().body(include_str!("home.html"))
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>If you launch your application with cargo run and visit <code>http://localhost:8000</code> in the browser you should see the <code>Welcome to our newsletter!</code> message.</div>
<div style="margin-top:.625em;">The browser is not entirely happy though - if you open the browser's console3, you should see a warning.
On Firefox 93.0:</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">The character encoding of the HTML document was not declared.</li>
  <li style="margin-top:.325em;">The document will render with garbled text in some browser configurations if the document contains characters from outside the US-ASCII range.</li>
  <li style="margin-top:.325em;">The character encoding of the page must be declared in the document or in the transfer protocol.</li>
</ul>
<div style="margin-top:.625em;">In other words - the browser has inferred that we are returning HTML content, but it would very much prefer to be told explicitly.</div>
<div style="margin-top:.625em;">We have two options:</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">Add a special HTML <code>meta</code> tag in the document;</li>
  <li style="margin-top:.325em;">Set the <code>Content-Type</code> HTTP header (<code>"transfer protocol"</code>).</li>
</ul>
<div style="margin-top:.625em;">Better to use both.</div>
<div style="margin-top:.625em;">Embedding the information inside the document works nicely for browsers and bot crawlers (e.g. Googlebot) while the Content-Type HTTP header is understood by all HTTP clients, not just browsers.</div>
<div style="margin-top:.625em;">When returning an HTML page, the content type should be set to text/html; charset=utf-8.
Let's add it in:</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<!-- src/routes/home/home.html -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- This is equivalent to a HTTP header -->
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Home</title>
    </head>
    <!-- [...] -->
</html>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/home/mod.rs
// [...]
use actix_web::http::header::ContentType;

pub async fn home() -> HttpResponse {
    HttpResponse::Ok()
        .content_type(ContentType::html())
        .body(include_str!("home.html"))
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>The warning should have disappeared from your browsers' console. <br />
Congrats, you have just served your first well-formed web page!</div>
    ]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



  <c:entry style="margin-top:0em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">2. Login</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>Let's start working on our login form. <br />
We need to wire up an endpoint placeholder, just like we did for GET /. We will serve the login form at GET /login.</div>
    ]]>
    </c:sourceContent>

    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/mod.rs

// [...]
// New module!
mod login;
pub use login::*;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/mod.rs
mod get;
pub use get::login_form;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
use actix_web::HttpResponse;

pub async fn login_form() -> HttpResponse {
    HttpResponse::Ok().finish()
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/startup.rs
use crate::routes::{/* */, login_form};
// [...]

fn run(/* */) -> Result<Server, std::io::Error> {
    // [...]
    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/login", web::get().to(login_form))
            // [...]
    })
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.1. HTML Forms" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
The HTML will be more convoluted this time:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<!-- src/routes/login/login.html -->
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta http-equiv="content-type" content="text/html; charset=utf-8">
        <title>Login</title>
    </head>
    <body>
        <form>
            <label>Username
                <input 
                    type="text" 
                    placeholder="Enter Username" 
                    name="username"
                >
            </label>

            <label>Password
                <input 
                    type="password" 
                    placeholder="Enter Password"
                    name="password"
                >
            </label>

            <button type="submit">Login</button>
        </form>
    </body>
</html>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
use actix_web::HttpResponse;
use actix_web::http::header::ContentType;

pub async fn login_form() -> HttpResponse {
    HttpResponse::Ok()
        .content_type(ContentType::html())
        .body(include_str!("login.html"))
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
<code>form</code> is the HTML element doing the heavy-lifting here. Its job is to collect a set of data fields and send them over for processing to a backend server.
</div>
<div style="margin-top:.625em;">
The fields are defined using the <code>input</code> element - we have two here: username and password.
Inputs are given a <code>type</code> attribute - it tells the browser how to display them.
<code>text</code> and <code>password</code> will both be rendered as a single-line free-text field, with one key difference: the characters entered into a <code>password</code> field are obfuscated.
</div>
<div style="margin-top:.625em;">
Each input is wrapped in a label element:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">clicking on the label name toggles the input field;</li>
  <li style="margin-top:.325em;">it improves accessibility for screen-readers users (it is read out loud when the user is focused on the element).</li>
</ul>
<div style="margin-top:.625em;">
On each input we have set two other attributes:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">placeholder, whose value is shown as a suggestion within the text field before the user starts filling the form;</li>
  <li style="margin-top:.325em;">name, the key that we must use in the backend to identify the field value within the submitted form data.</li>
</ul>
<div style="margin-top:.625em;">
At the end of the form, there is a <code>button</code> - it will trigger the submission of the provided input to the backend.
</div>
<div style="margin-top:.625em;">
What happens if you enter a random username and password and try to submit it?
</div>

<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .325em;">
  <li style="margin-top:.325em;">The page refreshes, the input fields are reset - the URL has changed though!</li>
  <li style="margin-top:.325em;">It should now be http://localhost:8000/login?username=myusername&password=mysecretpassword.</li>
</ul>
<div style="margin-top:.625em;">
This is form's default behaviour<sup>4</sup> - <code>form</code> submits the data to the very same page it is being served from (i.e. /login) using the <code>GET HTTP verb</code>. This is far from ideal - as you have just witnessed, a <code>form submitted</code> via GET encodes all input data in clear text as query parameters. Being part of the URL, they end up stored as part of the browser's navigation history. Query parameters are also captured in logs (e.g. http.route property in our own backend).
We really do not want passwords or any type of sensitive data there.
</div>
<div style="margin-top:.625em;">
We can change this behaviour by setting a value for action and method on form:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<!-- src/routes/login/login.html -->
<!-- [...] -->
<form action="/login" method="post">
<!-- [...] -->
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>We could technically omit action, but the default behaviour is not particularly well-documented therefore it is clearer to define it explicitly.
</div>
<div style="margin-top:.625em;">
Thanks to method="post" the input data will be passed to the backend using the request body, a much safer option.
</div>
<div style="margin-top:.625em;">
If you try to submit the form again, you should see a 404 in the API logs for POST /login. Let's define the endpoint!
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/mod.rs
// [...]
mod post;
pub use post::login;
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
use actix_web::HttpResponse;

pub async fn login() -> HttpResponse {
    HttpResponse::Ok().finish()
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/startup.rs
use crate::routes::login;
// [...]

fn run(/* */) -> Result</* */> {
    // [...]
    let server = HttpServer::new(move || {
        App::new()
            // [...]
            .route("/login", web::post().to(login))
            // [...]
    })
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.2. Redirect On Success" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>Try to log in again: the form will disappear, you will be greeted by a blank page. It is not the best kind of feedback - it would be ideal to show a message confirming that the user has logged in successfully. Furthermore, if the user tries to refresh the page, they will be prompted by the browser to confirm that they want to submit the form again.
</div>
<div style="margin-top:.625em;">
We can improve the situation by using a redirect - if authentication succeeds, we instruct the browser to navigate back to our home page.
</div>
<div style="margin-top:.625em;">
A redirect response requires two elements:
</div>
<ul style="margin-left:2.5em;list-style-type:decimal;margin-top: .325em;">
  <li style="margin-top:.325em;">a redirect status code;</li>
  <li style="margin-top:.325em;">a <code>Location</code> header, set to the URL we want to redirect to.</li>
</ul>
<div style="margin-top:.625em;">
All redirect status codes are in the <code>3xx</code> range - we need to choose the most appropriate one depending on the HTTP verb and the semantic meaning we want to communicate (e.g. temporary vs permanent redirection).
You can find a comprehensive guide on <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Redirections">MDN Web Docs</a>. <code>303 See Other</code> is the most fitting for our usecase (confirmation page after form submission):
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
use actix_web::http::header::LOCATION;
use actix_web::HttpResponse;

pub async fn login() -> HttpResponse {
    HttpResponse::SeeOther()
        .insert_header((LOCATION, "/"))
        .finish()
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
You should now see <code>Welcome to our newsletter!</code> after form submission.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.3. Processing Form Data" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>Truth be told, we are not redirecting on success - we are <code>always</code> redirecting.
We need to enhance our login function to actually verify the incoming credentials.
</div>
<div style="margin-top:.625em;">
As we have seen in chapter 3, form data is submitted to the backend using the <code>application/x-www-form-urlencoded</code> content type.
</div>
<div style="margin-top:.625em;">
We can parse it out of the incoming request using <code>actix-web</code>'s <code>Form</code> extractor and a struct that implements <code>serde::Deserialize:</code>
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
// [...]
use actix_web::web;
use secrecy::Secret;

#[derive(serde::Deserialize)]
pub struct FormData {
    username: String,
    password: Secret<String>,
}

pub async fn login(_form: web::Form<FormData>) -> HttpResponse {
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We built the foundation of password-based authentication in the earlier part of this chapter - let's look again at the auth code in the handler for <code>POST /newsletters</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
// [...]

#[tracing::instrument(
    name = "Publish a newsletter issue",
    skip(body, pool, email_client, request),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
pub async fn publish_newsletter(
    body: web::Json<BodyData>,
    pool: web::Data<PgPool>,
    email_client: web::Data<EmailClient>,
    request: HttpRequest,
) -> Result<HttpResponse, PublishError> {
    let credentials = basic_authentication(request.headers())
        .map_err(PublishError::AuthError)?;
    tracing::Span::current()
        .record("username", &tracing::field::display(&credentials.username));
    let user_id = validate_credentials(credentials, &pool).await?;
    tracing::Span::current()
        .record("user_id", &tracing::field::display(&user_id));
    // [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;;font-family:monospace;margin-top:1em;">
      <![CDATA[
<code>basic_authentication</code> deals with the extraction of credentials from the <code>Authorization</code> header when using the <code>'Basic' authentication scheme</code> - not something we are interested in reusing in login.
<code>validation_credentials</code>, instead, is what we are looking for: it takes username and password as input, returning either the corresponding <code>user_id</code> (if authentication is successful) or an error (if credentials are invalid).
The current definition of <code>validation_credentials</code> is polluted by the concerns of <code>publish_newsletters</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
// [...]

async fn validate_credentials(
    credentials: Credentials,
    pool: &PgPool,
    // We are returning a `PublishError`, 
    // which is a specific error type detailing 
    // the relevant failure modes of `POST /newsletters`
    // (not just auth!)
) -> Result<uuid::Uuid, PublishError> {
    let mut user_id = None;
    let mut expected_password_hash = Secret::new(
        "$argon2id$v=19$m=15000,t=2,p=1$\
        gZiV/M1gPc22ElAH/Jh1Hw$\
        CWOrkoo7oJBQ/iyh7uJ0LO2aLEfrHwTWllSAxT0zRno"
            .to_string()
    );

    if let Some((stored_user_id, stored_password_hash)) =
        get_stored_credentials(&credentials.username, pool)
            .await
            .map_err(PublishError::UnexpectedError)?
    {
        user_id = Some(stored_user_id);
        expected_password_hash = stored_password_hash;
    }

    spawn_blocking_with_tracing(move || {
        verify_password_hash(expected_password_hash, credentials.password)
    })
    .await
    .context("Failed to spawn blocking task.")
    .map_err(PublishError::UnexpectedError)??;

    user_id.ok_or_else(|| PublishError::AuthError(anyhow::anyhow!("Unknown username.")))
}
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="2.3.1. Building An authentication Module" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
Let's refactor <code>validate_credentials</code> to prepare it for extraction - we want to build a shared <code>authentication</code> module, which we will use in both <code>POST /login</code> and <code>POST /newsletters</code>.
Let's define <code>AuthError</code>, a new error enum:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/lib.rs
pub mod authentication;
// [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/authentication.rs
 
#[derive(thiserror::Error, Debug)]
pub enum AuthError {
    #[error("Invalid credentials.")]
    InvalidCredentials(#[source] anyhow::Error),
    #[error(transparent)]
    UnexpectedError(#[from] anyhow::Error),
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We are using an enumeration because, just like we did in <code>POST /newsletters</code>, we want to empower the caller to react differently depending on the error type - i.e. return a <code>500</code> for <code>UnexpectedError</code>, while AuthErrors should result into a <code>401</code>.
</div>
<div style="margin-top:.625em;">
Let's change the signature of <code>validate_credentials</code> to return <code>Result&lt;uuid::Uuid, AuthError&gt;</code> now:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
use crate::authentication::AuthError;
// [...]

async fn validate_credentials(
    // [...]
) -> Result<uuid::Uuid, AuthError> {
    // [...]

    if let Some(/* */) = get_stored_credentials(/* */).await?
    {/* */}

    spawn_blocking_with_tracing(/* */)
        .await
        .context("Failed to spawn blocking task.")??;

    user_id
        .ok_or_else(|| anyhow::anyhow!("Unknown username."))
        .map_err(AuthError::InvalidCredentials)
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<code>cargo check</code> returns two errors now:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
error[E0277]: `?` couldn't convert the error to `AuthError`
   --> src/routes/newsletters.rs
    |
    |     .context("Failed to spawn blocking task.")??;
    |                                                ^ 
      the trait `From<PublishError>` is not implemented for `AuthError`
      
error[E0277]: `?` couldn't convert the error to `PublishError`
   --> src/routes/newsletters.rs
    |
    |     let user_id = validate_credentials(credentials, &pool).await?;
    |                                                                 ^ 
      the trait `From<AuthError>` is not implemented for `PublishError`
    |
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The first error comes from <code>validate_credentials</code> itself - we are calling <code>verify_password_hash</code>, which is still returning a <code>PublishError</code>.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
// [...]

#[tracing::instrument(/* */)]
fn verify_password_hash(
    expected_password_hash: Secret<String>,
    password_candidate: Secret<String>,
) -> Result<(), PublishError> {
    let expected_password_hash = PasswordHash::new(
            expected_password_hash.expose_secret()
        )
        .context("Failed to parse hash in PHC string format.")
        .map_err(PublishError::UnexpectedError)?;

    Argon2::default()
        .verify_password(
            password_candidate.expose_secret().as_bytes(), 
            &expected_password_hash
        )
        .context("Invalid password.")
        .map_err(PublishError::AuthError)
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Let's fix it:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
// [...]

#[tracing::instrument(/* */)]
fn verify_password_hash(/* */) -> Result<(), AuthError> {
    let expected_password_hash = PasswordHash::new(/* */)
        .context("Failed to parse hash in PHC string format.")?;

    Argon2::default()
        .verify_password(/* */)
        .context("Invalid password.")
        .map_err(AuthError::InvalidCredentials)
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Let's deal with second error now:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
error[E0277]: `?` couldn't convert the error to `PublishError`
   --> src/routes/newsletters.rs
    |
    |     let user_id = validate_credentials(credentials, &pool).await?;
    |                                                                 ^ 
      the trait `From<AuthError>` is not implemented for `PublishError`
    |
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
This comes from the call to <code>verify_credentials</code> inside <code>publish_newsletters</code>, the request handler.
<code>AuthError</code> does not implement a conversion into <code>PublishError</code>, therefore the <code>?</code> operator cannot be used.
We will call <code>map_err</code> to perform the mapping inline:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
// [...]

pub async fn publish_newsletter(/* */) -> Result<HttpResponse, PublishError> {
    // [...]
    let user_id = validate_credentials(credentials, &pool)
        .await
        // We match on `AuthError`'s variants, but we pass the **whole** error 
        // into the constructors for `PublishError` variants. This ensures that
        // the context of the top-level wrapper is preserved when the error is 
        // logged by our middleware.
        .map_err(|e| match e {
            AuthError::InvalidCredentials(_) => PublishError::AuthError(e.into()),
            AuthError::UnexpectedError(_) => PublishError::UnexpectedError(e.into()),
        })?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The code should compile now. <br />
Let's complete the extraction by moving <code>validate_credentials</code>, <code>Credentials</code>, <code>get_stored_credentials</code> and <code>verify_password_hash</code> into the <code>authentication</code> module:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/authentication.rs
use crate::telemetry::spawn_blocking_with_tracing;
use anyhow::Context;
use secrecy::{Secret, ExposeSecret};
use argon2::{Argon2, PasswordHash, PasswordVerifier};
use sqlx::PgPool;
// [...]

pub struct Credentials {
    // These two fields were not marked as `pub` before!
    pub username: String,
    pub password: Secret<String>,
}

#[tracing::instrument(/* */)]
pub async fn validate_credentials(/* */) -> Result</* */> {
    // [...]
}

#[tracing::instrument(/* */)]
fn verify_password_hash(/* */) -> Result</* */> {
    // [...]
}

#[tracing::instrument(/* */)]
async fn get_stored_credentials(/* */) -> Result</* */> {
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/newsletters.rs
// [...]
use crate::authentication::{validate_credentials, AuthError, Credentials};
// There will be warnings about unused imports, follow the compiler to fix them!
// [...]
    ]]>
    </c:sourceContent>



    <c:sourceContent type="html" title="2.3.2. Rejecting Invalid Credentials" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
The extracted <code>authentication</code> module is now ready to be used in our <code>login</code> function. <br />
Let's plug it in:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
use crate::authentication::{validate_credentials, Credentials};
use actix_web::http::header::LOCATION;
use actix_web::web;
use actix_web::HttpResponse;
use secrecy::Secret;
use sqlx::PgPool;

#[derive(serde::Deserialize)]
pub struct FormData {
    username: String,
    password: Secret<String>,
}

#[tracing::instrument(
    skip(form, pool),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
// We are now injecting `PgPool` to retrieve stored credentials from the database
pub async fn login(form: web::Form<FormData>, pool: web::Data<PgPool>) -> HttpResponse {
    let credentials = Credentials {
        username: form.0.username,
        password: form.0.password,
    };
    tracing::Span::current()
        .record("username", &tracing::field::display(&credentials.username));
    match validate_credentials(credentials, &pool).await {
        Ok(user_id) => {
            tracing::Span::current()
                .record("user_id", &tracing::field::display(&user_id));
            HttpResponse::SeeOther()
                .insert_header((LOCATION, "/"))
                .finish()
        }
        Err(_) => {
            todo!()
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
A login attempt using random credentials should now fail: the request handler panics due to <code>validation_credentials</code> returning an error, which in turn leads to <code>actix-web</code> dropping the connection. It is not a graceful failure - the browser is likely to show something along the lines of <code>The connection was reset</code>.
We should try as much as possible to avoid panics in request handlers - all errors should be handled gracefully.
Let's introduce a <code>LoginError</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
// [...]
use crate::authentication::AuthError;
use crate::routes::error_chain_fmt;
use actix_web::http::StatusCode;
use actix_web::{web, ResponseError};

#[tracing::instrument(/* */)]
pub async fn login(/* */) -> Result<HttpResponse, LoginError> {
    // [...]
    let user_id = validate_credentials(credentials, &pool)
        .await
        .map_err(|e| match e {
            AuthError::InvalidCredentials(_) => LoginError::AuthError(e.into()),
            AuthError::UnexpectedError(_) => LoginError::UnexpectedError(e.into()),
        })?;
    tracing::Span::current().record("user_id", &tracing::field::display(&user_id));
    Ok(HttpResponse::SeeOther()
        .insert_header((LOCATION, "/"))
        .finish())
}

#[derive(thiserror::Error)]
pub enum LoginError {
    #[error("Authentication failed")]
    AuthError(#[source] anyhow::Error),
    #[error("Something went wrong")]
    UnexpectedError(#[from] anyhow::Error),
}

impl std::fmt::Debug for LoginError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        error_chain_fmt(self, f)
    }
}

impl ResponseError for LoginError {
    fn status_code(&self) -> StatusCode {
        match self {
            LoginError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LoginError::AuthError(_) => StatusCode::UNAUTHORIZED,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The code is very similar to what we wrote a few sections ago while refactoring <code>POST /newsletters</code>.
What is the effect on the browser?
</div>
<div style="margin-top:.625em;">
Submission of the form triggers a page load, resulting in <code>Authentication failed</code> being shown on screen5.
Much better than before, we are making progress!
</div>
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="2.4. Contextual Errors" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
The error message is clear enough - but what should the user do next?
It is reasonable to assume that they want to try to enter their credentials again - they have probably misspelled their username or their password.
</div>
<div style="margin-top:.625em;">
We need the error message to appear on top of the login form - providing the user with information while allowing them to quickly retry.
</div>
    ]]>
    </c:sourceContent>


    <c:sourceContent type="html" title="2.4.1. Naive Approach" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
What is the simplest possible approach? <br />
We could return the login HTML page from <code>ResponseError</code>, injecting an additional paragraph (<code>&lt;p&gt;</code> HTML element) reporting the error to the user. <br />
It would look like this:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
// [...]

impl ResponseError for LoginError {
    fn error_response(&self) -> HttpResponse {
        HttpResponse::build(self.status_code())
            .content_type(ContentType::html())
            .body(format!(
                r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Login</title>
</head>
<body>
    <p><i>{}</i></p>
    <form action="/login" method="post">
        <label>Username
            <input
                type="text"
                placeholder="Enter Username"
                name="username"
            >
        </label>
        <label>Password
            <input
                type="password"
                placeholder="Enter Password"
                name="password"
            >
        </label>
        <button type="submit">Login</button>
    </form>
</body>
</html>"#,
                self
            ))
    }

    fn status_code(&self) -> StatusCode {
        match self {
            LoginError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
            LoginError::AuthError(_) => StatusCode::UNAUTHORIZED,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>This approach has a few drawbacks:</div>

<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">we have two slightly-different-but-almost-identical login pages, defined in two different places. If we decide to make changes to the login form, we need to remember to edit both;</li>
  <li style="margin-top:.325em;">the user is prompted to confirm form resubmission if they try to refresh the page after an unsuccessful login attempt.</li>
</ul>

<div style="margin-top:.625em;">
To solve the second issue, we need the user to land on a <code>GET</code> endpoint. <br />
To solve the first issue, we need to find a way to reuse the HTML we wrote in <code>GET /login</code>, instead of duplicating it.
</div>
<div style="margin-top:.625em;">
We can achieve both goals with another redirect: if authentication fails, we send the user back to <code>GET /login</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
// [...]

impl ResponseError for LoginError {
    fn error_response(&self) -> HttpResponse {
        HttpResponse::build(self.status_code())
            .insert_header((LOCATION, "/login"))
            .finish()
    }

    fn status_code(&self) -> StatusCode {
        StatusCode::SEE_OTHER
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>Unfortunately a vanilla redirect is not enough - the browser would show the login form to the user again, with no feedback explaining that their login attempt was unsuccessful. <br />
We need to find a way to instruct GET /login to show an error message.
</div>
<div style="margin-top:.625em;">
Let's explore a few options.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.2. Query Parameters" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
    The value of the <code>Location</code> header determines the URL the user will be redirected to.
It does not end there though - we can also specify query parameters!
</div>
<div style="margin-top:.625em;">
Let's encode the authentication error message in an <code>error</code> query parameter.
Query parameters are part of the URL - therefore we need to URL-encode the display representation of <code>LoginError</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
#! Cargo.toml
# [...]
[dependencies]
urlencoding = "2"
# [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
// [...]

impl ResponseError for LoginError {
    fn error_response(&self) -> HttpResponse {
        let encoded_error = urlencoding::Encoded::new(self.to_string());
        HttpResponse::build(self.status_code())
            .insert_header((LOCATION, format!("/login?error={}", encoded_error)))
            .finish()
    }
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The <code>error</code> query parameter can then be extracted in the request handler for GET /login.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
use actix_web::{web, HttpResponse, http::header::ContentType};

#[derive(serde::Deserialize)]
pub struct QueryParams {
    error: Option<String>,
}

pub async fn login_form(query: web::Query<QueryParams>) -> HttpResponse {
    let _error = query.0.error;
    HttpResponse::Ok()
        .content_type(ContentType::html())
        .body(include_str!("login.html"))
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Finally, we can customise the returned HTML page based on its value:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
// [...]

pub async fn login_form(query: web::Query<QueryParams>) -> HttpResponse {
    let error_html = match query.0.error {
        None => "".into(),
        Some(error_message) => format!("<p><i>{error_message}</i></p>"),
    };
    HttpResponse::Ok()
        .content_type(ContentType::html())
        .body(format!(
            r#"<!DOCTYPE html>
<html lang="en">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <title>Login</title>
</head>
<body>
    {error_html}
    <form action="/login" method="post">
        <label>Username
            <input
                type="text"
                placeholder="Enter Username"
                name="username"
            >
        </label>
        <label>Password
            <input
                type="password"
                placeholder="Enter Password"
                name="password"
            >
        </label>
        <button type="submit">Login</button>
    </form>
</body>
</html>"#,
        ))
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
It works<sup>6</sup>!
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.3. Cross-Site Scripting (XSS)" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>Query parameters are not private - our backend server cannot prevent users from tweaking the URL.
In particular, it cannot prevent attackers from playing with them.</div>
<div style="margin-top:.625em;">
Try to navigate to the following URL:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
http://localhost:8000/login?error=Your%20account%20has%20been%20locked%2C%20
    please%20submit%20your%20details%20%3Ca%20href%3D%22https%3A%2F%2Fzero2prod.com
    %22%3Ehere%3C%2Fa%3E%20to%20resolve%20the%20issue.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
On top of the login form you will see: <br />
Your account has been locked, please submit your details here to resolve the issue.
</div>
<div style="margin-top:.625em;">
with <code>here</code> being a link to another website (zero2prod.com, in this case).
In a more realistic scenario, <code>here</code> would link to a website controlled by an attacker, luring the victim into disclosing their login credentials.
</div>
<div style="margin-top:.625em;">
This is known as a <code>cross-site scripting</code> attack (<code>XSS</code>). <br />
The attacker injects HTML fragments or JavaScript snippets into a trusted website by exploiting dynamic content built from untrusted sources - e.g. user inputs, query parameters, etc. <br />
From a user perspective, XSS attacks are particularly insidious - the URL matches the one you wanted to visit, therefore you are likely to trust the displayed content.
</div>
<div style="margin-top:.625em;">
OWASP provides an <a href="https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html">extensive cheat sheet</a> on how to prevent XSS attacks - I strongly recommend familiarising with it if you are working on a web application.
</div>
<div style="margin-top:.625em;">
Let's look at the guidance for our issue here: we want to display untrusted data (the value of a query parameter) inside an HTML element (<code>&lt;p&gt;&lt;i&gt;UNTRUSTED DATA HERE&lt;/i&gt;&lt;/p&gt;</code>).
According to OWASP's guidelines, we must HTML entity-encode the untrusted input - i.e.:
</div>
<ul style="margin-left:2em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">convert <code>&</code> to <code>&amp;</code></li>
  <li style="margin-top:.325em;">convert <code>&lt;</code> to <code>&lt;</code></li>
  <li style="margin-top:.325em;">convert <code>&gt;</code> to <code>&gt;</code></li>
  <li style="margin-top:.325em;">convert <code>"</code> to <code>&quot;</code></li>
  <li style="margin-top:.325em;">convert <code>'</code> to <code>&#x27;</code></li>
  <li style="margin-top:.325em;">convert <code>/</code> to <code>&#x2F.</code></li>
</ul>
<div style="margin-top:.625em;">
HTML entity encoding prevents the insertion of further HTML elements by escaping the characters required to define them. <br />
Let's amend our <code>login_form</code> handler:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[#! Cargo.toml
# [...]
[dependencies]
htmlescape = "0.3"
# [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
// [...]

pub async fn login_form(/* */) -> HttpResponse {
    let error_html = match query.0.error {
        None => "".into(),
        Some(error_message) => format!(
            "<p><i>{}</i></p>",
            htmlescape::encode_minimal(&error_message)
        ),
    };
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
Load the compromised URL again - you will see a different message:
</div>
<div style="margin-top:.625em;">
Your account has been locked, please submit your details &lt;a href="https://zero2prod.com"&gt;here&lt;/a&gt; to resolve the issue.
</div>
<div style="margin-top:.625em;">
The HTML <code>a</code> element is no longer rendered by the browser - the user has now reasons to suspect that something fishy is going on. <br />
Is it enough?
</div>
<div style="margin-top:.625em;">
At the very least, users are less likely to copy-paste and navigate to the link compared to just clicking on <code>here</code>. Nonetheless, attackers are not naive - they will amend the injected message as soon as they notice that our website is performing HTML entity encoding. It could be as simple as
</div>
<div style="margin-top:.625em;">
Your account has been locked, please call +CC3332288777 to resolve the issue.
</div>
<div style="margin-top:.625em;">
This might be good enough to lure in a couple of victims. We need something stronger than character escaping.
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.4. Message Authentication Codes" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
We need a mechanism to verify that the query parameters have been set by our API and that they have not been altered by a third party.
</div>
<div style="margin-top:.625em;">
This is known as <a href="https://en.wikipedia.org/wiki/Message_authentication">message authentication</a> - it guarantees that the message has not been modified in transit (<code>integrity</code>) and it allows you to verify the identity of the sender (<code>data origin authentication</code>).
</div>
<div style="margin-top:.625em;">
Message authentication codes (<code>MACs</code>) are a common technique to provide message authentication - a tag is added to the message allowing verifiers to check its integrity and origin. <br />
<code>HMAC</code> are a well-known family of MACs - <code>h</code>ash-based <code>m</code>essage <code>a</code>uthentication <code>c</code>odes.
</div>
<div style="margin-top:.625em;">
HMACs are built around a secret and a hash function. <br />
The secret is prepended to the message and the resulting string is fed into the hash function. The resulting hash is then concatenated to the secret and hashed again - the output is the message tag. <br />
In pseudo-code:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
let hmac_tag = hash(
    concat(
        key, 
        hash(concat(key, message))
    )
);
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We are deliberately omitting a few nuances around key padding - you can find all the details in <a href="https://datatracker.ietf.org/doc/html/rfc2104">RFC 2104</a>.
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.5. Add An HMAC Tag To Protect Query Parameters" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
Let's try to use a HMAC to verify integrity and provenance for our query parameters.
The <a href="https://github.com/RustCrypto">Rust Crypto</a> organization provides an implementation of HMACs, the <code>hmac</code> crate. We will also need a hash function <code>- let's go for SHA-256</code>.
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
#! Cargo.toml
# [...]
[dependencies]
hmac = { version = "0.12", features = ["std"] }
sha2 = "0.10"
# [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Let's add another query parameter to our Location header, tag, to store the HMAC of our error message.
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
use hmac::{Hmac, Mac};
// [...]

impl ResponseError for LoginError {
    fn error_response(&self) -> HttpResponse {
        let query_string = format!(
            "error={}", 
            urlencoding::Encoded::new(self.to_string())
        );
        // We need the secret here - how do we get it?
        let secret: &[u8] = todo!();
        let hmac_tag = {
            let mut mac = Hmac::<sha2::Sha256>::new_from_slice(secret).unwrap();
            mac.update(query_string.as_bytes());
            mac.finalize().into_bytes()
        };
        HttpResponse::build(self.status_code())
            // Appending the hexadecimal representation of the HMAC tag to the 
            // query string as an additional query parameter.
            .insert_header((
                LOCATION, 
                format!("/login?{}&tag={:x}", query_string, hmac_tag)
            ))
            .finish()
    }
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The code snippet is almost perfect - we just need a way to get our secret! <br />
Unfortunately it will not be possible from within <code>ResponseError</code> - we only have access to the error type (<code>LoginError</code>) that we are trying to convert into an HTTP response. <code>ResponseError</code> is just a specialised Into trait. <br />
In particular, we do not have access to the application state (i.e. we cannot use the <code>web::Data</code> extractor), which is where we would be storing the secret.
</div>
<div style="margin-top:.625em;">
Let's move our code back into the request handler:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
use secret::ExposeSecret;
// [...]

#[tracing::instrument(
    skip(form, pool, secret),
    fields(username=tracing::field::Empty, user_id=tracing::field::Empty)
)]
pub async fn login(
    form: web::Form<FormData>,
    pool: web::Data<PgPool>,
    // Injecting the secret as a secret string for the time being.
    secret: web::Data<Secret<String>>,
    // No longer returning a `Result<HttpResponse, LoginError>`!
) -> HttpResponse {
    // [...]
    match validate_credentials(credentials, &pool).await {
        Ok(user_id) => {
            tracing::Span::current()
                .record("user_id", &tracing::field::display(&user_id));
            HttpResponse::SeeOther()
                .insert_header((LOCATION, "/"))
                .finish()
        }
        Err(e) => {
            let e = match e {
                AuthError::InvalidCredentials(_) => LoginError::AuthError(e.into()),
                AuthError::UnexpectedError(_) => LoginError::UnexpectedError(e.into()),
            };
            let query_string = format!(
                "error={}", 
                urlencoding::Encoded::new(e.to_string())
            );
            let hmac_tag = {
                let mut mac = Hmac::<sha2::Sha256>::new_from_slice(
                    secret.expose_secret().as_bytes()
                ).unwrap();
                mac.update(query_string.as_bytes());
                mac.finalize().into_bytes()
            };
            HttpResponse::SeeOther()
                .insert_header((
                    LOCATION,
                    format!("/login?{query_string}&tag={hmac_tag:x}")
                ))
                .finish()
        }
    }
}

// The `ResponseError` implementation for `LoginError` has been deleted.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
This is a viable approach - and it compiles. <br />
It has one drawback - we are no longer propagating upstream, to the middleware chain, the error context. This is concerning when dealing with a <code>LoginError::UnexpectedError</code> - our logs should really capture what has gone wrong.
Luckily enough, there is a way to have our cake and eat it too: <code>actix_web::error::InternalError</code>. <br />
<code>InternalError</code> can be built from a <code>HttpResponse</code> and an error. It can be returned as an error from a request handler (it implements <code>ResponseError</code>) and it returns to the caller the <code>HttpResponse</code> you passed to its constructor - exactly what we needed!
</div>
<div style="margin-top:.625em;">
Let's change <code>login</code> once again to use it:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
// [...]
use actix_web::error::InternalError;

#[tracing::instrument(/* */)]
// Returning a `Result` again!
pub async fn login(/* */) -> Result<HttpResponse, InternalError<LoginError>> {
    // [...]
    match validate_credentials(credentials, &pool).await {
        Ok(user_id) => {
            // [...]
            // We need to Ok-wrap again
            Ok(/* */)
        }
        Err(e) => {
            // [...]
            let response = HttpResponse::SeeOther()
                .insert_header((
                    LOCATION,
                    format!("/login?{}&tag={:x}", query_string, hmac_tag),
                ))
                .finish();
            Err(InternalError::from_response(e, response))
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Error reporting has been saved. <br />
One last task left for us: injecting the secret used by our HMACs into the application state.
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/configuration.rs
// [...]
#[derive(serde::Deserialize, Clone)]
pub struct ApplicationSettings {
    // [...]
    pub hmac_secret: Secret<String>
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/startup.rs
use secrecy::Secret;
// [...]

impl Application {
    pub async fn build(configuration: Settings) -> Result<Self, std::io::Error> {
        // [...]
        let server = run(
            // [...]
            configuration.application.hmac_secret,
        )?;
        // [...]
    }
}

fn run(
    // [...]
    hmac_secret: Secret<String>,
) -> Result<Server, std::io::Error> {
    let server = HttpServer::new(move || {
        // [...]
        .app_data(Data::new(hmac_secret.clone()))
    })
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
#! configuration/base.yml
application:
    # [...]
    # You need to set the `APP_APPLICATION__HMAC_SECRET` environment variable 
    # on Digital Ocean as well for production!
    hmac_secret: "super-long-and-secret-random-key-needed-to-verify-message-integrity"
# [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Using <code>Secret&lt;String&gt;</code> as the type injected into the application state is far from ideal. <code>String</code> is a primitive type and there is a significant risk of conflict - i.e. another middleware or service registering another <code>Secret&lt;String&gt;</code> against the application state, overriding our HMAC secret (or vice versa). <br />
Let's create a wrapper type to sidestep the issue:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/startup.rs
// [...]

fn run(
    // [...]
    hmac_secret: HmacSecret,
) -> Result<Server, std::io::Error> {
    let server = HttpServer::new(move || {
        // [...]
        .app_data(Data::new(HmacSecret(hmac_secret.clone())))
    })
    // [...]
}

#[derive(Clone)]
pub struct HmacSecret(pub Secret<String>);
    ]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/post.rs
use crate::startup::HmacSecret;
// [...]

#[tracing::instrument(/* */)]
pub async fn login(
    // [...]
    // Inject the wrapper type!
    secret: web::Data<HmacSecret>,
) -> Result<HttpResponse, InternalError<LoginError>> {
    // [...]
    match validate_credentials(/* */).await {
        Ok(/* */) => {/* */}
        Err(/* */) => {
            // [...]
            let hmac_tag = {
                let mut mac = Hmac::<sha2::Sha256>::new_from_slice(
                    secret.0.expose_secret().as_bytes()
                ).unwrap();
                // [...]
            };
            // [...]
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.6. Verifying The HMAC Tag" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
    Time to validate that tag in <code>GET /login!</code>
</div>
<div style="margin-top:.625em;">
Let's start by extracting the <code>tag</code> query parameter.
We are currently using the <code>Query</code> extractor to parse the incoming query parameters into a <code>QueryParams</code> struct, which features an optional <code>error</code> field. <br />
Going forward, we foresee two scenarios:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">There is no error (e.g. you just landed on the login page), therefore we do not expect any query parameter;</li>
  <li style="margin-top:.325em;">There is an error to be reported, therefore we expect to see both an <code>error</code> and a <code>tag</code> query parameter.
</li>
</ul>
<div style="margin-top:.625em;">
Changing <code>QueryParams</code> from
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
#[derive(serde::Deserialize)]
pub struct QueryParams {
    error: Option<String>,
}

// To
#[derive(serde::Deserialize)]
pub struct QueryParams {
    error: Option<String>,
    tag: Option<String>,
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
would not capture the new requirements accurately - it would allow callers to pass a <code>tag</code> parameter while omitting the <code>error</code> one, or vice versa. We would need to do extra validation in the request handler to make sure this is not the case.
We can avoid this issue entirely by making all fields in <code>QueryParams</code> required while <code>QueryParams</code> itself becomes optional:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
// [...]

#[derive(serde::Deserialize)]
pub struct QueryParams {
    error: String,
    tag: String,
}

pub async fn login_form(query: Option<web::Query<QueryParams>>) -> HttpResponse {
    let error_html = match query {
        None => "".into(),
        Some(query) => {
            format!("<p><i>{}</i></p>", htmlescape::encode_minimal(&query.0.error))
        }
    };
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
A neat little reminder to make illegal state impossible to represent using types! <br />
To verify the tag we will need access to the HMAC shared secret - let's inject it:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
use crate::startup::HmacSecret;
// [...]

pub async fn login_form(
    query: Option<web::Query<QueryParams>>,
    secret: web::Data<HmacSecret>,
) -> HttpResponse {
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<code>tag</code> was a byte slice encoded as a hex string. We will need the <code>hex</code> crate to decode it back to bytes in <code>GET /login.</code> Let's add it as a dependency:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
#! Cargo.toml
# [...]
[dependencies]
# [...]
hex = "0.4"
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We can now define a verify method on QueryParams itself: it will return the error string if the message authentication code matches our expectations, an error otherwise.
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs
use hmac::{Hmac, Mac};
use secrecy::ExposeSecret;
// [...]

impl QueryParams {
    fn verify(self, secret: &HmacSecret) -> Result<String, anyhow::Error> {
        let tag = hex::decode(self.tag)?;
        let query_string = format!("error={}", urlencoding::Encoded::new(&self.error));

        let mut mac = Hmac::<sha2::Sha256>::new_from_slice(
            secret.0.expose_secret().as_bytes()
        ).unwrap();
        mac.update(query_string.as_bytes());
        mac.verify_slice(&tag)?;

        Ok(self.error)
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We now need to amend the request handler to call it, which raises a question: what do we want to do if the verification fails?
One approach is to fail the entire request by returning a <code>400</code>. Alternatively, we can log the verification failure as a warning and skip the error message when rendering the HTML.
</div>
<div style="margin-top:.625em;">
Let's go for the latter - a user being redirected with some dodgy query parameters will see our login page, an acceptable scenario.
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
//! src/routes/login/get.rs 
// [...]

pub async fn login_form(/* */) -> HttpResponse {
    let error_html = match query {
        None => "".into(),
        Some(query) => match query.0.verify(&secret) {
            Ok(error) => {
                format!("<p><i>{}</i></p>", htmlescape::encode_minimal(&error))
            }
            Err(e) => {
                tracing::warn!(
                    error.message = %e, 
                    error.cause_chain = ?e, 
                    "Failed to verify query parameters using the HMAC tag"
                );
                "".into()
            }
        },
    };
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
You can try again to load our scammy URL:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
http://localhost:8000/login?error=Your%20account%20has%20been%20locked%2C%20
    please%20submit%20your%20details%20%3Ca%20href%3D%22https%3A%2F%2Fzero2prod.com
    %22%3Ehere%3C%2Fa%3E%20to%20resolve%20the%20issue.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
No error message should be rendered by the browser!
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.7. Error Messages Must Be Ephemeral" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
    Implementation-wise, we are happy: the error is rendered as expected and nobody can tamper with our messages thanks to the HMAC tag. Should we deploy it?
</div>
<div style="margin-top:.625em;">
We chose a query parameter to pass along the error message because query parameters are a part of the URL - it is easy to pass them along in the value of the <code>Location</code> header when redirecting back to the login form on failures. This is both their strength and their weakness: URLs are stored in the browser history, which is in turn used to provide autocomplete suggestions when typing a URL into the address bar. You can experiment with this yourself: try to type <code>http://localhost:8000</code> in your address bar - what are the suggestions?
Most of them will be URLs including the <code>error</code> query parameter due to all the experiments we have been doing so far. If you pick one with a valid tag, the login form will feature an <code>Authentication failed</code> error message... even though it has been a while since your last login attempt. This is undesirable.
</div>
<div style="margin-top:.625em;">
We would like the error message to be <code>ephemeral</code>.
It is shown right after a failed login attempt, but it is not stored in your browser history. The only way to trigger the error message again should be to... fail to log in one more time.
</div>
<div style="margin-top:.625em;">
We established that query parameters do not meet our requirements. Do we have other options?
Yes, <code>cookies!</code>
</div>
<div style="margin-top:.625em;">
This is a great moment to take a break, this is a long chapter!
Check out the <a href="https://github.com/LukeMathWalker/zero-to-production/tree/root-chapter-10-part1">project snapshot on GitHub</a> if you want to check your implementation.
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.8. What Is A Cookie?" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
MDN Web Docs defines an HTTP cookie as
</div>
<div style="margin-top:.625em;">
[...] a small piece of data that a server sends to a user's web browser. The browser may store the cookie and send it back to the same server with later requests.
</div>
<div style="margin-top:.625em;">
We can use cookies to implement the same strategy we tried with query parameters:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">The user enters invalid credentials and submits the form;</li>
  <li style="margin-top:.325em;"><code>POST /login</code> sets a cookie containing the error message and redirects the user back to <code>GET /login</code>;</li>
  <li style="margin-top:.325em;">The browser calls <code>GET /login</code>, including the values of the cookies currently set for the user;</li>
  <li style="margin-top:.325em;"><code>GET /login</code>'s request handler checks the cookies to see if there is an error message to be rendered;</li>
  <li style="margin-top:.325em;"><code>GET /login</code> returns the HTML form to the caller and deletes the error message from the cookie.</li>
</ul>
<div style="margin-top:.625em;">
The URL is never touched - all error-related information is exchanged via a side-channel (cookies), invisible to the browser history. The last step in the algorithm ensures that the error message is indeed ephemeral - the cookie is "consumed" when the error message is rendered. If the page is reloaded, the error message will not be shown again.
</div>
<div style="margin-top:.625em;">
One-time notifications, the technique we just described, are known as <code>flash messages</code>.
</div>

]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="2.4.9. An Integration Test For Login Failures" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
So far we have experimented quite freely - we wrote some code, launched the application, played around with it.
We are now approaching the final iteration of our design and it would be nice to capture the desired behaviour using some black-box tests, as we did so far for all the user flows supported by our project. Writing a test will also help us to get familiar with cookies and their behaviour.
</div>
<div style="margin-top:.625em;">
We want to verify what happens on login failures, the topic we have been obsessing over for a few sections now.
Let's start by adding a new login module to our test suite:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/main.rs
// [...]
mod login;
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/login.rs
// Empty for now
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We will need to send a POST /login request - let's add a little helper to our TestApp, the HTTP client used to interact with our application in our tests:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/helpers.rs
// [...]

impl TestApp {
    pub async fn post_login<Body>(&self, body: &Body) -> reqwest::Response
    where
        Body: serde::Serialize,
    {
        reqwest::Client::new()
            .post(&format!("{}/login", &self.address))
            // This `reqwest` method makes sure that the body is URL-encoded
            // and the `Content-Type` header is set accordingly.
            .form(body)
            .send()
            .await
            .expect("Failed to execute request.")
    }
    
    // [...]
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We can now start to sketch our test case. Before touching cookies, we will begin with a simple assertion - it returns a redirect, status code <code>303</code>.
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/login.rs
use crate::helpers::spawn_app;

#[tokio::test]
async fn an_error_flash_message_is_set_on_failure() {
    // Arrange
    let app = spawn_app().await;

    // Act
    let login_body = serde_json::json!({
        "username": "random-username",
        "password": "random-password"
    });
    let response = app.post_login(&login_body).await;

    // Assert
    assert_eq!(response.status().as_u16(), 303);
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The test fails!
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
---- login::an_error_flash_message_is_set_on_failure stdout ----
thread 'login::an_error_flash_message_is_set_on_failure' panicked at 
'assertion failed: `(left == right)`
  left: `200`,
 right: `303`'
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
Our endpoint already returns a <code>303</code> - both in case of failure and success! What is going on?
The answer can be found in <code>reqwest</code>'s documentation:
</div>
<div style="margin-top:.625em;">
By default, a <code>Client</code> will automatically handle HTTP redirects, having a maximum redirect chain of 10 hops. To customize this behavior, a <code>redirect::Policy</code> can be used with a ClientBuilder.
</div>
<div style="margin-top:.625em;">
<code>reqwest::Client</code> sees the <code>303</code> status code and automatically proceeds to call <code>GET /login</code>, the path specified in the <code>Location</code> header, which return a <code>200</code> - the status code we see in the assertion panic message.
</div>
<div style="margin-top:.625em;">
For the purpose of our testing, we do not want <code>reqwest::Client</code> to follow redirects - let's customise the HTTP client behaviour by following the guidance provided in its documentation:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/helpers.rs
// [...]

impl TestApp {
    pub async fn post_login<Body>(&self, body: &Body) -> reqwest::Response
        where
            Body: serde::Serialize,
    {
        reqwest::Client::builder()
            .redirect(reqwest::redirect::Policy::none())
            .build()
            .unwrap()
            // [...]
    }
    // [...]
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The test should pass now. <br />
We can go one step further - inspect the value of the Location header.
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/helpers.rs
// [...] 

// Little helper function - we will be doing this check several times throughout
// this chapter and the next one.
pub fn assert_is_redirect_to(response: &reqwest::Response, location: &str) {
    assert_eq!(response.status().as_u16(), 303);
    assert_eq!(response.headers().get("Location").unwrap(), location);
}
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/login.rs
use crate::helpers::assert_is_redirect_to;
// [...] 

#[tokio::test]
async fn an_error_flash_message_is_set_on_failure() {
    // [...]

    // Assert
    assert_is_redirect_to(&response, "/login");
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
You should see another failure:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
---- login::an_error_flash_message_is_set_on_failure stdout ----
thread 'login::an_error_flash_message_is_set_on_failure' panicked at 
'assertion failed: `(left == right)`
  left: `"/login?error=Authentication%20failed.&tag=2f8fff5[...]"`,
 right: `"/login"`'
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The endpoint is still using query parameters to pass along the error message. Let's remove that functionality from the request handler:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/login/post.rs
// A few imports are now unused and can be removed.
// [...]

#[tracing::instrument(/* */)]
pub async fn login(
    form: web::Form<FormData>,
    pool: web::Data<PgPool>,
    // We no longer need `HmacSecret`!
) -> Result<HttpResponse, InternalError<LoginError>> {
    // [...]
    match validate_credentials(/* */).await {
        Ok(/* */) => {/* */}
        Err(e) => {
            let e = match e {
                AuthError::InvalidCredentials(_) => LoginError::AuthError(e.into()),
                AuthError::UnexpectedError(_) => LoginError::UnexpectedError(e.into()),
            };
            let response = HttpResponse::SeeOther()
                .insert_header((LOCATION, "/login"))
                .finish();
            Err(InternalError::from_response(e, response))
        }
    }
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
I know, it feels like we are going backwards - you need have a bit of patience! <br />
The test should pass. We can now start looking at cookies, which begs the question - what does "set a cookie" actually mean?
</div>
<div style="margin-top:.625em;">
Cookies are set by attaching a special HTTP header to the response - <code>Set-Cookie</code>.
In its simplest form it looks like this:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Set-Cookie: <cookie-name>=<cookie-value>
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
<code>Set-Cookie</code> can be specified multiple times - one for each cookie you want to set.
</div>
<div style="margin-top:.625em;">
<code>reqwest</code> provides the <code>get_all</code> method to deal with multi-value headers:
</div>
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/login.rs
// [...]
use reqwest::header::HeaderValue;
use std::collections::HashSet;

#[tokio::test]
async fn an_error_flash_message_is_set_on_failure() {
    // [...]
    let cookies: HashSet<_> = response
        .headers()
        .get_all("Set-Cookie")
        .into_iter()
        .collect();
    assert!(cookies
        .contains(&HeaderValue::from_str("_flash=Authentication failed").unwrap())
    );
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Truth be told, cookies are so ubiquitous to deserve a dedicated API, sparing us the pain of working with the raw headers. <code>reqwest</code> locks this functionality behind the <code>cookies</code> feature-flag - let's enable it:
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
#! Cargo.toml
# [...]
# Using multi-line format for brevity
[dependencies.reqwest]
version = "0.11"
default-features = false
features = ["json", "rustls-tls", "cookies"]
]]>
    </c:sourceContent>
    <c:sourceContent type="" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/login.rs
// [...]
use reqwest::header::HeaderValue;
use std::collections::HashSet;

#[tokio::test]
async fn an_error_flash_message_is_set_on_failure() {
    // [...]
    let flash_cookie = response.cookies().find(|c| c.name() == "_flash").unwrap();
    assert_eq!(flash_cookie.value(), "Authentication failed");
}
]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
As you can see, the cookie API is significantly more ergonomic. Nonetheless there is value in touching directly what it abstracts away, at least once. <br />
The test should fail, as expected.
]]>
    </c:sourceContent>

    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>



</c:component>
