<?xml version="1.0" encoding="utf-8"?>
<c:component type="chSourceHighlighting" componentId="chSourceHighlighting_1" xmlns:c="http://com.snnmo.website">
  <c:abstract>
    <![CDATA[
<div style="font-size:1.1em;line-height:1.625;">
This article is a sample from <a href="https://zero2prod.com/">Zero To Production In Rust</a>, a book on backend development in Rust.
You can get a copy of the book on <a href="https://zero2prod.com/">zero2prod.com</a>.
<a href="https://www.lpalmieri.com/subscribe">Subscribe to the newsletter</a> to be notified when a new episode is published.
</div>
]]>
  </c:abstract>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">TL;DR</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
To send a confirmation email you have to stitch together multiple operations: validation of user input, email dispatch, various database queries. <br />
They all have one thing in common: they may fail.
</div>
<div style="margin-top:.625em;">
In <a href="https://www.lpalmieri.com/posts/2020-12-11-zero-to-production-6-domain-modelling/#7-errors-as-values-result">Chapter 6</a> we discussed the building blocks of error handling in Rust - <code>Result</code> and the <code>?</code> operator.
We left many questions unanswered: how do errors fit within the broader architecture of our application? What does a good error look like? Who are errors for? Should we use a library? Which one?
</div>
<div style="margin-top:.625em;">
An in-depth analysis of error handling patterns in Rust will be the sole focus of this chapter.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="What Is The Purpose Of Errors?" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
Let's start with an example:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn store_token(
    transaction: &mut Transaction<'_, Postgres>,
    subscriber_id: Uuid,
    subscription_token: &str,
) -> Result<(), sqlx::Error> {
    sqlx::query!(
        r#"
    INSERT INTO subscription_tokens (subscription_token, subscriber_id)
    VALUES ($1, $2)
        "#,
        subscription_token,
        subscriber_id
    )
    .execute(transaction)
    .await
    .map_err(|e| {
        tracing::error!("Failed to execute query: {:?}", e);
        e
    })?;
    Ok(())
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We are trying to insert a row into the <code>subscription_tokens</code> table in order to store a newly-generated token against a <code>subscriber_id</code>.
</div>
<div style="margin-top:.625em;">
<code>execute</code> is a fallible operation: we might have a network issue while talking to the database, the row we are trying to insert might violate some table constraints (e.g. uniqueness of the primary key), etc.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Internal Errors" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<h4><b>Enable The Caller To React</b></h4>
<div>
The caller of <code>execute</code> most likely wants to be informed if a failure occurs - <b>they need to react accordingly</b>, e.g. retry the query or propagate the failure upstream using <code>?</code>, as in our example.
</div>
<div style="margin-top:.625em;">
Rust leverages the type system to communicate that an operation may not succeed: the return type of <code>execute</code> is <code>Result</code>, an enum.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
pub enum Result<Success, Error> {
    Ok(Success),
    Err(Error)
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The caller is then forced by the compiler to express how they plan to handle both scenarios - success and failure.
</div>
<div style="margin-top:.625em;">
If our only goal was to communicate to the caller that an error happened, we could use a simpler definition for <code>Result</code>:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
pub enum ResultSignal<Success> {
    Ok(Success),
    Err
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
There would be no need for a generic <code>Error</code> type - we could just check that <code>execute</code> returned the <code>Err</code> variant, e.g.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
let outcome = sqlx::query!(/* ... */)
    .execute(transaction)
    .await;
if outcome == ResultSignal::Err { 
    // Do something if it failed
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
This works if there is only one failure mode. Truth is, operations can fail in multiple ways and we might want to react differently depending on what happened.
</div>
<div style="margin-top:.625em;">
Let's look at the skeleton of <code>sqlx::Error</code>, the error type for <code>execute</code>:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! sqlx-core/src/error.rs
 
pub enum Error {
    Configuration(/* */),
    Database(/* */),
    Io(/* */),
    Tls(/* */),
    Protocol(/* */),
    RowNotFound,
    TypeNotFound {/* */},
    ColumnIndexOutOfBounds {/* */},
    ColumnNotFound(/* */),
    ColumnDecode {/* */},
    Decode(/* */),
    PoolTimedOut,
    PoolClosed,
    WorkerCrashed,
    Migrate(/* */),
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
Quite a list, ain't it?
</div>
<div style="margin-top:.625em;">
<code>sqlx::Error</code> is implemented as an enum to allow users to match on the returned error and behave differently depending on the underlying failure mode. For example, you might want to retry a <code>PoolTimedOut</code> while you will probably give up on a <code>ColumnNotFound</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Help An Operator To Troubleshoot" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
What if an operation has a single failure mode - should we just use <code>()</code> as error type?
</div>
<div style="margin-top:.625em;">
<code>Err(())</code> might be enough for the caller to determine what to do - e.g. return a <code>500 Internal Server Error</code> to the user.
</div>
<div style="margin-top:.625em;">
But control flow is not the only purpose of errors in an application.
</div>
<div style="margin-top:.625em;">
We expect errors to carry enough <code>context</code> about the failure to produce a <code>report</code> for an operator (e.g. the developer) that contains enough details to go and troubleshoot the issue.
</div>
<div style="margin-top:.625em;">
What do we mean by report? <br />
In a backend API like ours it will usually be a log event. <br />
In a CLI it could be an error message shown in the terminal when a <code>--verbose</code> flag is used.
</div>
<div style="margin-top:.625em;">
The implementation details may vary, the purpose stays the same: help a <code>human</code> understand what is going wrong.
That's exactly what we are doing in the initial code snippet:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn store_token(/* */) -> Result<(), sqlx::Error> {
    sqlx::query!(/* */)
        .execute(transaction)
        .await
        .map_err(|e| {
            tracing::error!("Failed to execute query: {:?}", e);
            e
        })?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
If the query fails, we grab the error and emit a log event. We can then go and inspect the error logs when investigating the database issue.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Errors At The Edge" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<h4><b>Help A User To Troubleshoot</b></h4>
<div>
So far we focused on the internals of our API - functions calling other functions and operators trying to make sense of the mess after it happened. <br />
What about users?
</div>
<div style="margin-top:.625em;">
Just like operators, users expect the API to <code>signal</code> when a failure mode is encountered.
</div>
<div style="margin-top:.625em;">
What does a user of our API see when <code>store_token</code></code> fails? <br />
We can find out by looking at the request handler:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn subscribe(/* */) -> HttpResponse {
    // [...]
    if store_token(&mut transaction, subscriber_id, &subscription_token)
        .await
        .is_err() 
    {
        return HttpResponse::InternalServerError().finish();
    }
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
They receive an HTTP response with no body and a <code>500 Internal Server Error</code> status code.
</div>
<div style="margin-top:.625em;">
The status code fulfills the same purpose of the error type in <code>store_token</code>: it is a machine-parsable piece of information that the caller (e.g. the browser) can use to determine what to do next (e.g. retry the request assuming it's a transient failure).
</div>
<div style="margin-top:.625em;">
What about the human behind the browser? What are we telling them? <br />
Not much, the response body is empty. <br />
That is actually a good implementation: the user should not have to care about the internals of the API they are calling - they have no mental model of it and no way to determine why it is failing. That's the realm of the operator. <br />
We are <code>omitting</code> those details by design.
</div>
<div style="margin-top:.625em;">
In other circumstances, instead, we need to convey additional information to the human user. Let's look at our input validation for the same endpoint:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs

#[derive(serde::Deserialize)]
pub struct FormData {
    email: String,
    name: String,
}

impl TryFrom<FormData> for NewSubscriber {
    type Error = String;

    fn try_from(value: FormData) -> Result<Self, Self::Error> {
        let name = SubscriberName::parse(value.name)?;
        let email = SubscriberEmail::parse(value.email)?;
        Ok(Self { email, name })
    }
} 
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We received an email address and a name as data attached to the form submitted by the user. Both fields are going through an additional round of validation - <code>SubscriberName::parse</code> and <code>SubscriberEmail::parse</code>. Those two methods are fallible - they return a <code>String</code> as error type to explain what has gone wrong:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/domain/subscriber_email.rs
// [...]

impl SubscriberEmail {
    pub fn parse(s: String) -> Result<SubscriberEmail, String> {
        if validate_email(&s) {
            Ok(Self(s))
        } else {
            Err(format!("{} is not a valid subscriber email.", s))
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
It is, I must admit, not the most useful error message: we are telling the user that the email address they entered is wrong, but we are not helping them to determine why.
</div>
<div style="margin-top:.625em;">
In the end, it doesn't matter: we are not sending any of that information to the user as part of the response of the API - they are getting a <code>400 Bad Request</code> with no body.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscription.rs
// [...]

pub async fn subscribe(/* */) -> HttpResponse {
    let new_subscriber = match form.0.try_into() {
        Ok(form) => form,
        Err(_) => return HttpResponse::BadRequest().finish(),
    };
    // [...]
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
This is a poor error: the user is left in the dark and cannot adapt their behaviour as required.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Summary" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
Let's summarise what we uncovered so far.
Errors serve two1 main purposes:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">Control flow (i.e. determine what do next);</li>
  <li style="margin-top:.325em;">Reporting (e.g. investigate, after the fact, what went wrong on).</li>
</ul>
<div style="margin-top:.625em;">
We can also distinguish errors based on their location:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">Internal (i.e. a function calling another function within our application);</li>
  <li style="margin-top:.325em;">At the edge (i.e. an API request that we failed to fulfill).</li>
</ul>
<div style="margin-top:.625em;">
Control flow is scripted: all information required to take a decision on what to do next must be accessible to a <b>machine</b>.
</div>
<div style="margin-top:.625em;">
We use types (e.g. enum variants), methods and fields for internal errors. <br />
We rely on status codes for errors at the edge.
</div>
<div style="margin-top:.625em;">
Error reports, instead, are primarily consumed by <code>humans</code>. <br />
The content has to be tuned depending on the audience. 
</div>
<div style="margin-top:.625em;">
An operator has access to the internals of the system - they should be provided with as much <code>context</code> as possible on the failure mode.
</div>
<div style="margin-top:.625em;">
A user sits outside the boundary of the application: they should only be given the amount of information required to adjust their behaviour if necessary (e.g. fix malformed inputs).
</div>
<div style="margin-top:.625em;">
We can visualise this mental model using a 2x2 table with <code>Location</code> as columns and <code>Purpose</code> as rows:
</div>
<table style="color:darkslateblue;margin:.5em 0;line-height:1.3em;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:140px;">&nbsp;</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:300px;">Internal</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">At the edge</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:140px;">Control Flow</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:300px;">Types, methods, fields</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Status codes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:140px;">Reporting</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:300px;">Logs/traces</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Response body</td>
        </tr>
    </tbody>
</table>
<div style="margin-top:.625em;">
We will spend the rest of the chapter improving our error handling strategy for each of the cells in the table.
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">Error Reporting For Operators</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
Let's start with error reporting for operators. <br />
Are we doing a good job with logging right now when it comes to errors?
</div>
<div style="margin-top:.625em;">
Let's write a quick test to find out:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/subscriptions.rs
// [...]

#[tokio::test]
async fn subscribe_fails_if_there_is_a_fatal_database_error() {
    // Arrange
    let app = spawn_app().await;
    let body = "name=le%20guin&email=ursula_le_guin%40gmail.com";
    // Sabotage the database
    sqlx::query!("ALTER TABLE subscription_tokens DROP COLUMN subscription_token;",)
        .execute(&app.db_pool)
        .await
        .unwrap();

    // Act
    let response =  app.post_subscriptions(body.into()).await;

    // Assert
    assert_eq!(response.status().as_u16(), 500);
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The test passes straight away - let's look at the log emitted by the application.
</div>
<div style="margin-top:.625em;">
Make sure you are running on <code>tracing-actix-web 0.4.0-beta.8</code>, <code>tracing-bunyan-formatter 0.2.4</code> and <code>actix-web 4.0.0-beta.8</code>!
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
# sqlx logs are a bit spammy, cutting them out to reduce noise
export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The output, once you focus on what matters, is the following:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
INFO: [HTTP REQUEST - START] 
 INFO: [ADDING A NEW SUBSCRIBER - START]
 INFO: [SAVING NEW SUBSCRIBER DETAILS IN THE DATABASE - START]
 INFO: [SAVING NEW SUBSCRIBER DETAILS IN THE DATABASE - END]
 INFO: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - START]
ERROR: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - EVENT] Failed to execute query: 
        Database(PgDatabaseError { 
          severity: Error, 
          code: "42703", 
          message: 
              "column 'subscription_token' of relation
               'subscription_tokens' does not exist", 
          ...
        })
    target=zero2prod::routes::subscriptions
 INFO: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - END]
 INFO: [ADDING A NEW SUBSCRIBER - END]
ERROR: [HTTP REQUEST - EVENT] Error encountered while 
        processing the incoming HTTP request: "" 
    exception.details="",
    exception.message="",
    target=tracing_actix_web::middleware
 INFO: [HTTP REQUEST - END] 
    exception.details="",
    exception.message="",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
How do you read something like this? <br />
Ideally, you start from the outcome: the log record emitted at the end of request processing. In our case, that is:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
 INFO: [HTTP REQUEST - END] 
    exception.details="",
    exception.message="",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
What does that tell us? <br />
The request returned a <code>500</code> status code - it failed. <br />
We don't learn a lot more than that: both <code>exception.details</code> and <code>exception.message</code> are empty.
</div>
<div style="margin-top:.625em;">
The situation does not get much better if we look at the next log, emitted by <code>tracing_actix_web</code>:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
 ERROR: [HTTP REQUEST - EVENT] Error encountered while 
        processing the incoming HTTP request: "" 
    exception.details="",
    exception.message="",
    target=tracing_actix_web::middleware
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
No actionable information whatsoever. Logging "Oops! Something went wrong!" would have been just as useful. <br />
We need to keep looking, all the way to the last remaining error log:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
ERROR: [STORE SUBSCRIPTION TOKEN IN THE DATABASE - EVENT] Failed to execute query: 
        Database(PgDatabaseError { 
          severity: Error, 
          code: "42703", 
          message: 
              "column 'subscription_token' of relation
               'subscription_tokens' does not exist", 
          ...
        })
    target=zero2prod::routes::subscriptions
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
Something went wrong when we tried talking to the database - we were expecting to see a <code>subscription_token</code> column in the <code>subscription_tokens</code> table but, for some reason, it was not there. <br />
This is actually useful!
</div>
<div style="margin-top:.625em;">
Is it the cause of the <code>500</code> though? <br />
Difficult to say just by looking at the logs - a developer will have to clone the codebase, check where that log line is coming from and make sure that it's indeed the cause of the issue.
</div>
<div style="margin-top:.625em;">
It can be done, but it takes time: it would be much easier if the <code>[HTTP REQUEST - END]</code> log record reported something useful about the <b>underlying root cause</b> in <code>exception.details</code> and <code>exception.message</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Keeping Track Of The Error Root Cause" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
To understand why the log records coming out <code>tracing_actix_web</code> are so poor we need to inspect (again) our request handler and <code>store_token</code>:
]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn subscribe(/* */) -> HttpResponse {
    // [...]
    if store_token(&mut transaction, subscriber_id, &subscription_token)
        .await
        .is_err()
    {
        return HttpResponse::InternalServerError().finish();
    }
    // [...]
}

pub async fn store_token(/* */) -> Result<(), sqlx::Error> {
    sqlx::query!(/* */)
        .execute(transaction)
        .await
        .map_err(|e| {
            tracing::error!("Failed to execute query: {:?}", e);
            e
        })?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The useful error log we found is indeed the one emitted by that <code>tracing::error</code> call - the error message includes the <code>sqlx::Error</code> returned by <code>execute</code>.
We propagate the error upwards using the <code>?</code> operator, but the chain breaks in subscribe - we discard the error we received from <code>store_token</code> and build a bare <code>500</code> response.
</div>
<div style="margin-top:.625em;">
<code>HttpResponse::InternalServerError().finish()</code> is the only thing that <code>actix_web</code> and <code>tracing_actix_web::TracingLogger</code> get to access when they are about to emit their respective log records. The error does not contain any context about the <b>underlying root cause</b>, therefore the log records are equally useless.
</div>
<div style="margin-top:.625em;">
How do we fix it?
</div>
<div style="margin-top:.625em;">
We need to start leveraging the error handling machinery exposed by <code>actix_web</code> - in particular, <code>actix_web::Error</code>. According to the documentation:
</div>
<div style="margin-top:.625em;">
<code>actix_web::Error</code> is used to carry errors from <code>std::error</code> through <code>actix_web</code> in a convenient way.
</div>
<div style="margin-top:.625em;">
It sounds exactly like what we are looking for. How do we build an instance of <a href="https://docs.rs/actix-web/4.0.1/actix_web/struct.Error.html">actix_web::Error</a>?
The documentation states that
</div>
<div style="margin-top:.625em;">
<code>actix_web::Error</code> can be created by converting errors with into().
</div>
<div style="margin-top:.625em;">
A bit indirect, but we can figure it out. <br />
The only <code>From/Into</code> implementation that we can use, browsing the ones listed in the documentation, seems to be this one:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
/// Build an `actix_web::Error` from any error that implements `ResponseError`
impl<T: ResponseError + 'static> From<T> for Error {
    fn from(err: T) -> Error {
        Error {
            cause: Box::new(err),
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<a href="https://docs.rs/actix-web/4.0.1/actix_web/trait.ResponseError.html">ResponseError</a> is a trait exposed by <code>actix_web</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
/// Errors that can be converted to `Response`.
pub trait ResponseError: fmt::Debug + fmt::Display {
    /// Response's status code.
    ///
    /// The default implementation returns an internal server error.
    fn status_code(&self) -> StatusCode;

    /// Create a response from the error.
    ///
    /// The default implementation returns an internal server error.
    fn error_response(&self) -> Response;
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We just need to implement it for our errors! <br />
<code>actix_web</code> provides a default implementation for both methods that returns a <code>500 Internal Server Error</code> - exactly what we need. Therefore it's enough to write:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
use actix_web::ResponseError;
// [...]

impl ResponseError for sqlx::Error {}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The compiler is not happy:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
error[E0117]: only traits defined in the current crate 
              can be implemented for arbitrary types
   --> src/routes/subscriptions.rs:162:1
    |
162 | impl ResponseError for sqlx::Error {}
    | ^^^^^^^^^^^^^^^^^^^^^^^-----------
    | |                      |
    | |                      `sqlx::Error` is not defined in the current crate
    | impl doesn't use only types from inside the current crate
    |
    = note: define and implement a trait or new type instead
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We just bumped into <a href="https://doc.rust-lang.org/book/ch10-02-traits.html#implementing-a-trait-on-a-type">Rust's orphan rule</a>: it is forbidden to implement a foreign trait for a foreign type, where foreign stands for "from another crate".
</div>
<div style="margin-top:.625em;">
This restriction is meant to preserve coherence: imagine if you added a dependency that defined its own implementation of <code>ResponseError</code> for <code>sqlx::Error</code> - which one should the compiler use when the trait methods are invoked?
</div>
<div style="margin-top:.625em;">
Orphan rule aside, it would still be a mistake for us to implement <code>ResponseError</code> for <code>sqlx::Error</code>.
We want to return a <code>500 Internal Server Error</code> when we run into a <code>sqlx::Error</code> while trying to persist a subscriber token.
In another circumstance we might wish to handle a <code>sqlx::Error</code> differently.
</div>
<div style="margin-top:.625em;">
We should follow the compiler's suggestion: define a new type to wrap <code>sqlx::Error</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

//                                    Using the new error type!
pub async fn store_token(/* */) -> Result<(), StoreTokenError> {
    sqlx::query!(/* */)
    .execute(transaction)
    .await
    .map_err(|e| {
        // [...]
        // Wrapping the underlying error
        StoreTokenError(e)
    })?;
    // [...]
}

// A new error type, wrapping a sqlx::Error
pub struct StoreTokenError(sqlx::Error);

impl ResponseError for StoreTokenError {}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
It doesn't work, but for a different reason:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
error[E0277]: `StoreTokenError` doesn't implement `std::fmt::Display`
   --> src/routes/subscriptions.rs:164:6
    |
164 | impl ResponseError for StoreTokenError {}
    |      ^^^^^^^^^^^^^ 
    `StoreTokenError` cannot be formatted with the default formatter
    |
    |
59  | pub trait ResponseError: fmt::Debug + fmt::Display {
    |                                       ------------ 
    |     required by this bound in `ResponseError`
    |
    = help: the trait `std::fmt::Display` is not implemented for `StoreTokenError`

error[E0277]: `StoreTokenError` doesn't implement `std::fmt::Debug`
   --> src/routes/subscriptions.rs:164:6
    |
164 | impl ResponseError for StoreTokenError {}
    |      ^^^^^^^^^^^^^ 
    `StoreTokenError` cannot be formatted using `{:?}`
    |
    |
59  | pub trait ResponseError: fmt::Debug + fmt::Display {
    |                          ---------- 
                required by this bound in `ResponseError`
    |
    = help: the trait `std::fmt::Debug` is not implemented for `StoreTokenError`
    = note: add `#[derive(Debug)]` or manually implement `std::fmt::Debug`
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We are missing two trait implementations on <code>StoreTokenError</code>: Debug and <code>Display</code>. <br />
Both traits are concerned with formatting, but they serve a different purpose.
</div>
<div style="margin-top:.625em;">
<code>Debug</code> should return a programmer-facing representation, as faithful as possible to the underlying type structure, to help with debugging (as the name implies). Almost all public types should implement <code>Debug</code>.
</div>
<div style="margin-top:.625em;">
<code>Display</code>, instead, should return a user-facing representation of the underlying type. Most types do not implement <code>Display</code> and it cannot be automatically implemented with a <code>#[derive(Display)]</code> attribute.
</div>
<div style="margin-top:.625em;">
When working with errors, we can reason about the two traits as follows: <code>Debug</code> returns as much information as possible while <code>Display</code> gives us a brief description of the failure we encountered, with the essential amount of context.
</div>
<div style="margin-top:.625em;">
Let's give it a go for <code>StoreTokenError</code>:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

// We derive `Debug`, easy and painless.
#[derive(Debug)]
pub struct StoreTokenError(sqlx::Error);

impl std::fmt::Display for StoreTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "A database error was encountered while \
            trying to store a subscription token."
        )
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
It compiles! <br />
We can now leverage it in our request handler:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn subscribe(/* */) -> Result<HttpResponse, actix_web::Error> {
    // You will have to wrap (early) returns in `Ok(...)` as well!
    // [...]
    // The `?` operator transparently invokes the `Into` trait
    // on our behalf - we don't need an explicit `map_err` anymore.
    store_token(/* */).await?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Let's look at our logs again:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
# sqlx logs are a bit spammy, cutting them out to reduce noise
export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
...
 INFO: [HTTP REQUEST - END] 
    exception.details= StoreTokenError(
        Database(
            PgDatabaseError { 
                severity: Error, 
                code: "42703", 
                message: 
                    "column 'subscription_token' of relation 
                     'subscription_tokens' does not exist",
                ...
            }
        )
    )
    exception.message=
        "A database failure was encountered while 
         trying to store a subscription token.",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
Much better! <br />
The log record emitted at the end of request processing now contains both an in-depth and brief description of the error that caused the application to return a <code>500 Internal Server Error</code> to the user.
</div>
<div style="margin-top:.625em;">
It is enough to look at this log record to get a pretty accurate picture of everything that matters for this request.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="The Error Trait" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
So far we moved forward by following the compiler suggestions, trying to satisfy the constraints imposed on us by <code>actix-web</code> when it comes to error handling.
</div>
<div style="margin-top:.625em;">
Let's step back to look at the bigger picture: what should an error look like in Rust (not considering the specifics of <code>actix-web</code>)?
</div>
<div style="margin-top:.625em;">
Rust's standard library has a dedicated trait, <code>Error</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
pub trait Error: Debug + Display {
    /// The lower-level source of this error, if any.
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        None
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
It requires an implementation of <code>Debug</code> and <code>Display</code>, just like <code>ResponseError</code>. <br />
It also gives us the option to implement a <code>source</code> method that returns the underlying cause of the error, if any.
</div>
<div style="margin-top:.625em;">
What is the point of implementing the <code>Error</code> trait at all for our error type? <br />
It is not required by <code>Result</code> - any type can be used as error variant there.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
pub enum Result<T, E> {
    /// Contains the success value
    Ok(T),

    /// Contains the error value
    Err(E),
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The Error trait is, first and foremost, a way to <b>semantically</b> mark our type as being an error. It helps a reader of our codebase to immediately spot its purpose.
</div>
<div style="margin-top:.625em;">
It is also a way for the Rust community to standardise on the minimum requirements for a <b>good</b> error:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">it should provide different representations (<code>Debug</code> and <code>Display</code>), tuned to different audiences;</li>
  <li style="margin-top:.325em;">it should be possible to look at the underlying cause of the error, if any (<code>source</code>).</li>
</ul>
<div style="margin-top:.625em;">
This list is still evolving - e.g. there is an unstable <a href="https://doc.rust-lang.org/std/error/trait.Error.html#method.backtrace">backtrace method</a>.
</div>
<div style="margin-top:.625em;">
Error handling is an active area of research in the Rust community - if you are interested in staying on top of what is coming next I strongly suggest you to keep an eye on the <a href="https://blog.rust-lang.org/inside-rust/2020/11/23/What-the-error-handling-project-group-is-working-on.html">Rust Error Handling Working Group</a>.
</div>
<div style="margin-top:.625em;">
By providing a good implementation of all the optional methods we can fully leverage the error handling ecosystem - functions that have been designed to work with errors, generically. We will be writing one in a couple of sections!
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Trait Objects" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
Before we work on implementing source, let's take a closer look at its return - <code>Option<&(dyn Error + 'static)></code>. <code>dyn Error</code> is a trait object5 - a type that we know nothing about apart from the fact that it implements the <code>Error</code> trait.
</div>
<div style="margin-top:.625em;">
Trait objects, just like generic type parameters, are a way to achieve polymorphism in Rust: invoke different implementations of the same interface. Generic types are resolved at compile-time (static dispatch), trait objects incur a runtime cost (dynamic dispatch).
</div>
<div style="margin-top:.625em;">
Why does the standard library return a trait object? <br />
It gives developers a way to access the underlying root cause of current error while keeping it opaque.
</div>
<div style="margin-top:.625em;">
It does not leak any information about the type of the underlying root cause - you only get access to the methods exposed by the <code>Error</code> trait: different representations (<code>Debug</code>, <code>Display</code>), the chance to go one level deeper in the <b>error chain</b> using <code>source</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Error::source" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
Let's implement Error for <code>StoreTokenError</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [..]

impl std::error::Error for StoreTokenError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        // The compiler transparently casts `&sqlx::Error` into a `&dyn Error`
        Some(&self.0)
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
<code>source</code> is useful when writing code that needs to handle a variety of errors: it provides a structured way to navigate the error chain without having to know anything about the specific error type you are working with.
</div>
<div style="margin-top:.625em;">
If we look at our log record, the causal relationship between <code>StoreTokenError</code> and <code>sqlx::Error</code> is somewhat implicit - we infer one is the cause of the other because it is a part of it.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
...
 INFO: [HTTP REQUEST - END] 
    exception.details= StoreTokenError(
        Database(
            PgDatabaseError { 
                severity: Error, 
                code: "42703", 
                message: 
                    "column 'subscription_token' of relation 
                     'subscription_tokens' does not exist",
                ...
            }
        )
    )
    exception.message=
        "A database failure was encountered while 
         trying to store a subscription token.",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Let's go for something more explicit:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs

// Notice that we have removed `#[derive(Debug)]`
pub struct StoreTokenError(sqlx::Error);

impl std::fmt::Debug for StoreTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}\nCaused by:\n\t{}", self, self.0)
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The log record leaves nothing to the imagination now:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
...
 INFO: [HTTP REQUEST - END] 
    exception.details=
        "A database failure was encountered 
        while trying to store a subscription token.
    
        Caused by:
            error returned from database: column 'subscription_token'
            of relation 'subscription_tokens' does not exist"
    exception.message=
        "A database failure was encountered while 
         trying to store a subscription token.",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
<code>exception.details</code> is easier to read and still conveys all the relevant information we had there before.
</div>
<div style="margin-top:.625em;">
Using <code>source</code> we can write a function that provides a similar representation for any type that implements <code>Error</code>:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

fn error_chain_fmt(
    e: &impl std::error::Error,
    f: &mut std::fmt::Formatter<'_>,
) -> std::fmt::Result {
    writeln!(f, "{}\n", e)?;
    let mut current = e.source();
    while let Some(cause) = current {
        writeln!(f, "Caused by:\n\t{}", cause)?;
        current = cause.source();
    }
    Ok(())
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
It iterates over the whole chain of errors that led to the failure we are trying to print. <br />
We can then change our implementation of <code>Debug</code> for <code>StoreTokenError</code> to use it:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

impl std::fmt::Debug for StoreTokenError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        error_chain_fmt(self, f)
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The result is identical - and we can reuse it when working with other errors if we want a similar <code>Debug</code> representation.
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">Errors For Control Flow</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="Layering" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
We achieved the outcome we wanted (useful logs), but I am not too fond of the solution: we implemented a trait from our web framework (<code>ResponseError</code>) for an error type returned by an operation that is blissfully unaware of REST or the HTTP protocol, <code>store_token</code>. We could be calling <code>store_token</code> from a different entrypoint (e.g. a CLI) - nothing should have to change in its implementation.
</div>
<div style="margin-top:.625em;">
Even assuming we are only ever going to be invoking <code>store_token</code> in the context of a REST API, we might add other endpoints that rely on that routine - they might not want to return a <code>500</code> when it fails.
</div>
<div style="margin-top:.625em;">
Choosing the appropriate HTTP status code when an error occurs is a concern of the request handler, it should not leak elsewhere. <br />
Let's delete
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

// Nuke it!
impl ResponseError for StoreTokenError {}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
To enforce a proper separation of concerns we need to introduce another error type, <code>SubscribeError</code>. We will use it as failure variant for <code>subscribe</code> and it will own the HTTP-related logic (<code>ResponseError</code>'s implementation).
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    // [...]  
}

#[derive(Debug)]
struct SubscribeError {}

impl std::fmt::Display for SubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(
            f,
            "Failed to create a new subscriber."
        )
    }
}

impl std::error::Error for SubscribeError {}

impl ResponseError for SubscribeError {}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
If you run <code>cargo check</code> you will see an avalanche of <code>'?' couldn't convert the error to 'SubscribeError'</code> - we need to implement conversions from the error types returned by our functions and <code>SubscribeError</code>.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Modelling Errors as Enums" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
An enum is the most common approach to work around this issue: a variant for each error type we need to deal with.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

#[derive(Debug)]
pub enum SubscribeError {
    ValidationError(String),
    DatabaseError(sqlx::Error),
    StoreTokenError(StoreTokenError),
    SendEmailError(reqwest::Error),
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We can then leverage the <code>?</code> operator in our handler by providing a <code>From</code> implementation for each of wrapped error types:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

impl From<reqwest::Error> for SubscribeError {
    fn from(e: reqwest::Error) -> Self {
        Self::SendEmailError(e)
    }
}

impl From<sqlx::Error> for SubscribeError {
    fn from(e: sqlx::Error) -> Self {
        Self::DatabaseError(e)
    }
}

impl From<StoreTokenError> for SubscribeError {
    fn from(e: StoreTokenError) -> Self {
        Self::StoreTokenError(e)
    }
}

impl From<String> for SubscribeError {
    fn from(e: String) -> Self {
        Self::ValidationError(e)
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We can now clean up our request handler by removing all those <code>match</code> / <code>if fallible_function().is_err()</code> lines:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    let new_subscriber = form.0.try_into()?;
    let mut transaction = pool.begin().await?;
    let subscriber_id = insert_subscriber(/* */).await?;
    let subscription_token = generate_subscription_token();
    store_token(/* */).await?;
    transaction.commit().await?;
    send_confirmation_email(/* */).await?;
    Ok(HttpResponse::Ok().finish())
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The code compiles, but one of our tests is failing:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
thread 'subscriptions::subscribe_returns_a_400_when_fields_are_present_but_invalid' 
panicked at 'assertion failed: `(left == right)`
  left: `400`,
 right: `500`: The API did not return a 400 Bad Request when the payload was empty name.'
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We are still using the default implementation of <code>ResponseError</code> - it always returns <code>500</code>. <br />
This is where <code>enums</code> shine: we can use a <code>match</code> statement for <b>control flow</b> - we behave differently depending on the failure scenario we are dealing with.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
use actix_web::http::StatusCode; 
// [...]

impl ResponseError for SubscribeError {
    fn status_code(&self) -> StatusCode {
        match self {
            SubscribeError::ValidationError(_) => StatusCode::BAD_REQUEST,
            SubscribeError::DatabaseError(_)
            | SubscribeError::StoreTokenError(_)
            | SubscribeError::SendEmailError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The test suite should pass again.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="The Error Type Is Not Enough" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
What about our logs? <br />
Let's look again:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
...
 INFO: [HTTP REQUEST - END] 
    exception.details="StoreTokenError(
            A database failure was encountered while trying to 
            store a subscription token.
            
        Caused by:
            error returned from database: column 'subscription_token' 
            of relation 'subscription_tokens' does not exist)"
    exception.message="Failed to create a new subscriber.",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We are still getting a great representation for the underlying <code>StoreTokenError</code> in <code>exception.details</code>, but it shows that we are now using the derived Debug implementation for <code>SubscribeError</code>. No loss of information though.
</div>
<div style="margin-top:.625em;">
The same cannot be said for <code>exception.message</code> - no matter the failure mode, we always get <code>Failed to create a new subscriber</code>. Not very useful.
</div>
<div style="margin-top:.625em;">
Let's refine our <code>Debug</code> and <code>Display</code> implementations:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

// Remember to delete `#[derive(Debug)]`!
impl std::fmt::Debug for SubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        error_chain_fmt(self, f)
    }
}

impl std::error::Error for SubscribeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            // &str does not implement `Error` - we consider it the root cause
            SubscribeError::ValidationError(_) => None,
            SubscribeError::DatabaseError(e) => Some(e),
            SubscribeError::StoreTokenError(e) => Some(e),
            SubscribeError::SendEmailError(e) => Some(e),
        }
    }
}

impl std::fmt::Display for SubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SubscribeError::ValidationError(e) => write!(f, "{}", e),
            // What should we do here?
            SubscribeError::DatabaseError(_) => write!(f, "???"),
            SubscribeError::StoreTokenError(_) => write!(
                f,
                "Failed to store the confirmation token for a new subscriber."
            ),
            SubscribeError::SendEmailError(_) => {
                write!(f, "Failed to send a confirmation email.")
            },
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
Debug is easily sorted: we implemented the <code>Error</code> trait for <code>SubscribeError</code>, including <code>source</code>, and we can use again the helper function we wrote earlier for <code>StoreTokenError</code>.
</div>
<div style="margin-top:.625em;">
We have a problem when it comes to <code>Display</code> - the same <code>DatabaseError</code> variant is used for errors encountered when:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">acquiring a new Postgres connection from the pool;</li>
  <li style="margin-top:.325em;">inserting a subscriber in the <code>subscribers</code> table;</li>
  <li style="margin-top:.325em;">committing the SQL transaction.</li>
</ul>
<div style="margin-top:.625em;">
When implementing <code>Display</code> for <code>SubscribeError</code> we have no way to distinguish which of those three cases we are dealing with - the <b>underlying error type is not enough</b>.
</div>
<div style="margin-top:.625em;">
Let's disambiguate by using a different enum variant for each operation:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub enum SubscribeError {
    // [...]
    // No more `DatabaseError`
    PoolError(sqlx::Error),
    InsertSubscriberError(sqlx::Error),
    TransactionCommitError(sqlx::Error),
}

impl std::error::Error for SubscribeError {
    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
        match self {
            //  [...]
            // No more DatabaseError
            SubscribeError::PoolError(e) => Some(e),
            SubscribeError::InsertSubscriberError(e) => Some(e),
            SubscribeError::TransactionCommitError(e) => Some(e),
            // [...]
        }
    }
}

impl std::fmt::Display for SubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            // [...]
            SubscribeError::PoolError(_) => {
                write!(f, "Failed to acquire a Postgres connection from the pool")
            }
            SubscribeError::InsertSubscriberError(_) => {
                write!(f, "Failed to insert new subscriber in the database.")
            }
            SubscribeError::TransactionCommitError(_) => {
                write!(
                    f,
                    "Failed to commit SQL transaction to store a new subscriber."
                )
            }
        }
    }
}

impl ResponseError for SubscribeError {
    fn status_code(&self) -> StatusCode {
        match self {
            SubscribeError::ValidationError(_) => StatusCode::BAD_REQUEST,
            SubscribeError::PoolError(_)
            | SubscribeError::TransactionCommitError(_)
            | SubscribeError::InsertSubscriberError(_)
            | SubscribeError::StoreTokenError(_)
            | SubscribeError::SendEmailError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<code>DatabaseError</code> is used in one more place:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [..]

impl From<sqlx::Error> for SubscribeError {
    fn from(e: sqlx::Error) -> Self {
        Self::DatabaseError(e)
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The type alone is not enough to distinguish which of the new variants should be used; we cannot implement <code>From</code> for <code>sqlx::Error</code>. <br />
We have to use <code>map_err</code> to perform the right conversion in each case.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [..]

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    // [...]
    let mut transaction = pool.begin().await.map_err(SubscribeError::PoolError)?;
    let subscriber_id = insert_subscriber(&mut transaction, &new_subscriber)
        .await
        .map_err(SubscribeError::InsertSubscriberError)?;
    // [...]
    transaction
        .commit()
        .await
        .map_err(SubscribeError::TransactionCommitError)?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The code compiles and <code>exception.message</code> is useful again:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
...
 INFO: [HTTP REQUEST - END] 
    exception.details="Failed to store the confirmation token 
        for a new subscriber.

        Caused by:
            A database failure was encountered while trying to store 
            a subscription token.
        Caused by:
            error returned from database: column 'subscription_token'
            of relation 'subscription_tokens' does not exist"
    exception.message="Failed to store the confirmation token for a new subscriber.",
    target=tracing_actix_web::root_span_builder, 
    http.status_code=500
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Removing The Boilerplate With thiserror" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
It took us roughly 90 lines of code to implement <code>SubscribeError</code> and all the machinery that surrounds it in order to achieve the desired behaviour and get useful diagnostic in our logs.
</div>
<div style="margin-top:.625em;">
That is a lot of code, with a ton of boilerplate (e.g. <code>source</code>'s or <code>From</code> implementations). <br />
Can we do better?
</div>
<div style="margin-top:.625em;">
Well, I am not sure we can write less code, but we can find a different way out: we can <code>generate</code> all that boilerplate using a macro!
</div>
<div style="margin-top:.625em;">
As it happens, there is already a great crate in the ecosystem for this purpose: <a href="https://github.com/dtolnay/thiserror">thiserror</a>. Let's add it to our dependencies:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
#! Cargo.toml

[dependencies]
# [...]
thiserror = "1"
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
It provides a derive macro to generate most of the code we just wrote by hand. <br />
Let's see it in action:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

#[derive(thiserror::Error)]
pub enum SubscribeError {
    #[error("{0}")]
    ValidationError(String),
    #[error("Failed to acquire a Postgres connection from the pool")]
    PoolError(#[source] sqlx::Error),
    #[error("Failed to insert new subscriber in the database.")]
    InsertSubscriberError(#[source] sqlx::Error),
    #[error("Failed to store the confirmation token for a new subscriber.")]
    StoreTokenError(#[from] StoreTokenError),
    #[error("Failed to commit SQL transaction to store a new subscriber.")]
    TransactionCommitError(#[source] sqlx::Error),
    #[error("Failed to send a confirmation email.")]
    SendEmailError(#[from] reqwest::Error),
}

// We are still using a bespoke implementation of `Debug`
// to get a nice report using the error source chain
impl std::fmt::Debug for SubscribeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        error_chain_fmt(self, f)
    }
}

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    // We no longer have `#[from]` for `ValidationError`, so we need to 
    // map the error explicitly
    let new_subscriber = form.0.try_into().map_err(SubscribeError::ValidationError)?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We cut it down to 21 lines - not bad! <br />
Let's break down what is happening now.
</div>
<div style="margin-top:.625em;">
<code>thiserror::Error</code> is a <a href="https://doc.rust-lang.org/reference/procedural-macros.html">procedural macro</a> used via a <code>#[derive(/* */)]</code> attribute.
We have seen and used these before - e.g. <code>#[derive(Debug)]</code> or <code>#[derive(serde::Serialize)]</code>.
</div>
<div style="margin-top:.625em;">
The macro receives, at compile-time, the definition of <code>SubscribeError</code> as input and returns another stream of tokens as output - it generates new Rust code, which is then compiled into the final binary.
</div>
<div style="margin-top:.625em;">
Within the context of <code>#[derive(thiserror::Error)]</code> we get access to other attributes to achieve the behaviour we are looking for:
</div>
<ul style="margin-left:1.5em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;"><code>#[error(/* */)]</code> defines the Display representation of the enum variant it is applied to. E.g. <code>Display</code> will return <code>Failed to send a confirmation email</code>. when invoked on an instance of <code>SubscribeError::SendEmailError</code>. You can interpolate values in the final representation - e.g. the <code>{0}</code> in <code>#[error("{0}")]</code> on top of <code>ValidationError</code> is referring to the wrapped <code>String</code> field, mimicking the syntax to access fields on tuple structs (i.e. <code>self.0</code>).</li>
  <li style="margin-top:.325em;"><code>#[source]</code> is used to denote what should be returned as root cause in <code>Error::source</code>;</li>
  <li style="margin-top:.325em;"><code>#[from]</code> automatically derives an implementation of <code>From</code> for the type it has been applied to into the top-level error type (e.g. <code>impl From<StoreTokenError> for SubscribeError {/* */}</code>). The field annotated with <code>#[from]</code> is also used as error source, saving us from having to use two annotations on the same field (e.g. <code>#[source] #[from] reqwest::Error</code>).</li>
</ul>
<div style="margin-top:.625em;">
I want to call your attention on a small detail: we are not using either <code>#[from]</code> or <code>#[source]</code> for the <code>ValidationError</code> variant. That is because <code>String</code> does not implement the <code>Error</code> trait, therefore it cannot be returned in <code>Error::source</code> - the same limitation we encountered before when implementing <code>Error::source</code> manually, which led us to return <code>None</code> in the <code>ValidationError</code> case.
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>


  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">Avoid "Ball Of Mud" Error Enums</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
In <code>SubscribeError</code> we are using enum variants for two purposes:
</div>
<div style="margin-top:.625em;">
Determine the response that should be returned to the caller of our API (<code>ResponseError</code>); <br />
Provide relevant diagnostic (<code>Error::source</code>, <code>Debug</code>, <code>Display</code>).
</div>
<div style="margin-top:.625em;">
<code>SubscribeError</code>, as currently defined, exposes a lot of the implementation details of <code>subscribe</code>: we have a variant for every fallible function call we make in the request handler! <br />
It is not a strategy that scales very well.
</div>
<div style="margin-top:.625em;">
We need to think in terms of <b>abstraction layers</b>: what does a caller of <code>subscribe</code> <b>need</b> to know?
</div>
<div style="margin-top:.625em;">
They should be able to determine what response to return to a user (via <code>ResponseError</code>). That's it.
</div>
<div style="margin-top:.625em;">
The caller of <code>subscribe</code> does not understand the intricacies of the subscription flow: they don't know enough about the domain to behave differently for a <code>SendEmailError</code> compared to a <code>TransactionCommitError</code> (by design!). <code>subscribe</code> should return an error type that speaks at the <b>right level of abstraction</b>.
</div>
<div style="margin-top:.625em;">
The ideal error type would look like this:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs 

#[derive(thiserror::Error)]
pub enum SubscribeError {
    #[error("{0}")]
    ValidationError(String),
    #[error(/* */)]
    UnexpectedError(/* */),
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
<code>ValidationError</code> maps to a <code>400 Bad Request</code>, <code>UnexpectedError</code> maps to an opaque <code>500 Internal Server</code> Error.
</div>
<div style="margin-top:.625em;">
What should we store in the <code>UnexpectedError</code> variant? <br />
We need to map <code>multiple</code> error types into it - <code>sqlx::Error</code>, <code>StoreTokenError</code>, <code>reqwest::Error</code>.
</div>
<div style="margin-top:.625em;">
We do not want to expose the implementation details of the fallible routines that get mapped to <code>UnexpectedError</code> by <code>subscribe</code> - it must be <b>opaque</b>.
</div>
<div style="margin-top:.625em;">
We bumped into a type that fulfills those requirements when looking at the <code>Error</code> trait from Rust's standard library: <code>Box&lt;dyn std::error::Error&gt;</code>
</div>
<div style="margin-top:.625em;">
Let's give it a go:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs 

#[derive(thiserror::Error)]
pub enum SubscribeError {
    #[error("{0}")]
    ValidationError(String),
    // Transparent delegates both `Display`'s and `source`'s implementation
    // to the type wrapped by `UnexpectedError`.
    #[error(transparent)]
    UnexpectedError(#[from] Box<dyn std::error::Error>),
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We can still generate an accurate response for the caller:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs 
// [...]

impl ResponseError for SubscribeError {
    fn status_code(&self) -> StatusCode {
        match self {
            SubscribeError::ValidationError(_) => StatusCode::BAD_REQUEST,
            SubscribeError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We just need to adapt <code>subscribe</code> to properly convert our errors before using the <code>?</code> operator:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs 
// [...]

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    // [...]
    let mut transaction = pool
        .begin()
        .await
        .map_err(|e| SubscribeError::UnexpectedError(Box::new(e)))?;
    let subscriber_id = insert_subscriber(/* */)
        .await
        .map_err(|e| SubscribeError::UnexpectedError(Box::new(e)))?;
    // [...]
    store_token(/* */)
        .await
        .map_err(|e| SubscribeError::UnexpectedError(Box::new(e)))?;
    transaction
        .commit()
        .await
        .map_err(|e| SubscribeError::UnexpectedError(Box::new(e)))?;
    send_confirmation_email(/* */)
        .await
        .map_err(|e| SubscribeError::UnexpectedError(Box::new(e)))?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
There is some code repetition, but let it be for now. <br />
The code compiles and our tests pass as expected.
</div>
<div style="margin-top:.625em;">
Let's change the test we have used so far to check the quality of our log messages: let's trigger a failure in <code>insert_subscriber</code> instead of <code>store_token</code>.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! tests/api/subscriptions.rs
// [...] 

#[tokio::test]
async fn subscribe_fails_if_there_is_a_fatal_database_error() {
    // [...]
    // Break `subscriptions` instead of `subscription_tokens` 
    sqlx::query!("ALTER TABLE subscriptions DROP COLUMN email;",)
        .execute(&app.db_pool)
        .await
        .unwrap();
    
    // [..]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
The test passes, but we can see that our logs have regressed:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
 INFO: [HTTP REQUEST - END] 
    exception.details: 
        "error returned from database: column 'email' of 
         relation 'subscriptions' does not exist"
    exception.message: 
        "error returned from database: column 'email' of 
         relation 'subscriptions' does not exist"
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We do not see a cause chain anymore. <br />
We lost the operator-friendly error message that was previously attached to the <code>InsertSubscriberError</code> via <code>thiserror</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

#[derive(thiserror::Error)]
pub enum SubscribeError {
    #[error("Failed to insert new subscriber in the database.")]
    InsertSubscriberError(#[source] sqlx::Error),
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
That is to be expected: we are forwarding the raw error now to Display (via <code>#[error(transparent)]</code>), we are not attaching any <b>additional context</b> to it in <code>subscribe</code>.
</div>
<div style="margin-top:.625em;">
We can fix it - let's add a new <code>String</code> field to <code>UnexpectedError</code> to attach contextual information to the opaque error we are storing:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

#[derive(thiserror::Error)]
pub enum SubscribeError {
    #[error("{0}")]
    ValidationError(String),
    #[error("{1}")]
    UnexpectedError(#[source] Box<dyn std::error::Error>, String),
}

impl ResponseError for SubscribeError {
    fn status_code(&self) -> StatusCode {
        match self {
            // [...]
            // The variant now has two fields, we need an extra `_`
            SubscribeError::UnexpectedError(_, _) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We need to adjust our mapping code in <code>subscribe</code> accordingly - we will reuse the error descriptions we had before refactoring <code>SubscribeError</code>:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    // [..]
    let mut transaction = pool.begin().await.map_err(|e| {
        SubscribeError::UnexpectedError(
            Box::new(e),
            "Failed to acquire a Postgres connection from the pool".into(),
        )
    })?;
    let subscriber_id = insert_subscriber(/* */)
        .await
        .map_err(|e| {
            SubscribeError::UnexpectedError(
                Box::new(e),
                "Failed to insert new subscriber in the database.".into(),
            )
        })?;
    // [..]
    store_token(/* */)
        .await
        .map_err(|e| {
            SubscribeError::UnexpectedError(
                Box::new(e),
                "Failed to store the confirmation token for a new subscriber.".into(),
            )
        })?;
    transaction.commit().await.map_err(|e| {
        SubscribeError::UnexpectedError(
            Box::new(e),
            "Failed to commit SQL transaction to store a new subscriber.".into(),
        )
    })?;
    send_confirmation_email(/* */)
        .await
        .map_err(|e| {
            SubscribeError::UnexpectedError(
                Box::new(e), 
                "Failed to send a confirmation email.".into()
            )
        })?;
    // [..]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
It is somewhat ugly, but it works:
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
 INFO: [HTTP REQUEST - END] 
    exception.details=
        "Failed to insert new subscriber in the database.
        
        Caused by:
            error returned from database: column 'email' of 
             relation 'subscriptions' does not exist"
    exception.message="Failed to insert new subscriber in the database."
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="Using anyhow As Opaque Error Type" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
We could spend more time polishing the machinery we just built, but it turns out it is not necessary: we can lean on the ecosystem, again. <br />
The author of <code>thiserror</code> has another crate for us - <a href="https://github.com/dtolnay/anyhow">anyhow</a>.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
#! Cargo.toml

[dependencies]
# [...]
anyhow = "1"
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The type we are looking for is <code>anyhow::Error</code>. Quoting the documentation:
</div>
<div style="margin-top:.625em;">
<code>anyhow::Error</code> is a wrapper around a dynamic error type. <code>anyhow::Error</code> works a lot like <code>Box&lt;dyn std::error::Error&gt;</code>, but with these differences:
</div>
<ul style="margin-left:2em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;"><code>anyhow::Error</code> requires that the error is <code>Send</code>, <code>Sync</code>, and <code>'static</code>.</li>
  <li style="margin-top:.325em;"><code>anyhow::Error</code> guarantees that a backtrace is available, even if the underlying error type does not provide one.</li>
  <li style="margin-top:.325em;"><code>anyhow::Error</code> is represented as a narrow pointer  exactly one word in size instead of two.</li>
</ul>
<div style="margin-top:.625em;">
The additional constraints (<code>Send</code>, Sync and <code>'static</code>) are not an issue for us. <br />
We appreciate the more compact representation and the option to access a backtrace, if we were to be interested in it.
</div>
<div style="margin-top:.625em;">
Let's replace <code>Box&lt;dyn std::error::Error&gt;</code> with <code>anyhow::Error</code> in <code>SubscribeError</code>:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

#[derive(thiserror::Error)]
pub enum SubscribeError {
    #[error("{0}")]
    ValidationError(String),
    #[error(transparent)]
    UnexpectedError(#[from] anyhow::Error),
}

impl ResponseError for SubscribeError {
    fn status_code(&self) -> StatusCode {
        match self {
            // [...]
            // Back to a single field
            SubscribeError::UnexpectedError(_) => StatusCode::INTERNAL_SERVER_ERROR,
        }
    }
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
We got rid of the second <code>String</code> field as well in <code>SubscribeError::UnexpectedError</code> - it is no longer necessary. <br />
<code>anyhow::Error</code> provides the capability to enrich an error with <b>additional context</b> out of the box.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
use anyhow::Context;
// [...]

pub async fn subscribe(/* */) -> Result<HttpResponse, SubscribeError> {
    // [...]
    let mut transaction = pool
        .begin()
        .await
        .context("Failed to acquire a Postgres connection from the pool")?;
    let subscriber_id = insert_subscriber(/* */)
        .await
        .context("Failed to insert new subscriber in the database.")?;
    // [..]
    store_token(/* */)
        .await
        .context("Failed to store the confirmation token for a new subscriber.")?;
    transaction
        .commit()
        .await
        .context("Failed to commit SQL transaction to store a new subscriber.")?;
    send_confirmation_email(/* */)
        .await
        .context("Failed to send a confirmation email.")?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
The <code>context</code> method is performing double duties here:
</div>
<ul style="margin-left:2em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">it converts the error returned by our methods into an <code>anyhow::Error</code>;</li>
  <li style="margin-top:.325em;">it enriches it with additional context around the intentions of the caller.</li>
</ul>
<div style="margin-top:.625em;">
<code>context</code> is provided by the <code>Context</code> trait - <code>anyhow</code> implements it for <code>Result</code>, giving us access to a fluent API to easily work with fallible functions of all kinds.
</div>

    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="anyhow Or thiserror?" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;margin-top:1em;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
We have covered a lot of ground - time to address a common Rust myth:
</div>
<div style="margin-top:.625em;">
<code>anyhow</code> is for applications, <code>thiserror</code> is for libraries.
</div>
<div style="margin-top:.625em;">
It is not the right framing to discuss error handling. <br />
You need to reason about <b>intent</b>.
</div>
<div style="margin-top:.625em;">
Do you expect the caller to behave differently based on the failure mode they encountered? <br />
Use an error enumeration, empower them to match on the different variants. Bring in <code>thiserror</code> to write less boilerplate.
</div>
<div style="margin-top:.625em;">
Do you expect the caller to just give up when a failure occurs? Is their main concern reporting the error to an operator or a user? <br />
Use an opaque error, do not give the caller programmatic access to the error inner details. Use <code>anyhow</code> or <code>eyre</code> if you find their API convenient.
</div>
<div style="margin-top:.625em;">
The misunderstanding arises from the observation that most Rust libraries return an error enum instead of <code>Box&lt;dyn std::error::Error&gt;</code> (e.g. <code>sqlx::Error</code>).
</div>
<div style="margin-top:.625em;">
Library authors cannot (or do not want to) make assumptions on the intent of their users. They steer away from being opinionated (to an extent) - enums give users more control, if they need it.
</div>
<div style="margin-top:.625em;">
Freedom comes at a price - the interface is more complex, users need to sift through 10+ variants trying to figure out which (if any) deserve special handling.
</div>
<div style="margin-top:.625em;">
Reason carefully about your usecase and the assumptions you can afford to make in order to design the most appropriate error type - sometimes <code>Box&lt;dyn std::error::Error&gt;</code> or <code>anyhow::Error</code> are the most appropriate choice, even for libraries.
</div>
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">Who Should Log Errors?</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
Let's look again at the logs emitted when a request fails.
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
# sqlx logs are a bit spammy, cutting them out to reduce noise
export RUST_LOG="sqlx=error,info"
export TEST_LOG=enabled
cargo t subscribe_fails_if_there_is_a_fatal_database_error | bunyan
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
There are three error-level log records: <br />
one emitted by our code in <code>insert_subscriber</code>
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs 
// [...]

pub async fn insert_subscriber(/* */) -> Result<Uuid, sqlx::Error> {
    // [...]
    sqlx::query!(/* */)
        .execute(transaction)
        .await
        .map_err(|e| {
            tracing::error!("Failed to execute query: {:?}", e);
            e
        })?;
    // [...]
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
one emitted by <code>actix_web</code> when converting <code>SubscribeError</code> into an <code>actix_web::Error</code>; <br />
one emitted by <code>tracing_actix_web::TracingLogger</code>, our telemetry middleware.
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
<div>
We do not need to see the same information three times - we are emitting unnecessary log records which, instead of helping, make it more confusing for operators to understand what is happening (are those logs reporting the same error? Am I dealing with three different errors?).
</div>
<div style="margin-top:.625em;">
As a rule of thumb,
</div>
<div style="margin-top:.625em;">
errors should be logged when they are handled.
</div>
<div style="margin-top:.625em;">
If your function is propagating the error upstream (e.g. using the <code>?</code> operator), it should <b>not</b> log the error. It can, if it makes sense, add more context to it.
</div>
<div style="margin-top:.625em;">
If the error is propagated all the way up to the request handler, delegate logging to a dedicated middleware - <code>tracing_actix_web::TracingLogger</code> in our case.
</div>
<div style="margin-top:.625em;">
The log record emitted by <code>actix_web</code> is going to be <a href="https://github.com/actix/actix-web/pull/2196">removed in the next release</a>. Let's ignore it for now.
</div>
<div style="margin-top:.625em;">
Let's review the <code>tracing::error</code> statements in our own code:
</div>
    ]]>
    </c:sourceContent>
    <c:sourceContent type="rust" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
//! src/routes/subscriptions.rs
// [...]

pub async fn insert_subscriber(/* */) -> Result<Uuid, sqlx::Error> {
    // [...]
    sqlx::query!(/* */)
        .execute(transaction)
        .await
        .map_err(|e| {
            // This needs to go, we are propagating the error via `?`
            tracing::error!("Failed to execute query: {:?}", e);
            e
        })?;
    // [..]
}

pub async fn store_token(/* */) -> Result<(), StoreTokenError> {
    sqlx::query!(/* */)
        .execute(transaction)
        .await
        .map_err(|e| {
            // This needs to go, we are propagating the error via `?`
            tracing::error!("Failed to execute query: {:?}", e);
            StoreTokenError(e)
        })?;
    Ok(())
}
    ]]>
    </c:sourceContent>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;margin-top:1em;">
      <![CDATA[
Check the logs again to confirm they look pristine.
    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>

  <c:entry style="margin-top:1em;color:rgb(175, 0, 190);font-size:2.2em;">
    <c:title id="Reproduce-the-connection-reset-by-peer-error">Summary</c:title>
    <c:desc>
      <c:desc1> <![CDATA[]]></c:desc1>
    </c:desc>
    <c:sourceContent type="html" title="" id="sourceContent1" style="background-color:transparent;"
                     titleStyle="padding-left:0;color:black;font-size:1.8em;background-color:white;"
                     bodyStyle="padding:0;font-size:1em;line-height:1.825;font-family:monospace;">
      <![CDATA[
<div>
We used this chapter to learn error handling patterns "the hard way" - building an ugly but working prototype first, refining it later using popular crates from the ecosystem.
You should now have:
</div>
<ul style="margin-left:2em;list-style-type:disc;margin-top: .325em;">
  <li style="margin-top:.325em;">a solid grasp on the different purposes fulfilled by errors in an application;</li>
  <li style="margin-top:.325em;">the most appropriate tools to fulfill them.</li>
</ul>
<div style="margin-top:.625em;">
Internalise the mental model we discussed (<code>Location</code> as columns, <code>Purpose</code> as rows):
</div>

<table style="color:darkslateblue;margin:.5em 0;line-height:1.3em;width:100%;">
    <tbody>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:220px;">&nbsp;</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:300px;">Internal</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">At the edge</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:220px;">Control Flow</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:300px;">Types, methods, fields </td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Status codes</td>
        </tr>
        <tr style="padding: 0;margin: 0;border-bottom: solid 1px #d4d4d4;border-style: dashed;
          border-top: solid 1px #d4d4d4;border-style: dashed;">
            <td style="padding:0 10px;margin: 0;text-align:left;font-weight:normal;width:220px;">Reporting</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;width:300px;">Logs/traces</td>
            <td style="padding:0 10px;margin: 0;text-align:left;padding:.5em 0;">Response body</td>
        </tr>
    </tbody>
</table>

<div style="margin-top:.625em;">
Practice what you learned: we worked on the <code>subscribe</code> request handler, tackle <code>confirm</code> as an exercise to verify your understanding of the concepts we covered. Improve the response returned to the user when validation of form data fails.
</div>
<div style="margin-top:.625em;">
You can look at the code in <a href="https://github.com/lukemathwalker/zero-to-production">the GitHub repository</a> as a reference implementation.
</div>
<div style="margin-top:.625em;">
Some of the themes we discussed in this chapter (e.g. layering and abstraction boundaries) will make another appearance when talking about the overall layout and structure of our application. Something to look forward to!
</div>

    ]]>
    </c:sourceContent>
    <c:comment>
      <c:comment1>
        <![CDATA[]]>
      </c:comment1>
    </c:comment>
  </c:entry>
  


</c:component>
